<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/212238-update-management-for-encoded-data-in-memory by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:15:49 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 212238:UPDATE MANAGEMENT FOR ENCODED DATA IN MEMORY</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">UPDATE MANAGEMENT FOR ENCODED DATA IN MEMORY</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>This invention concerns a system to update encoded data stored in a memory of a data processing device such as a smartcard. In this system, the data is represented by a tree structure in directories and files according to an object representation. According to the invention, the update system comprises a specific referencing object able to reference all or some of the attributes of the encoded data in memory. A microcontroller is then programmed to extract from the referencing object the information required to locate the memory block occupied by this attribute, and update this block, replacing it by the new previously encoded data.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
Update management for encoded data in memory.<br>
Technical field<br>
This invention concerns update management for encoded data stored in memory. The invention applies especially to the management of security data stored in a memory of a token. The example chosen to illustrate the invention is that of the smartcard.<br>
The invention applies especially to portable devices including a WIM (WAP Identity Module) application. This WIM application generally included in a smartcard performs, when requested by a data processing device such as a cellular telephone, operations using public keys such as electronic signatures or data encryption, etc. In this WIM application, the data is stored in memory in compliance with standard PKCS#15 (P K C S: Public-Key Cryptography Standards) defined and published by the RSA incorporation laboratories for the implementation of Public Key Cryptography. As a reminder, note that Public Key Cryptography uses a pair of keys, a public key which can be disclosed to everyone and a private key which must be kept in a safe place and never disclosed. This standard uses an object-oriented data structure, i.e. a hierarchic structure of object classes sorted by category.<br>
Note that the RSA laboratory defines a set of standards PKCS #n (n is the identifier of the standard; RSA uses an integer to identify the various PKCS standards) designed to ensure data interoperability in heterogeneous computer systems. These various standards (PKCS#1. ..., PKCS#15) define the data types and the algorithms used in public key cryptography. In particular, the standard PKCS#15 concerns the cryptology information stored on tokens capable of staring permanent data.<br>
Refer to the RSA documentation describing these various standards. This document is available at the following web site: http://www.rsasecurlty.com.<br>
State of the art technoloqv<br>
Generally, cryptography uses a private key accessed only by a user and a public key which can be published or distributed upon request for use by those people wanting to communicate with the user. A person wanting to communicate<br><br>
with the user will first obtain a certificate which can be obtained from a certification authority, bearing the user's public key.<br>
Data concerning the keys and certificates is represented by a tree structure in directories and files. Two file types are generally found in this structure:<br>
-	the DF type files containing file control information (and pointers to EF files<br>
or other files),<br>
-	and the EF (elementary files) type files .<br>
In this application, we will not detail the access conditions defined at each level of the card file structure and for function groups acting on the files.<br>
More precisely, format PKCS#15 defines four object classes attached to the root. These classes are:<br>
the Key class, the certificate class, the authentication class, and the data class. These classes themselves include subclasses. For example, the "Key" class includes three classes called:<br>
private key class secret key class public key class Each object belonging to a class includes attributes. A tree therefore generally includes several objects distributed thraughout the tree.<br>
These objects and directories are represented according to the standard ASN.1 (ASN.I Abstract Syntax Notation) ISO/IEC 8824 published by ANSI (American National Standards Institute). This standard specifies the syntax to be used to describe complex data objects.<br>
These objects are then encoded according to Distinguished Encoding Rules (DER) defined in the same standard ASN.1. These encoding rules define the encoding of objects as byte sequences. There is no need to describe this standard ASN.1 any further since it is not the subject of the invention.<br><br>
Once encoding has been carried out, an application external to the card, for example a card reader, can read the encoded data stored on the card from a directory PKCS#15 (the root) and find from the tree structure described above how to use the keys, the certificates and applications stored on the card.<br>
Encoding is generally carried out during the card personalisation. After personalisation, some tree attributes may have to be updated. This updating is extremely complicated. Updating from a reader consists, in fact, of two main steps:<br>
-	Firstly, all encoded data must be decoded,<br>
-	Secondly, once updating has bee carried out, this data must be encoded again.<br>
These two steps must be repeated whenever at least one attribute of an object has to be updated.<br>
The invention<br>
One purpose of the invention is to simplify the procedure used to update the encoded data on the card.<br>
The card therefore includes in memory a specific referencing object able to reference all or some of the attributes of the encoded data in memory. According to the invention, updating comprises the following steps:<br>
-	a step to extract from the referencing object the information required to locate the memory block occupied by this attribute,<br>
-	a step to update this block, replacing it by the new data, previously encoded.<br>
Unlike the previous method, it is no longer necessary to decode all the encoded data then re-encode all this data after the update. Now, by using the referencing object, it is possible to update only some of the encoded data. The location information is extracted from the referencing object in order to locate the encoded data which must be updated. The new data is now simply encoded and stored in place of the previous data. The update procedure is considerably simplified.<br>
I	■■<br><br>
It will be easier to understand the invention on reading the description 'oetov-i, given as an example and referring to the attached drawings.<br>
In the drawings<br>
Figure 1 is a view of a computer system on which the invention can be applied.<br>
Figure 2 is a diagrammatic view of an example of the card file tree structure.<br>
Figure 3 is a diagrammatic view' of the aata organisation in memory.<br>
Figure 4 shows an example of realisation of a referencing object.<br>
Figure 5 is an algorithm illustrating the various steps of an example of realisation.<br>
Description of an example of realisation<br>
To simplify the description, the same elements illustrated in the drawings have the same references.<br>
Figure 1 is a simplified view of a computer system on which the invention can be implemented. This system includes a smartcard CAR and a smartcard reader RDR. This reader can be incorporated in a computer such as a cellular telephone, an electronic assistant, etc. Note that a computer is a programmable machine capable of data processing.<br>
In our example of realisation, the smartcard reader is incorporated in a cellular telephone.<br>
Note that a smartcard includes an electronic module (not shown). The module includes a microcontroller and contacts to communicate with the exterior. The microcontroller generally includes:<br><br>
-	a microprocessor to execute the commands,<br>
-	non volatile memories ROM (Read Only Memory), whose content is burnt in in the factory and therefore cannot be modified. An encryption algorithm, the operating system, application programming interfaces (API), etc. can therefore be written in the ROM;<br>
non volatile memories, 'or example EEPROM {electrically erasable programmable read only memory. This memory is generally used to store data specific to each card, for example the cardholder identity, the access rights to the services, the file systems of the card application programs, etc.<br>
-	volatile memories RAM, work space to execute the card commands,<br>
-	security units, taking into consideration the power supply voltage, clock<br>
speed, etc.,<br>
-	a data bus connecting everything,<br>
- an input-output bus BUS to communicate, in our example of realisation, with the reader RDR.<br>
The card stores various items of information in memory. An application WIM stored in this memory performs operations when requested by the cellular telephone. For example, when the cellular telephone requires a signature, it transmits a command to the application WIM, instructing it to produce the signature and return the requested signature to the telephone. Note that the private key which is used to produce the signature is never disclosed.<br>
This application WIM generally uses several private keys stored in the card. When the telephone requests a signature from the application, it must therefore indicate the key to be selected for the cryptography operation. The telephone first reads the tree from the root PKCS#15 up to the nodes associated with the private<br><br>
keys to find the number of private keys available in the application W/M and the identifier of each key.<br>
This data is stored in memery as a tree structure. Figure 2 is a diagranrs illustrating this structure, in our example, this tree includes files cf type DF and EF (elementary files) in its nodes. The DF file is called PKCS#15 and represents the tree root. File PKCS#15 has sub-nodes, including a node called EF(ODF) which is an elementary file containing pointers lo other elementary files, especially pointers to<br>
-	an elementary file called EF(PrKDF) containing full information concerning the<br>
private keys in the application WIM,<br>
-	an elementary file called EF(PuKDF) dedicated to the public keys,<br>
-	an elementary file called EF(CDF) dedicated to the certificates,<br>
-	etc.<br>
Each file EF(PrKDF), EF(PuKDF) and EF(CDF) generally contains an object directory PKCS#15 of a special class. The content of file EF(ODF) complies with ASN.1 syntax.<br>
An object can be written in the elementary file EF(PrKDF), corresponding to a private key, as follows:<br>
value PKCS15PrivateKey ::= privateRSAKey :<br>
{ commonObjectAttributes<br>
{ label "AUT-KEY",<br>
flags {private},<br>
authld'01 H<br><br>
classAttributes<br>
( iD'6754C890FD57453289AB9076E54245BC6D709FE7'H,<br>
usage { encrypt, decrypt, sign, verify },<br>
keyReference 1<br>
} typeAttributes<br>
{ value indirect; path :<br>
{ path'0012'H<br>
}. modulusLength 1024<br>
} }<br>
On reading this file, we see that each object includes several attributes. This file includes the following attributes:<br>
-	The "Label" attribute whose value is AUT-KEY<br>
-	The "Flag" attribute whose value is {private}. The value {private} indicates that this attribute is protected against unauthorised access. On an integrated circuit card, the accesses (read, write, in use, etc.) to so-called private objects are defined by authentication objects. An access condition could be entry of a PIN code known by the user.<br>
-	The attribute "AuthId" which includes the value '01'H designating the identifier of the PIN code which protects the use of this key.<br>
-	The attribute "ClassAttibute.iD" is the key identifier. In our example, it is a binary value which is the value obtained by a cryptographic hashing function such as the SHA-1 function of the public key. For further details on<br><br>
this function, refer to standard FIPS 180- 1. The hashing function is not essential in this application.<br>
-	The attribute "Usage' which has four values { encrypt, decrypt, sign, verify } indicating that this key is only used for encryption, decryption, document signature and signature verification.<br>
-	Attributes which provide information abcut the key access path. In our example this key, of length 1024 bytes, is accessed via an access path given by'0012'H.<br>
In our example of realisation, this file is created during the smartcard personalisation phase.<br>
When all files have been written, the data is encoded according to the DER standard. After encoding, the result is stored in memory.<br>
As seen in the introduction, the problem is that once the encoding has been carried out, updating one or more attributes is very costly in terms of computation time and the level of difficulty of the update algorithm.<br>
According to the invention, referencing objects are created, whose attribute values provide information on the referencing in memory of all or some of the object attributes PKCS#15,These referencing objects will then be used by programs running in the device (smartcard in this example) or in the card reader. In our example of realis'ation, this referencing object is created during the smartcard personalisation phase.<br>
Figure 3 is a diagrammatic and general view of the data organisation in a file Er(PrKDF) after encoding. Generally, all data items in the memory are concatenated, i.e. stored one after the other. In this file, each attribute has length L, i.e. a number of bytes. The position of each attribute in a file EF can also be<br><br>
determined using a counter OFF which represents in number of bytes the offset between the start of the file EF(PrKDF) and the 1st byte of the attribute.<br>
For example, in this file EF(PrKDF), a first attribute ATT1 has a length L12 bytes. This attribute is the first attribute referenced in the file EF(PrKDF); its counter OFF1 is therefore equal to 0. The next attribute ATT2 has a length L23 bytes and its counter 0FF2 is equal to L12. Similarly, attribute ATT3 has length L34 bytes and a counter of L12+L23, and so on.<br>
Referencing can be carried out in several ways. In our example of realisaticn, we have chosen to use the following attributes:<br>
-	an object type attribute (e.g. privateRSAKey)<br>
-	an attribute designating the instance concerned for this object type,<br>
-	an attribute to designate the attribute name,<br>
-	a counter OFF attribute used to locate in the file (e.g. EF(PrKDF)) the data block associated with this attribute<br>
-	a Length attribute used to indicate the length of the attribute concerned.<br>
Obviously, there are different ways to locate data in a file. For example, instead of the "Counter" and "Length" attributes, the start and end addresses of the data block occupied by this attribute can be used.<br>
Figure 4 is an example of a referencing object. On this figure, the attributes are represented as a table.<br>
The above five attributes are stored in this table. In our example of realisation, we want to update the attributes Label and ClassAttributes.iD stored in .file EF(PrKDF) defined above. We will assume that the object to be modified is the first instance stored with type "privateRSAKey" in file EF(PrKDF).<br>
Obviously, the tree PKGS#15 can store other instances of the same type and other files including objects with attributes. The principle of the invention also applies to all these instances and all these files.<br>
The first row concerns the attribute ClassAttributes.iD. For this attribute,<br><br>
-	The first column in the table identifies the object type. In our example, the object type is "privateRSAkey".<br>
-	The second column indicates that the instance concerned is the first instance of type "pnVateRSAkey". Obviously, this column is only required if there is more than one instance of this type in the tree.<br>
-	The third column indicates its name "Labef.<br>
-	The fourth column indicates the file concerned ~F(PrKDF) storing the<br>
attribute ClassAttributes.iD.<br>
-	The fifth attribute gives the counter which is 15 bytes in cur exarnple.<br>
-	The sixth attribute gives the attribute length in bytes. In our example, this attribute is set to 20 bytes.<br>
In our example illustrated, for security reasons, this table must be write protected. Preferably, the attributes Counter and Length are set independently from the length of the values of the attributes to be updated. In other words, for each attribute referenced in the table, a specific length is set which cannot be modified. This specific length includes enough bytes to store attributes of varying length.<br>
Figure 5 is an algorithm illustrating the main steps of the method applied to our example of realisation. Assume that the updating concerns the attribute "Label" in file EF(PrKDF) of type privateRSAKey and that the new value of this attribute is "AUT-KEY2".<br>
The steps are as follows:<br>
Step 1:<br>
A first step ET1 consists of obtaining the new value to be updated in file EF(PrKDF).<br>
Step 2:<br>
A second step ET2 consists of transmitting the new value of the attribute "Label" to the card for updating, using a command included in the cellular telephone. (n order to identify the attribute in the table, since it could be in several flies in the<br><br>
tree at the same time, the command also includes, in our example, the attributes ClassAttributes.iD and the instance concerned "privateRSAkey". A computer program stored in the cellular telephone transmits an update command to the card.<br>
Step 3<br>
During a third step ET3, the card receives and processes the command. A computer program stored in the card is activated upon reception of rhe update command sent from the cellular telephone. This program then points io the referencing object to locate the attribute "Label" in memory.<br>
Step 4<br>
During a fourth step ET4, the referencing object supplies the counter with 110 and the length with 20.<br>
Step 5<br>
A fifth step ET5 consists of encoding this new value "AUT-KEY2" and writing it at the position indicated.<br>
Another example could be the generation of a new public key pair in the smartcard. In our example, the hash of the public key is used as the key identifier in the objects PKCS#15. After generating the key pair, the corresponding objects PKCS#15 must be updated by the new hashed value of the public key. Since the hashed value of the public key has a fixed length, the application stored in the card which generates the new public key pair only needs to find all instances of the hashed public key to be replaced amongst the objects PKCS#15; the application uses the specific referencing object to find these instances. Once the instances have been found, they are updated by the new values. In this case, the procedure is the same with an additional step ET4bis. The encoding of step 4 is therefore preceded by a hashing step on the value of the attribute "ClassAttribute.iD".<br>
A synonym for "public key pair" is "asymmetric key pair".<br><br>
Generally, the invention concerns a data processing device, in particular a smartcard, storing in memory encoded data represented by a tree structure in directories and files according to an object representation, characterised in that it comprises<br>
-	a specific referencing object able to reference all or some of the attributes of the encoded data in memory,<br>
-	and in that the update of the encoded data is managed by a microcontroller programmed to<br><br>
-	extract from the referencing object the information required to locate the memory block occupied by this attribute.<br>
-	and update this block, replacing it by the new data, previously encoded.<br>
This referencing object is stored in memory in the data processing device. We have seen in our example of realisation that this referencing object is write protected for obvious security reasons. Write protection ensures that the referencing data stored in this memory will not be modified.<br>
The microcontroller programmed for the update may either be located on the data processing device or on an external tool connected to the data processing device.<br>
In our example of realisation, said referencing object comprises permanent data, i.e. the data remains unchanged even in case of power failure. In our example, even when the card is withdrawn from its reader, i.e. when it is no longer powered up, this object is stored in memory and cannot be changed.<br>
Also, we have seen that said referencing object includes attributes. In our example of realisation, five attributes were defined. We can see that three attributes are sufficient to identify<br>
-	the file, for example file EF(PrKDF),<br>
-	the attribute, for example attribute ClassAttributes.iD to be updated in this file,<br><br>
and the location, for example by the pair of values (counter, Length), of this attribute in the file in question.<br>
We obtain a method to update encoded data stored in a memon/ of a data processing device such as a smartcard, characterised in that it comprises;<br>
-	a preliminary step to create a specific referencing object able to reference all<br>
or some of the attributes of the encoded data in memory,<br>
and in that updating comprises the following steps:<br>
-	a step to extract from the referencing object the information required to<br>
locate the memory block occupied by this attribute,<br>
-	a step to update this block, replacing it by the new data, previously encoded.<br>
Preferably, this specific referencing object is created during the smartcard<br>
personalisation phase.<br>
The invention also concerns a computer program to update encoded data stored in a memory of a data processing device such as a smartcard, said program comprising program code instructions to execute update steps as previously defined, said program being executed using a microcontroller of the update system as previously defined. We have also seen that this program carries out updating which can either be carried out by a microcontroller located on the card or on an external tool connected to the card. This external tool could be, for example, a mobile telephone reader to which the smartcard is connected.<br>
The invention offers significant savings in terms of computation time, storage size as well as considerably simplifying the update algorithm.<br><br>
APPENDIX 1) writing file EF(PrKDF') according to standard PKCS#15 and ASN1 value PKCS15PrivateKey ::= privateRSAKey :<br>
{ commonObjectAttributes<br>
{ label "AUT-KEY",<br>
flags { private },<br>
authld'01'H<br>
}. classAttributes<br>
{ iD '00111111111111111111111111111111111111 OO'H,<br>
usage { encrypt, decrypt, sign, verify },<br>
keyReference 1<br>
}. typeAttributes<br>
{ value indirect: path :<br>
{ path'0012'H<br>
}. modulusLength 1024<br>
} }<br>
value PKCS15PrivateKey ::= privateRSAKey :<br>
{ commonObjectAttributes<br>
{ label "NR-KEY",<br>
flags {private},<br>
authld *02'H<br>
}. classAttributes<br>
{ iD'0022222222222222222222222222222222222200'H,<br><br>
usage {nonRepudiation}, keyReference 2<br>
}. typeAttributes<br>
{ value indirect: path :<br>
{ path'0012'H<br>
rnodulusLength 1024<br>
} }<br>
After encoding this file, we obtain:<br>
Record length (hexa): 41<br>
303F3010 0C074155 542D4B45 59030207 80040101 301D0414 00111111 11111111<br>
11111111 11111111 11111100 030201 E2 020101A1 OC300A30 04040200 12020204<br>
00<br>
Record length (hexa): 41<br>
303F300F 0C064E52 2D4B4559 03020780 04010230 1 E041400 22222222 22222222<br>
22222222 22222222 22220003 03060040 020102A1 0C300A30 04040200 12020204<br>
00<br>
EF(PrKDF) fiie length: 82<br>
ll) Writing file EF(UnusedSpace) according to standard PKCS#15 and ASN1 value PKCS15UnusedSpace ::=<br>
{ path<br>
{ path '6200'H,<br>
index 0,<br>
length 1500<br><br>
authld'OVH<br>
After encoding this fiie, we obtain:<br>
Record length (hexa): 12<br>
3010300B 04026200 02010080 0205DC04 0101<br>
EF(UnusedSpace) file length; 12<br>
HI) Writing file EF(DQDF) according to standard PKCS#15 and ASN1<br>
value PKCS15Data ::= opaqueDO :<br>
{ commonObjectAttributes<br>
{ flags { private, modifiable },<br>
authld'OVH<br>
}, classAttributes<br>
{ appIicationOID { 2 23 43 1 2 1 }<br>
}.<br>
typeAtthbutes indirect: path :<br>
{ path'5108'H.<br>
index 0,<br>
length 176<br>
}<br>
}<br>
value PKCS15Data ::= opaqueDO :<br>
{ commonObjectAttributes<br>
{ flags { private, modifiable },<br>
authld'OI'H<br><br>
ciassAttributes<br>
{ appliGationOID{2 23 43 122}<br>
typeAttributes indirect: path :<br>
{ path'5109'H,<br>
index 0,<br>
length 176<br>
}<br>
After encoding this file, we obtain:<br>
Record length (hexa): 23<br>
30213007 030206CO 04010130 07060567 2B010201 A10D300B 04025103 02010080<br>
0200B0<br>
Record length (hexa): 23<br>
30213007 030206C0 04010130 07060567 2B010202 A10D300B 04025109 02010080<br>
0200B0<br>
EF(DODF) file length: 46<br>
IV) Writing file EF(CDn according to standard PKCS#15 and ASN1<br>
value PKCS15Certificate ;:= x509Certificate :<br>
{ commonObjectAttributes<br>
{ label "User Auth Certificate File", flags {modifiable}<br>
}, ciassAttributes<br>
{ iD '00111111111111111111111111111111111111 OO'H,<br>
authority FALSE,<br><br>
requestld<br>
{ idType 5, idValue PKCS15identifier: '492C1 FF42D87C375789444E8EC309C67C97B8D25'H<br>
}<br>
typeAttributes<br>
{ value indirect: path :<br>
{ path'6001'H.<br>
index 0, length 704<br>
}<br>
} }<br>
value PKCS15Certificate ::= x509Certificate :<br>
{ commonObjectAttributes<br>
1 label "User NR Certificate File",<br>
flags { modifiable}<br>
}.<br>
class Attributes<br>
{ iD '0022222222222222222222222222222222222200'H.<br>
authority FALSE,<br>
requestld<br>
{ idType 5,<br>
idValue PKCS15ldentifler: '492C1 FF42D87C376789444E8EC309C57C97B8D25'H<br>
}<br>
}, typeAttributes<br>
{ value indirect: path :<br>
(<br><br>
path'6002'H. index 0, length 704<br>
}<br>
} }<br>
value PKCS15Certificate ::= x509Certificate ;<br>
{<br>
	commonObjectAttributes<br>
{ label "User Auth Certificate URL", flags { modifiable}<br>
}.<br>
	classAttributes<br>
{ ID '00111111111111111111111111111111111111OO'H,<br>
authority FALSE,<br>
requestld<br>
	{<br>
IdType 5,<br>
idValue PKCS151dentifier: '492C1 FF42D87C376789444E8EC309C67C97B8D25'H }<br>
}-typeAttributes<br>
{ value indirect: uri: "http://baseAddress/certs?ih=:OI+06/g ..."<br>
}<br>
}<br>
value PKCS15Certifioate ::= x509Certificate :<br>
{ commonObjectAttributes<br>
{ label "User NR Certificate URL", flags {modifiable}<br>
ci ass Attributes<br><br>
{<br>
lD'00222222222222222222222222222222222222C0 H, authority FALSE, requestld<br>
{ idType 5,<br>
idVaiue PKCS15Identifier: '492C1FF42D87C376789444E3EC3G9C57C97B3D25'M<br>
} }, typeAttributes<br>
I. value indirect: url: "http://baseAddress/cert3?ih=Oi-f05/g ..."<br>
i After encoding this file, we obtain;<br>
Record length (hexa): 68<br>
30663020 0C1A5573 65722041 75746820 43657274 69666963 61746520 45696C65 03020640 30310414 00111111 11111111 11111111 11111111 11111100 30190201 05041449 2C1FF42D 87C37678 9444E8EC 309C67C9 7B8D25A1 OF300D30 0B04C260. 01020100 800202C0<br>
Record length (hexa): 66<br>
3064301E 0C185573 6572204E 52204365 72746966 69636174 65204669 6C650302 06403031 04140022 22222222 22222222 22222222 22222222 22003019 02010504 14492C1F F42D87C3 76789444 E8EC309C 67C97B8D 25A10F30 0D300B04 02600202 01008002 02C0<br>
Record length (hexa): AO<br>
30819030 1F0C1955 73657220 41757468 20436572 74696669 63617465 2055524C 03020640 30310414 00111111 11111111 11111111 11111111 11111100 30190201 05041449 2C1FF42D 87C37678 9444E8EC 309C67C9 7B8D25A1 47304516 43687474 703A2F2F 62617365 41646472 6573732F 63657274 733F6968 3D4F692B 30362F67 3975574E 66777977 42344343 6D343147 79523845 3D736E3D 4F6F7230 36673D3D<br>
Record length (hexa): 9E<br>
30819B30 1D0C1755 73657220 4E522043 65727469 66696361 74652055 524C0302<br><br>
06403031 04140022 22222222 22222222 22222222 22222222 22003019 02010504 14492C1F F42D87C3 76789444 E8EC3C9C 37C97B8D 25A14730 45164368 7474703A 2F2F6261 73654164 64726573 732F6365 7274733F 69683D4F 692B3036 2F673975 574E6677 79774234 43436D34 31477952 38453D73 6E3D4F6F 72303741 3D3D<br>
EF(CDF) file length: 20C<br>
V) Writing file EF(ODF) according to standard PKCS#15 and ASN1<br>
value PKCS150bjects ::= privateKeys : path :<br>
{ path'5101'H<br>
}<br>
value PKCS150bjects ;:= certificates : path :<br>
{ path'5103'H<br>
)<br>
value PKCSISObjects ::= trustedCertificates : path :<br>
{ path'5104'H<br>
}<br>
value PKCS150bjects = usefulCertificates : path :<br>
{ path'5105H<br>
}<br>
value PKCSISObjects ::= dataObjects ; path :<br>
{ path'5106'H<br>
}<br>
value PKCS150bjects ::= authObjects : path : {<br><br>
path'5107'H<br>
}<br>
Record length (hexa): 8 A0063004 04025101<br>
Record length (hexa): 8 A4063004 04025103<br>
Record length (hexa): 8 A5063004 04025104-<br>
Record length (hexa): 8 A6063004 04025105<br>
Record length (hexa): 8 A7063004 04025106<br>
Record length (hexa): 8 A8063004 04025107<br>
EF(ODF) tile length: 30<br>
Vl) Writing file EF(CDR according to standard PKCS#15 and ASN1<br>
value PKCS15Certificate ::= wtlsCertificate :<br>
{ commonObjectAttributes<br>
{ label "Entrust.net Test WAP CA",<br>
flags { }<br>
}. classAttributes<br><br>
{<br>
iD'D4C6D9234AEF75233FB5B5BF4427FCFBC55C40E3'H,<br>
authority TRUE,<br>
requestid<br>
{ idType 5, idValue PKCS15ldentifier: 'D4C6D9234AEF75233FB5B5BF4427FCFBC55C40E3^H<br>
} }. typeAttributes<br>
{ value indirect: path ;<br>
{ path'610rH.<br>
index 0,<br>
length 431<br>
}<br>
}<br>
}<br>
After encoding this file, we obtain:<br>
Record length (hexa): 67<br>
A365301C 0C17456E 74727573 742E6E65 74205465 73742057 41502043 410301 CO 30340414 D4C6D923 4AEF7523 3FB5B5BF 4427FCFB C55C40E3 0101FF30 19020105 0414D4C6 D9234AEF 75233FB5 B5BF4427 FCFBC55C 40E3A10F 300D300B 04026101 02010080 0201AF<br>
EF(CDF) file length: 67<br>
VH) Writing file EF(AQDF) according to standard PKCS#15 and ASN1<br>
value PKCS15Authenticatlon ::= pin :<br>
{ commonObjectAttributes<br>
{ label "PIN-G",<br><br>
flags { private, modifiable }<br>
}, ciassAttributes<br>
{ authld'01'H<br>
}, typeAttributes<br>
{ pinFIags { case-sensitive, local, initialized, needs-padding, disabie-allowed },<br>
pinType ascii-numeric,<br>
minLength 4,<br>
storedLength 8,<br>
pinReference 1,<br>
padChar 'FF'H,<br>
path<br>
{ path 'OOOO'H<br>
} }<br>
;<br>
value PKCS15Authentication ::= pin :<br>
{ commonObjectAttributes<br>
{ label "PIN-NR",<br>
flags { private, modifiable }<br>
}. ciassAttributes<br>
{ authld '02'H<br>
}. typeAttributes<br>
{ pinFIags { case-sensitive, local, initialized, needs-padding },<br>
pinType ascii-numeric,<br>
minLength 4,<br>
StoredLength 8,<br><br>
pinReference 2,<br>
padChar'FF'H,<br>
path<br>
{ path'0100'H<br>
} }<br>
}<br>
After encoding this file, we obtain:<br>
Record length (hexa): 32<br>
3030300B 0C055049 4E2D4703 0206C030 03040101 A11C301A 030307CC 800A0101<br>
02010402 01088001 010401FF 30040402 0000<br>
Record length (hexa): 32<br>
3030300C 0C065049 4E2D4E52 03020SC0 30030401 02A11B30 19030202 CC0A01G1<br>
02010402 01088001 020401 FF 30040402 0100<br>
EF(AODF) file length: 64<br><br><br><br>
Claims<br>
1- Data processing device, in particular a smartcard, storing encoded data in memory represented by a tree structure in directories and files according to an object representation, characterised in that it comprises<br>
-	a specific referencing object abie to reference all or some of the attributes of the encoded data in memory,<br>
-	and in that the update of the encoded data is managed by a microcontroller programmed to<br><br>
-	extract from the referencing object the information required to locate the memory block occupied by this attribute,<br>
-	and update this block, replacing it by the new data, previously encoded.<br><br>
2.	Device according to claim 1, characterised in that the access to said referencing object is write protected in the data processing device<br>
3.	Device according to claim 1 or 2, characterised in that said referencing object comprises permanent data.<br>
4.	Device according to claim 1, characterised in that the referencing object<br>
comprises attributes identifying<br>
-	the file (EF(PrKDF)),<br>
-	the attribute (ClassAttributes.iD) to be updated in this file,<br>
-	and the location (counter, Length) of this attribute in the file in question,<br>
5- Method to update encoded data stored in a memory of a data processing device such as a smartcard, said data being represented by a tree structure in directories and files according to an object representation, characterised in that it comprises:<br>
-	a preliminary step to create a specific referencing object able to reference ail or<br>
some of the attributes of the encoded data in memory,<br>
and in that updating comprises the following steps:<br><br>
-	a step to extract from the referencing object the information required to locate the memory block occupied by this attribute,<br>
-	a step to update this block, replacing it by the new data, previously encoded.<br><br>
6.	Update method according to claim 5, characterised in that, after creating the referencing object and before updating the encoded data, a step consists of write protecting said referencing object in the data processing device.<br>
7.	Method according to claim 5, characterised in that the preliminary step to create a specific referencing object is carried out during the personalisation phase of the data processing device.<br>
8.	Computer program to update encoded data stored in a memory of a data processing device such as a smartcard, said program comprising program code instructions to execute update steps as defined in claim 5.<br>
9.	Computer program according to claim 8, characterised in that the execution of the update steps is carried out on the smartcard.<br>
10.	Computer program according to claim 8, characterised in that the execution of<br>
the update steps is carried out by an external tool connected to the smartcard.<br>
1<br><br>
11.      A data processing device, substantially as herein described with reference to the accompanying drawings.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY3My1jaGVucC0yMDA0LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">1673-chenp-2004-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY3My1jaGVucC0yMDA0LWNsYWltcyBmaWxlZC5wZGY=" target="_blank" style="word-wrap:break-word;">1673-chenp-2004-claims filed.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY3My1jaGVucC0yMDA0LWNsYWltcyBncmFudGVkLnBkZg==" target="_blank" style="word-wrap:break-word;">1673-chenp-2004-claims granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY3My1jaGVucC0yMDA0LWNvcnJlc3BvbmRuZWNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">1673-chenp-2004-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY3My1jaGVucC0yMDA0LWNvcnJlc3BvbmRuZWNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">1673-chenp-2004-correspondnece-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY3My1jaGVucC0yMDA0LWRlc2NyaXB0aW9uKGNvbXBsZXRlKWZpbGVkLnBkZg==" target="_blank" style="word-wrap:break-word;">1673-chenp-2004-description(complete)filed.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY3My1jaGVucC0yMDA0LWRlc2NyaXB0aW9uKGNvbXBsZXRlKWdyYW50ZWQucGRm" target="_blank" style="word-wrap:break-word;">1673-chenp-2004-description(complete)granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY3My1jaGVucC0yMDA0LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1673-chenp-2004-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY3My1jaGVucC0yMDA0LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">1673-chenp-2004-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY3My1jaGVucC0yMDA0LWZvcm0gMjYucGRm" target="_blank" style="word-wrap:break-word;">1673-chenp-2004-form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY3My1jaGVucC0yMDA0LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">1673-chenp-2004-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY3My1jaGVucC0yMDA0LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">1673-chenp-2004-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY3My1jaGVucC0yMDA0LW90aGVyIGRvY3VtZW50cy5wZGY=" target="_blank" style="word-wrap:break-word;">1673-chenp-2004-other documents.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY3My1jaGVucC0yMDA0LXBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">1673-chenp-2004-pct.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzLTE2NzMtY2hlbnAtMjAwNC5qcGc=" target="_blank" style="word-wrap:break-word;">abs-1673-chenp-2004.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="212237-a-medicament-for-inhibiting-the-production-of-beta-lactamases-by-pathogenic-bacteria.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="212239-medicament-container-and-method-of-manufacture-thereof.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>212238</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1673/CHENP/2004</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>07/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>15-Feb-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>26-Nov-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>29-Jul-2004</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>M/S. AXALTO SA</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>50 avenue Jean Jaurès, F-92120 Montrouge</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>MAHALAL, Ilan</td>
											<td>16 avenue de Bouvines, F-75011 Paris</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G07F 7/10</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/IB2003/000311</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2003-01-31</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>0201363</td>
									<td>2002-02-01</td>
								    <td>France</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/212238-update-management-for-encoded-data-in-memory by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:15:50 GMT -->
</html>
