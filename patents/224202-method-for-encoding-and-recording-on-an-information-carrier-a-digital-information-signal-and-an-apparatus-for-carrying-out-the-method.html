<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/224202-method-for-encoding-and-recording-on-an-information-carrier-a-digital-information-signal-and-an-apparatus-for-carrying-out-the-method by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:15:36 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 224202:METHOD FOR ENCODING AND RECORDING ON AN INFORMATION CARRIER A DIGITAL INFORMATION SIGNAL AND AN APPARATUS FOR CARRYING OUT THE METHOD</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD FOR ENCODING AND RECORDING ON AN INFORMATION CARRIER A DIGITAL INFORMATION SIGNAL AND AN APPARATUS FOR CARRYING OUT THE METHOD</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The invention relates to measures to improve an arithmetic encoder and a corresponding arithmetic decoder. More specifically, proposals are given to truncate the A parameter, prior to carrying out the multiplication A.p. Further, a proposal is given for the carry-over control in the re-nomalization step in the encoder.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>Arithmetic encoding and decoding of an information signal.<br>
The invention relates to a method of arithmetic encoding an information signal, to an apparatus for arithmetic encoding the information signal and to an apparatus for decoding the arithmetically encoded information signal-Arithmetic coding is a well-known technique for lossless coding and an introduction can be found in any current source coding book. For a thorough understanding of the implementations of arithmetic coding that are most relevant for the current work, the reader is referred to [Lang84]. The history of aritlimetic coding is nicely described in the appendix of this document. Further, [Howard94] gives an extensive explanation of arithmetic coding.<br>
The implementation of aritlimetic coding that is the subject of the present invention uses two finite-size registers, which are usually called C and A. The flow diagram of the encoder operation is shown in figure 1. The C register points to the bottom of an interval on the number line, the size of which is stored in A, see, e.g [Lang81] and [Pemn88]. The interval is split into sub-intervals, each sub-interval corresponding to a symbol to be encoded and the size of each sub-interval corresponding to the probability of the associated symbol. For actually encoding a symbol, the C register is adjusted to point to the bottom of the sub-interval corresponding to the symbol and the A register is set to the size of the selected sub-interval. The A register (as well as C) is then normalized (left-shifted), before the next symbol is encoded. In general, after re-normalization, the value of A lies between the values k and 2k: k 
For example, in the binary case, there are two sub-intervals and thus two possible updates of the C and A registers, depending on whether the bit to be encoded is the most probable symbol (MPS) or the least probable symbol (LPS). It is assumed that the MPS is assigned to the lower interval. The "Update A and C" block of figure 1 is shown for the binary case in figure 2. The probability of the input bit being the LPS is denoted by p (notice that p <l because the probability of mps is> 1/2). The input bit to be encoded is denoted by b. The values of b and p are provided by the "Read......." block. Now, if a MPS is<br>
to be encoded, C does not change, since the lower interval is selected and C already points to this interval. However, A does change and its update is A=A-A.p (using the fact that the probability of the MPS equals 1-p). If a LPS is to be encoded, both C and A are changed: C is updated as C=C+A-A.p and the ne\v interval size is A= A.p. It should further be noted that, by a pre- and post-processing, it can be assured that the MPS is always e.g. the "0" bit and the LPS is always the "1" bit. Finally, figure 2 shows an "approximate multiplication" block, because it turns out that the multiplication A.p can be performed with low accuracy, at only a small loss of performance, thus reducing the hardware complexity. Techniques to do the approximate multiplication are discussed later on below.<br>
For the non-binary case, the "Update A and C" block of figure 1 is shown in<br>
figure 3. The "Read......" block now provides the symbol to be encoded, s, as well as two<br>
probability values: the probability ps of symbol s and the cumulative probability p, of all symbols ranked below symbol s. As can be observed from figure 3, symbol M is treated differently from the others, in order to exactly "fill" A. It is shown in [Riss89] that it is advantageous to assign the MPS to symbol M.<br>
In order to be able to decode, the decoder must know the value of C, since this determines the symbol that was encoded. So, what is sent to the decoder is the value of the C register. Actually, each time the A register is left-shifted in the renormalization process, the MSB of C (also referred to as "carry bit") is processed for transmission to the decoder. The problem with using a finite-size register for C is that a bit that was already shifted out of C could later have to be adjusted by a carry caused by incrementing C. To take care of this, carry-over control is needed. The state-of-the-art techniques completely solve the problem at the encoder, so the decoder is not affected by this. These solutions, which minimize decoder complexity, will also be discussed later on.<br>
The decoder flow diagram is shown in figure 4. For the binary case, the "Output symbol ...." block is shown in figure 5. In the non-binary case, the decoder is more complex, since it has to find the inverse of "C=C+D", without knowing the value of s.<br>
The invention aims at providing improvements for the above described arithmetic coders. In accordance with the invention, the encoding method comprises a serial sequence of n-bit symbols, n being an integer for which holds n&gt;l, using finite sized first and second registers for storing an A parameter and a C parameter, respectively, the C parameter<br>
having a relationship with a boundary' of a value interval and the A parameter having a relationship with the size of the said interval, the method comprising the steps of<br>
(a) inputting a symbol of the information signal and at least one corresponding probability value of the associated symbol for encoding,<br>
(b) retrieving the values for the A and C parameters from the first and second registers, respectively,<br>
(c) splitting the value interval corresponding to the value retrieved from the first register into sub intervals corresponding to the said at least one probability value, and selecting one of the subintervals in response to the said symbol,<br>
(d) updating at least the A parameter so as to bring its value in accordance with the size of the selected subinterval, in order to become the new size of the interval for encoding the next symbol in the information signal,<br>
(e) storing the updated value for the A parameter in the first register,<br>
(f) continue the method in step (a) for encoding the next symbol,<br>
characterized in that the step (b) further comprises the substep of truncating the value of the A<br>
parameter 0.bob1.....bi-1b,.... to the bit b,.| and adding T at the position of the bit to the<br>
truncated value of A, if bj equals '1'. In another elaboration, the encoding method comprises a serial sequence of n-bit symbols, n being an integer for which holds n&gt;l, using finite sized first and second registers for storing an A parameter and a C parameter, respectively, the C parameter having a relationship with a boundary of a value interval and the A parameter having a relationship with the size of the said interval, the method comprising the steps of<br>
(a) inputting a symbol of the information signal and at least one corresponding probability value of the associated symbol for encoding,<br>
(b) retrieving the values for the A and C parameters from the first and second registers, respectively,<br>
(c) splitting the value interval corresponding to the value retrieved from the first register into sub intervals corresponding to the said at least one probability value, and selecting one of the subintervals in response to the said symbol,<br>
(d) updating at least the A parameter so as to bring its value in accordance with the size of the selected subinterval, in order to become the new size of the interval for encoding the next symbol in the information signal,<br>
(e) storing the updated value for the A parameter in the first register,<br>
(f) continue the method in step (a) for encoding the next symbol,<br>
characterized in that the step (b) further comprises the substep of truncating the value of the A<br>
parameter 0.b0bi ..... to the bit b,.| and, if bi = 0' and b, = T, raise b,.i to T.<br>
In again another elaboration, the encoding method comprises a serial sequence of n-bit symbols, n being an integer for which holds n&gt;l, using finite sized first and second registers for storing an A parameter and a C parameter, respectively, the C parameter having a. relationship with a boundary of a value interval and the A parameter having a relationship with the size of the said interval, the method comprising the steps of<br>
(a) inputting a symbol of the information signal and at least one corresponding probability value of the associated symbol for encoding,<br>
(b) retrieving the values for the A and C parameters from the first and second registers, respectively,<br>
(c) splitting the value interval corresponding to the value retrieved from the first register into sub intervals corresponding to the said at least one probability value, and selecting one of the subintervals in response to the said symbol,<br>
(d) updating at least the A parameter so as to bring its value in accordance with the size of the selected subinterval, in order to become the new size of the interval for encoding the next symbol in the information signal,<br>
(e) storing the updated value for the A parameter in the first register,<br>
(f) continue the method in step (a) for encoding the next symbol,<br>
characterized in that the step (b) further comprises the substep of truncating the value of the A<br>
parameter to the bit bi. and make the bit bi. equal to ' 1'.<br>
The improvements presented in this invention relate to the approximate multiplication blocks (which arc used in both the encoder and the decoder) and the carry-over control, which takes place in the "Renormalize......" block, in the encoder only.<br>
These and other aspects of the invention will be described in more detail hereafter, <br>
figure 1 shows a flow diagram of the arithmetic encoder,<br>
figure 2 shows the flow diagram of the encoder block "Update A and C" in<br>
figure 1, for the binary case. The LPS probability is p and the value of the bit that is to be<br>
encoded is held by b,<br>
figure 3 shows the flow diagram of the encoder block "Update A and C" in figure 1, for the non-binary case. The value of the symbol that is to be encoded is held by s and its probability is held in ps. The M+l symbols are numbered 0,....M. p is the cumulative probability of all symbols ranked below symbol s. figure 4 shows a flow diagram of the decoder,<br>
figure 5 shows the flow diagram for decoder block "Output symbol...." in figure 4, for the binary case. The LPS probability is p and the value of the bit that is decoded is put in b.<br>
figure 6 shows the flow diagram of the encoder block denoted "Renormalize ...." in figure 1,<br>
figure 7 shows the flow diagram of the encoder block denoted "Initialize" in figure 1,<br>
figure 8 shows a flow diagram of the encoder block denoted "Terminate" in figure 1,<br>
figure 9 shows a flow diagram of the decoder block denoted 'Initialize" in figure 4,<br>
figure 10 shows a flow diagram of the decoder block denoted "Renormalize....."<br>
in figure 4,<br>
figure 11 shows an embodiment of the encoder apparatus, and<br>
figure 12 shows an embodiment of the decoder apparatus.<br>
As regards the improvements to the multiplication, the following can be said. The problem of "avoiding" the multiplication A.p was solved in [Lang81] by approximating p by 2 exp{-Q}, where Q is an integer. Multiplication by p then simply corresponds to a right shift by Q positions. Q is called the skew number. Later, such as in [Riss89] the A register was normalized such that 0.75 
Still better performance was obtained in [Chev91a] and [Chev91b]. They claim approximating A by eliminating all binary digits less significant than a predetermined binary 1 digit, and their preferred embodiment is to use the second most significant binary 1 digit. Thus, in the preferred embodiment, the value of A is approximated by a binary number containing two non-zero bits, which implies that the multiplication can be performed using a single shift and add operation. Finally, [Feyg93] describes an improved approximation of A, that also can be implemented using a single shift and add operation.<br>
The method(s) that is(are) actually used in the present invention to approximate the multiplication are as follows. Let the probabilities (p) be described using NP bits. For example, ifNP=8, then p= 1/4=2 exp{-2}=0.01 (binary) would be represented by binary 01000000, i.e. the "0." is not included, since it is the same for all probabilities. The size of the A register is chosen as NA=NP+NX bits, where NX represents the number of bits that are used to approximate the value of A that is used for the multiplication. For example, let NX=3 and A=3/4=0.11, then A would be a 8+3=11-bit register containing 11000000000 (notice that again the "0." is dropped, since we normalize A such that it is always less than one). For the multiplication, we approximate A by a 3-bit number; in this case, it is clear that the best approximation is 110. The result of the approximate multiplication A . p would then be 00110000000, i.e. again an 11-bit number. This way of implementing the approximate multiplication was suggested, amongst others, in [Feyg93].<br>
Below, an discussion will be given as to how the NA-bit number A should be approximated by NX bits.<br>
The first way of approximating A (the method PI) comprises the measure to round A to NX bits instead of truncating it. Rounding means that A is truncated to NX bits if the (NX+l)th bit of A is a 0 and that 1 is added to this truncated representation if the (NX+l)th<br>
bit is a 1. For example, if A=l 101......, the 3-bit approximation would be 111. The rounding<br>
that is applied increases the complexity, since, in about half of the cases, 1 has to be added to the truncated representation, which means either an add operation or a table lookup must be done.<br>
As an alternative (method P2), it is proposed to adopt a what is called "partial rounding". By partial rounding, a 1 is only added to the truncated representation of A in case the (NX+l)th bit is a T and the NXth bit is a '0'. In the implementation this means that the NXth bit of the approximation of A equals the logical OR of the NXth and (NX+l)th bits of<br>
the original A. For example, A=1011......would be approximated by 101 and A=1001.....<br>
would be approximated by 101 as well, whereas A=1000........would be approximated by 100.<br>
Notice that the partial rounding results in the same approximation as the "full rounding" in about 75 % of the cases.<br>
In another alternative (method P3), it is proposed to approximate A by<br>
truncating it to NX bits and to always set the NXth bit of the approximation to 1, with the idea that this further reduces the complexity of a hardware implementation, since it eliminates half of the possible approximate values for A.<br>
The performance of some known methods have been compared to the three new methods described above. The performances of the various methods are listed in table I The methods that are shown in the table, in addition to the three approximation methods (PI, P2 and P3) described above, are a reference method, denoted 'reference', which computes the full NAxNP-bit multiplication and only then truncates A to NA bits, the method of [Moff95], the method of [Chev91a], the method described in section 3 of Feyg93, denoted Feyg93(l), and the method described in section 4 of Feyg93, denoted Feyg93(2).<br>
The numbers that are listed are relative sizes of the compressed files, with 100 corresponding to "no loss" due to a non-perfect approximation of the multiplication. For example, a number of 100.57 means that the size of the compressed file is increased by 0.57 % due to the approximate multiplication.<br>
As expected, the performance of method P2 is better than that of method Moff95, but not as good as that of method PI.<br>
The method P2 is a good compromise. More specifically, P2 for NX=3 and NX=4 provides a good trade-off between performance and complexity, since its performance is practically the same as that of method PI (see the above table), at a lower complexity. For NX=2, method PI is the preferred method, whilst the method P3 can be used for NX=5 and larger.<br>
In the non-binary case, methods that can approximate the value of A by rounding up have the potential problem that there could be no "room" left for the MPS, when the alphabet size increases [Feyg93]. For method Feyg93(2), the worst-case limit on the alphabet size is 11 [Feyg93]. The presently proposed new approximation methods have the advantage that the amount by which A can be increased by rounding up decreases as NX is<br>
increased. Therefore, if there is an application in which the probability distribution is such that the alphabet size is limited (and the performance of the methods that can only truncate, or round down, is insufficient), a larger alphabet can be handled by increasing NX.<br>
The carry-over control problem in the renormalization step in the encoder was originally solved by a technique called "bit stuffing" [LangSl]. This teclmique "catches" the carry by inserting a 0 stuff bit into the coded stream in case a series of 1 bits has been encountered. The disadvantages of this technique are that it reduces the compression efficiency, because of the extra stuff bits, and that it requires special processing in the decoder.<br>
A method to prevent the carry-over without affecting the compression performance was described in [Witt87]. This method has the disadvantage that the decoder complexity is somewhat increased. The idea of [Witt87] was adapted in [Cham90], such that it could be used without increasing the decoder complexity.<br>
Here, a different solution is presented that also does not increase the decoder complexity. The flow diagram of the encoder rcnonnalization procedure in accordance with<br>
the invention is shown in figure 6. The main improvement is the block with C 
this same block, the prior art uses C+A
compared to the present proposal.<br>
To complete the description of the encoder, the initialization and termination blocks are shown in figure 7 and figure 8, respectively. The counter variable is the same as the one that is used in the encoder renormalization block shown in figure 6. Since the size of C is (NA+1) bits (in the encoder), it has NA fractional bits ("bits after the point"), which are outpul on termination, as shown in figure 8.<br>
The decoder initialization is shown in figure 9. The C register is filled by reading (NA+1) bits from the stream. The first bit read is a "dummy", since it is always a "0" bit. The size of the C register in the decoder is only NA bits, so one less than in the encoder. There is no special termination in the decoder (the "Terminate" block in figure 4 is empty).<br>
The renormalization in the decoder (the "Renormalize......" block in figure 4) is shown in<br>
figure 10.<br>
Figure 11 shows an embodiment of the encoder apparatus in accordance with the invention. The apparatus comprises input terminals 100 and 102, for receiving the information signal and a probability signal, respectively. The information signal comprises a serial sequence of n-bit symbols, n being an integer for which holds n&gt;l. The probability signal applied to the input terminal 102 comprises one or more probabilities for each symbol in the information signal. For binary1 symbols, the probability signal comprises one probabilit)<br>
for each symbol. Finite sized first and second registers 104 and 106, respectively, are present, for storing the A parameter and the C parameter.<br>
A processing unit 108 is available for carrying out the arithmetic coding on the information signal. It should be understood that, without going into very much detail as regards the processing unit 108, this unit comprises circuitry for retrieving the values for the A and C parameters from the first and second registers, as well as circuitry for storing the updated and renormalized values for A and C in the first and second registers 104 and 106, respectively, after having encoded a symbol. Further, the unit 108 comprises circuitry for splitting the value interval corresponding to the value retrieved from the first register 104 into sub intervals corresponding to the said at least one probability value applied to the input terminal 102, and circuitry for selecting one of the sub intervals in response to the said symbol applied to the input terminal 100.<br>
Circuitry for updating the A and C parameters are also present, where this circuitry is required so as to bring the A value in accordance with the size of the selected subinterval, and so as to bring the C value in accordance with a boundary of the said subinterval.<br>
An output terminal 110 is available outputting encoded bits in response to the encoded symbols.<br>
The retrieval means for retrieving the A and C parameters from their corresponding registers further comprises means for truncating the value of the A parameter, prior to carrying out the calculation A . p. More specifically, this truncation can be as follows:<br>
suppose the value for A is expressed as 0.b0b1.....bi-1bi.....This value is truncated to to the bit<br>
0.b and a T is added at the position of the bit b,.| to the truncated value of A, if b, equals T.<br>
In another elaboration, the value of the A parameter is truncated to the bit b,.| and, if b, = '0' and b, = T, the bit b,.| is raised to '1'. In again another elaboration, the A parameter is truncated to the bit b,.| and the bit b,.| is made equal to T.<br>
It will be appreciated that the processing unit 108 is capable of carrying out the method, as disclosed in the figures 1, 2, 3, 6, 7 and 8.<br>
Preferably, the encoder apparatus is further provided with a channel encoding unit 112, well known in the art, for channel encoding (and, if needed, error correction encoding) the encoded information signal into a channel encoded information signal, and a write unit 104 for writing the channel encoded signal onto a record carrier, such as a magnetic record carrier 116, or an optical record carrier 11 8.<br>
Figure 12 shows an embodiment of the decoder apparatus in accordance with the invention. The decoder apparatus comprises an input terminal 120 for receiving the encoded information signal. Finite sized First and second registers 122 and 124 arc present, for storing the A parameter and the C parameter, respectively.<br>
A processing unit 126 is available for carrying out the arithmetic decoding on the encoded information signal that is received via its input 120, in response to a probability signal supplied to the processing unit 126 via an input 134. The probability signal can be obtained in a well known way. An example of deriving the probabilities for a 1-bit audio signal is shown in [Bruek97], In this example, the probabilities are derived from the decoded output signal that is supplied to the output 128, namely by carrying out a prediction filtering on the decoded output signal in prediction filter 136 and generating the probobility in response to the output signal of the prediction filter 136 in the probability determining unit 138. It should be understood that, without going into very much detail as regards the processing unit 126, this unit comprises circuitry for retrieving the values for the A and C parameters from the first and second registers, as well as circuitry for storing the updated and renormalized values for A and C in the first and second registers 122 and 124, respectively, after having decoded a symbol. Further, the unit 126 comprises circuitry for carrying out the steps shown in the figures 4, 5, 9 and 10.<br>
The circuitry for retrieving the value of the A parameter from the register 122 further comprises means for truncating the value of the A parameter prior to carrying out the calculation A . p. This truncation is in the same way as described above for the encoder, so that from a further explanation will be refrained.<br>
Preferably, the decoder apparatus is further provided with a channel decoding unit 132, well known in the art, for channel decoding (and, if needed, error correcting) the channel encoded information signal into the arithmetically encoded information signal for the arithmetic decoder 126, and a read unit 130 for reading the channel encoded signal from a record carrier, such as the magnetic record carrier 116, or the optical record carrier 118.<br>
Arithmetic coding is applied in most modem lossless and lossy coding schemes for video and audio. It can also be applied in the compression of computer data (such as, e.g., text files). The application envisaged here, is in lossless coding of 1-bit audio signals. Reference is made in this respect to US ser. no 08/966,375, corresponding to EP patent application no.97201680.2 (PHN16405), US scr. no. 08/937,435, corresponding to international patent application no. IB 97/01156 (PHN 16452).<br>
Whilst the invention has been described with reference to preferred embodiments thereof, it is to be understood that these are not limitative examples. Thus, various modification may become apparent to those skilled in the art, without departing from the scope of the invention, as defined by the claims.<br>
Further, the invention lies in each and every novel feature or combination of features.<br>
REFERENCES:<br>
[Lang81] G.G. Langdon et al, "Compression of black-white images with aritlimctic<br>
coding", IEEE Trans, on Com., Vol. COM-29, pp. 858-67, June 1981." [Witt87] I.H. Witten et al, "Arithmetic coding for data compression", Communications<br>
ACM, Vol. 30, pp. 520-540, June 1987. [Lang 84] G.G. Langdon, "An introduction to arithmetic coding", IBM J. Res. Develop.,<br>
Vol. 28, pp. 135-149, March 1984.<br>
[Penn88] W.B. Pennebaker et al, "An overview of the basic principles of the Q-coder adaptive binary arithmetic coder", IBM J. Res. Develop., Vol. 32, pp. 717-26, Nov. 1988. [Riss89] J. Rissanen et al, "A multiplication-free multialphabet arithmetic code", IEEE<br>
Trans on Com, Vol. 37, pp. 93-8, Febr. 1989 [Cham90] USP 4,973,961 [Chev91a] D. Chevion et al, "High efficiency, multiplication free approximation of<br>
arithmetic coding" in Data Compression Conference (DCC '91), pp. 43-52, 1991 [Chev91b] USP 4,989,000.<br>
[Feyg93] G. Feygin et al, "Minimizing error and VLSI complexity in the multiplication free approximation of arithmetic coding" in Data Compression Conference" (DCC '93), pp. 118-127, Mar. 30-Apr. 1, 1993. [Howard94] P.G. Howard et al, "Arithmetic coding for data compression", Proc. IEEE,<br>
Vol. 82, no. 6, pp. 857-65, June 1994. [Moff95] A. Moffat et al, "Arithmetic coding revisited" in Data Compression Conference<br>
(DCC'95), pp. 202-11,1995.<br>
[Bruek97] F. Bruekers et al, "Improved lossless coding of 1 -bit audio signals", presented at 103rd Convention of the AES, Sept., 26-29, 1997, preprint 4563(1-6)<br>
We Claim,<br>
1. Method of encoding and recording on an information carrier a digital information signal, the digital information signal comprising a serial sequence of n-bit symbols, n being an integer for which holds n&gt;l, the method comprising the steps of:<br>
• arithmetically encoding the digital information signal, using finite sized first and second registers for storing an A parameter and a C parameter, respectively, the C parameter having a relationship with a boundary of a value interval and the A parameter having a relationship with the size of the said interval, by:<br>
(a) inputting a symbol of the information signal and at least one corresponding probability value of the associated symbol for encoding,<br>
(b) retrieving the values for the A and C parameters from the first and second registers, respectively,<br>
(c) splitting the value interval corresponding to the value retrieved from the first register into sub intervals corresponding to the said at least one probability value, and selecting one of the subintervais in response to the said symbol,<br>
(d) updating at least the A parameter so as to bring its value in accordance with the size of the selected subinterval, in order to become the new size of the interval for encoding the next symbol in the information signal,<br>
(e) storing the updated value for the A parameter in the first register, and<br>
(f) continue the method in step (a) for encoding the next symbol, so obtaining an encoded information signal,<br>
• channel encoding the encoded information signal into a channel encoded signal, and<br>
• recording the channel encoded signal on a record carrier, characterized in that<br>
the step (b) further comprises the substep of truncating the value of the A parameter 0.b0b1.....bi-1bi.... to the bit bj and the substep of manipulating the bit bj-i.<br>
2. The method of claim 1, characterized in thst the substep of manipulating the bit bj-i comprises the step of adding '1' at the position of the bit b|-i to the truncated value of A, if b; equals '1'.<br>
3. The method of claim i, characterized in that the substep of manipulating the bit b-1 comprises the step of raising bj.i of the truncated value of A to '1' if bj.i = '0' and bi = 1'.<br>
4. The method of ciaim i, characterized in that the substep of manipulating the bit bj_i comprises the step of making the bit bj.i of the truncated value of A equal to '1'.<br>
5. The method of ciaim 1, 2, 3 or 4, the step of updating also comprising updating the C value so as to bring the value of tiie C parameter into a corresponding relationship with a boundary of the selected sub interval, in order to become the new C parameter for encoding the next symbol in the information signal, the step of storing further comprising storing the updated value of the C parameter in the second register.<br>
6. The method of claim 1, 2, 3, or 4, the step of updating further comprising the substep of renormalizing the values for the A and C parameter, prior to storing the renormalized values for the A and C parameters in the first and second registers, respectively, characterized in that the renormalization substep comprising<br>
(g1) comparing the value for A with a first binary value, if the value for A is not smaller<br>
than said first binary value, leave the renormaiization step, and if the value for A is<br>
smaller than said first binary value, then<br>
(g2) multiply the value for A with a first integer value,<br>
(g3) return to (g1).<br>
7. The method of claim 6, characterized in that if A Is smaller than said first binary value in (gl)<br>
(g4) compare the value for C with a second and a third binary value, the second binary value being larger than said third binary vaiue, and that, if the vaiue for C is smaller than said second binary value, and larger than or equal to said third binary value, then (g4) subtract a fourth binary value from the value for C so as to obtain an intermediate value for C, (g5) multiplying the intermediate value for C with a second integer value.<br>
8. The method of ciaim 6, characterized in that the first binary value equals 0.100....0.<br>
9. The method cf claim 7 characterized in that the second binary value equals 1.000...0..<br>
10. The method of claim 6, characterized in that the first integer value equals 2.<br>
11. The method of claim 7, characterized in that the third binary value equals 0.100...0.<br>
12. The method of ciaim 7, characterized in that the fourth binary value equals 0.1000...0.<br>
13. The method of claim 7, characterized in that the second integer value equals 2.<br>
14. Apparatus for carrying out the method as claimed in anyone of the preceding cairns, for arithmetically encoding a digital information signai comprising a serial sequence of n-bit symbols, n being an integer for which holds n&gt;l, the apparatus comprising<br>
- finite sized first and second registers for storing an A parameter and a C parameter, respectively, the C parameter having a relationship with a boundary of a vaiue interval and the A parameter having a relationship with the size of the said Interval,<br>
- input means for receiving a symbol of the information signal and at least one corresponding probability value for the associated symbol for encoding,<br>
- retrieval means for retrieving the values for the A and C parameters from the first and second registers, respectively,<br>
- means for splitting the value interval corresponding to the value retrieved from the first register into sub intervals corresponding to the said at least one probability value, and selecting one of the sub intervals in response to the said symbol,<br>
- means for updating at least the A parameter so as to bring its value in accordance with the size of the selected subinterval in order to become the new size of the interval for encoding the next symbol in the information signal,<br>
- means for storing the updated value for the A parameter in the first register, characterized in that the retrieval' means are further being adapted for truncating the<br>
value of the A parameter 0.b0b1.....bi-1bi .... to the bit bj_1 and for manipulating the bit<br>
15. Apparatus as claimed in claim 14 , characterized in that the retrieval means are further adapted for adding T at the position of the bit b;-i to the truncated value of A, if b, equals '1'.<br>
16. Apparatus as claimed in claim 14, characterized in that the retrieval means are further adapted for raising bj-i of the truncated value of A to '1' If b = *0' and b, = T.<br>
17. Apparatus as claimed in claim 14, characterized in that the retrieval means are further adapted for making the bit bj-i of the truncated value of A equal to T.<br>
18. The apparatus of claim 15, 16 or 17, further comprising means for renormalizing the values for the A and C parameter, prior to storing the renormalized values for the A and C parameters in the first and second registers, respectively, characterized in that the means for renormaSizing comprises means for<br>
(gi) comparing the value for A with a first binary value, if the vaiue for A is not smalier than said first binary value, leave the renormalization step, and if the value for A is smaller than said first binary value, then (g2) multiply the value for A with a first integer value.<br>
19= The apparatus of claim 18, characterized in that the renormalizing means<br>
further comprises means for<br>
(g4) comparing the value for C with a second and a third binary value, the second binary value being larger than said third binary value,<br>
(g4) subtracting a fourth binary value from the value for C so as to obtain an<br>
intermediate value for C,<br>
(g5) multiplying the intermediate value for C with a second integer value.<br>
20. The apparatus of claim 14, i5, 16 or 17, characterized in that it further comprises means for channel encoding the encoded information signal into a channel encoded signal.<br>
21. The apparatus of claim 20, characterized in that it further comprises recording means for recording the channel signal on a record carrier.<br>
22. Apparatus for arithmetically decoding an arithmetically encoded information signal into an information signal comprising a serial sequence of n-bit symbols, n being an integer for which holds n&gt;l, the apparatus comprising<br>
- input means for receiving the arithmetically encoded information signal,<br>
- finite sized first and second registers, the first register for storing an A parameter, the A parameter having a relationship with the size of a value interval, the second register for storing a C parameter, the contents of the second register before 3 decoding step being obtained from the contents of the second register obtained in a previous decoding step, by shifting m bits of the arithmetically encoded information signal into the second register, where m is a variable integer for which holds: m &gt; 0,<br>
- generator means for generating at least one probability value for an associated symbol to be decoded,<br>
- retrieval means for retrieving tine values for the A and C parameters from the first and second registers, respectively,<br>
- deriving means for deriving a symbol in response to the said at least one probability value, and in response to a value for A and a value for C,<br>
- means for updating at least the A parameter in order to become the new size of the interval for decoding the next symbol of the information signal,<br>
- means for outputting the derived symbol,<br>
- means for storing the updated value for the A parameter in the first register, characterized in that the retrieval means are further adapted for truncating the value of the A parameter O.bobi.....bj-ibi.... to the bit bj-i and manipulating the bit bj-t-<br>
23. The apparatus as claimed in claim 22, characterized in that the retrieval means further are arranged for adding 1' at the position of the bit b-,-i to the truncated value of A, if bj equals '!'.<br>
24. The apparatus as claimed in claim 22, characterized in that the retrieval means further are arranged for raising bi-i of the truncated value of A to T if b-i = '0' and bj = T.<br>
25. The apparatus as claimed in claim 22, characterized in that the retrieval means further are arranged for making the bit b,_i of the truncated value of A equal to T.<br>
25. The decoding apparatus as claimed in claim 23, 24 or 25, characterized in<br>
that it further comprises channel decoding means for channel decoding the arithmetically encoded information signal, prior to arithmetic decoding.<br>
27. The apparatus as claimed in claim 25, characterized in that it further<br>
comprises read means for reading the channel encoded arithmetically* encoded information signal from a record carrier.<br>
The invention relates to measures to improve an arithmetic encoder and a corresponding arithmetic decoder. More specifically, proposals are given to truncate the A parameter, prior to carrying out the multiplication A.p. Further, a proposal is given for the carry-over control in the re-nomalization step in the encoder.</l></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
		<br>
		<div class="pull-left">
			<a href="224201-an-improved-electrical-connector-element-having-a-plurailty-of-insulation-displacement-contacts.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="224203-a-pharmaceutical-composition-exhibiting-anti-hypertensive-activity-comprising-in-combination-an-effective-amount-of-a-non-steroidal-anti-inflammatory-drug-nsaid-and-an-effective-amount-of-a-vitami">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>224202</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/1999/0079/KOL</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>41/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>10-Oct-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>03-Oct-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>04-Nov-1999</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>KONINKLIJKE PHILIPS ELECTRONICS N.V.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>GROENEWOUDSEWEG 1, 5621 BA EINDHOVEN</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>VAN DER VLEUTEN, RENATUS, J</td>
											<td>PROF. HOLSTLAAN 6, NL-5656 AA EINDHOVEN</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H03M 7/40</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/IB99/00310</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>1999-02-22</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>98200914.4</td>
									<td>1998-03-23</td>
								    <td>EUROPEAN UNION</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/224202-method-for-encoding-and-recording-on-an-information-carrier-a-digital-information-signal-and-an-apparatus-for-carrying-out-the-method by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:15:37 GMT -->
</html>
