<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/264534-method-and-apparatus-for-determining-most-delayed-frame-in-a-virtual-concatenation-group by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:49:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 264534:METHOD AND APPARATUS FOR DETERMINING MOST DELAYED FRAME IN A VIRTUAL CONCATENATION GROUP</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD AND APPARATUS FOR DETERMINING MOST DELAYED FRAME IN A VIRTUAL CONCATENATION GROUP</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The discloser is related to a method to determine most delayed frame for each VCG within TUs contained in stream comprising multiple multiplexed STM streams comprising acts of: generating a frame update event for each TU at a predetermined point in each frame, storing &quot;frame number&quot; for each VCG, the corresponding VCG that the TU belongs to, and an &quot;age&quot; indication in a memory, implementing state machine to compare the newly received frame number with stored frame number for the current &quot;age&quot; value, updating the stored frame number for each VCG if the newly received frame is less than the stored frame number in a given &quot;age&quot; period and obtaining the stored frame number at the end of the current &quot;age&quot; period as the most-delayed frame for the given &quot;age&quot; period at beginning of next &quot;age&quot; indication. Figure 1</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FIELD OF INVENTION<br><br>
Virtual Concatenation is technique where data is split across different tributary units (TU's) and tagged with a frame number. As these are carried independently, the TUs experience different delays through the network. At the receiver, there needs to be a mechanism to determine the TU that suffers the longest delay. Only when a frame for this most-delayed TU has been received the data in all the TU's used for interleaving can be read and the original data-stream recovered by the appropriate interleaving of bytes. The present invention describes a method where multiple streams of data of various granularities are processed by a single controller to determine, for each stream, the frame number that can be processed for recovering the stream.<br><br>
BACKGROUND OF THE INVENTION<br><br>
Virtual concatenation is a technique standardized in ITU G.707 standard that describes how a signal can be split across several members and re-combined at the destination. The basis of this is to add a Multi-Frame Indicator (MFI) value for each 125 micro second frame at the source. The MFI is a 12-bit number as defined in the standard and is incremented for each successive frame transmitted. Since each frame is tagged with an MFI reference, at the receiver we can re-align the received frames based on this MFI value and re-constitute the original signal.<br><br>
The re-construction has to wait for all the frames with the same MFI value to arrive. Thus re-construction has to wait for the most-delayed member to be received and so determining which of the constituent members suffered the most delay, and on its arrival, to reconstruct the signal is the basis for the Virtual Concatenation operation.<br><br>
The term Virtual Concatenation Group (VCG) is used to refer to the aggregate signal that is made up using the Virtual Concatenation (VCAT) technique. Each of the members of the VCG is a Tributary Unit (TU). The synchronous Digital Hierarchy (SDH) standard specifies TU's of various granularities (TU11, TU12, TU2, VC3, VC4), each of a different bandwidth. In a given SDH frame, there can be TU's of different granularities and these in turn can be combined to form VCGs of varying bandwidth. This flexibility of partitioning the Bandwidth in small increments leads to very good utilization of the Optical transmission capacity and has led to the adoption of the VCAT technique for transporting several types of signals. In particular, it is popular to use VCGs to transport Ethernet signals across the Wide Area Network (WAN).<br><br>
 A carrier may use his SDH network to carry several data streams using VCAT and also carry traditional voice traffic mapped onto the Tributary units.<br><br>
The calculation of the most-delayed member in previous implementation was performed by storing in memory the frame number for each member on a continuous basis. On a periodic basis, or when there was a need to re-compute the most-delayed member, software would disable the updating of the frame-number memory. The result of this was that the frame number in memory reflected the approximate delay of the members. By reading the frame numbers and calculating in software the most-delayed member, implementations of VCAT would program the most-delayed member index into the logic. Then it was a simple matter to use the MFI value of the specified most-delayed member to be the reference for the frames to be re-combined.<br><br>
The SDH standard operates on byte-wide data. As the data-rates increase the time that it takes a byte to be transmitted decreases. This implies that the clock-frequency for the circuit that works on a byte-wide input increases. As an example for a 622Mb/s standardized stream (STM4 in SDH, OC-12 in SONET) we need to operate at 77MHz with byte wide data to be able to handle the stream. At 2.5Gb/s (STM16 or OC-48) the clock frequency is 311MHz. This is considerable speed for technologies like Field Programmable Gate Arrays (FPGAs) to be able to handle. Designers then typically rely on operating multiple designs running at slower speeds that take advantage of the fixed multiplexing that is part of the SDH/SONET standards. Thus we may use 4 separate byte-wide STM4 designs operating in parallel at 77MHz to realize a single STM16 data stream processing.<br><br>
When SW is given the task of updating the Most-delayed Member as the reference for the frame to be read, we are dependent on the SW architecture. In particular, we find that the delay in SW responding to an event can be quite significant in a chassis-based system where there are several cards competing for Software attention. Furthermore, when the design scales to multiple parallel instances, the Most-delayed member Tributary can move from one instance to another. This results in solving the problem of keeping a single most-delayed member definition across the multiple parallel design instances.<br><br>
OBJECTS OF PRESENT INVENTION<br><br>
The main object of the instant invention is to develop a method to determine most-delayed frame in a virtual concatenation group (VCG).<br><br>
Another object of the present invention is to develop said method by determining for each tributary Unit (TU) a frame-number event which happens once per "age" interval which can be SDH frame time of 125 micro-seconds.<br><br>
Another object of the present invention is to develop said method by accumulating data into memory wherein the memory address is function of the TU number, the frame number and page count.<br><br>
Another object of the present invention is to develop said method generating periodic signal to perform read of the accumulated data for all the Tributary Units (TU's) that comprise a Virtual Concatenation Group (VCG).<br><br>
Another main object of the present invention is to develop said method an apparatus to determine most-delayed frame across multiple tributary units (TUs) in a virtual concatenation group (VCG) that serves at the frame-number for which the accumulated data can be read from memory.<br><br>
Another object of the present invention is to develop said method processor for detecting the minimum frame number in the period to determine the most-delayed frame of a TU in a VCG that spans multiple parallel, lower speed, blocks.<br><br>
Another object of the present invention is to develop said method processor that can handle the most-delayed frame computation across multiple VCG's that can have multiple members which can span multiple parallel, lower-speed blocks.<br><br>
STATEMENT OF INVENTION<br><br>
The present invention provides for a method to determine most delayed frame for each VCG within TUs contained in stream comprising multiple multiplexed STM streams comprising acts of: generating a frame update event for each TU at a predetermined point in each frame, storing "frame number" for each VCG, the corresponding VCG that the TU belongs to, and an "age" indication in a memory, implementing state machine to compare the newly received frame number with stored frame number, updating the stored frame number for each VCG if the newly received frame is less than the stored frame number in a given "age" period, and obtaining the stored frame number at the end of the "age" period as the most-delayed frame for the given "age" period at beginning of next "age"; and it is also provides for an apparatus to determine most delayed frame for each VCG within TUs contained in stream comprising multiple multiplexed STM streams comprises: distributed memory for storing state of each VCG and continuously referencing to obtain frame-end event to generate frame event comprising frame number and its "age", a state machine being configured to compare the newly received frame number with stored frame number, wherein the frame number is updated provided newly received frame number is less than the stored frame number in a given "age" period as a subsequent update, and central age timer generator to generate the "age" period for all the STM write blocks.<br><br>
BRIEF DESCRIPTION OF THE DRAWINGS<br><br>
Figure 1 shows a High-Level organization of the VCAT processing<br><br>
Figure 2 shows details of Write Process Block Diagram<br><br>
Figure 3 is an Illustration of the frame-change events<br><br>
Figure 4 shows Most Delayed Logic that tracks the most-delayed frame per VCG<br><br>
Figure 5 shows a configuration with multiple Write Logic blocks providing updates<br><br>
Figure 6 illustrates jitter due to Pointer movement affecting Most-Delayed calculation<br><br>
DETAILED DESCRIPTION OF THE INVENTION<br>
The present invention relates to a method to determine most delayed frame for each VCG within TUs contained in stream comprising multiple multiplexed STM streams comprising acts of:<br><br>
a)	Generating a frame update event for each TU at a predetermined point in each frame,<br><br>
b)	storing "frame number" for each VCG, the corresponding VCG that the TU belongs to, and an "age" indication in a memory,<br><br>
c)	implementing state machine to compare the newly received frame number with stored frame number,<br><br>
d)	updating the stored frame number for each VCG if the newly received frame is less than the stored frame number for the current "age" value , and<br><br>
e)	obtaining the stored frame number at the end of the current "age" period as the most-delayed frame for the given "age" period at beginning of next "age" indication, and<br><br>
f)	communicating the most-delayed frame to the read side state machines to allow for the recovery of the data streams by performing the appropriate data interleaving.<br><br>
In one embodiment of the present invention the memory used for storing the state and other information for each TU and VCG is a distributed RAM available in several FPGA devices.<br><br>
In one embodiment of the present invention the most-delayed frame number is forwarded to a read machine for each VCG to ensure that frames earlier than the most-delayed frame are read.<br><br>
In one embodiment of the present invention multiple methods are multiplexed to determine the most-delayed frame over multiple parallel streams of multiplexed STM streams.<br><br>
In one embodiment of the present invention the update events are written into a FIFO using a first clock for each of the multiple parallel streams of multiplexed STM streams.<br><br>
In one embodiment of the present invention the update events are read from the multiple FIFO's using a second clock before comparing the events with the stored frame number for each VCG.<br>
In one embodiment of the present invention the period "age" is assigned with unique numbers to avoid ambiguity in comparing the frame updates across multiple interleaved STM streams.<br><br>
In one embodiment of the present invention the period is pre-determined time duration preferably 125us corresponding to an SDH frame.<br><br>
In one embodiment of the present invention the "age" period is being adopted to overcome jitter due to pointer movement.<br><br>
Another main embodiment of the present invention is apparatus to determine most delayed frame for each VCG within TUs contained in stream comprising multiple multiplexed STM streams comprises:<br><br>
a)	distributed memory for storing state of each VCG and continuously referencing to obtain frame-end event to update frame number,<br><br>
b)	a state machine being configured to compare the newly received frame number with stored frame number, wherein the frame number is updated provided newly received frame number is less than the stored frame number in a given "age" period as a subsequent update, and<br><br>
c)	central age timer generator to generate the "age" indication that is used by all the multiple lower-speed write blocks.<br><br>
In one embodiment of the present invention the said apparatus comprises FIFO queue to store the most delayed frame.<br><br>
In one embodiment of the present invention the said apparatus comprises multiplexer for serially reading the FIFO data to determine the most delayed frame for the each VCG within the TUs contained in the multiple STM.<br><br>
In one embodiment of the present invention the multiplexer periodically selects inputs from the FIFO queues.<br><br>
In one embodiment of the present invention the most delayed frame for the given "age" period is determined at beginning of next "age" period.<br><br>
In one embodiment of the present invention the central age timer generator assign unique numbers for distinction of plurality of the "age" periods to avoid ambiguity in comparison of the frame updates.<br><br>
In one embodiment of the present invention the central age timer generator provides selection signal to the multiplexer.<br><br>
The invention described can be scaled from STM4 to STM 16, and can support many VCGs, each of them can be use Higher-Order or Lower-Order Virtual Concatenation. Since an STM 16 signal can be viewed as 4 STM4 signals that have been multiplexed, a byte at a time, we have the ability to replicate the processing for each STM4. In the case of multiple STM4s, the members of a VCG may now be split across several STM4 processing blocks and consequently, we would need to determine the most-delayed member of a VCG across all the STM4 blocks. However, since each of the processing blocks is identical, and it is not known which block will have the most-delayed member for a given VCG, we need to design the logic that each STM4 logic block will, for each VCG, determine when the most-delayed member within that STM4 block has been written, and then we need to combine the information across multiple STM4 blocks to determine the actual most-delayed member for that VCG.<br><br>
Differential Delay Compensation design (DD) is responsible for the proper recovery of the transmitted stream after the various members have been subjected to different delays in the network while propagating to the destination. Each 125us SDH frame of a<br><br>
Tributary Unit (TU) is tagged with a frame number at the source and a Sequence Number indicating its position in the interleaving of the members of a Virtually Concatenated Group (VCG).<br><br>
Figure 1 shows the broad organization of the HW Most-Delayed Logic. The functional description and the details of the individual blocks are explained below.<br><br>
Rx Telecom Logic 105<br><br>
This block handles an STM4 worth of traffic. It operates at 77 MHz and byte-wide data path to accomplish all the Telecom Layer related logic. It is clear to a practitioner skilled in the art that this is for illustrative use only and that various combinations of Bandwidth and processing speeds can be used in the design of the telecom logic. This includes the pointer-interpreter, the path-overhead processing (extraction and alarm generation) as well as the VCAT and LCAS related processing. It is responsible for generating interrupts for various changes in alarms and other events that require a response from software. The operation of this block is controlled by configuration that is on a per Tributary Unit (TU).<br><br>
The entire logic is implemented in a TDMized scheme. A central block is responsible for generating the sequence of TU addresses. These are referred to as A-k-l-m numbers and the sequence of these is dependent on the multiplexing structure associated with an STM1. We use the terms A-k-l-m and TUno interchangeably.<br><br>
The data that is received from the Telecom Layer is passed to the Write Logic 102. In order to perform Virtual Concatenation, the data is written to external memory 101 based on the frame number and tributary Index.<br><br><br><br>
Write Logic 102<br><br>
The write logic 102 works on a per STM4 basis and is responsible for accumulating byte-wide data into a page-memory and when a page is complete, generate an external memory access to transfer the accumulated data to external memory 101. The size of the page is determined by the memory technology used and in our implementation we use a 16 byte page. Thus once the state-machine accumulates 16 bytes of data for a TU, it will generate a write request for external memory. The address of the location in external memory 101 is a function of the Tu no, the frameno, and a page-count that is maintained by the state machine in the write-logic. See figure 2.<br><br>
The State Machine of the Write logic works on the incoming frame number. It detects the start of a 2 ms boundary based on a transition of the frame number. The state is itself stored in a Block RAM (due to the large number of possible TU's - 384 in an STM4). On completion of 16 bytes of writing, a "Page Write Request" is generated to transfer that page to external memory 101. Note that it is likely, though not necessary, that the memory sub-system is working off a different clock frequency. The state information for each TU consists of the following information.<br><br><br><br>
Most Delayed Logic 103<br><br>
Also, when the write machine receives data, it compares the incoming frame-number with the frame number stored in its state memory. When a change occurs, it indicates that the corresponding TU has a frame completed, and an "update request" event is generated that records the VCG number, the frame number, and the TU number. By generating at the updaterequest event at the transition of a frame-number we are guaranteed that the data for the previous frame is written in external memory.<br><br>
The problem is how to determine, form these events that encompass several TU's and multiple STM4 write blocks, what frame number corresponding to each VCGg should be read. Figure 3 illustrates the problem. Each TU generates an event at an approximate interval of 125 micro seconds. Note, that due to the pointer movements that are part of the SDH standard, the distance between two successive frame-change events for a given TU is not guaranteed to be 125 micro seconds. Thus while in most cases there is 1 update event for each TU in a frame time, it is also possible to have 125 us intervals where there are 2 updates and some frames where there is no update event. This will have to be addressed in the design.<br><br>
The end-of-frame updates received from the write side from the multiple TU's belonging to multiple VCG's spanning across multiple STM4's need to be compared to determine up till what frame-number value can the reconstruction logic read frames from external memory. Essentially, the most-delayed member has the least frame number and that is where the reads must proceed till. Subsequent reads are stalled till we receive an update informing us that more data has been written to external memory and we can proceed with reading further.<br><br>
Since the end-of-frame events are periodic and their relation to one another is arbitrary, we need to group of events in a 125us interval and determine the appropriate frame number (also called an Multi-Frame Indication or MFI value in the G.707 standard) to update the read logic with it. We can generate a periodic signal called the "age" and for all events that are generated in a particular value of the "age" signals will be logically associated as a group for purposes of finding the minimum MFI value, which is a property of the most-delayed member. The events generated by the write-logic on detecting a change in the frame number in a particular value of the "age" signal form a logical set of events. Note, as explained in Figure 2 earlier, the association of "age" and the frame-end event is not exact since the timing of each TU can vary within the SDH frame (as the frequency reference of the source and the sink may not be exactly the same).<br><br>
To track all the events for multiple VCGs we implement a state machine with distributed RAM. The state for each VCG is stored in memory, and is referenced each time we get a frame-end event from the write-logic. See figure 4. For the first update we load the updated frame number in RAM, and on every subsequent update in the same "age" time period, we look at the frame number being signaled and if it is smaller we update the state replacing the cur_frm value with the updatefrm value. Thus at the end of the "age" period, we have the most-delayed update received in that 125us, At the first update of the next value of "age", this is signaled to the Read Logic to determine the MFI value for which reads can progress to. Thus the read side normally gets the update with the first event for that VCG of each "age" setting.<br><br>
It is important to understand that there is certain ambiguity in the frame number indicated to the read side. This arises from the fact that during some 125us period, the most-delayed TU may not signal an event on account of the pointer movement, thereby an incorrect frame-number (less delayed member) will be notified to the read side. Of-course, in the next period, the most-delayed frame will be indicated. It is therefore recommended that the read-side allow for this ambiguity when it is communicated the frame number. Since, typical implementations of VCAT have a read memory bandwidth slightly greater than the write memory bandwidth (to allow for the delay buffer to be drained when a most-delayed member is deleted), one technique is to read one or two less frames than indicated by the minimum in every period.<br><br>
When the Virtual Concatenation is implemented across multiple STM4 design blocks working in parallel, each unit is only capable of generating the update events for the TU's that are contained in that STM4 block. In order to compute, for a given VCG spanning multiple STM blocks, the most-delayed member we need to process all 4 of them simultaneously. See figure 5.<br><br>
We realize that the updates from the Write-logic for each STM4 are independent and hence in a given cycle we could have multiple updates for one or more VCGs. This would normally require a number of separate machines, one for each VCG, to track the events that each of the STM4's generate. This replication increases the logic required manifold.<br><br>
Note that in the case of STM4 worth of Tributaries, the maximum number of TU's that can be present is 384. If we use VC4 mapping, then only 4 updates are required. The actual number of updates is a function of the multiplexing scheme and the elements provisioned to carry VCAT traffic. Moreover, within the TU's that are provisioned, the membership within various VCGs is arbitrary.<br><br>
In the case pointer-movements are present in the incoming signal, the time between the successive frame-end events occasionally is less-than or more-than the frame time. As a result, it is possible for two successive frame-end events to be generated with the same value of the "age" signal and causing error in determining the frame number for the read logic. This is illustrated in the following example with figure 6.<br><br>
In the example shown in figure 6, when the Most-delayed frame number jumps to 151 after 141, the read logic is free to read fames in between. There may be a situation where for TU1, in the example, data has not been written to external memory. Note However, that the error will be recovered from in the next frame time and as a result, we need to ensure that the read-logic does not exceed the frame that has been written. Since the Bandwidth of the Read Logic typically exceeds the bandwidth of the write-logic by a small amount, we can subtract from the actual Most-delayed computation, a constant difference, which ensures that the read-logic does not go past the write side frame numbers.Rather than processing all the events as they are generated, which requires us to evaluate multiple update request in the same cycle with complex and replicated logic, we propose to simplify the implementation by realizing that an accurate computation of frame time can be avoided if we are willing to settle for some additional delay, which is anyways required to compensate for the jitter due to pointer movements. With this realization we can simplify the design and use a single stream of updates across all the STM4 logic blocks. Figure 7 illustrates an example.<br><br>
There is a central controller 702 that generates an "age" signal and this is input to each of the per-STM4 Write Logic Blocks 501, 502, 503 and 504 as well as a selection signal, named "stm4_sel", that gives each STM4 the opportunity to present its update to the most-delayed logic 704. When the updates are generated, they are tagged with the "age" at which they are generated and then stored into a First-ln First-Out (FIFO) structure for each of the STM4 blocks. 701 shows a FIFO structure for the STM4 write logic 501. Then based on the "stm4_sel" signal being valid, the FIFO for the relevant Write Block contributes an event into the interleaved stream of events. Note that the number of events contributed by each STM4 is a function of its multiplexing configuration and the provisioning of members to VCGs. The time at which these events are introduced into the interleaved event stream is a function of the network delays of the tributary units. The resulting structure is shown in the figure 7.<br><br>
It is often the case that the Telecom Logic, that runs in lock-step with the Cross Connect clock, and the memory system run at different frequencies. The FIFO also allows the clock-domain crossing structure required in this case Due to the interleaving and the pointer movements, it is possible that the updates arrive at the Most Delayed block in out-of-order. We rely on the change in the "age" value received to determine that a frame-time has elapsed. However, the interleaving can result in frame updates from a later value of "age" to be inserted between updates from a previous value of the "age" signal. As a result, we do not want to re-start the loading of the frame-time into the curfram value when this happens. We handle this case by ensuring that the "age" signal is a multiple-bit signal so that it is easy to distinguish this case. On an update request with a different "age" indication from the previous, we ignore the events that belong to the previous frame. Only on a change in framtime for the next period, we indicate the frame-time from the previous frame-time interval to the read-side (with the appropriate difference to account for the jitter). Subsequent, older updates can then be used in the computation of the most-delayed but it does not trigger the notification to the read side.<br><br>
Further this invention can easily be scaled to OC-192 design as well and a large number of streams. Retaining the structure of parallel blocks working at 77 MHz or 155MHz we will be able to determine the most-delayed member across multiple write blocks and the time to advance the read machine for each stream. Furthermore, since the logic is shared and only the current multi-frame indicator is used on a per stream basis, this design can be called to support arbitrary number of streams.<br><br><br>
We claim:<br><br>
1.	A method to determine most delayed frame for each VCG within TUs contained in stream comprising multiple multiplexed STM streams comprising acts of:<br><br>
a)	generating a frame update event for each TU at a predetermined point in each frame,<br><br>
b)	storing "frame number" for each VCG, the corresponding VCG that the TU belongs to, and an "age" indication in a memory,<br><br>
c)	implementing state machine to compare the newly received frame number with stored frame number,<br><br>
d)	updating the stored frame number for each VCG if the newly received frame is less than the stored frame number in a given "age" period ,and<br><br>
e)	obtaining the stored frame number at the end of the "age" period as the most-delayed frame for the given "age" period at beginning of next "age".<br><br>
2.	The method as claimed in claim 1, wherein the memory is a distributed RAM.<br>
3.	The method as claimed in claim 1, wherein the most-delayed frame number is forwarded to a read machine for each VCG to ensure that frames earlier than the most-delayed frame are read by data interleaving.<br><br>
4.	The method as claimed in claim 3, wherein multiple methods are multiplexed to determine the most-delayed frame over multiple parallel streams of multiplexed STM streams.<br><br>
5.	The method as claimed in claim 3, wherein the read machine reads one or two less frames than indicated by the most-delayed frame in each period.<br><br>
6.	The method as claimed in claim 1, wherein the update events are written into a FIFO using a first clock for each of the multiple parallel streams of multiplexed STM streams.<br><br>
7.	The method as claimed in claim 6, wherein the update events are read using a second clock before comparing the events with the stored frame number.<br><br>
8.	The method as claimed in claim 1, wherein the period "age" is assigned with unique numbers to avoid ambiguity in comparing the frame updates across multiple interleaved STM streams.<br><br>
9.	The method as claimed in claim 1, wherein the period is pre-determined time duration preferably 125u,s corresponding to an SDH frame.<br><br>
10.	The method as claimed in claim 1, wherein the "age" counter is being adopted to overcome jitter due to pointer movement.<br><br>
11.	An apparatus to determine most delayed frame for each VCG within TUs contained in stream comprising multiple multiplexed STM streams comprises:<br><br>
a)	distributed memory for storing state of each VCG and continuously referencing to obtain frame-end event to generate frame event comprising frame number and its "age",<br><br>
b)	a state machine being configured to compare the newly received frame number with stored frame number, wherein the frame number is updated provided newly received frame number is less than the stored frame number in a given "age" period as a subsequent update, and<br><br>
c)	central age timer generator to generate the "age" period for all the STM write blocks.<br><br>
12.	The apparatus as claimed in claim 11 comprises FIFO queue to store the update events.<br><br>
13.	The apparatus as claimed in claim 11 comprises multiplexer for serially reading the FIFO data to determine the most delayed frame for the each VCG within the TUs contained in the multiple STM.<br><br>
14.	The apparatus as claimed in claim 13, wherein the multiplexer periodically selects inputs from one of the FIFO queue.<br><br>
15.	The apparatus as claimed in claim 11, wherein the most delayed frame for the given "age" period is determined at beginning of next "age" period.<br><br>
16.	The apparatus as claimed in claim 11, wherein the central age timer generator assign unique numbers for distinction of plurality of the "age" periods to avoid ambiguity in comparison of the frame updates.<br><br><br>
17. The method and apparatus to determine most delayed frame for each VCG within TUs contained in stream comprising multiple multiplexed STM streams as herein substantiated in the description along with accompanied drawings.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDEwMS1jaGUtMjAwOCBhYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">0101-che-2008 abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDEwMS1jaGUtMjAwOCBjbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">0101-che-2008 claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDEwMS1jaGUtMjAwOCBjb3JyZXNwb25kZW5jZS1vdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">0101-che-2008 correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDEwMS1jaGUtMjAwOCBkZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">0101-che-2008 description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDEwMS1jaGUtMjAwOCBkcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">0101-che-2008 drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDEwMS1jaGUtMjAwOCBmb3JtLTEucGRm" target="_blank" style="word-wrap:break-word;">0101-che-2008 form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDEwMS1jaGUtMjAwOCBmb3JtLTE4LnBkZg==" target="_blank" style="word-wrap:break-word;">0101-che-2008 form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDEwMS1jaGUtMjAwOCBmb3JtLTIucGRm" target="_blank" style="word-wrap:break-word;">0101-che-2008 form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDEwMS1jaGUtMjAwOCBmb3JtLTMucGRm" target="_blank" style="word-wrap:break-word;">0101-che-2008 form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDEwMS1jaGUtMjAwOCBmb3JtLTUucGRm" target="_blank" style="word-wrap:break-word;">0101-che-2008 form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLUNIRS0yMDA4ICAgIEZPUk0tMSAgMDEtMDgtMjAxMi5wZGY=" target="_blank" style="word-wrap:break-word;">101-CHE-2008    FORM-1  01-08-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLUNIRS0yMDA4ICAgIEZPUk0tMTMgIDAxLTA4LTIwMTIucGRm" target="_blank" style="word-wrap:break-word;">101-CHE-2008    FORM-13  01-08-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLUNIRS0yMDA4ICAgQ09SUkVTUE9OREVOQ0UgT1RIRVJTIDAxLTA4LTIwMTIucGRm" target="_blank" style="word-wrap:break-word;">101-CHE-2008   CORRESPONDENCE OTHERS 01-08-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLUNIRS0yMDA4ICBBTUVOREVEIENMQUlNUyAgMDUtMTItMjAxNC5wZGY=" target="_blank" style="word-wrap:break-word;">101-CHE-2008  AMENDED CLAIMS  05-12-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLUNIRS0yMDA4ICBBTUVOREVEIFBBR0VTIE9GIFNQRUNJRklDQVRJT04gIDA1LTEyLTIwMTQucGRm" target="_blank" style="word-wrap:break-word;">101-CHE-2008  AMENDED PAGES OF SPECIFICATION  05-12-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLWNoZS0yMDA4ICBjb3JyZXNwb25kZW5jZSBvdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">101-che-2008  correspondence others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLUNIRS0yMDA4ICBFWEFNSU5BVElPTiBSRVBPUlQgUkVQTFkgUkVDRUlWRUQgIDA1LTEyLTIwMTQucGRm" target="_blank" style="word-wrap:break-word;">101-CHE-2008  EXAMINATION REPORT REPLY RECEIVED  05-12-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLUNIRS0yMDA4ICBGT1JNLTEgIDA1LTEyLTIwMTQucGRm" target="_blank" style="word-wrap:break-word;">101-CHE-2008  FORM-1  05-12-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLWNoZS0yMDA4ICBmb3JtLTEzLnBkZg==" target="_blank" style="word-wrap:break-word;">101-che-2008  form-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLUNIRS0yMDA4ICBGT1JNLTMgIDA1LTEyLTIwMTQucGRm" target="_blank" style="word-wrap:break-word;">101-CHE-2008  FORM-3  05-12-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLUNIRS0yMDA4ICBGT1JNLTUgIDA1LTEyLTIwMTQucGRm" target="_blank" style="word-wrap:break-word;">101-CHE-2008  FORM-5  05-12-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLUNIRS0yMDA4ICBQT1dFUiBPRiBBVFRPUk5FWSAgMDUtMTItMjAxNC5wZGY=" target="_blank" style="word-wrap:break-word;">101-CHE-2008  POWER OF ATTORNEY  05-12-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLWNoZS0yMDA4IG90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">101-che-2008 others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLWNoZS0yMDA4LWNvcnJlc3BvbmRuZWNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">101-che-2008-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLWNoZS0yMDA4LWRlc2NyaXB0aW9uKHByb3Zpc2lvbmFsKS5wZGY=" target="_blank" style="word-wrap:break-word;">101-che-2008-description(provisional).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLWNoZS0yMDA4LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">101-che-2008-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLWNoZS0yMDA4LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">101-che-2008-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLWNoZS0yMDA4LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">101-che-2008-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAxLWNoZS0yMDA4LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">101-che-2008-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=QWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">Abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxMDEtQ0hFLTIwMDguanBn" target="_blank" style="word-wrap:break-word;">abstract101-CHE-2008.jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=QW1lbmRlZCBjbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">Amended claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Q29tcGxldGUgU3BlY2lmaWNhdGlvbi5wZGY=" target="_blank" style="word-wrap:break-word;">Complete Specification.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Q29ycmVzcG9uZGVuY2UucGRm" target="_blank" style="word-wrap:break-word;">Correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=RkVSX1JFUExZIGFsb25nIHdpdGggYWxsIGVuY2xvc3VyZXMucGRm" target="_blank" style="word-wrap:break-word;">FER_REPLY along with all enclosures.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=T3RoZXIgZG9jdW1lbnRzLnBkZg==" target="_blank" style="word-wrap:break-word;">Other documents.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=UGV0aXRpb25fMTM3LnBkZg==" target="_blank" style="word-wrap:break-word;">Petition_137.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="264533-fluid-product-dispenser.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="264535-transducer-detection-method-and-system-for-ibp-monitor.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>264534</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>101/CHE/2008</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>02/2015</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>09-Jan-2015</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>02-Jan-2015</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>10-Jan-2008</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>TEJAS NETWORKS LIMITED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>58, 1ST MAIN ROAD, J.P. NAGAR, 3RD PHASE, BANGALORE-560 078, KARNATAKA, INDIA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>KANWAR JIT SINGH</td>
											<td>58, 1ST MAIN ROAD, J.P. NAGAR, 3RD PHASE, BANGALORE-560 078, KARNATAKA, INDIA</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td></td>
									<td></td>
								    <td>NA</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/264534-method-and-apparatus-for-determining-most-delayed-frame-in-a-virtual-concatenation-group by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:49:48 GMT -->
</html>
