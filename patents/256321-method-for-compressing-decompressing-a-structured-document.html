<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/256321-method-for-compressing-decompressing-a-structured-document by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:40:56 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 256321:METHOD FOR COMPRESSING/DECOMPRESSING A STRUCTURED DOCUMENT</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD FOR COMPRESSING/DECOMPRESSING A STRUCTURED DOCUMENT</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The invention concerns a method for compressing a structured document comprising nested information elements, the document being associated with at least a tree-like structure schema (1) defining a structure of the document and comprising of nested structural components, representing information elements, which consists in: analysing (11) and compiling (13) the structural schema of the document to obtain for each component of the schema, a sequence of executable instructions (5), comprising instructions for inserting control codes and codes of element or calling for sequences of component instructions, and instructions for controlling the development of the execution of the sequence on the basis of control code values; and decompressing (14&amp;quot;) the document to be decompressed (10) which is in the form of a bit stream, said step including execution of sequences of instructions (5) on the bit stream, to restore a document with original format.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>METHOD FOR COMPRESSING/DECOMPRESSING<br>
A STRUCTURED DOCUMENT<br>
This invention relates to a method for compressing/decompressing<br>
a structured document.<br>
It is particularly but not exclusively applicable to transmission of<br>
documents such as images, video or sound data, through digital data transmission<br>
networks, and to storage of such documents and storage of data describing these<br>
documents.<br>
A structured document is a collection of information elements, each<br>
associated with a type and attributes, and related to each other by mainly<br>
hierarchical relations. These documents use a structuring language such as<br>
SGML, HTML or XML, which in particular distinguishes the different<br>
information sub elements making up the document. On the contrary, in a so-<br>
called linear document, the information defining the document contents is mixed<br>
with presentation and typeset information.<br>
A structured document includes separation markers for the different<br>
information sets in the document. In the case of SGML, XML or HTML formats,<br>
these markers are called "tags" and are in the form "<xxxx>" and "</xxxx>",<br>
the first tag indicating the begirming of an information element "<xxxx>" and<br>
the second tag indicating the end of this set. An information element may be<br>
composed of several lower level information elements. Thus, a structured<br>
document has a hierarchical structure or tree-like structure schema, each node<br>
representing an information element and being connected to a node at a higher<br>
hierarchical level representing an information element that contains lower level<br>
information elements. Nodes located at the end of the branch of this tree-like<br>
structure represent information elements containing a predefined type of data that<br>
cannot be decomposed into information sub elements.<br>
Thus, a structured document contains separation tags represented in the<br>
form of text or binary data, these tags delimiting information elements or sub<br>
elements that may themselves contain other information sub elements delimited<br>
by tags.<br>
Furthermore, a structured document is associated with what is called a<br>
structure schema defining the structure and type of information in each<br>
information set in the document, in the form of rules. A schema is composed of<br>
nested groups of information set structures, these groups possibly being ordered<br>
sequences, or ordered or unordered groups of choice elements or groups of<br>
necessary elements.<br>
At the present time, there are several digital document compression<br>
algorithms. Some compression algorithms are designed to process document<br>
binary data directly without considering the type of these data. These algorithms<br>
have the advantage that they can process any type of document, but their<br>
performance is not very good (low compression ratio) for use with large<br>
documents, which are usually of the sound or image type.<br>
Other more efficient compression algorithms are known which are<br>
specially adapted to a data type, for example image or sound type of data, so that<br>
they cannot be used or are efficient if they are applied to documents that do not<br>
exclusively contain data of the type for which they were designed. Consequently,<br>
compression algorithms designed for use with a specific data type are not very<br>
efficient and badly adapted for handling structured documents containing<br>
different data types.<br>
Compression algorithms adapted to compression of documents in the XML<br>
format were developed in the documents "XMILL: An efficient Compressor for<br>
XML Data" by H. Liefke et al., Sigmod Record, Association for Computing<br>
Machinery, New York, US, Vol. 29, No. 2, June 2000, pages 153-164, and<br>
"Millau: An Encoding Format for Efficient Representation and Exchange of XML<br>
over the Web" by M. Girardot et al, Computer Networks and ISDN Systems,<br>
North Holland Publishing, Amsterdam, NL, Vol. 33, No. 1-6, June 2000, pages<br>
747-765.<br>
The purpose of this invention is to eliminate these disadvantages. This<br>
objective is achieved by providing a method for compressing a structured<br>
document comprising information elements nested in each other and each<br>
associated with an information type, the structured document being associated<br>
with at least one structure schema defining a document tree-like structure and<br>
comprising structure components nested in each other, each type of document<br>
information being defined by a component in the schema.<br>
According to the invenfion, this method comprises steps consisting of<br>
analyzing the document structure schema in order to obtain a sequence of<br>
executable instructions for each component of the structure schema, comprising<br>
instructions for inserting control codes and compressed values of information<br>
elements or component instruction sequences call codes, instructions for<br>
controlling the execution of the sequence as a function of control code values,<br>
execution of the instruction sequences on the structured document compressing<br>
the structured document into a bit stream containing compressed values of<br>
information elements in the document.<br>
Advantageously, this method also comprises a step for execution of<br>
instruction sequences on the structured document.<br>
According to one special feature of the invention, the document<br>
comprising basic elements not decomposed into sub-elements, at least one type of<br>
basic element information is associated in advance with a compression algorithm<br>
adapted to the type of information, the method comprising application of the<br>
compression algorithm to the value of each information element with an<br>
information type associated with said algorithm, during execution of the<br>
instruction sequences.<br>
According to another special feature of the invention, the method<br>
comprises a step for compilation of instruction sequences obtained for each<br>
component of said structure schema, to obtain a binary encoding program<br>
dedicated to said structure schema, and directly executable or interpretable by a<br>
computer to compress a document with the structure schema.<br>
According to another special feature of the invention, the method<br>
comprises a prior step for normalization of the document structure schema, so as<br>
to obtain a single predefined order of components in the schema.<br>
According to another special feature of the invention, the method<br>
comprises a prior step of optimizing and simplifying the document structure<br>
schema consisting of reducing the number of nesting levels in structure<br>
components.<br>
Advantageously, at least one element of information in the document is<br>
associated with an information element code in the generated bit stream, which is<br>
marked so as to enable direct access to a particular compressed information<br>
element in the bit stream, without it being necessary to decompress information<br>
elements preceding the element to be decompressed in the bit stream.<br>
According to yet another special feature of the invention, the generated<br>
compressed document comprises a code for each information element in the<br>
structured document, used to determine the type of information associated with<br>
the information element and the binary value of the information element.<br>
According to yet another special feature of the invention, the document<br>
structure schema comprises the definition of sub-types of at least one type of<br>
information, and the instructions sequence generated for a component of a type<br>
with n sub-types comprises the following in sequence:<br>
an instruction to insert a sub-type code representing a sub-type to be<br>
applied to an element corresponding to the component of the document,<br>
associated with the size of this code as a number of bits, and<br>
instructions to test the value of the sub-type code, each test instruction<br>
being associated with a reference to the sub-type of the element corresponding to<br>
the tested value of the sub-type code, and an instructions sequence generated for<br>
compression of an element associated with the sub-type.<br>
Preferably, the bit stream generated for a component corresponding to<br>
several occurrences of an elements set comprising at least one infonnation<br>
element in the document, comprises a predefined end code.<br>
According to yet another special feature of the invention, each component<br>
of the structure schema corresponds to an elements set in the document<br>
comprising at least one information element, and is also associated with a set of<br>
numbers of possible occurrences, indicating the number of times that an elements<br>
set corresponding to this component may appear in information element at a level<br>
immediately higher than the level to which it belongs.<br>
According to yet another special feature of the invention, the instructions<br>
sequence generated for a component with a number of occurrences equal to 0 or 1<br>
comprises, in sequence:<br>
an instruction to insert a presence code on one bit indicating whether or not<br>
an elements set corresponding to the component is present in the document,<br>
an instruction to test the value of the presence code, and<br>
in association with the test instruction, if the value of the presence code<br>
indicates the presence of the elements set in the document, an instructions<br>
sequence generated for the component, independently of the associated number of<br>
occurrences.<br>
According to yet another special feature of the invention, the instructions<br>
sequence generated for a component with a number of occurrences between n and<br>
m includes the following steps in sequence:<br>
an instruction to insert a number of occurrences code indicating the<br>
number of successive occurrences of an elements set corresponding to the<br>
component in the compressed document, minus the minimum number n of<br>
occurrences, associated with the size of this code as a number of bits,<br>
a loop instruction defining a number of iterations corresponding to the<br>
value of the number of occurrences codes, and<br>
in association with the loop instruction, an instructions sequence that is<br>
generated for the component independently of the associated number of<br>
occurrences.<br>
According to yet another special feature of the invention, the instructions<br>
sequence generated for a component with a number of occurrences between 0 and<br>
m also comprises:<br>
an instruction to insert a presence code indicating whether or not there is at<br>
least one occurrence of the elements set corresponding to the component in the<br>
document, and<br>
an instruction to test the value of the presence code associated with the<br>
instructions sequence generated for a number of occurrences of the component<br>
between 1 and m, if the value of the presence code indicates that at least one<br>
elements set is present.<br>
According to yet another special feature of the invention, the instructions<br>
sequence generated for a component with a number of occurrences between n and<br>
m includes the following steps in sequence:<br>
an instruction to insert a single-bit presence code signaling an occurrence<br>
of an elements set corresponding to the component in the document, associated<br>
with the size of this code as a number of bits,<br>
a loop instruction to be executed as long as the presence code to be<br>
inserted indicates that a new occurrence of the elements set is present,<br>
in association with the loop instruction, an instructions sequence generated<br>
for the component, and an instruction to insert a new single-bit presence code<br>
signaling a new occurrence of the elements set in the document.<br>
According to yet another special feature of the invention, each component<br>
in the structure schema corresponds to an elements set comprising at least one<br>
information element, the structure schema of the structured document comprises<br>
at least one sequence type component of ordered components, in which the order<br>
of appearance in the sequence defines the order of appearance of element sets in<br>
the document corresponding to components of the sequence type group, and the<br>
instructions sequence generated for a sequence comprising n components<br>
comprises instruction sequences generated for each component in the sequence,<br>
successively.<br>
According to yet another special feature of the invention, each component<br>
in the structure schema corresponds to an elements set comprising at least one<br>
information element, the structure schema of the document to be compressed<br>
comprises at least one component of the choice components group type, each<br>
choice component corresponding to an information elements set, the component<br>
of the choice components group type corresponding to one of the information sets<br>
in the document corresponding to choice components, and the instructions<br>
sequence generated for a group of choice components comprising n components<br>
defining n corresponding element sets, comprises the following in sequence:<br>
an instruction to insert an elements set number code denoting which<br>
elements set among the n element sets appears in the document, associated with<br>
the size of this code as a number of bits, and<br>
instructions to test the value of the elements set number code, each test<br>
instruction being associated with an instructions sequence generated for the<br>
component corresponding to the elements set corresponding to the tested value of<br>
the elements set number code.<br>
According to yet another special feature of the invention, each component<br>
of the structure schema corresponds to an elements set comprising at least one<br>
information element, and the structure schema of the document to be compressed<br>
comprises at least one group of the unordered components type, each component<br>
in the unordered group corresponding to an elements set and the group of the<br>
unordered group type corresponding to a group in the document containing all<br>
element sets corresponding to components of the unordered type group, in an<br>
arbitrary order, and the instructions sequence generated for an unordered type<br>
group comprising n components corresponding to n element sets in the document,<br>
comprises the following in sequence:<br>
an instruction to insert an elements set number code and denoting the next<br>
elements set appearing in the document associated with the size of the code as a<br>
number of bits, and<br>
an instruction to test the value of the elements set number code, each test<br>
instruction being associated with an instructions sequence generated for the<br>
component corresponding to the elements set corresponding to the tested value of<br>
the elements set number code, and an instructions sequence generated for an<br>
unordered type group comprising all components in the unordered group except<br>
for the component corresponding to the element set.<br>
The invention also relates to a method for decompressing a structured<br>
document comprising information elements nested in each other and each<br>
associated with an information type, the structured document being associated<br>
with at least one structure schema defining a tree-like structure of the document<br>
and comprising structure components nested in each other, each type of document<br>
information being defined by a component of the schema.<br>
According to the invention, this method comprises steps consisting of<br>
analyzing the document structure schema in order to obtain a sequence of<br>
executable instructions for each component of the structure schema, this sequence<br>
comprising instructions for reading control codes and compressed values of<br>
information elements or call codes to call component instruction sequences, and<br>
instructions for controlling the execution of the sequence as a function of the<br>
control code values, in a bit stream forming the compressed document, the<br>
execution of instruction sequences on the compressed document being sufficient<br>
to restore a document in the same format as the original document and with an at<br>
least equivalent structure.<br>
Advantageously, this method also comprises a step for execution of the<br>
instruction sequences on the bit stream forming the document to be<br>
decompressed.<br>
According to a special feature of the invention, the structured document<br>
comprising basic elements not broken down into sub-elements and at least one<br>
basic elements information type, is associated with a decompression algorithm<br>
adapted to the information type, the method comprising the detection of an<br>
information element binary code corresponding to said information type in the bit<br>
stream, and application of the decompression algorithm to this binary code,<br>
during execution of instruction sequences on the bit stream forming the<br>
compressed document.<br>
According to another special feature of the invention, the method<br>
comprises a step for compiling instruction sequences obtained for each<br>
component of said structure schema, to obtain a binary decoding program<br>
dedicated to said structure schema, and that can be directly executed or<br>
interpreted by a computer to decompress a document with this structure schema.<br>
According to yet another special feature of the invention, the method<br>
comprises a prior step of normalizing the document structure schema, so as to<br>
obtain a single predefined order of the components of the schema.<br>
According to yet another special feature of the invention, the method<br>
comprises a prior step of optimizing and simplifying the document structure<br>
schema consisting of reducing the number of hierarchical levels of structure<br>
component groups.<br>
Advantageously, at least one information element code is identified in the<br>
bit stream of the compressed document, so as to enable direct access to this<br>
informafion element, without it being necessary to decompress informadon<br>
elements preceding this element in the bit stream.<br>
According to yet another special feature of the invention, the compressed<br>
document comprises a code for each information element in the original<br>
document, to determine the information type associated with the information<br>
element and the binary value of the compressed information element.<br>
According to yet another special feature of the invention, the structure<br>
schema of the document to be decompressed comprises the definition of sub-<br>
types of at least one information type, and the instructions sequence generated for<br>
a component of a type with n sub-types includes the following in sequence:<br>
an instruction to read a sub-type code representing a number of the sub-<br>
type to be applied to an element corresponding to the component in the document,<br>
associated with the size of this code as a number of bits, and<br>
instructions to test the value of the sub-type code, each test instruction<br>
being associated with a reference to the sub-type of the element corresponding to<br>
the value of the tested sub-type code, and an instructions sequence generated for<br>
decompression of an element associated with the sub-type.<br>
Preferably, the end of a group of several occurrences of an elements set<br>
comprising at least one information element corresponding to a component of the<br>
schema, is marked in the bit stream of the compressed document by a<br>
predetermined binary code.<br>
According to yet another special feature of the invention, each component<br>
in the structure schema corresponds to an elements set in the bit stream of the<br>
document, comprising at least one information element, and is also associated<br>
with a set of possible numbers of occurrences indicating the number of times that<br>
an elements set corresponding to this structure component can appear in the<br>
information element at a level immediately above the level to which it belongs.<br>
According to yet another special feature of the invention, the instructions<br>
sequence generated for a component with a number of occurrences equal to 0 or 1<br>
comprises the following in sequence:<br>
an instruction to read a single-bit presence code indicating whether or not<br>
an elements set corresponding to the component is present in the compressed<br>
document,<br>
an instruction to test the value of the presence code, and<br>
in association with the test instruction, if the value of the presence code<br>
indicates that the elements set is present in the compressed document, an<br>
instructions sequence that is generated for the component independently of the<br>
associated number of occurrences.<br>
According to yet another special feature of the invention, the instructions<br>
sequence generated for a component with a number of occurrences between n and<br>
m comprises the following in sequence:<br>
an instruction to read a number of occurrences code indicating the number<br>
of successive occurrences in the compressed document of an elements set<br>
corresponding to the component, minus the minimum number n of occurrences<br>
associated with the size of this code as a number of bits,<br>
a loop instruction defining a number of iterations corresponding to the<br>
value of the number of occurrences code, and<br>
in association with the loop instruction, an instructions sequence generated<br>
for the component, independently of the associated number of occurrences.<br>
According to yet another special feature of the invention, the instructions<br>
sequence generated for a component with a number of occurrences between 0 and<br>
m also comprises:<br>
an instruction to read a single-bit presence code indicating whether or not<br>
there is at least one occurrence of an elements set corresponding to the<br>
component in the compressed document, and<br>
an instruction to test the value of the presence code, associated with the<br>
instructions sequence generated for a number of occurrences of the component<br>
between 1 and n, if the value of the presence code indicates that there is at least<br>
one elements set present.<br>
According to yet another special feature of the invention, the instructions<br>
sequence generated for a component with a number of occurrences between n and<br>
m comprises the following successively:<br><br>
an instruction to read a single-bit presence code indicating whether or not<br>
there is an occurrence of an elements set corresponding to the component in the<br>
compressed document, associated with the size of this code as a number of bits,<br>
a loop instruction to be executed as long as the presence code read in the<br>
bit stream of the compressed document indicates that there is a new occurrence of<br>
the element set,<br>
in association with the loop instruction, an instructions sequence generated<br>
for the component, and an instruction to insert a new single-bit presence code<br>
indicating whether or not there is a new occurrence of the elements set in the<br>
compressed document.<br>
According to yet another special feature of the invention, each component<br>
of the structure schema corresponds to an elements set comprising at least one<br>
information element, and the structure schema of the compressed document<br>
comprises at least one ordered components sequence type component, for which<br>
the order of appearance in the sequence defines the order of appearance of<br>
element sets in the document corresponding to components of the sequence type<br>
group, and the instructions sequence generated for a sequence comprising n<br>
components comprises instruction sequences generated for each component in the<br>
sequence successively.<br>
According to yet another special feature of the invention, each component<br>
in the structure schema corresponds to an elements set comprising at least one<br>
information element, and the structure schema of the document to be<br>
decompressed comprises at least one component of the choice components group<br>
type, each choice component corresponding to an information elements set, the<br>
component of the choice components group type in the document corresponding<br>
to one of the information sets corresponding to the choice components, and the<br>
instructions sequence generated for a choice components group comprises n<br>
components defining n element (XI, X2, ..., Xn) sets respectively, comprises the<br>
following in sequence:<br>
an instruction to read an elements set number code denoting the elements<br>
set that appears in the document among the n element sets, associated with the<br>
size of this code as a number of bits, and<br>
instructions to test the value of the elements set number code, each test<br>
instruction being associated with an instructions sequence generated for the<br>
component corresponding to the elements set corresponding to the tested value of<br>
the elements set number code.<br>
According to yet another special feature of the invention, each component of the<br>
structure schema corresponds to an elements set comprising at least one information<br>
element, the structure schema of the document to be compressed comprises at least<br>
one group of the unordered components type, each component in the unordered group<br>
corresponding to an elements set and the group of the unordered group type<br>
corresponding to a group in the document containing all element sets corresponding to<br>
components of the unordered type group in an arbitrary order, and the instructions<br>
sequence generated for an unordered type group comprising n components<br>
corresponding to n element sets in the document, comprises the following<br>
successively : an instruction to read an elements set number code and denoting the<br>
next elements set appearing in the document, associated with the size of this code as a<br>
number of bits, and instructions to test the value of the elements set number code, each<br>
test instruction being associated with an instructions sequence generated for the<br>
component corresponding to the elements set corresponding to the tested value of the<br>
elements set number code, and an instructions sequence generated for an unordered<br>
type group comprising all components in the unordered group except for the component<br>
corresponding to the element set.<br>
Accordingly, the present invention provides a method for compressing a<br>
structured document comprising information elements nested in each other and each<br>
associated with an information type, the structured document being associated with at<br>
least one structure schema defining a document tree-like structure and comprising<br>
structure components nested in each other, each type of document information being<br>
defined by a component in the schema, characterized in that it comprises steps of<br>
analyzing the document structure schema in order to obtain a sequence of executable<br>
instructions for each component of the structure schema, comprising instructions for<br>
inserting into a bit stream control codes and compressed values of information<br>
elements or component instruction sequence call codes, and instructions for<br>
controlling the execution of the sequence as a function of control code values,<br>
execution of the instruction sequences on the structured document compressing the<br>
structured document into a bit stream containing compressed values of tlie information<br>
elements in the document.<br>
The present invention also provides a method for decompressing a structured<br>
document comprising information elements nested in each other and each associated<br>
with an information type, the structured document being associated with at least one<br>
structure schema defining a tree-like structure of the document and comprising structure<br>
components nested in each other, each type of document information being defined by<br>
a component of the schema, characterized in that it comprises steps of analyzing the<br>
document structure schema in order to obtain a sequence of executable instructions for<br>
each component of the structure schema, this sequence comprising instructions for<br>
reading control codes in a bit stream forming the compressed document, with<br>
compressed values of information elements or call codes to component instruction<br>
sequences, and instructions for controlling the execution of the sequence as a function<br>
of the control code values, the execution of instruction sequences on the compressed<br>
document restoring a document in a same format as the original document and with an<br>
at least equivalent structure.<br>
A preferred embodiment of the invention will now be described as a non-limitative<br>
example, with reference to the accompanying drawings, wherein :<br>
Figure 1 shows the different steps in the method according to the invention in the<br>
form of a block diagram ;<br>
Figures 2a, 2b and 2c graphically show a tree-like structure schema ;<br>
Figure 3 shows a structure schema obtained by applying a reduction method<br>
according to the invention to the structure schema shown in Figure 2 ;<br>
Figures 4a, 4b and 4c show a structure schema obtained by applying another<br>
reduction method according to the invention to the structure schema shown in Figure 2.<br>
Figure 1 shows the chaining of the different steps in the method according to the<br>
invention.<br>
This method is designed to handle a structured document composed of a<br>
structure schema 1 defining the document structure and structured information 2 of the<br>
document.<br>
For example, the following shows the form of one structure schema using<br>
the XML-Schema language:<br><elementname><br><complextype><br><choice><br><element name="A" type- minoccurs="l" maxoccurs="l/"><br><elementname type='TB" minOccurs=l maxOccurs=l/&gt;&lt;br/&gt;
&lt;/Choice&gt;&lt;br/&gt;
&lt;attribute name="a2" required=false type="boolean"/&gt;&lt;br/&gt;
&lt;attribute name="al" required=false type="integer"/&gt;&lt;br/&gt;
&lt;complexType&gt;&lt;br/&gt;
&lt;element&gt;&lt;br/&gt;
This schema indicates that the structure component named "C" has a&lt;br/&gt;
complex structure composed of a first optional Boolean type attribute named&lt;br/&gt;
"a2", a second integer type attribute named "al" that is always present in the&lt;br/&gt;
structure, and a group of choice components named "A" and "B" with types "TA"&lt;br/&gt;
and "TB" respectively, one of these two components only being present in the&lt;br/&gt;
structure once.&lt;br/&gt;
Types "TA" and "TB" are defined in the document structure schema by an&lt;br/&gt;
analogue formulation.&lt;br/&gt;
In general, particular components called component groups are used to&lt;br/&gt;
define a document structure. These component groups may be of the following&lt;br/&gt;
type:&lt;br/&gt;
SEQ that defines a list of ordered components, in which the corresponding&lt;br/&gt;
elements of the document must all appear and must be in the indicated order,&lt;br/&gt;
CHO that defines a group of choice components, a single element&lt;br/&gt;
corresponding to a component of the group that must appear in the document,&lt;br/&gt;
AND that defines a group of components for which the corresponding&lt;br/&gt;
elements must all appear in the document and in an arbitrary order that must not&lt;br/&gt;
be modified; this group corresponds to the "all" group in the XML Schema&lt;br/&gt;
standard,&lt;br/&gt;
ANDho that defines a components group for which the corresponding&lt;br/&gt;
elements must all be present in the document in an arbitrary order which is&lt;br/&gt;
unimportant; this group may be used for encoding attributes for which the order is&lt;br/&gt;
not important in the XML standard, and&lt;br/&gt;
ANY that includes any element among all the possible elements that can&lt;br/&gt;
be found in the document.&lt;br/&gt;
According to the invention, this formulation is analyzed and transformed&lt;br/&gt;
in step 11 of the method to obtain syntactic trees 4, with one tree for each&lt;br/&gt;
structure component. The syntactic tree corresponding to the component with&lt;br/&gt;
structure TC is symbolized by the following expression:&lt;br/&gt;
TC-&gt;SEQ[l,l](ANDNo[l,l](ali„t[l,l],a2booi[0,l]),CHO[l,l]ATA[l,l],BTB[l,l])&lt;br/&gt;
in which:&lt;br/&gt;
"A[x,y]" indicates that the component "A" corresponds to an element&lt;br/&gt;
repeated from x to y times in the document, and that can be equal to "*"&lt;br/&gt;
representing an undetermined value.&lt;br/&gt;
This expression may be represented by the tree shown in Figure 2c,&lt;br/&gt;
comprising a root component "TC" 43 composed of a single occurrence of a&lt;br/&gt;
group of sequence type components 44. This group comprises a single occurrence&lt;br/&gt;
of an unordered group of "AND" type components 45 and a single occurrence of&lt;br/&gt;
a group of choice components 46. The group 45 is composed of a single&lt;br/&gt;
occurrence of an integer named "al" and a Boolean named "a2", and the group 46&lt;br/&gt;
comprises a single occurrence of an element type "TA" named "A" and an&lt;br/&gt;
element type "TB" named "B".&lt;br/&gt;
Types "TA" and "TB" obtained in step 11 may for example be given by the&lt;br/&gt;
following formulas:&lt;br/&gt;
TA-&gt;SEQ[l,l](AND[l,l](a3i„t[l,l],a4i„t[0,l]),SEQ[l,l](XTc[l,l],YTc[l,l]))&lt;br/&gt;
TB -&gt; SEQ[1,1] (albooi[l,l],a5booi [1,1])&lt;br/&gt;
and represented by the trees shown in Figures 2a and 2b respectively.&lt;br/&gt;
Type "TA" 31 comprises a single sequence type group 32 composed of&lt;br/&gt;
two single groups 33, 34 of types AND and SEQ respectively. The group 33&lt;br/&gt;
comprises two single integer type occurrences called "a3" and "a4" respectively.&lt;br/&gt;
The group 34 comprises two single "TC" type occurrences named "X" and "Y"&lt;br/&gt;
respectively.&lt;br/&gt;
Type "TB" 39 is composed of a single sequence type group 40 comprising&lt;br/&gt;
two Booleans named "al" and "a5" respectively.&lt;br/&gt;
Although a distinction is made between the name of each element and its&lt;br/&gt;
type in the above description, the method according to the invention is also&lt;br/&gt;
applicable to structuring languages that do not make this distinction.&lt;br/&gt;
Furthermore, some languages such as the XML Schema language enable&lt;br/&gt;
what is called "polymorphism" or the use of sub-types.&lt;br/&gt;
These sub-types are defined as follows:&lt;br/&gt;
&lt;complexType name="TAr'><br><restriction base='="TA"'><br></restriction><br></elementname></element></choice></complextype><br><complextype type="TA2"><br><extension base="TA"><br></extension><br></complextype><br><element name="X" type="TA/&gt;&lt;br/&gt;
This syntax defines types TAl and TA2 as sub-types of type TA by&lt;br/&gt;
restriction or extension, and the information component X of type TA.&lt;br/&gt;
A document with this structure schema can include a type TAl element X&lt;br/&gt;
that may be added as follows:&lt;br/&gt;
&lt;Xxsi:type=" tal><br>
Furthermore, some types that possess sub-types in this way may be<br>
declared to be abstract, which means that information elements in a document<br>
with a structure schema comprising the definition of an abstract type do not<br>
necessarily contain information elements of this type. Abstract elements are only<br>
used to create hierarchies or type classes. An abstract type is defined as follows in<br>
the XML Schema language:<br><complextype name="a" type="TA" abstract="true"><br></complextype><br>
Furthermore, structure components must be deterministic, in other words it<br>
must not be possible to interpret an element of the document in more than one<br>
way. For example, in the "CHO(a,SEQ(a,b))" schema, in the case in which "a"<br>
appears in the document, it is impossible to know whether or not "b" has to<br>
appear afterwards. There are algorithms for this purpose that can be applied using<br>
the method according to the invention to transform a non-deterministic schema<br>
into a deterministic schema. For example, refer to the documents ["Regular<br>
expressions into finite automata" Briiggemann-Klein, Anne, Extended Abstract in<br>
I. Simon, Hrsg., LATIN 1992, S. 97-98. Springer-Verlag Berlin 1992. Full<br>
Version in Theoretical Computer Science 120: 197-213, 1993]. Thus, the schema<br>
mentioned above could be replaced by "SEQ(a,b[0,l])".<br>
In the next step 12 of the method according to the invention, processing<br>
can then be done on the components of the structure schema transformed into<br>
syntactic trees, to reduce or simplify them.<br>
For example, this reduction processing may consist of a globally flattening<br>
method to generate a single syntactic tree 51 from all the trees 31, 39 and 43 as<br>
shown in Figure 3.<br>
This tree actually shows a dictionary of all element types that might be<br>
encountered in the document, these elements being collected into a choice type<br>
group 52 appearing at least once [1,*] in the document. In this tree, complex type<br>
components "A", "B", "X" and "Y" are associated with an "ANY" type, and<br>
component "al" that appeared twice (in components "TB" and "TC") with<br>
different types, is associated with a default "pcdata" type according to the XML<br>
language, or with the element type in the initial document, for example text. The<br>
same information element may actually be represented in different ways; for<br>
example, a binary sequence may also be considered as a character string or an<br>
integer number.<br>
As a variant, this reduction processing consists of locally flattening the<br>
syntactic trees to obtain the trees represented as 31', 39' and 43' in Figures 4a to<br>
4c.<br>
In each of these figures, groups 32 to 34 (Figure 2a), 40 (Figure 2b) and 44<br>
to 46 (Figure 2c) have been replaced by a choice type group 53, 54, 55 appearing<br>
at least once [1,*].<br>
Trees "TA", "TB" and "TC" may also be further processed to eliminate<br>
ambiguities appearing in the structure schema.<br>
In some cases, syntactic trees may be simplified non-destructively, while<br>
improving the compactness of the binary code that can be generated.<br>
This type of simplification may be done in the case of a group of<br>
components containing a single component X for which the minimum number of<br>
occurrences n^ is equal to 0 or 1, in the following form:<br>
GROUP[nG,mG](X[nx,mx])<br>
in which GROUP may be a SEQ, CHO or AND type group. A group may<br>
be replaced by the following component:<br>
X[nG.nx,mG.mx]<br>
Another case of non-destructive simplification is possible in the case of a<br>
group of choice components CHO, comprising at least one component for which<br>
the minimum number of occurrences is equal to 0. Thus the group:<br>
CHO[0,mc](Xi[nxi,mxi],X2[l,mx2], X3[nx3,mx3])<br>
can be replaced by:<br>
CHO[nc,mc](Xi[nxi,mxi], X2[0,mx2], X3[nx3,mx3]).<br>
Similarly, a group CHO[l,!](..., CHO[l,l](...), ...) with a single CHO type<br>
occurrence particularly containing a single CHO type occurrence may be<br>
simplified by replacing it by a single CHO[l,l](...) group of the CHO type<br>
containing all components in the two CHO type groups.<br>
In step 12, trees "TA", "TB" and "TC" are also subjected to a<br>
normalization processing that consists of reordering the schema so as to obtain a<br>
single order of components in the schema. This processing then assigns a binary<br>
number to the different nodes of the syntactic trees obtained following the<br>
previous processing. This number is used during compression of the<br>
corresponding information element.<br>
In particular, the normalization processing consists of attributing a<br>
signature to each group, generated by concatenation of a group name with the<br>
signature of all components in the group, previously put into order. Thus, group<br>
53 in Figure 4 is associated with the "CHO.a3.a4.X.Y" signature.<br>
During this processing, it is considered that the ordered groups (SEQ) are<br>
already normalized. Therefore, the groups to be normalized are choice type<br>
groups ("CHO"), and "AND" and "ANDno" groups. This processing comprises<br>
the following steps for each group G composed of sub-groups gj and components<br>
Ci defining a corresponding element in the document:<br>
normalization of sub-groups gj, if any, in group G before group G is<br>
normalized, the normalization algorithm being recursive,<br>
storage of components Cj, if any, in group G before the sub-groups g,<br>
storage of components Cj in a predefined order,<br>
storage of sub-groups gj in the predefined order, and<br>
determination of the signature of group G given by concatenation of all<br>
signatures of its components (and sub-groups) in the order produced after the<br>
above steps.<br>
The predefined order for storage of group components may be<br>
alphanumeric order of their corresponding signatures, or decreasing order of their<br>
minimum number of occurrences, and in this case components with the same<br>
minimum number of occurrences are stored in alphanumeric order.<br>
Note that this normalization processing is not necessary for the method<br>
according to the invention. The order in which components appear in the schema<br>
can be conserved.<br>
The next step 13 in the method consists of generating an instructions<br>
sequence 5, also called the "binary syntax" describing a bit stream. This<br>
processing consists of generating an instructions sequence for each syntactic tree<br>
or complex type in the structure schema, beginning with nodes or components at<br>
the lowest level in the syntactic trees in the document tree-like structure schema.<br>
Call instructions to binary syntaxes thus generated for the lowest level nodes are<br>
then inserted in binary syntaxes for the higher level nodes in which the low-level<br>
components appear. The result is that a binary syntax is obtained for the entire<br>
document structure schema, which calls the binary syntaxes for lower level<br>
components, in the same way as software comprising a main program that calls<br>
sub-programs, which can then call other subprograms, and so on.<br>
The binary syntax of a component representing an element X of type TX is<br>
in the following form:<br>
where "X" represents an instruction to insert or to read the value of the<br>
element X or to call the instructions sequence corresponding to element X, and<br>
"TX" represents a reference to the type of element X.<br>
If type TX has one or several sub-types, it represents what is called<br>
polymorphism. In this case, it is associated with the following binary syntax:<br>
If the type TX comprises sub-types SI, S2, ..., Sn, two different cases have<br>
to be considered depending on whether or not the default type TX is abstract.<br>
If the default type TX is abstract, then a "TX_poly" binary syntax<br>
comprises the following in sequence:<br>
an instruction to insert or read a code of sub-type "flagPoly" representing a<br>
number of the sub-type to be applied to element X, associated with the size of this<br>
code as a number of bits, and<br>
instructions to test the value of the sub-type code, each test instruction<br>
being associated with an instruction to insert or read the value of element X or to<br>
call the instructions sequence corresponding to element X associated with a<br>
reference to the sub-type of element X corresponding to the tested value of the<br>
sub-type code.<br>
Sub-types SI, ..., Sn are arranged in the order of their signatures, before<br>
this operation:<br>
for example, this type of binary syntax may be in the following form:<br>
where E() is a function rounding up to the next higher integer, and<br>
"flagPoly" contains the number code of the sub-type to be apphed to element X,<br>
and "X" indicates the positions at which the code for element X must be inserted.<br>
If 2^^'°^2^"^^ &gt; n, the following line can be added at the end of the binary<br>
sequence to detect malfunctions:<br>
where "SpecificProcess" is a procedure designed to signal a processing<br>
error in the case in which the value of "flagPoly" does not correspond to a sub-<br>
type of TX.<br>
If the default type TX is not abstract, the binary syntax of TXjoly is<br>
obtained by inserting the previous binary syntax into a binary syntax comprising<br>
the following successively:<br>
an instruction to insert or read a single-bit "typInfoFlag" sub-typing<br>
presence code indicating if the element type is the default type or a sub-type of<br>
this default type, and<br>
an instruction to test the value of the sub-typing presence code, and<br>
in association with the test instruction, the instructions sequence defining<br>
polymorphism like that indicated in Table 1, if the value of the sub-typing<br>
presence code indicates that the element type is a sub-type, and otherwise an<br>
instruction to insert or read a value of the element X associated with a reference<br>
to the default type of element X.<br>
For example, this type of binary syntax may be in the following form:<br>
in which "typelnfoFlag" is a code indicating if the type of X is TX or one<br>
of the sub-types of TX.<br>
The next step is to determine the binary syntax of the number of<br>
occurrences [n,m] of each element or elements set X for which the binary syntax<br>
has been determined. Afterwards, an element can represent an elements set.<br>
A distinction is made between three cases for this purpose. In a first case,<br>
m and n are equal to 1, in other words component X is associated with occurrence<br>
numbers [1,1]. The binary syntax produced corresponds to the binary syntax<br>
generated for component X.<br>
In the second case, n = 0 and m = 1, the binary syntax generated comprises<br>
the following successively:<br>
an instruction to insert or read a single-bit presence code "flagX"<br>
indicating whether or not element X is present in the compressed document,<br>
associated with the size of this code as a number of bits,<br>
an instruction to test the value of the presence code, and<br>
in association with the test instruction, an instruction to insert or read the<br>
value of the element X or calling the instructions sequence corresponding to the<br>
element X, if the value of the presence code indicates that the element X is<br>
present in the document.<br>
For example, this type of binary syntax may be in the following form:<br>
in which flagX is a single-bit code indicating whether or not X is present in<br>
the document. This binary syntax is similar to a sequence of programming<br>
instructions in which X is inserted if the value of the indicator flagX is equal to<br>
"true".<br>
In the third case, m - n is less than a predetermined threshold constant, for<br>
example 2^^ (= 65536), which means that the number of occurrences may be<br>
encoded in the form of an unsigned 16-bit integer. In this case, the binary syntax<br>
of element X[n,m] comprises the following successively:<br>
an instruction to insert or read a number of occurrences code<br>
"loopflagX" indicating the number of successive occurrences of element X in the<br>
compressed document, minus the minimum number n of occurrences of element<br>
X associated with the size of this code as a number of bits,<br>
a loop instruction defining a number of iterations corresponding to<br>
the value of the number of occurrence codes, and<br>
in association with the loop instruction, an instruction to insert or<br>
read the value of the element X or calling an instructions sequence corresponding<br>
to element X.<br>
For example, this type of binary syntax may be in the following form:<br>
Table 4<br>
in which "loopflagX" is the code of the number of successive occurrences<br>
of X in the document, minus the minimum number n of occurrences of X and E()<br>
is the function rounding up to the next higher integer.<br>
This syntax indicates that "loopflagX" is encoded on E(log2(m-n+l)) bits,<br>
and that X must be inserted (loopflagX+n) times.<br>
In the fourth case, m is not bounded or m - n is greater than the<br>
predetermined threshold constant. The binary syntax generated is similar to the<br>
binary syntax for the third case, except that "loopflagX" is not encoded on<br>
E(log2(m-n+l)) bits, but it is encoded in another format in which any integer can<br>
be encoded.<br>
For example, this format may be the "UINTVLC" format composed of<br>
sets of a predetermined number of bits, for example 5 bits, the first bit of each set<br>
indicating whether or not this set is the last set in the code of the integer number,<br>
and the next four bits of the set are used to code the integer number.<br>
In the third and fourth cases, if the minimum number of occurrences n is 0,<br>
it is preferable to add a binary syntax also comprising:<br>
an instruction to insert or read a single-bit "shuntflagX" presence code, to<br>
indicate whether or not at least one element X is present in the compressed<br>
document, and<br>
an instruction to test the value of the presence code, associated with the<br>
instructions sequence generated for a number of occurrences of the element X<br>
between 1 and m, if the value of the presence code indicates that at least one<br>
element X is present.<br>
For example, this type of binary syntax may be in the following form:<br>
Table 5<br>
in which "shuntFlag" denotes a single-bit code indicating whether or not<br>
the number of occurrences is 0, and the "binary syntax of X[n,m]" line is the<br>
binary syntax of the number of occurrences X corresponding to the third or to the<br>
fourth case.<br>
As a variant, another type of encoding can be chosen in which there is no<br>
need to input the number of occurrences of elements of a structure schema. This<br>
type of encoding uses a binary syntax comprising the following successively:<br>
an instruction to insert or read a single-bit "flagX" presence code<br>
indicating if there is an occurrence of element X in the document, associated with<br>
the size of this code as a number of bits,<br>
a loop instruction to be executed as long as the presence code to be<br>
inserted or read indicates the presence of a new occurrence of element X,<br>
in association with the loop instruction, an instruction to insert or read the<br>
value of element X or calling an instructions sequence corresponding to element<br>
X, and an instruction to insert or read a new single-bit "flagX" presence code<br>
indicating if tliere is a new occurrence of element X in the document.<br>
For example, this type of binary syntax may be in the following form:<br>
Table 6<br>
This solution has the advantage that there is no need to analyze the entire<br>
structure schema of the document to determine the minimum and maximum<br>
numbers of occurrences of each element in the structure.<br>
The binary syntax of a sequential type group SEQ(X1, X2, ..., Xn)<br>
comprises sequences of instructions generated successively, for sequence type<br>
group components, or calling of these instruction sequences.<br>
For example, this type of binary syntax may be in the following form:<br>
The binary syntax of a choice group CH0(X1, X2, .... Xn) comprises the<br>
following, successively:<br>
an instruction to insert or read a component number code "flagChoX"<br>
representing a component number Xi (i = l...n) and denoting the next element Xi<br>
in the group to be inserted or read in the compressed document, associated with<br>
the size of this code as a number of bits, and<br>
instructions to test the value of the element number code, each test<br>
instruction being associated with an instruction to insert or read the value of<br>
element Xi or calling an instructions sequence corresponding to element Xi<br>
corresponding to the tested value of the component code.<br>
For example, this type of binary syntax may be in the following form:<br>
where n is the number of components in the group and "flagCho" is the<br>
component code to be selected in the CHO group.<br>
As above, if 2^('°S2("^&gt; &gt; n, the following line can be added at the end of the<br>
binary syntax to detect malfunctions:<br>
This instruction calls an error signaling procedure if the value of the<br>
indicator "flagCho" does not correspond to one of the components expected in the<br>
CHO group.<br>
If the number of occurrences is not encoded, an unused value of "tlagCho"<br>
may also be used (if 2^^'°^2^"^^&gt; n) to mark the last occurrence of group CHO:<br>
The binary syntax of the AND group is generated by a recursive<br>
procedure. It consists of nesting CHO type groups, each determining which<br>
element is present in the description.<br>
More precisely, this type of binary syntax is generated by making a<br>
distinction between two cases, the first case in which the group contains only one<br>
component, and the second case in which the group contains several components.<br>
If the group contains only one component, the binary syntax of such a group is<br>
the same as the binary syntax of a sequence type group with a single component.<br>
If the group contains n components, it may be written in the form AND<br>
(Xi, X2, ..., Xn). The binary syntax of such a group comprises the following<br>
successively:<br>
an instruction to insert or read a component number code "flagChoX"<br>
representing a component number Xi of the group and denoting the next element<br>
Xi of the group to be inserted or read in the compressed document, associated<br>
with the size of this code as a number of bits, and<br>
instructions to test the value of the component number code, each test<br>
instruction being associated with an instruction to insert or read the value of the<br>
element Xi or calling an instructions sequence corresponding to element Xi<br>
corresponding to the tested value of the component code, and an instructions<br>
sequence generated for an "unordered group" type group comprising all<br>
components XI, ..., Xn in the group except for component Xi.<br>
For example, this type of binary syntax may be in the following form:<br>
This binary syntax is obtained starting from the binary syntax of a<br>
CHO(Xi, X2, ..., Xn) group in which the binary syntax of a group<br>
AND(Xi,...,Xk+i,...,X„) from which component X^ has been removed, has been<br>
added following the binary syntax of each component X^ in the group (where k is<br>
between 1 and n). Therefore this binary syntax is recursive.<br>
The binary syntax of the ANDno type group is identical to the binary<br>
syntax of an SEQ group, in which the encoding can also be optimized by<br>
adopting an appropriate order of components in the group.<br>
The next step 14 consists of reading the document 2, compressing the data<br>
contained in it by executing the binary syntaxes that were generated on the<br>
document structure in order to obtain a bit stream containing a sequence of binary<br>
codes in which the compressed value of each element or basic information<br>
element of the document is located.<br>
More precisely, the objective is to start from the contents of the document,<br>
and determine values of the different "typelnfoFlag", "flagX", "loopflagX", ...<br>
codes defined by the binary sequences, to be inserted in the bit stream.<br>
According to a first encoding type, this bit stream is in the fomi<br>
(K.N.Vi..VN)e for each element e, where N is the number of occurrences of the<br>
element e or the number of successive information elements corresponding to<br>
element e, K is the code used to determine the element e, and Vj .. Vn are the<br>
corresponding values, possibly compressed, of the N occurrences of element e. If<br>
e is a group of elements, its value V is broken down into as many binary<br>
sequences (K.N.V) as there are elements contained in it. However, N may be<br>
omitted in some cases, particularly when this number is fixed. The same is true<br>
for K, for example in the case of a sequence type group.<br>
As a comparison, considering the extended duration representation format<br>
as defined by standard ISO 8601 :<br>
sPnYnMnDTnHnMnS<br>
where s is the "+" or "-" sign, nY represents a number of years (infinite<br>
integer), nM is a number of months (infinite integer), nD a number of days<br>
(infinite integer), "T" is a separating character between the date and the time, nH<br>
is a number of hours (infinite integer), nM is a number of minutes (infinite<br>
integer) and nS is a number of seconds (decimal), all these elements being<br>
optional.<br>
This format corresponds to a structure schema that may be represented as<br>
follows:<br>
(\+|\-)P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+(\,\d+)?S)?)?<br>
where "\+" indicates insertion of the "+" character, "(x|y)" indicates<br>
insertion of element x or y, "?" indicates that insertion of the previous element is<br>
optional, and "\d+" represents a binary number on an arbitrary number of bits.<br>
The following shows an example of the structure of this type of binary<br>
syntax:<br>
Table 11<br>
in which the value Sign is equal to 0 to represent the "+" sign, and 1 to<br>
represent the "-" sign.<br>
Thus, the duration "+P1347Y" is encoded as follows:<br>
This encoding system requires 22 bits, while conventional encoding<br>
requires 48 bits. The duration "-P1Y2MT2H" is encoded as follows:<br>
namely on 22 bits instead of 72 necessary for conventional encoding.<br>
Before this is done, a general header can be produced for the compressed<br>
document that contains several encoded parameters useful for the document<br>
description. Thus, this type of header may comprise a signature of the structure<br>
schema(s) used, and a set of parameters defining the encoding used, for example<br>
as follows:<br>
a parameter indicating if encoding of the length of each element is<br>
compulsory or optional, or if it is not present in the document,<br>
a parameter indicating whether or not elements may be sub-typed, in other<br>
words associated with a more precise type than their basic type, and<br>
a parameter indicating the encoding type used for the number of<br>
occurrences.<br>
Each information element in the document can also be associated with a<br>
header, its presence and nature being specified in the document header.<br>
An element header may also comprise the encoded length of the element,<br>
so as to enable access to a particular element while the document is being<br>
decompressed without decompressing all previous elements in the document.<br>
Element headers are inserted in the document, for example just before encoding<br>
the value of elements.<br>
In general, decompression of the document consists of sequentially reading<br>
the compressed document, by executing binary syntaxes generated from the<br>
schema on the bit stream obtained by sequentially reading the compressed<br>
document. This processing also provides a means of verifying that the structure of<br>
the compressed document corresponds to the schema compiled in binary<br>
syntaxes.<br>
When the number of occurrences of elements in the structure schema is not<br>
encoded, the form of the element encoding is simply KV, the encoding of each<br>
elements set of the same type terminating with a Kesc bit equal to 0.<br>
This type of encoding is only useful for encoding complex forms, and for<br>
elements in which there is no maximum number of occurrences or in which the<br>
minimum number of occurrences is zero. In particular, it is ideal for encoding<br>
choice type groups, comprising a number of elements not equal to 2', where p is<br>
an integer number.<br>
This type of encoding may be combined with the previous type. In this<br>
case, all that is necessary is to include it in the header of the compressed<br>
document and to assign a bit to the encoding locations at which several<br>
occurrences must be located.<br>
According to the invention, at least one basic type of information elements<br>
for the document is associated with an external compression module 16. hi this<br>
way, the corresponding types of infomiation elements encountered are analysed<br>
when the document is being read, and when an information type is associated<br>
with an external compression module 16, it is applied to the contents of the<br>
information element and the result of the compression is inserted in the<br>
compressed document as the value of the corresponding information element.<br>
For example, external compression modules may use the "mp3" standard<br>
for sound information, or "jpeg" for images and "MPEGl" or "MPEG2" for video<br>
type data, or IEEE 754 for real number type values or UTF8 for character strings.<br>
If none of the compression modules is associated with an information type,<br>
a default compression module may be used or information elements of this type<br>
may be retrieved in the same way as they appear in the initial document.<br>
For example, encoding of the CHO[0,*](al, a2, a3) structure produces the<br>
following binary syntax:<br>
Table 12<br>
If we now want to code the occurrence "aa a^ ai a] a^" with this structure,<br>
the result of the encoding is as follows if the number of occurrences is encoded:<br>
00101 01 Va2 10 Va3 00 V^i 00 Val 10 Va3<br>
in which "00101" represents the binary value of the number of<br>
occurrences, which is equal to 5 in the "UINT_VLC" format and V„y, V„2 and V^^<br>
are the values of occurrences of ai, 82 and a^ respectively.<br>
If the number of occurrences is not encoded, the encoding is as follows;<br>
01 V32l0Va3 00Vai00Va, lOVasll<br>
"11" is the end code for the number of occurrences which in this case is<br>
integrated into the selection code of the CHO group.<br>
In the first case, the result is that element values are encoded on not more<br>
than 15 bits, whereas the second case gives a more compact encoding on 12 bits.<br>
The structure of the encoding processing for occurrence "b2 bj ai" is as<br>
follows:<br>
SEQ[0,*](ai[0,*],CHO[0,*](b,,b2))<br>
giving the following binary syntax:<br>
The encoding for this binary syntax is as follows:<br>
1 number of occurrences of the sequence not equal to 0<br>
00010 number of occurrences of the sequence (in this case twice)<br>
0 number of occurrences of a = 0<br>
1 number of occurrences of CHO not equal to 0<br>
00010 number of occurrences of CHO (twice)<br>
1 choice code for ba<br>
Vb2 encoding value of ba<br>
0 choice code for bi<br>
Vb 1 encoding value of b,<br>
1 number of occurrences of a = 0<br>
00001 number of occurrences of ai (once)<br>
Vai encoding value of for ai<br>
0 number of occurrences of CHO = 0<br>
If the order of the attributes is not useful (as in the XML language),<br>
encoding may be done to reorder attributes of the elements in a predetermined<br>
order, for example in alphanumeric order, and then depending on whether or not<br>
they are required. This arrangement correspondingly reduces the size of the<br>
compressed description.<br>
If the document header contains an indication that the encoding of the<br>
length is optional or compulsory, elements are associated with a header in the<br>
compressed document containing the length of the value of the element as a<br>
number of bits. This feature enables direct access to an element in the compressed<br>
document, without needing to decompress elements before it in the document,<br>
using binary syntaxes to read only the corresponding lengths of these elements as<br>
far as the searched element.<br>
The length of elements may be encoded as follows.<br>
If the document header includes an indication that the encoding of element<br>
length is compulsory, the length L of elements as a number of bits is calculated<br>
using the following formula:<br>
L = 8*p + h (1)<br>
where p represents the number of bytes (in ANSI encoding or using the<br>
high order bits of each byte used to code this number) used to code the element<br>
length, and h is the number of remaining bits with this length (h 
Note that the external compression module 16 called to code the value of<br>
an element may supply this length in return.<br>
If it is not compulsory to code the length of the elements, the value of the<br>
first bit corresponding to the value of the element indicates whether or not the<br>
next bits represent the length of the element.<br>
Decompression a document compressed in this way is done by executing<br>
steps 11 to 14 on the document structure schema to obtain binary syntaxes of<br>
structure components of the document structure schema, and then executing step<br>
14' to decode or decompress the document, this step consisting of browsing<br>
through the compressed document executing binary syntaxes obtained following<br>
steps 11 to 14 so as to be able to determine the type and name of compressed<br>
information elements found in the document. The values of elements obtained<br>
using external compression modules 16 are decompressed using the<br>
corresponding decompression modules 16'.<br>
Note that if several documents with the same structure schema have to be<br>
processed (compressed or decompressed), steps 11 to 13 are only executed once,<br>
and only steps 14 and 16 (or 14' and 16') have to be applied to each document to<br>
be processed.<br>
Furthermore, the binary syntax of a structure schema that is similar to a<br>
conventional programming language, may be compiled 17, 17' using an<br>
appropriate conversion processing, to generate binary code for a compression or<br>
decompression program 6, 6' that can be directly executed or interpreted by a<br>
computer processor. Therefore, the method according to the invention is capable<br>
of automatically generating executable and therefore very fast compression and<br>
decompression programs dedicated to a given structure schema.<br><br>
CLAIMS<br>
1. Method for compressing a structured document comprising information<br>
elements nested in each other and each associated with an information type, the<br>
structured document (2) being associated with at least one structure schema (1; 31, 39,<br>
43) defining a document tree-like structure and comprising structure components (a3,<br>
a4, X, Y, a1, a5, a1, a2. A, B, 32, 33, 34, 40, 44, 45, 46) nested in each other, each type<br>
of document information being defined by a component in the schema,<br>
characterized in that it comprises steps of analyzing (11, 13) the document<br>
structure schema (1) in order to obtain a sequence of executable instructions (5) for<br>
each component of the structure schema, comprising instructions for inserting into a bit<br>
stream control codes and compressed values of information elements or component<br>
instruction sequence call codes, and instructions for controlling the execution of the<br>
sequence as a function of control code values, execution of the instruction sequences<br>
on the structured document (2) compressing (14) the structured document (2) into a bit<br>
stream (10) containing compressed values of the information elements in the document.<br>
2. Compression method as claimed in claim 1, wherein it comprises a step of<br>
executing instruction sequences on the structured document (2).<br>
3. Compression method as claimed in claim 1 or 2, wherein the document<br>
comprises basic elements not decomposed into sub-elements, and at least one type of<br>
basic element information is associated in advance with a compression algorithm (16)<br>
adapted to the type of information, the method comprising application of the<br>
compression algorithm (16) to the value of each information element with an information<br>
type associated with said algorithm, during execution of the instruction sequences (5).<br>
4. Compression method as claimed in one of claims 1 to 3, wherein it comprises<br>
a step of compiling (17) of Instruction sequences (5) obtained for each component of<br>
said structure schema, to obtain a binary encoding program (6) dedicated to said<br>
structure schema, and directly executable or interpretable by a computer to compress a<br>
document (2) with the structure schema (1).<br>
5. Compression method as claimed in one of claims 1 to 4, wherein it comprises<br>
a prior step of normalizing (12) the document structure schema (5), so as to obtain a<br>
single predefined order of components in the schema.<br>
6. Compression method as claimed in one of claims 1 to 5, wherein it comprises<br>
a prior step (12) for optimization and simplification of the document structure schema<br>
consisting of reducing the number of nesting levels in structure components.<br>
7. Compression method as claimed in one of claims 1 to 6, wherein at least one<br>
information element in the document (2) is associated with an information element code<br>
in the generated bit stream (10), which is marked so as to enable direct access to a<br>
particular compressed information element in the bit stream, without it being necessary<br>
to decompress information elements preceding the element to be decompressed in the<br>
bit stream.<br>
8. Compression method as claimed in one of claims 1 to 7, wherein the<br>
generated compressed document (10) comprises a code for each information element<br>
in the structured document (2), used to determine the type of information associated<br>
with the information element and the binary value of the information element.<br>
9. Compression method as claimed in one of claims 1 to 8, wherein the structure<br>
schema (1) of the document (2) comprises the definition of sub-types of at least one<br>
type of information, and in that the instructions sequence (5) generated for a component<br>
of a type (TX) with n sub-types (Si, S2, ..., Sn) comprises the following in sequence :<br>
an instruction to insert a sub-type code ("flagPoly") representing a sub-type to be<br>
applied to an element (X) corresponding to the component in the document, associated<br>
with the size of this code as a number of bits, and<br>
instructions to test the value of the sub-type code, each test instruction being<br>
associated with a reference to the sub-type (Si, S2..... Sn) of the element (X)<br>
corresponding to the tested value of the sub-type code, and an instructions sequence<br>
generated for compression of an element (X) associated with the sub-type.<br>
10. Compression method as claimed in to one of claims 1 to 9, wherein the bit<br>
stream generated for a component corresponding to several occurrences of an<br>
elements set comprising at least one information element in the document (2),<br>
comprises a predefined end code.<br>
11. Compression method as claimed in one of claims 1 to 10, wherein each<br>
component of the structure schema (1) corresponds to an elements set in the document<br>
(2) comprising at least one information element, and is also associated with a set of<br>
numbers of possible occurrences, indicating the number of times that an elements set<br>
corresponding to this component may appear in an information element at a level<br>
immediately higher than the level to which it belongs.<br>
12. Compression method as claimed in claim 11, wherein the instructions<br>
sequence generated for a component with a number of occurrences equal to 0 or 1<br>
comprises, in sequence :<br>
an instruction to insert a presence code ("flagX") on one bit indicating whether or<br>
not an elements (X) set corresponding to the component is present in the document (2),<br>
an instruction to test the value of the presence code, and<br>
in association with the test instruction, if the value of the presence code indicates<br>
the presence of the elements set (X) in the document, an instructions sequence<br>
generated for the component, independently of the associated number of occurrences.<br>
13. Compression method as claimed in claim 11 or 12, wherein the instructions<br>
sequence generated for a component with a number of occurrences between n and m<br>
includes the following steps in sequence :<br>
an instruction to insert a number of occurrences code ("loopflagX") indicating the<br>
number of successive occurrences of an elements set (X) corresponding to the<br>
component in the compressed document, minus the minimum number n of occurrences,<br>
associated with the size of this code as a number of bits.<br>
a loop instruction defining a nunnber of iterations corresponding to the value of<br>
the number of occurrences codes, and<br>
in association with the loop instruction, an instructions sequence that is<br>
generated for the component independently of the associated number of occurrences.<br>
14. Compression method as claimed in claim 13, wherein the instructions<br>
sequence generated for a component with a number of occurrences between 0 and m<br>
also comprises :<br>
an instruction to insert a presence code ("shuntflagX") indicating whether or not<br>
there is at least one occurrence of the elements set (X) corresponding to the component<br>
in the document, and<br>
an instruction to test the value of the presence code associated with the<br>
instructions sequence generated for a number of occurrences of the component<br>
between 1 and m, if the value of the presence code indicates that at least one elements<br>
set is present.<br>
15. Compression method as claimed in claim 11, wherein the instructions<br>
sequence generated for a component with a number of occurrences between n and m<br>
includes the following steps in sequence :<br>
an instruction to insert a single-bit presence code ("flagX") signaling an<br>
occurrence of an elements set (X) corresponding to the component in the document (2),<br>
associated with the size of this code as a number of bits,<br>
a loop instruction to be executed as long as the presence code to be inserted<br>
indicates that a new occurrence of the elements (X) set is present,<br>
in association with the loop instruction, an instructions sequence generated for<br>
the component, and an instruction to insert a new single-bit presence code ("flagX")<br>
signaling a new occurrence of the elements set (X) in the document.<br>
16. Compression method as claimed in one of claims 1 to 15, wherein each<br>
component in the structure schema (1) corresponds to an elements set comprising at<br>
least one information element, and in that the structure schema (1) of the structured<br>
document (2) comprises at least one sequence type component of ordered<br>
components, in which the order of appearance in the sequence defines the order of<br>
appearance in the document of element sets corresponding to components of the<br>
sequence type group, and in that the instructions sequence generated for a sequence<br>
comprising n components (XI, X2, ..., Xn) comprises instruction sequences generated<br>
for each component in the sequence, successively.<br>
17. Compression method as claimed in one of claims 1 to 16, wherein each<br>
component in the structure schema (1) corresponds to an elements set comprising at<br>
least one information element, the structure schema (1) of the document to be<br>
compressed comprises at least one component of the choice components group type,<br>
each choice component corresponding to an information elements set, the component<br>
of the choice components group type corresponding in the document to one of the<br>
information sets corresponding to choice components, and in that the instructions<br>
sequence generated for a group of choice components comprising n components<br>
defining n corresponding element sets (XI, X2, ..., Xn), comprises the following in<br>
sequence :<br>
an instruction to insert an elements set number code ("flagChoX") denoting which<br>
elements set among the n element sets (XI, X2, ..., Xn) appears in the document (2),<br>
associated with the size of this code as a number of bits, and<br>
instructions to test the value of the elements set number code, each test<br>
instruction being associated with an instructions sequence generated for the component<br>
corresponding to the elements set (Xi) corresponding to the tested value of the<br>
elements set number code.<br>
18. Compression method as claimed in one of claims 1 to 17, wherein each<br>
component of the structure schema (1) corresponds to an elements set comprising at<br>
least one information element, and in that the structure schema (1) of the document to<br>
be compressed comprises at least one unordered components group type, each<br>
component in the unordered group corresponding to an elements set and the group of<br>
the unordered group type corresponding in the document to a group containing all<br>
element sets corresponding to components of the unordered type group, in an arbitrary<br>
order, and in that the instructions sequence generated for an unordered type group<br>
comprising n components corresponding to n element sets (XI, X2..... Xn) in the<br>
document, comprises the following in sequence :<br>
an instruction to insert an elements set (Xi) number code ("flagChoX") and<br>
denoting the next elements set appearing in the document (2) associated with the size<br>
of this code as a number of bits, and<br>
instructions to test the value of the elements set number code, each test<br>
instruction being associated with an instructions sequence generated for the component<br>
corresponding to the elements set (Xi) corresponding to the tested value of the<br>
elements set number code, and an instructions sequence generated for an unordered<br>
type group comprising all components (XI,..., Xn) of the unordered group except for the<br>
component corresponding to the elements set (Xi).<br>
19. Method for decompressing a structured document comprising information<br>
elements nested in each other and each associated with an information type, the<br>
structured document (2) being associated with at least one structure schema (1; 31, 39,<br>
43) defining a tree-like structure of the document and comprising structure components<br>
(a3, a4, X, Y, a1, a5, a1, a2, A, B, 32, 33, 34, 40, 44, 45, 46) nested in each other, each<br>
type of document information being defined by a component of the schema,<br>
characterized in that it comprises steps of analyzing (11, 13) the document<br>
structure schema (1) in order to obtain a sequence of executable instructions (5) for<br>
each component of the structure schema, this sequence comprising instructions for<br>
reading control codes in a bit stream forming the compressed document (10), with<br>
compressed values of information elements or call codes to component instruction<br>
sequences, and instructions for controlling the execution of the sequence as a function<br>
of the control code values, the execution of instruction sequences on the compressed<br>
document (10) restoring a document (2') in a same format as the original document (2)<br>
and with an at least equivalent structure.<br>
20. Decompression method as claimed in claim 19, wherein it comprises a step<br>
of executing instruction sequences (5) on the bit stream forming the document to be<br>
decompressed (10).<br>
21. Decompression method as claimed in claim 19 or 20, wherein the structured<br>
document (2) comprises basic elements not broken down into sub-elements, and at<br>
least one basic elements information type is associated with a decompression algorithm<br>
(16') adapted to the information type, the method comprising steps of detecting an<br>
information element binary code corresponding to said information type in the bit stream<br>
during execution of instruction sequences (5) in the bit stream forming the compressed<br>
document (10), and applying the decompression algorithm to this binary code,.<br>
22. Decompression method as claimed in one of claims 19 to 21,<br>
wherein it comprises a step of compiling (17) instruction sequences (5) obtained<br>
for each component of said structure schema (1), to obtain a binary decoding program<br>
(6) dedicated to said structure schema, and directly executable or interpretable by a<br>
computer to decompress a document (10) with this structure schema.<br>
23. Decompression method as claimed in one of claims 19 to 22,<br>
wherein it comprises a prior step for normalization (12) of the document structure<br>
schema (5), so as to obtain a single predefined order of the components of the schema.<br>
24. Decompression method as claimed in one of claims 19 to 23,<br>
wherein it comprises a prior step (12) for optimization and simplification of the<br>
document structure schema consisting of reducing the number of hierarchical levels of<br>
structure component groups.<br>
25. Decompression method as claimed in one of claims 19 to 24,<br>
wherein at least one information element code is identified in the bit stream of the<br>
compressed document (10), so as to enable direct access to this information element,<br>
without it being necessary to decompress information elements preceding this element<br>
in the bit stream.<br>
26. Decompression method as claimed in one of claims 19 to 25,<br>
wherein the compressed document (10) comprises a code for each information<br>
element in the original document, to determine the information type associated with the<br>
information element and the binary value of the compressed information element.<br>
27. Decompression method as claimed in one of claims 19 to 26,<br>
wherein the structure schema (1) of the document to be decompressed (10)<br>
comprises the definition of sub-types of at least one information type (TX), and in that<br>
the instructions sequence (5) generated for a component of a type (TX) with n sub-types<br>
(Si, S2,..., Sn) includes the following in sequence :<br>
an instruction to read a sub-type code ("flagPoly") representing a number of the<br>
sub-type to be applied to an element (X) corresponding to the component in the<br>
document, associated with the size of this code as a number of bits, and<br>
instructions to test the value of the sub-type code, each test instruction being<br>
associated with a reference to the sub-type (Si, S2, ..., Sn) of the element (X)<br>
corresponding to the value of the tested sub-type code, and an instructions sequence<br>
generated for decompression of an element (X) associated with the sub-type.<br>
28. Decompression method as claimed in one of claims 19 to 27,<br>
wherein the end of a group of several occurrences of an elements set comprising<br>
at least one information element corresponding to a component of the schema (1), is<br>
marked in the bit stream of the compressed document (10) by a determined binary<br>
code.<br>
29. Decompression method as claimed in one of claims 19 to 28,<br>
wherein each component in the structure schema (1) corresponds to an elements<br>
set in the bit stream of the document (10), comprising at least one information element,<br>
and is also associated with a set of possible numbers of occurrences, indicating the<br>
number of times that an elements set corresponding to this structure component can<br>
appear in the information element at a level immediately above the level to which it<br>
belongs.<br>
30. Decompression method as claimed in claim 29,<br>
wherein the instructions sequence generated for a component with a number of<br>
occurrences equal to 0 or 1 comprises the following in sequence :<br>
an instruction to read a single-bit presence code ("flagX") indicating whether or<br>
not an elements set (X) corresponding to the component is present in the compressed<br>
document,<br>
an instruction to test the value of the presence code, and<br>
in association with the test instruction, if the value of the presence code indicates<br>
that the elements set (X) is present in the compressed document, an instructions<br>
sequence that is generated for the component independently of the associated nurnber<br>
of occurrences.<br>
31. Decompression method as claimed in claim 29 or 30,<br>
wherein the instructions sequence generated for a component with a number of<br>
occurrences between n and m comprises the following in sequence :<br>
an instruction to read a number of occurrences code ("loopflagX") indicating the<br>
number of successive occurrences in the compressed document of an elements set (X)<br>
corresponding to the component, minus the minimum number n of occurrences<br>
associated with the size of this code as a number of bits,<br>
a loop instruction defining a number of iterations corresponding to the value of<br>
the number of occurrences code, and<br>
in association with the loop instruction, an instructions sequence generated for<br>
the component, independently of the associated number of occurrences.<br>
32. Decompression method as claimed in claim 31,<br>
wherein the instructions sequence generated for a component with a number of<br>
occurrences between 0 and m also comprises :<br>
an instruction to read a single-bit presence code ("shuntflagX") Indicating whether<br>
or not there is at least one occurrence of an elements set (X) corresponding to the<br>
component in the compressed document, and<br>
an instruction to test the value of the presence code, associated with the<br>
instructions sequence generated for a number of occurrences of the component<br>
between 1 and n, if the value of the presence code indicates that there is at least one<br>
elements set present.<br>
33. Decompression method as claimed in claim 29, wherein the instructions<br>
sequence generated for a component with a number of occurrences between n and m<br>
comprises the following successively :<br>
an instruction to read a single-bit presence code ("flagX") indicating whether or<br>
not there is an occurrence of an elements set (X) corresponding to the component in<br>
the compressed document (10), associated with the size of this code as a number of<br>
bits,<br>
a loop instruction to be executed as long as the presence code read in the bit<br>
stream of the compressed document indicates that there is a new occurrence of the<br>
elements set (X),<br>
in association with the loop instruction, an instructions sequence generated for<br>
the component, and an instruction to insert a new single-bit presence code ("flagX")<br>
indicating whether or not there is a new occurrence of the elements set (X) in the<br>
compressed document (10).<br>
34. Decompression method as claimed in one of claims 19 to 33,<br>
wherein each component of the structure schema (1) corresponds to an<br>
elements set comprising at least one information element, and the structure schema (1)<br>
of the compressed document (10) comprises at least one ordered components<br>
sequence type component, for which the order of appearance in the sequence defines<br>
the order of appearance of element sets in the document corresponding to components<br>
of the sequence type group, and in that the instructions sequence generated for a<br>
sequence comprising n components (X1, X2, ..., Xn) comprises instruction sequences<br>
generated for each component in the sequence successively.<br>
35. Decompression method as claimed in one of claims 19 to 34,<br>
wherein each component in the structure schema (1) corresponds to an elements<br>
set comprising at least one information element, in that the structure schema (1) of the<br>
document to be decompressed comprises at least one component of the choice<br>
components group type, each choice component corresponding to an information<br>
elements set, the component of the choice components group type in the document<br>
corresponding to one of the information sets corresponding to the choice components,<br>
and in that the instructions sequence generated for a choice components group<br>
comprises n components (XI, X2, ..., Xn) defining n element sets respectively,<br>
comprises the following in sequence :<br>
an instruction to read an elements set number code ("flagChoX") denoting the<br>
elements set that appears in the document among the n element sets (XI, X2, ..., Xn),<br>
associated with the size of this code as a number of bits, and<br>
instructions to test the value of the elennents set number code, each test<br>
instruction being associated with an instructions sequence generated for the component<br>
corresponding to the elements set (Xi) corresponding to the tested value of the<br>
elements set number code.<br>
36. Decompression method as claimed in one of claims 19 to 35,<br>
wherein each component in the structure schema (1) corresponds to an elements<br>
set comprising at least one information element, and the structure schema (1) of the<br>
document to be decompressed comprises at least one component of the unordered<br>
type group, each component in the unordered group corresponding to an elements set<br>
and the group of the unordered group type corresponding to a group in the document,<br>
containing all element sets corresponding to components of the unordered type group,<br>
in an arbitrary order, and in that the instructions sequence generated for an unordered<br>
type group comprising n components corresponding to n element sets (X1, X2, ..., Xn)<br>
in the document, comprises the following successively :<br>
an instruction to read a number code for an elements set (Xi) and denoting the<br>
next elements set appearing in the document (10), associated with the size of this code<br>
as a number of bits, and<br>
instructions to test the value of the elements set number code, each test<br>
instruction being associated with an instructions sequence generated for the component<br>
corresponding to the elements set (Xi) corresponding to the tested value of the<br>
elements set number code, and an instructions sequence generated for an unordered<br>
type group comprising all components (XI,.....Xn) in the unordered group except for the<br>
component corresponding to the elements set (XI).<br></element></elementname></xxxx></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LUtPTE5QLTIwMDMtKDExLTA1LTIwMTIpLUNPUlJFU1BPTkRFTkNFLnBkZg==" target="_blank" style="word-wrap:break-word;">985-KOLNP-2003-(11-05-2012)-CORRESPONDENCE.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LUtPTE5QLTIwMDMtKDE1LTEwLTIwMTIpLUNPUlJFU1BPTkRFTkNFLnBkZg==" target="_blank" style="word-wrap:break-word;">985-KOLNP-2003-(15-10-2012)-CORRESPONDENCE.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtYXNzaWdubWVudC5wZGY=" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtYXNzaWdubWVudDEuMS5wZGY=" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-assignment1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LUtPTE5QLTIwMDMtQ09SUkVTUE9OREVOQ0UgMS4xLnBkZg==" target="_blank" style="word-wrap:break-word;">985-KOLNP-2003-CORRESPONDENCE 1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtY29ycmVzcG9uZGVuY2UucGRm" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtY29ycmVzcG9uZGVuY2UxLjIucGRm" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-correspondence1.2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZXhhbWluYXRpb24gcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZXhhbWluYXRpb24gcmVwb3J0MS4xLnBkZg==" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-examination report1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZm9ybSAxLnBkZg==" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZm9ybSAxOC4xLnBkZg==" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-form 18.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZm9ybSAxOC5wZGY=" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZm9ybSAzLjEucGRm" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-form 3.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZm9ybSAzLnBkZg==" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZm9ybSA1LjEucGRm" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-form 5.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZm9ybSA1LnBkZg==" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZ3BhLnBkZg==" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZ3BhMS4xLnBkZg==" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-gpa1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZ3JhbnRlZC1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-granted-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZ3JhbnRlZC1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-granted-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZ3JhbnRlZC1kZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-granted-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZ3JhbnRlZC1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-granted-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZ3JhbnRlZC1mb3JtIDEucGRm" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-granted-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZ3JhbnRlZC1mb3JtIDIucGRm" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-granted-form 2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtZ3JhbnRlZC1zcGVjaWZpY2F0aW9uLnBkZg==" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-granted-specification.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtcmVwbHkgdG8gZXhhbWluYXRpb24gcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-reply to examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtcmVwbHkgdG8gZXhhbWluYXRpb24gcmVwb3J0MS4xLnBkZg==" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-reply to examination report1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTg1LWtvbG5wLTIwMDMtc3BlY2lmaWNhdGlvbi5wZGY=" target="_blank" style="word-wrap:break-word;">985-kolnp-2003-specification.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="256320-chair-comprising-a-seat-frame-with-tilt-lock-mechanism.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="256322-a-crth2-antagonist-or-prodrug-thereof.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>256321</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>985/KOLNP/2003</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>23/2013</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>07-Jun-2013</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>31-May-2013</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>31-Jul-2003</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>EXPWAY</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>16, RUE VAUTHIER LE NOIR, F-51100 REIMS</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>SEYRAT CLAUDE</td>
											<td>12, RUE ROLLIN, F-75005 PARIS</td>
										</tr>
										<tr>
											<td>2</td>
											<td>THIENOT CEDRIC</td>
											<td>115, RUE OBERKAMPF F-75011, PARIS</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H03M 7/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/FR2002/00394</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2002-02-01</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>01/01447</td>
									<td>2001-02-02</td>
								    <td>France</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/256321-method-for-compressing-decompressing-a-structured-document by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:40:57 GMT -->
</html>
