<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/202402-a-method-for-controlling-firing-nozzle-within-overlapped-print-head-segments by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 00:01:55 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 202402:A METHOD FOR CONTROLLING FIRING NOZZLE WITHIN OVERLAPPED PRINT HEAD SEGMENTS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD FOR CONTROLLING FIRING NOZZLE WITHIN OVERLAPPED PRINT HEAD SEGMENTS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method and apparatus is provided for compensating for variable overlap between segments of a page width print head system reduce visualIy perceptible artifacts due to misalignment of adjacent overlapped segments. One method employs a summation means which sums a current dither value from a dither matrix with an overlap signal to provide an output value which is then compared in a comparator with an input continuous tone data value providing an output compensated dither value to control nozzles in the overlap region of the segments. Another method uses a software program to provide the compensated dither matrix. A sensing means provides a measure of the degree of overlap of the segments to generate the overlap signal. The sensing means may sense temperature or relative displacement of the segments. The degree of overlap may be determined for various temperatures and stored in a ROM.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>•METHOD AND APPARATUS FOR COMPENSATION FOR TIME VARYING NOZZLE MISALIGNMENT IN A DROP ON DEMAND PRINTHEAD"<br>
FIELD OF THE INVENTION<br>
The present invention relates to the field of Inkjet printing and in particular discloses a method and apparatus for the compensation for the time varying nozzle misalignment of a print head assembly having overlapping segments.<br>
CO-PENDING APPLICATIONS Various methods, systems and apparatus relating to the present invention are disclosed in the following co-pending applications filed by the applicant or assignee of the present invention simultaneously with the present application:<br><br>
BACKGROUND OF THE INVENTION<br>
In the applicant"s co-pending application PCT/AU98/00550, a series of Inkjet printing arrangements were proposed for printing at high speeds across a page width employing novel ink ejection mechanisms. The disclosed crrangements utilized a thermal bend actuator built as part of a monolithic structure.<br>
In such arrangements, it is desirable to form larger arrays of ink ejection nozzles so as to provide for a page width drop on demand print head. Desirably, a very high resolution of droplet size is required. For example, common competitive printing systems such as offset printing allow for resolutions of one thousand six hundred dots per inch 1600dpi). Hence, by way of example, for an A4 page print head which is eight inches wide, to print at that resolution vould require the equivalent of around 12800 ink ejection nozzles for each colour. Assuming a standard four colour process, this equates to approximately fifty one thousand ink ejection nozzles. For a six colour process including the tandard four colours plus a fixative and an IR ink this results in 76800 ink ejection nozzles. Unfortunately, it is mpractical to make large monolithic print heads from a contiguous segment of substrate such as a silicon wafer substrate.<br><br>
Ambient conditions and the operational environment of a print head may result in thermal cycling of the print head in the overlap region resulting in expansion and contraction of the overlap between adjacent print head segments which may in turn lead to the production of artifacts in the resultant output image. For example, the temperature of the print head may rise 25°C above ambient when in operation. The assembly of the print head may also be made of materials having different thermal characteristics to the print head segments resulting in a differential thermal expansion between these components. The silicon substrate may be packaged in elastomer for which the respective thermal expansion coefficients are 26 X 10"* and 20 x 10" per degree Celsius.<br>
Artifacts are produced due to the limited resolution of the print head to represent a continuous tone image in a binary form and the ability of the human eye to detect 0.5% differences in colour of adjacent dots in an image.<br>
SUMMARY OF THE INVENTION<br>
In accordance with a first aspect of the invention there is provided in an ink ejection print head It is an object of the present invention to provide for a mechanism for compensating for relative displacement of overlapping print head segments during operation in an effective and convenient manner.comprising a plurality of overlapping print head segments, wherein the spatial relationship between adjacent segment is variable with time, a method for controlling the firing of nozzles within the overlapped segments comprising the steps of : (a) determining a measure of the overlap between adjacent print head segments ; (b) creating a half toning pattern for the nozzles in the region of overlap of the overlapping segments; and (c) adjusting said half toning pattern as a function of said measure in the overlapping regions of said print head segments to reduce artifacts produced by the overlapping of said print head segments.<br>
Preferably, the step for determining a measure of overlap employs a measure of temperature of the print head segments. The half toning patterns are preferably produced by means of a dither matrix volume and the alteration can comprise adding an overlap value to a current continuous tone pixel output value before utilizing the dither matrix or dither volume. In place of a measure of temperature a measure of distance can be provided by the use of fiduciary strips on each of the segments and using an interferometric technique to determine the degree of relative movement between the segments.<br>
In accordance with the further aspect of the present invention, there is provided an link ejection print head system comprising : a plurality of spaced apart sparially overlapping print head segments; at east one means for measurement of the degree of overlap between adjacent print head segments; means for providing a half toning of a continuous tone image and means for adjusting said half toning means in a region of overlap between adjacent print head segments to reduce artifacts between said adjacent segments.<br>
The means for adjusting the half toning means can include a continuous tone input, a spatial overlap input and a binary input, the half toning means utilizing the spatial overlap input to vary the continuous tone input to produce a varied continuous tone input for utilization in a look up table of a dither matrix or dither volume so as to produce output biuary.<br><br>
values to adjust for the regions of overlap of print head segments. The means for adjusting the halftone or dither matrix may be implemented in hardware or by means of software employing an algorithm.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
This invention is pointed out with particularity in the appended claims. The above and further advantages of this invention may be better understood by referring to the following description taken in conjunction with the accompanying drawings, in which:<br>
Fig. 1 shows a schematic of a pair of adjacent print head segments according to the invention;<br>
Fig. 2 illustrates the process for printing dots from adjacent print head segments as shown in Fig. 1:<br>
Fig. 3 illustrates a process of blending dots between adjacent print head segments according to the invention;<br>
Fig. 4 illustrates a process of dither matrix variational control according to an embodiment of the invention;<br>
Fig. 5 illustrates a process of dither matrix variational control according to another embodiment of the invention; and<br>
Fig. 6 illustrates graphically an algorithm implementing a further process of dither matrix variational control according to a further embodiment of the invention.<br>
DETAILED DESCRIPTION OF THE EMBODIMENTS<br>
In a first embodiment, a method of compensation for the temperature varying relative displacement of adjacent print head segments is provided by the utilization of a digital processing mechanism which adjusts for the overlap between adjacent segments.<br>
In a print head covering an A4 page width there may be 10 segments having 9 overlapping portions arranged in a repeating sequence of staggered pairs. Initial alignment of segments can be made within 10 microns using techniques well known in the art of monolithic fabrication techniques. The width of a segment for a 6 colour ink arrangement would be approximately 225 microns assuming the nozzles of a segment are arranged on 16 micron centres in a zig-zag pattern longitudinally.<br>
In this embodiment, a temperature sensor is placed on each print head segment so as to provide for a measure of the current temperature characteristics of each print head segment. The current temperature measurement can then be utilized to determine the amount of overlap between adjacent print head segments.<br>
Alternatively, only a single temperature sensor can be used if it can be assumed that the segments of the print head are sufficiently similar to one another in physical characteristics and performance and that the ambient milieu of each pair of overlapped segment is substantially the same.<br>
The degree of overlap is then used to provide a mechanism for controlling the halftoning between adjacent print head segments. It is assumed that outputting of an image in the instant invention is by means of digital halftoning employing any method or technique well known in the art. Many different halftoning techniques can be utilized and reference is made to the text by Ulichney entitled "Digital Half Toning" published by MIT Press.<br>
As shown in Fig. 1 adjacent print head segments 2, 3 overlap in the respective regions 12, 13. The overlap region may extend approximately 40 thou (~lmm.) providing an overlap of 64 nozzles spaced at 16 microns for 1600dpi resolution. In the region 10 of the segment 2 the nozzles of this segment are used exclusively for the ejection of ink. Similarly in the region 11 of the segment 3 the nozzles of this segment are used exclusively for the ejection of ink. In the overlapping regions 12, 13 a "blend" is provided between the two print head segments 2, 3 such that along the edge 14 of the print head segment 2 nozzles are used exclusively in the region 12 to print and similarly along the edge 15, the nozzles of the segment 3 are used almost exclusively for printing. In between, an interpolation, which can be linear or otherwise.<br><br>
is provided between these two extreme positions. Hence, as shown in Fig. 2, when printing a full colour output on a page the area on the side 17 is printed exclusively by the print head segment 10 while the area 18 is printed exclusively by the print head segment 11 (as illustrated by the black dots) with the area 19 comprising a blend between the nozzles of the two segments. The printing process utilizes any well known halftoning matrix such as disclosed in the aforementioned references. While a known halftoning matrix is utilized, the actual print head segment utilized will depend upon the blending ratio provided by the measure of overlap between the overlapping segments.<br>
One such method is illustrated in Fig. 3 where a linear interpolation within the overlapped regions is shown. In the region corresponding to the overlapped section 12 at the edge 14 there is 100% utilization of the nozzles of print head segment 2, whereas in the equivalent region, edge 7, of the print head segment 3 there is zero output. As the distance of the overlap region from the line 14 of the segment 2 is increased towards the line 15 of the segment 3 the proportion of utilization of the nozzles of the section 12 is gradually decreased (linearly), being zero at edge 9 while the utilization of the nozzles of the section 13 is progressively increased to unity by the time the edge 15 is reached. In a first embodiment, where there is an increased overlap between nozzles, the halftoning thresholds utilized are increased in the overlap region. This reduces the number of dots printed in the blend region. Conversely, if there is a reduced overlap with the print head segments being spaced apart slightly more than normally acceptable, the dot frequency can be increased by reducing the halftoning threshold.<br>
An overall general halftoning arrangement can be provided as shown in Fig. 4 with a dither matrix 25 outputting a current dither value 26 to a summation means 27 with summation means 27 having another input 28, an overlap signal, which varies in either a positive or a negative sense depending on the degree of overlap between the adjacent segments. The output value 29 of summation means or adder 27 is compared to the input continuous tone data 32 via a comparator 30 so as to output halftone data 31. An alternative arrangement allows that the data value 28 can be subtracted from the continuous tone data 29 before dithering is applied producing similar results. This arrangement is shown in Fig. 5.<br>
As shown in Fig. 5, a halftone data output 52 can be generated by combining the output 42 of dither matrix 40 in an adder 46 with the overlap signal 44, and then taking the difference of the output 54 of adder 46 and the continuous tone data 48 in subtracter 50. This is an equivalent arrangement to that of Fig. 4.<br>
Through the utilization of an arrangement such as described above with respect to Figs. 3 and 4, a degree of control of the overlap blending can be provided so as to reduce the production of streak artifacts between adjacent print head segments.<br>
As each overlap signal 28 can be multiplied by a calibration factor and added to a calibration offset factor, the degree of accuracy of placement of adjacent print head segments can also be dramatically reduced. Hence, adjacent print head segments can be roughly aligned during manufacture with one another. Test patterns can then be printed out at known temperatures to determine the degree of overlap between nozzles of adjacent segments. Once a degree of overlap has been determined for a particular temperature range a series of corresponding values can be written to a programmable ROM storage device so as to provide full offset values on demand which are individually factored to the print head segment overlap,<br>
A further embodiment of the invention involves the use of a software solution for reducing the production of artifacts between overlapped segments of the print heads. A full software implementation of a dither matrix including the implementation of an algorithm for adjusting variable overlap between print head segments is attached as appendix A. The program is written in the programming language C. The algorithm may be written in some other code mutatis mutandis within the knowledge of a person skilled in the art. The basis of the algorithm is explained as follows.<br>
A dispersed dot stochastic dithering is used to reproduce the continuous tone pixel values using bi-level dots. Dispersed dot dithering reproduces high spatial frequency, that is, image detail, almost to the limits of the dot resolution.<br><br>
while simultaneously reproducing lower spatial frequencies to their full intensity depth when spatially integrated by the eye. A stochastic dither matrix is designed to be free of objectionable low frequency patterns when tiled across the page.<br>
Dot overlap can be modelled using dot gain techniques. Dot gain refers to any increase from the ideal intensity of a pattern of dots to the actual intensity produced when the pattern is printed. In Ink jet printing, dot gain is caused mainly by ink bleed. Bleed is itself a function of the characteristics of the ink and the printing medium. Pigmented inks can bleed on the surface but do not diffuse far inside the medium. Dye based inks can diffuse along cellulose fibres inside the medium. Surface coatings can be used to reduce bleed.<br>
Because the effect of dot overlap is sensitive to the distribution of the dots in the same way that dot gain is, it is useful to model the ideal dot as perfectly tiling the page with no overlap. While an actual Inkjet dot is approximately round and overlaps its neighbours, the ideal dot can be modelled by a square. The ideal and actual dot shapes thus become dot gain parameters.<br>
Dot gain is an edge effect, that is it is an effect which manifests itself along edges between printed dots and adjacent unprinted areas. Dot gain is proportional to the ratio between the edge links of a dot pattern and the area of the dot pattern. Two techniques for dealing with dot gain are dispersed dot dithering and clustered dot dithering. In dispersed dot dithering the dot is distributed uniformly over an area, for example for a dot of 50% intensity a chequer board pattern is used. In clustered dot dithering the dot is represented with a single central "coloured" area and an "uncoloured" border with the ratio of the area of "coloured" to "uncoloured" equalling the intensity of the dot to be printed. Dispersed dot dithering is therefore more sensitive to dot gain than clustered dot dithering.<br>
Two adjacent print head segments have a number of overlapping nozzles. In general, there will not be perfect registration between corresponding nozzles in adjacent segments. At a local level there can be a misregistration of plus or minus half the nozzle spacing, that is plus or minus about 8 microns at 1600 dpi. At a higher level, the number of overlapping nozzles can actually vary.<br>
The first approach to smoothly blending the output across the overlap bridge and from one segment to the next consists of blending the continuous tone input to the two segments from one to the other across the overlap region. As output proceeds across the overlap region, the second segment receives an increasing proportion of the input continuous tone value and the first segment receives a correspondingly decreasing proportion as described above with respect to Fig. 3. A linear or higher order interpolation can be used. The dither matrices used to dither the output through the two segments are then registered at the nozzle level.<br>
The first approach has two drawbacks. Firstly, if the dither threshold at a particular dot location is lower than both segments" interpolated continuous tone values then both segments will produce a dot for that location. Since the two dots will overlap, the intensities promised by the two dither matrices will be only partially reproduced, leading to a loss of overall intensity. This can be remedied by ensuring that corresponding nozzles never both produce a dot. This can also be achieved by using the inverse of the dither matrix for alternating segments, or dithering the continuous tone value through a single dither matrix and then assigning the output dot to one or the other nozzle stochastically, according to a probability given by the current interpolation factor.<br>
Secondly, adjacent dots printed by different segments will overlap again leading to a loss of overall intensity.<br>
As shown in Fig. 6, the value for each overlapped segment is plotted along the horizontal axes 60, 62 as VA and VB respectively between the values of 0.0 and 1.0. The calculated output 66 is plotted with respect to the vertical axis 64 as a function, U+B, for values ranging from 0.0 to 1.0. A contour plane 68 shows the resultant values for 1A+B=0.5.<br>
Fig. 6 shows the qualitative shape of the three dimensional function linking the two segments" input continuous tone values V and VB to the observed output intensity U+B. For the first approach, an input continuous tone value V and an interpolation factor f together yield Vpr (1-f) V and Vg = f V. The closer the interpolation factor is to 0.5 the greater the difference between the input continuous tone value and the observed output intensity. For V=1.0, this is illustrated in Fig. 6 by the curve 200 on the vertical VA+VB= 1.0 plane. By definition this curve lies on the function surface. Fig. 6<br><br>
inaicates mat wtien any kind ot mixing occurs, that is 0.0 V. This forms the basis for the algorithm in appendix A.<br>
The function shows a linear response when only one segment contributes to the output, that is f=0.0 or f=l .0. This assumes of course that the dither matrix includes the effects of dot gain.<br>
The foregoing description has been limited to specific embodiments of this invention . It will be apparent, however, that variations and modifications may be made to the invention, with the attainment of some or all of the advantages of the invention, For example, it will be appreciated that the invention may be embodied in either hardware or software in a suitably programmed digital data processing system, both of which are readily accomplished by those of ordinary skill in the respective arts. Therefore, it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.<br>
static void<br>
ObtainMisregiStrationTransferFunction<br><br>
(<br><br>
int dotsPerPixel, int subdotsPerDot, BI_Image const&amp; dotlmage, char const* pDotlmageName, char const* pRefDotlmageName, int const overlapSize, int const overlaplndex, int const misregFactor, BI_Image const&amp; ditherMatrix, BI_LUT&amp; lutv, BI_LUT&amp; lutO, BI LUT&amp; lutl<br><br>
// 0<br><br>
overlapSize-1<br><br>
);<br>
class RLE DotLine<br>
{<br><br>
public:<br><br>
int int<br><br>
RLE_DotLine{)<br>
: m_whiteRun(0), m_blackRun(0) {} RLE_DotLine(int whiteRun, int blackRun)<br>
: m_whiteRun(whiteRun) , in_blackRun(blackRun) {} WhiteRun() const { return m_whiteRun; } BlackRun0 const { return m blackRun; }<br><br>
private:<br>
int	m_whiteRun;<br>
int	m_blackRun;<br>
};<br>
typedef vector<rle_dotline allocator> &gt; RLE_Dot;<br><br>
static void Usage () {<br><br>
fprintf(stderr, fprintf(stderr, fprintf(stderr, fprintf(stderr, fprintf(stderr, fprintf(stderr, fprintf(stderr, fprintf(stderr, fprintf(stderr, fprintf(stderr, fprintf(stderr, fprintf(stderr, exit (1) ;<br><br>
usage: SegitientDither<br>") ; inputlmageXn"); dotsPerPixel<br>"); subdotsPerDotXn"); dotlmageXn"); refDotlmageVn"); overlapCenter<br>"); overlapSizeXn"); misregFactor<br>"); ditherMatrix<br>"); outputlmageXn"); outputResolutionXn");<br><br>
static<br>
void<br>
BadArgument(char const* pErrorMsg)<br>
{<br>
fprintf(stderr, "SegmentDither: argument error: %s<br>", pErrorMsg);<br>
exit (1) ;<br>
#define CHECK ARGUMENT(cond) if (cond) BadArgument(#cond)<br>
static double MisregDots(int const misregFactor)<br>
{<br>
return (double)misregFactor / 1000;<br>
static int<br>
MisregSubdots(int const misregFactor, int const subdotsPerDot)<br>
{<br>
return (int)BU_Round(MisregDots(misregFactor) * subdotsPerDot)<br>
}<br>
static<br><br>
void<br>
PutDot (<br><br>
int const subdotsPerDot,<br>
RLE_Dot consts rleDot,<br>
int const dotRow,<br>
int const dotCol,<br>
int const misregFactor,<br>
BI_Image&amp; outputlmage<br>
int const misregSubdots = MisregSubdots(misregFactor, subdotsPerDot) int const subdotRow = dotRow * subdotsPerDot; int const subdotCol = dotCol * subdotsPerDot;<br>
int const dotOverlap = rleDot.size() - subdotsPerDot; int const dotMargin = dotOverlap / 2;<br>
RLE_Dot::const_iterator ii = rleDot.begin(); for (int i = 0; i 
int const row = subdotRow - dotMargin + i;<br>
if (row = outputlmage.Height()) continue;<br>
int const whiteRun = {*ii).WhiteRun(); int blackRun = (*ii) .BlackRun ();<br>
int col = subdotCol - dotMargin + whiteRun + misregSubdots; if (col 
{<br>
blackRun += col; col = 0;<br>
}<br>
if (col + blackRun &gt;= outputlmage.Width())<br>
blackRun = outputlmage.Width() - col; if (blackRun 
continue;<br>
BU_ExpandBitRun<br>
(<br>
outputlmage.Image(row),<br>
col,<br>
outputlmage.Width 0, blackRun,<br><br>
static<br>
void<br>
MergeScale<br>
double const scale, ints V, doubles fO, doubles fl<br>
{<br>
double const vScaled = (double)v * scale; if (vScaled 
(int)BU Round(vScaled)<br><br>
} else<br>
1<br><br>
V = 255;<br>
double const fScale = vScaled / 255.0;<br>
fO *= fScale;<br>
fl *= fScale;<br><br><br><br>
static void Dither (<br><br>
BI_Image consts inputlmage, BI_LUT consts lutDotGain, int const dotsPerPixel, int const subdotsPerDot, BI_Image consts dotlmage, char const* pDotlmageName, char const* pRefDotlmageName, int const overlapCenter, int const overlapSize, int const misregFactor, BI_Image consts ditherMatrix, BI Images outputlmage,<br><br>
int const outputResolution,<br>
bool const bRetain,<br>
bool const bSkipLHS,<br>
bool const bSkipRHS,<br>
bool const bFixedlnterp = false,<br>
double const fixedFO = 0,<br>
double const fixedFl = 0<br>
// compute overlap interval<br>
int const overlapStart = overiapCenter - (overlapSize / 2);<br>
int const overlapEnd = overlapStart + overlapSize - 1;<br>
// copy and invert dither matrix BI_Image ditherMatrix2; ditherMatrix2 = ditherMatrix; BI_Invert(ditherMatrix2) ;<br>
// initialise and clear output image<br>
int const subdotsPerPixel = dotsPerPixel * subdotsPerDot;<br>
int const bilevelHeight = inputlmage.Height() * subdotsPerPixel;<br>
int const bilevelWidth = inputlmage.Width() * subdotsPerPixel;<br>
if (IbRetain)<br>
{<br>
// initialise<br>
outputlmage.Initialise<br>
(<br>
BI_ColorModel(BI_ColorGrayscale, 1),<br>
bilevelHeight, bilevelWidth, outputResolution, outputResolution<br>
// clear<br>
BI CC*  pOutputRow = outputlmage.Image 0;<br>
for (int j = 0; j 
(<br>
BU_ClearLine(pOutputRow, outputlmage.Width()); pOutputRow += outputlmage.RowSize0;<br>
// convert dot image to RLE RLE Dot rleDot;<br><br>
for (int i = 0; i 
int const whiteRun = BU_GetBitRun (<br>
dotImage.Image(i), 0,<br>
dotlmage.Width 0, 0 // white );<br>
int blackRun;<br>
if (whiteRun == dotlmage.Width()) {<br>
blackRun = 0; }<br>
else {<br>
blackRun = BUGetBitRun (<br>
dotlmage.Image(i), whiteRun, dotImage.Width(), 1 // black ); ) rleDot.push_back(RLE_DotLine(whiteRun, blackRun))<br>
// dither contone input image to bi-level output image<br>
BI_CC const* pimage = inputImage.Image();<br>
BI_CC const* pRow = pimage;<br>
BI_CC const* pDither = ditherMatrix.Image();<br>
BI_CC const* pDitherRow = pDither;<br>
BI_CC const* pDither2 = ditherMatrix2.Image();<br>
BI_CC const* pDitherRow2 = pDither2;<br>
int ditherRow = 0;<br>
for (int row = 0; row 
{<br>
for (int dotRow = 0; dotRow 
{<br>
int const globalDotRow = (row * dotsPerPixel) + dotRow;<br>
BI_CC const* pPixel = pRow;<br>
BI_CC const* pDitherPixel = pDitherRow;<br>
BI_CC const* pDitherPixel2 = pDitherRow2;<br>
int ditherCol = 0;<br>
for (int col = 0; col 
 <br>
int const vRaw = *pPixel++;<br>
int const vDotGain = lutDotGain[vRaw];<br>
for (int dotCol = 0; dotCol 
{<br>
int vRawDot = vRaw;<br>
int const tO = *pDitherPixel;<br>
int const tl = tO; //*pDitherPixel2;<br>
int const globalDotCol = (col * dotsPerPixel) +<br>
dotCol;<br><br>
dither<br><br>
// interpolate intensities in overlap region and<br>
// one or the other or both<br>
if (IbFixedlnterp &amp;s globalDotCol 
 <br><br><br>
overlapStart)<br>
&amp;&amp; vDotGain != 0)<br>
tl;<br>
&amp;&amp; vDotGain != 0))<br><br>
int const t = tO;<br>
if ( (VDotGain == 255) I I (vDotGain &gt;= t<br>
if (IbSkipLHS) {<br>
PutDot<br>
subdotsPerDot,<br>
rleDot,<br>
globalDotRow,<br>
globalDotCol,<br>
0,<br>
outputlmage<br>
);<br>
else<br>
if (IbFixedlnterp S&amp; overlapEnd 
{<br>
int const t = (overlapSize == 0) ? tO :<br>
if ((vDotGain == 255) II (vDotGain &gt;= t<br>
if (IbSkipRHS)<br><br>
PutDot (<br><br>
subdotsPerDot,<br>
rleDot,<br>
globalDotRow,<br>
globalDotCol,<br>
misregFactor,<br>
outputlmage<br><br>
) ;<br>
else {<br>
#if 1<br><br>
MisregDots(misregFactor); overlapSize + misregDots; newOverlapSize / overlapSize;<br>
overlapScale) ;<br><br>
// account for stretch or shrink<br>
if (IbFixedlnterp)<br>
{<br>
double const misregDots =<br>
double const newOverlapSize =<br>
double const overlapScale =<br>
vRawDot = (int)BU_Round(vRawDot *<br>
if (vRawDot &gt; 255)<br>
vRawDot = 255; //MergeScale(overlapScale, vRawDot,<br><br>
fO, fl);<br>
#endif<br><br>
tif 1<br><br>
// compute interpolation factors double fO, fl; if (bFixedlnterp)<br>
{<br>
fO = fixedFO;<br>
fl = fixedFl; }<br>
else (<br><br>
// compute overlap index int const overlaplndex =<br>
globalDotCol - overlapStart;<br>
// obtain misregistration LUTs BI_LUT lutv; BI_LUT lutO; BI LUT lutl<br>
ObtainMisregistrationTransferFunction<br>
dotsPerPixel,<br>
subdotsPerDot,<br>
dotlmage,<br>
pDotImageName,<br>
pRefDotlmageName,<br>
overlapSize,<br>
overlaplndex,<br>
misregFactor,<br>
ditherMatrix,<br>
lutv,<br>
lutO,<br>
lutl<br>
);<br>
// retrieve interpolation factors fO = (double)lutO[vRawDot] / 255; fl = (double)lutl[vRawDot] / 255; if (globalDotCol &gt; overlapCenter) BU_Swap(fO, fl);<br>
// adjust intensity for attenuation vRawDot = lutv[vRawDot];<br>
endif<br><br>
"Raw=%d v=%d<br>",<br><br>
// diagnostics<br>
//printf("f0=%5.11f fl=%5.11f (%5.11f)<br>
//    fO, fl, fO + fl, vRaw, vRawDot);<br>
// interpolate dither witli jitter<br>
int vd = 0; int vOd = 0; int vld = 0;<br><br>
if {(vRawDot == 255) || (vRawDot &gt;= tO &amp;S<br>
vRawDot != 0)<br>
vd = 1;<br>
double const rr = (double)rand() /<br>
RAND MAX;<br>
if (vd &amp;S rr 
 <br>
1<br><br>
vOd = 1;<br>
if   (IbSltipLHS)<br>
i<br>
PutDot<br><br>
subdotsPerDot,<br>
rleDot,<br>
globalDotRow,<br>
globalDotCol,<br>
0,<br>
outputlmage<br>
if (vd &amp;&amp; (1.0 - rr) 
{<br>
vld = 1;<br>
if (!bSl<iprhs></iprhs>
{<br>
PutDot<br>
subdotsPerDot,<br>
rleDot,<br>
globalDotRow,<br>
globalDotCol,<br>
misregFactor,<br>
outputlmage<br>
);<br><br>
#if 0<br><br>
if (globalDotRow == 864) (<br><br>
%3d) ",<br>
vl, vO + vl);<br><br>
printf("%ld %ld %ld (%3d %3d %3d vd, vOd, vld, vRawDot, vO,<br>
if (vOd + vld 
printf("?"); if (vOd + vld &gt; vd)<br>
printf("#"); printf("<br>");<br><br>
#endif<br>
pDitherPixel++;<br>
pDitherPixel2++;<br>
ditherCol++;<br>
if (ditherCol &gt;= ditherMatrix.Width{))<br>
{<br>
pDitherPixel = pDitherRow;<br>
pDitherPixel2 = pDitherRow2;<br>
ditherCol = 0;<br>
pDitherRow += ditherMatrix.RowSize() ; pDitherRow2 += ditherMatrix2.RowSize (); ditherRow++;<br>
if (ditherRow &gt;= ditherMatrix.Height()) {<br>
pDitherRow = pDither;<br>
pDitherRow2 = pDither2;<br>
ditherRow = 0;<br>
pRow += inputlmage.RowSize{)<br>
static<br>
void<br>
ChangeFileSuffix<br>
(<br>
char	const* pPath,<br>
char	const* pSuffix,<br>
char	const* pExt,<br><br>
char path[_MAX__PATH] ) {<br>
char drive[_MAX_DRIVE];<br>
char dir[_MAX_DIR];<br>
char fname[_MAX_FNAME];<br>
char ext[_MAX_EXT];<br>
_splitpath(pPath, drive, dir, fname, ext)<br>
strcat(fname, pSuffix);<br>
_makepath(path, drive, dir, fname, pExt);<br>
static<br>
void<br>
LogTransferFunction(char const* pType, double const intensity[], int const v)<br>
{<br>
printf("%s: %03d : %5.11f (%5.11f)<br>",<br>
pType, V, intensity[v], v - intensity[v]); }<br>
static void<br>
ComputeMisregistrationTransferFunction (<br>
int dotsPerPixel,<br>
int subdotsPerDot,<br>
BI_Image consts dotlmage,<br>
char const* pDotlmageName,<br>
double const fO,<br>
double const fl,<br>
int const misregFactor,<br>
BI_Image consts ditherMatrix,<br>
BI_LUT&amp; lutv,<br>
BI_LUT&amp; lutO,<br>
BI LUT&amp; lutl<br>
// create test image BI_Image testlmage; testImage.Initialise (<br>
BI_ColorModel(BI_ColorGrayscale),<br>
ditherMatrix.Height (),<br>
ditherMatrix.WidthO<br><br>
// build identity transfer function BI_LUT identityLut; for (int V = 0; v 
// create output image BI_Image outputlmage;<br>
// compute intensity for each gray level<br>
double intensity[512];<br>
int vLast;<br>
for (V = 0; V 
{<br>
// compute extended interpolation factors<br>
double fOx, fix;<br>
int vx;<br>
if {V 
<br>
	VX  =  V;<br>
	fOx  =  fO;<br>
\	fix  =  fl;<br>
else	<br>
{	<br>
VX = 255;<br>
double const fScale = {double)v / 255.0;<br>
fOx = fO * fScale;<br>
fix = fl * fScale;<br>
// set test image to next intensity testlmage = BI_Color((BI_CC)vx);<br>
// dither test image to bi-level output Dither<br>
(<br>
testlmage,<br>
identityLut,<br>
dotsPerPixel,<br>
subdotsPerDot,<br>
dotImage,<br>
pDotlmageName,<br>
pDotImageName,<br>
0, 0,	// no explicit overlap<br><br>
misregFactor,<br>
ditherMatrix,<br>
outputlmage,<br>
72,<br>
false,<br>
false,<br>
false,<br>
true,<br>
fOx,<br>
fix<br><br>
// output resolution // don"t retain output image // don"t skip LHS // don"t skip RHS // fixed interpolation<br><br>
) ;<br>
// determine intensity of dithered bi-level output<br>
long nDots = 0;<br>
BI_CC const* pRow = outputlmage.Image();<br>
for (int row = 0; row 
{<br>
nDots += BU_CountBits(pRow, 0, outputlmage.Width ());<br>
pRow += outputlmage.RowSize0; }<br>
intensity[v] = 255 * (double)nDots / outputlmage.PixelCount (); //LogTransferFunction("misreg", intensity, v);<br>
vLast = v;<br>
if (intensity[v] &gt;= 255) break;<br>
}<br>
LogTransferFunction("misreg", intensity, 1);<br>
LogTransferFunction("misreg", intensity, vLast) ;<br>
// create LUTs<br>
for (int X = 0; X 
{<br>
double d = -1;<br>
for (v = 0; V 
{<br>
double const d2 = BU_Abs(intensity[v] - x)<br>
if (d 
d = d2;<br>
if (V 
{<br>
lutv[x] = v;<br>
int const kO = (int)BU_Round(f0 * 255);<br>
lut0[xj   =   (BI   CC)BU  Min(kO,   255);<br><br>
int   const   kl   =   (int)BU_Round(f1   *   255); lutl[x]   =   (BI   COBU Min(kl,   255);<br>
}<br>
else<br>
{<br><br>
f0=%5.11f   fl=%5.11f<br>",<br><br>
lutv[x]   =   255;<br>
int   const   kO   =   (int)BO_Round(f0   *   v);<br>
lutO[x]   =   (BI_CC)BU__Min(kO,   255);<br>
int const kl = (int)BU_Round(f1 * v);<br>
lutl[x] = (BI_CC)BU_Min(kl, 255);<br>
if (kO &gt; 255 II kl &gt; 255)<br>
{<br>
fprintf(stderr, "kO=%d kl=%d (x=%d v=%d<br>
kO, kl, X, V, fO, fl);<br><br>
static<br>
void<br>
SimplifyFraction(int&amp; n, int&amp; d)<br>
{<br>
for (int i = n; i &gt; 1 &amp;&amp; n &gt; 1; —i)<br>
{<br>
if ((d % i) == 0) {<br>
if ((n % i) == 0) {<br>
n /= i; d /= i; }<br>
static void<br>
ObtainMisregistrationTransferFunction<br>
(<br>
int dotsPerPixel, int subdotsPerDot,<br><br>
Bi_image consts dotlmage, char const* pDotlmageName, char const* pRefDotlmageName, int const overlapSize, int const rawOverlapIndex, int const misregFactor, BI_Image consts ditherMatrix, BI_LUT&amp; lutv, BI_LUTS lutO, BI LUT&amp; lutl<br><br>
// 0<br><br>
overlapSize-1<br><br>
// normalize overlap index<br>
int overlaplndex = rawOverlapIndex;<br>
if (overlaplndex &gt;= ((overlapSize + 1) / 2) )<br>
overlaplndex = (overlapSize - 1) - overlaplndex;<br>
char lutvName[_MAX_PATH] char lutOName[_MAX_PATH] char lutlName[_MAX_PATH] char suffix! MAX FNAME];<br>
int interpNum = overlaplndex + 1; int interpDenom = overlapSize + 1; SimplifyFraction(interpNum, interpDenom);<br>
sprintf(suffix, "_%03d_%02d_%02d",<br>
BU_Abs(misregFactor), interpNum, interpDenom); ChangeFileSuffix(pRefDotlmageName, suffix, ".amp", lutvName);<br>
sprintf(suffix, "_%03d_%02d_%02d_0",<br>
BU_Abs(misregFactor), interpNum, interpDenom); ChangeFileSuffix(pRefDotlmageName, suffix, ".amp", lutOName);<br>
sprintf(suffix, "_%03d_%02d_%02d_l",<br>
BU_Abs(misregFactor), interpNum, interpDenom); ChangeFileSuffix(pRefDotlmageName, suffix, ".amp", lutlName);<br>
try<br>
BU_File lutvFile(lutvName, _0_BINARY | _0_RDONLY);<br>
lutv.Load(lutvFile);<br>
BU_File lutOFile(lutOName, _0_BINARY | _0_RDONLY);<br>
lutO.Load(lutOFile);<br>
BU File lutlFile(lutlName,  0 BINARY |  0 RDONLY);<br><br>
lutl.Load(lutlFile);<br>
}<br>
catch (...)<br>
{<br>
//if using a reference dot image, LUTs must already exist<br>
if (strcmp(pDotImageName, pRefDotlmageName) != 0)<br>
{<br>
fprintf(stderr, "can"t load %s or %s or %s<br>", lutvName, lutOName, lutlName);<br>
exit (1) ; }<br>
// determine interpolation factors<br>
double fl = (double)interpNum / interpDenom;<br>
double fO = 1.0 - fl;<br>
ComputeMisregistratlonTransferFunction (<br>
dotsPerPixel,<br>
subdotsPerDot,<br>
dotImage,<br>
pDotImageName,<br>
. fo,<br>
fl,<br>
BU_Abs(misregFactor),<br>
ditherMatrix,<br>
lutv,<br>
lutO,<br>
lutl ) ;<br>
BU_File lutvFile(lutvName, _0_BINARY I _0_WRONLY I _0_CREAT); lutv.Save(lutvFile) ;<br>
BU_File lutOFile(lutOName, _0_BINARy i _0_WRONLY | _0_CREAT); lutO.Save(lutOFile);<br>
BU_File lutlFile(lutlName, _0_BINARY I _0_WRONLY I _0_CREAT); lutl.Save(lutlFile);<br>
static<br>
void<br>
ComputeDotGainTransferFunction<br>
(<br>
int dotsPerPixel, int subdotsPerDot,<br><br>
BI_Image consts dotlmage, char const* pDotlmageName, BI_Image consts ditherMatrix, BI LUTS lutDotGain<br>
// create test image BI_Image testImage,■ testImage.Initialise (<br>
BI_ColorModel(BI_ColorGrayscale) ,<br>
ditherMatrix.Height() ,<br>
ditherMatrix.Width()<br>
);<br>
// build identity transfer function BI_LUT identityTransferFunction,■ for (int V = 0; V 
identityTransferFunction[v] = v;<br>
// create output image BI_Image outputImage;<br>
// compute intensity for each gray level double intensity[256]; for (V = 0; V 
{<br>
// set test image to next intensity testlmage = BI_Color((BI_CC)v);<br>
// dither test image to bi-level output<br>
Dither<br>
{<br>
testlmage,<br>
identityTransferFunction,<br>
dotsPerPixel,<br>
subdotsPerDot,<br>
dotlmage,<br>
pDotImageName,<br>
pDotImageName,<br>
0, 0,	// no overlap<br>
0,	// no misregistration<br>
ditherMatrix,<br>
outputlmage,<br>
72	// output resolution<br><br>
false,	//	don"t	retain output image<br>
false,	//	don"t	skip LHS<br>
false	//	don"t	skip RHS<br>
) ;<br>
// determine intensity of dithered bi-level output<br>
long nDots = 0;<br>
BI_CC const* pRow = outputlmage.Image();<br>
for (int row = 0; row 
{<br>
nDots += BU_CountBits(pRow, 0, outputlmage.Width()); pRow += outputlmage.Rowsize();<br>
)<br>
intensity[v] = 255 * (double)nDots / outputlmage.PixelCount ();<br>
//LogTransferFunction("dot gain", intensity, v); }<br>
LogTransferFunction("dot gain", intensity, 1); LogTransferFunctionC"dot gain", intensity, 255);<br>
// create LUT<br>
for (int X = 0; x 
{<br>
double d = -1;<br>
for (V = 0; V 
{<br>
double const d2 = BU_Abs(intensity[v] - x);<br>
if (d 
{<br>
d = d2;<br>
lutDotGain[x] = v; }<br>
atic id<br>
:ainDotGainTransferFunction<br>
int dotsPerPixel, int subdotsPerDot, BI_Image consts dotlmage, char const* pDotlmageName, char const* pRefDotlmageName, BI Image consts, ditherMatrix,<br><br>
BI LUT&amp; lutDotGain<br>
char lutName[_MAX_PATH];<br>
ChangeFileSuffix(pRefDotImageName, "", ".amp", lutName); try<br>
(<br>
BU_File lutFile(lutName, _0_BINARY I _0_RDONLY); lutDotGain.Load(lutFile); }<br>
catch (...) {<br>
// if using a reference dot image, LUT must already exist<br>
if (strcmp(pDotlmageName, pRefDotlmageName) != 0)<br>
{<br>
fprintf(stderr, "can"t load %s<br>", lutName);<br>
exit (1); }<br>
ComputeDotGainTransferFunction (<br>
dotsPerPixel,<br>
subdotsPerDot,<br>
dotlmage,<br>
pDotlmageName,<br>
ditherMatrix,<br>
lutDotGain<br>
) ;<br>
BU_File lutFile(lutName, _0_BINARY I _0_WRONLY | _0_CREAT);<br>
lutDotGain.Save(lutFile);<br>
static void<br>
SegmentDither(int argc, char* argv[])<br>
I<br>
// parse arguments if (argc != 12) Usage(); char const* pInputlmageName = argv[l]; int const dotsPerPixel = atoi(argv[2]); int const subdotsPerDot = atoi (argv [3]); char const* pDotlmageName = argv[4]; char const* pRefDotlmageName = argv[5]; int const overlapCenter = atoi(argv[6]);<br><br>
int const overlapSize = atoi{argv[7]);<br>
int const misregFactor = atoi(argv[8]);<br>
int const misregSubdots = MisregSubdots(misregFactor, subdotsPerDot);<br>
char const* pDitherMatrixName = argv[9];<br>
char const* pOutputlmageName = argv[10];<br>
int const outputResolution = atoi(argv[11]);<br>
// open input image BI_Image inputlmage;<br>
BI_LoadImage(inputlmage, pInputlmageName); CHECK_ARGUMENT(inputlmage.ColorModel() != BI_ColorModel(BI_ColorGrayscale));<br>
BI_Invert (inputlmage) ; // max is blacl
// check arguments<br>
CHECK_ARGUMENT(dotsPerPixel 
CHECK_ARGUMENT(dotsPerPixel &gt; 16);<br>
CHECK_ARGUMENT(subdotsPerDot 
CHECK_ARGUMENT(subdotsPerDot &gt; 32);<br>
CHECK_ARGUMENT(overlapCenter 
CHECK_ARGUMENT(overlapCenter &gt;= inputlmage.Width() * dotsPerPixel);<br>
CHECK_ARGUMENT(overlapSize 
CHECK_ARGUMENT(misregSubdots 
CHECK_ARGUMENT(misregSubdots &gt; subdotsPerDot / 2);<br>
CHECK_ARGUMENT(outputResolution 
// diagnostics<br>
printf("misregSubdots=%d<br>", misregSubdots);<br>
// open dot image<br>
BI_Image dotlmage;<br>
BI_LoadImage(dotlmage, pDotlmageName);<br>
D)<br>
CHECK_ARGUMENT(dotlmage.ColorModel() != BI_ColorModel(BI_ColorGrayscale,<br>
CHECK_ARGUMENT(dotlmage.Height() 
// open dither matrix<br>
BI_Image ditherMatrix;<br>
BI Loadlmage(ditherMatrix, pDitherMatrixName);<br><br>
CHECK_ARGUMENT(ditherMatrix.ColorModel () ! = BI_ColorModel(BI_ColorGrayscale, 8)) ;<br>
CHECK_ARGUMENT(ditherMatrix.Height{) 
// create output image BI_Image outputlmage;<br>
// obtain dot gain transfer function for particular dot shape BI_LUT lutDotGain; ObtainDotGainTransferFunction (<br>
dotsPerPixel,<br>
subdotsPerDot,<br>
dotlmage,<br>
pDotlmageName,<br>
pRefDotlmageName,<br>
ditherMatrix,<br>
lutDotGain );<br>
// dither input to bi-level output<br>
Dither<br>
(<br>
inputlmage,<br>
lutDotGain,<br>
dotsPerPixel,<br>
subdotsPerDot,<br>
dotlmage,<br>
pDotlmageName,<br>
pRefDotlmageName,<br>
overlapCenter,<br>
overlapSize,<br>
misregFactor,<br>
ditherMatrix,<br>
outputlmage,<br>
outputResolution,<br>
false,	// don"t retain output image<br>
false,	// don"t skip LHS<br>
false	// don"t skip RHS<br>
);<br>
BI_SaveImage(outputlmage, pOutputlmageName);<br>
// dither input to bi-level output (LHS only) BI Image outputlmageLHS;<br><br>
Dither (<br>
inputImage,<br>
lutDotGain,<br>
dotsPerPixel,<br>
subdotsPerDot,<br>
dotlmage,<br>
pDotImageN ame,<br>
pRefDotImageName,<br>
overlapCenter,<br>
overlapSize,<br>
misregFactor,<br>
ditherMatrix,<br>
outputImageLHS,<br>
outputResolution,<br>
false,	// don"t retain output image<br>
false,	// don"t skip LHS<br>
true	// skip RHS<br>
); BI_SaveImage(outputlmageLHS, "OutLHS.tif");<br>
// dither input to bi-level output (RHS only)<br>
BI_Image outputlmageRHS;<br>
Dither<br>
(<br>
inputImage,<br>
lutDotGain,<br>
dotsPerPixel,<br>
subdotsPerDot,<br>
dotlmage,<br>
pDotImageName,<br>
pRefDotlmageName,<br>
overlapCenter,<br>
overlapSize,<br>
misregFactor,<br>
ditherMatrix,<br>
outputImageRHS,<br>
outputResolution,<br>
false,	// don"t retain output image<br>
true,	// skip LHS<br>
false	// don"t skip RHS<br>
) ;<br>
BI Savelmage(outputlmageRHS, "OutRHS.tif");<br>
// dither input to bi-level output (no interp)<br><br>
BI_Image outputlmageNoInterp;<br>
Dither<br>
(<br>
inputlmage,<br>
lutDotGain,<br>
dotsPerPixel,<br>
subdotsPerDot,<br>
dotlmage,<br>
pDotImageName,<br>
pRefDotlmageName,<br>
overlapCenter,<br>
overlapSize,<br>
misregFactor,<br>
ditherMatrlx,<br>
outputlmageNoInterp,<br>
outputResolution,<br>
false,	// don"t retain output image<br>
false,	// skip LHS<br>
false,	// don"t skip RHS<br>
true,	// fixed interp<br>
0,	// fO<br>
0	// fl<br>
);<br>
BI Savelmage(outputlmageNoInterp, "OutNoInterp.tif");<br>
void<br>
main(int argc, char* argv[])<br>
(<br>
try<br>
(<br>
SegmentDither(argc, argv)<br>
catch (BU Error error)<br>
error.Print()<br>
exit (0) ;<br><br>
WE CLAIM :<br>
1.	A method for controlling firing of nozzles within overlapped print head segments of an ink ejection print head, wherein the spatial relationship between adjacent print head segments is variable with time; said method comprising the steps of: (a) determining a measure of the overlap between adjacent print head segments ; (b) creating a half toning pattern for the nozzles in the region of overlap of the overlapping segments; and (c) adjusting said half toning pattern as a function of said measure in the overlapping regions of said print head segments to reduce artifacts produced by the overlapping of said print head segments.<br>
2.	The method as claimed in claim 1 wherein said step of determining a measure of the overlap between adjacent print head segments comprises measuring the temperature of the print head segment.<br>
3.	The method as claimed in claim 1 wherein said step of determining a measure of the overlap between adjacent print head segments comprises measuring the relative displacement of said overlapping segments.<br>
4.	The method as claimed in claim 2 wherein said step of creating a half toning pattern for the nozzles in the region of overlap of the overlapping segments comprises employing a dither matrix with an interpolation function.<br>
5.	The method as claimed in claim 4 wherein said step of adjusting said half toning pattern is such that VA + VB is greater than V where VA and VB are the respective independent dither matrix values of the two adjacent segments and V is the continuous tone value to be represented.<br><br>
6.	The method as claimed in claim 5 comprising the step of adjusting the firing of nozzles in adjacent segments such that corresponding nozzles of respective segments never both fire simultaneously.<br>
7.	The method as claimed in claim 5 wherein said step comprises the step of using the inverse of the dither matrix for alternating segments.<br>
8.	The method as claimed in claim 5 wherein said step comprises the step of assigning the output dot to one or the other nozzle stochastically according to a probability given by a current interpolation factor of said interpolation function.<br>
9.	The method as claimed in claim 3 comprising the step of ensuring that corresponding nozzles of adjacent overlapping segments never both produce an output.</rle_dotline></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgYWJzdHJhY3QuanBn" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che abstract.jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgYXNzaWdubWVudC5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgY2xhaW1zLWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che claims-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgY29ycmVzcG9uZGVuY2Utb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgY29ycmVzcG9uZGVuY2UtcG8ucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgZGVzY3JpcHRpb24gKGNvbXBsZXRlKS1kdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che description (complete)-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgZHJhd2luZ3MtZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che drawings-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgZm9ybS0xLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgZm9ybS0xOS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgZm9ybS0zLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgZm9ybS00LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che form-4.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgZm9ybS01LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgcGN0LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che pct.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTkxMi1jaGUgcGV0aXRpb24ucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1912-che petition.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="202401-a-pagewidth-printer.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="202403-a-nozzle-guard-for-an-ink-jet-printhead.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>202402</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2002/1912/CHE</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>05/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>02-Feb-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>05-Oct-2006</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>22-Nov-2002</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>M/S. SILVERBROOK RESEARCH PTY LTD</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>393 Darling Street, Balmain, New South Wales 2041</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>SILVERBROOK, Kia</td>
											<td>Silverbrook Research Pty Ltd, 393 Darling Street, Balmain, New South Wales 2041</td>
										</tr>
										<tr>
											<td>2</td>
											<td>LAPSTUN, Paul</td>
											<td>13 Duke Avenue, Rodd Point, NSW 2046</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>B41J 2/145</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/AU2000/000593</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2000-05-24</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td></td>
									<td></td>
								    <td>NA</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/202402-a-method-for-controlling-firing-nozzle-within-overlapped-print-head-segments by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 00:01:56 GMT -->
</html>
