<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/212189-system-and-method-for-concentration-and-load-balancing-of-requests by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:01:08 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 212189:SYSTEM AND METHOD FOR CONCENTRATION AND LOAD-BALANCING OF REQUESTS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">SYSTEM AND METHOD FOR CONCENTRATION AND LOAD-BALANCING OF REQUESTS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The present invention relates to a system for a distributed object environment for allowing a local client application to invoke upon a remote server service, comprising: a concentrator, for binding an invoke request from a client application upon the remote service, said concentrator comprising: a plurality of connection handlers, for handling the connection from the client to the server; a listener which determines a particular connection handler of said plurality of connection handlers to handle the connection, wherein the listener calls a service routine to bind the object reference, host, port, and client identifier parameters; and a shared memory for allowing communication between said listener and said plurality of connection handlers, said shared memory comprising a list of currently connected servers, and the connection handler handling each connection, and the shared memory is used by the listener to determine if the host and port are already in use, and incrementing a user multiplex reference count, and assigning an existing handler to the request unless no existing handler can handle the connection, then starting a new handler, The present invention also relates to a method for a distributed object environment for allowing a local client application to invoke upon a remote service on a remote server. (Figure 4)</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
SYSTEM AND METHOD FOR CONCENTRATION AND LOAD-BALANCING OF REQUESTS<br>
COPYRIGHT NOTICE A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.<br>
This application claims priority from provisional application "SYSTEM AMD METHOD FOR CONCENTRATION AND LOAD-BALANCING OF REQUESTS, Application No. 60/221,057, filed July 27, 2000, and incorporated herein by reference.<br>
Field of the Invention<br>
The invention relates generally to distributed computing environments, and specifically to a system and a method for reducing the number of Object Request Broker (ORB) connections in an Internet Inter-ORB Protocol (HOP) environment.<br>
Background<br>
In the field of the distributed computing, several architectures exist to allow machines to communicate with one another or to share distributed or net-centric applications. One of these architectures includes the Common Object Request Broken Architecture (CORBA). CORBA is an architecture design specification developed by the Object<br><br>
Management Group (OMG), an independent group devoted to deveioping standards for u$e in object-oriented computing. Examples of CORBA-compliant systems include Netscape's ONE product, and BEA System's Webiogic Enterprise Server.<br>
CORBA provides a specification for the Interface Definition Language (IDL), which allows software deveiopers to define interfaces to therr object-oriented applications in a standard fashion. IDL includes mappings that allow IDL definition and types to be mapped to a variety of programming languages, including C. C++, and Java. Thus, CORBA allows developers to create "transparent" applications, which may be interpreted independent of the original programming language. Developer and third-party vendors create objects which interact with one another through an Object Request Broker (ORB). Using language mappings, developers can create client-side "stubs" and server-side "skeletons", which the ORB's understand.<br>
Since CORBA 2.0, the CORBA specification has included a method to allow ORB's to communicate seamlessly with each other. The ORB Interoperability Architecture, or more specifically, the General Inter-ORB Protocol (GlOP) standard, defines a set of message requests which ORB's may make over a network. Various flavors of GlOP exist, each tailored to the needs of a specific network transport. GlOP as defined by the OMG, comprises three components:<br>
The Common Data Representation - a transfer syntax mapping IDL types to low-level types for use between network agents.<br><br>
The GIOP Message Formats - of which there are currently seven, including client request, server reply, client cancel request, client locate request, server locate reply, server close connection, and message en'or.<br>
The GIOP Message Transport Assumptions - including that: the transport is connection-oriented, reliable, can be viewed as a byte stream, provides reasonable notification of disorderly connection loss, and that the transport's model for initiating connections can be mapped onto the general connection model of TCP/IP.<br>
A common GIOP implementation, which ail ORB's must by specification be able to use, is the Internet Inter-ORB Protocol (HOP). NOP maps GIOP messages to TCP/IP, allowing the ORB to use a TCP/IP network, for example the Internet, as a communications bus or backbone. Referring to the pyramid structure of Figure 1, at the lowest level of the pyramid exists the Physical Device, for example an Ethernet card having a MAC (Media Access Control) address. Upon this sits the Ethernet protocol, which provides a connection-based, broadcast topology where messages are encoded and collisions resolved. The next layer is the Internet Protocol (IP), which specifies the format of packets that traverse the Internet and supports hostnames and IP addresses. The hostname allows IP to be routed, Above IP is the Transport Control Protocol (TCP), which adds the functionality of port number and control directives such as packet segmentation and time to live. This provides reliable, stream-based delivery. HOP is built upon TCP. Above HOP sits the ORB level, which marshals the HOP requests. At the top of the pyramid   is   the   application   level   itself,   which   includes   object<br><br>
implementations and other ORB objects and services, such as the Naming Service.<br>
In such a distributed Object System as described above and, as further illustrated in Figure 2, requests 50 are passed back and forth between processes requiring an object's function 42,44,46,48 and the processes implementing an object's function 52, 54, 56, 58. The example of Figure 2 shows n clients invoking upon m servers. With such a system it is difficult to achieve scalability when there are n x m connections, where n represents processes requiring a group of object function and m represents the processes implementing the group of object functions. This is commonly known as a "tan-out problem", and leads to difficulties in ensuring system resources are sufficient enough to allow scalability. Techniques exist to allow concentration of requests through a concentrator process to an IIOP/ORB domain o:- group of object implementations. Trie-problem is how scalability may be achieved going in the opposite direction, from the object implementations within the domain, to other object implementations outside of the domain.<br>
Summary of the Invention<br>
To address the problem of scalability in Object Systems, an embodiment of the invention allows native clients, and servers acting as native clients, to invoke on a remote object reference. The ability to invoke on a remote object reference should be: scalable, robust, usable as a mechanism to carry out invocations on object references implemented in foreign ORB servers, usable as a mechanism to carry out invocations that are implemented in remote clients (client callbacks), and usable as a mechanism to carry out invocations that deliver events to remote clients.<br><br>
One solution and embodiment of the invention is to utilize an intelligent concentrator process for requests going from within the domain to outside of the domain, One or more master processes are configured which load-balance requests across sub-processes which actually handle the requests. The master processes may dynamically add sub-processes as required by the load. Additionally, the master processes can allow concentration by ensuring that multiple requests from within the domain use the same actual connection for their requests to an object implementation outside of the domain. A multiplicity of these master processes allow for fail-over and recoverability in case a master process dies.<br>
An embodiment of the invention allows both native clients, and native servers acting as clients, to invoke on object references whose implementation exists outside of an Internet Inter-ORB Protccol (HOP) domain. This provides an underlying mechanism allowing for remote clients to receive events, for remote clients to receive callbacks and for native clients and servers acting as clients to invoke on object references whose implementation is in a remote server built with an Object Request Broker (ORB).<br>
Description of the figures<br>
Figure 1 illustrates how the HOP and ORB layers relate to other network communication protocols in the prior art.<br>
Figure 2 illustrates a fan-out problem known in the prior art.<br>
Figure 3 shows for an embodiment of the invention how an ISH can be used to interface between multiple clients and a TCP/IP link to a<br>
server.<br><br>
Figure 4 shows for an embodiment of the invention how an ISL/ISH concentrator may be used to minimize the number of server connections required to service n clients.<br>
Figure 5 illustrates an embodiment of the invention in which an ISL and multiple ISH's serve a variety of client and server types.<br>
Figure 6 shows for an embodiment of the invention how the routing code interacts with the ISL and the ISH(s).<br>
Figure 7 shows for an embodiment of the invention the services contained in the ISL.<br>
Figure 8 shows for an embodiment of the invention steps in the juting/binding process.<br>
Figure 9 shows for an embodiment of the invention the unbinding process.<br>
Figure 10 illustrates an outbound HOP embodiment of the nvention using a bi-directional connection.<br>
Figure 11 illustrates an outbound HOP embodiment of the nvention using a paired connection.<br>
Figure 12 illustrates an outbound HOP embodiment of the invention using an asymmetric connection.<br>
Figure 13 shows for an embodiment of the invention how a bidirectional connection maybe rebound after a client has disconnected.<br>
Detailed Description of the Preferred Embodiment<br>
Various embodiments of the invention will now be described with respect to the accompanying figures, Several definitions are given below, which will be useful in the discussion of the preferred embodiments.<br>
Client/Server - a machine or process which may act either ss a client or<br><br>
as a server, or both.<br>
Domain - a collection of machines and resources that may be administered as a unit. Domains can be set up based on application function, security needs, or geographical location, and are particularly useful in situations where multiple applications intercommunicate.<br>
Native - a client or server located within the domain.<br>
Callback - the ability to invoke on an object reference that has been created by a remote client (acting as a server) such that an HOP request is delivered to the object implementation in the remote client.<br>
CaHout * the ability to take an object reference for some remote server and invoke on it such that a request is delivered to that remote server. The callout may be to a remote client acting as a server (callback) or to a remote ORB server,<br>
ISH (HOP Server Handler) - Refers specifically to the component that receives HOP messages from remote clients, and forwards them as Tunneled GIOP^fTGlOP) messages to native (or in-domain) servers. This component also receives the replies and makes sure they get back to the appropriate<br>
remote client, in one embodiment of the invention, the ISH will also receive TGIOP request messages from native clients/servers and send the HOP request messages on to remote servers. This component receives the replies and makes sure they get back to the appropriate native client/server.<br><br>
ISL (HOP Server Listener) - Refers to the component that decides which ISH should handle a particular remote client conversation with a native server. The ISL handles fail-over for ISHs and load balancing of connections to native objects. In one embodiment of the invention, the ISL also decides which ISH should handle a particular conversation with a remote server for object references that are not located in a client connected to an ISH. The ISL concentrates connections for multiple invokes on identical remote objects.<br>
Inbound HOP - A concept known in the prior art which refers to initiating an HOP request from a remote server to a native client within the domain.<br>
Outbound HOP - Refers to the inventions method of initiating an HOP request from a native client, or server acting as a client, in the domain to a remote server not in the domain. '<br>
Asymmetric HOP - In some versions of GIOP, HOP connections are not symmetrical, e.g. only clients can send requests and only servers can receive them. If a server needs to send requests to an object in the client, it must create a second connection from the server to the client.<br>
Bi-directional HOP - connections between the client and server are symmetric, i.e. clients can send requests to servers on a connection and &gt;  servers can send requests to objects exported by the client on the same connection.<br><br>
MOP CONCENTRATION<br>
Figure 3 shows a typical concentration process in an embodiment of the invention. Current systems only provides for inbound HOP concentration - the invention adds support for outbound HOP concentration. As shown in Figure 3 an ISH concentrator 66 reduces the number of connections required on a remote client/server 70 by "concentrating" the connections from multiple local clients to operate over a single server link 68. Several clients are contained within the same domain as the ISH and communicate with each other by interprocess communication. Client/servers outside the domain (remote client/servers) communicate with the ISH via a standard TCP/IP link.<br>
As illustrated in Figure 4, an embodiment of an ISH concentrator of the invention is used to improve the scalability of the system first depicted in Figure 2. An ISH 90 reduces the number of active connections from n x m to n + m. In one embodiment of the invention messago queues are used to replace the direct link to the remote servers - this reduces the number of active connections to just n.<br>
OUTBOUND HOP SUPPORT<br>
An exemplary system including one embodiment of the invention is shown in Figure 5. As illustrated, several clients invoke upon a series of remote servers. The client may be, for example, a native C++ client 102, a Java client 164, a notification service 106, or a native server acting as a client 108. The remote server may be another native server 110, a native client registered for events 112, or a non-native CORBA-compliant ORB server 114. When one of the clients invokes upon a server, a routing process directs the connection to the ISL by calling a<br><br>
BIND service 122. The ISL determines which ISH 130. 132, or 134 is best suited to handle the connection. At least one ISH is thus required, although many ISH's may be used. The ISL determines which ISH to hand the connection to by first checking to see if any ISH currently handles a connection to the destination server. If none currency handle such a connection, then the least burdened ISH will be chosen. In this manner the ISL serves to balance the load of increasing number of connections among all available ISH's.<br>
When an ISH is chosen 126, the ciient thereafter invokes that server via that ISH 128. Since the clients and ISH are within the same domain they may communicate using Tunneled GiOP (TGIOP) 136. The ISH's communicate with servers outside of the domain using HOP over TCP/IP 138.<br>
Outbound NOP Support, as embodied in the invention, provides native clients, and servers acting as native clients, the ability to invoke on a remote object reference outside of the domain. This means that events are able to flow to remote clients that have registered for events, callbacks may be done to remote clients and objects In remote servers may be accessed. The Outbound HOP Support comprises four functional parts:<br>
Support for bi-directional HOP to objects contained in clients connected to the JSH. If the remote ORB supports bi-directional GIOP 1.2, then the ISH can utilize the same connection to send requests and receive replies to/from the connected client.<br>
Support for bi-directional-like HOP to objects contained in clients connected to the ISH. If the ORB does not support bi-directional GIOP<br><br>
1.2, then the client can call an Application Program Interface (API) to notify the iSH of the listening host/port in the client The ISH utilizes a second paired outbound connection to send requests to, and receive replies from the connected client. This outbound connection is paired with the incoming connection. If the client disconnects the incoming connection, then the outbound connection is also torn down.<br>
Support for invokes on an ISH or native client. The infrastructure supports routing to an iSH or native client based on the client information. The ORB is modified to embed client identifier information in an object reference.<br>
Support for asymmetric outbound HOP to objects not contained in clients connected to an ISH. The ISL allows for concentration of requests from different native clients/servers that are going tc the same remote server to go through the same connection. The ISL will allow for load balancing of requests so that a specific connection does not get overburdened.<br>
To support scalability, an ISL can start up additional handlers as necessary, and additional ISLs and additional ISHs can be added to support increased outbound HOP traffic as necessary.<br>
To support failover, multiple ISHs can be started on a machine or within the domain. If a client attempts to use an ISH unsuccessfully, an attempt will be made to rebind the object reference and failover to another ISH.<br>
In a typical environment of an embodiment of the invention, system administrators may be the only users that will directly interact w'rth<br><br>
the Outbound HOP Support components. They are responsible for booting the ISL's with the correct startup parameters to enable outbound HOP to objects not located in a connected client. The number of ISL's booted, and the various startup parameters, may be adjusted in order to obtain the best configuration for their installations specific workload characteristics.<br>
OUTBOUND ROUTING<br>
Functional features in the outbound routing process are shown in Figures 6-9, As shown in Figure 6 the ISL 160 and the ISH's 168 (several are shown for demonstration purposes, although the system may operate with only one ISH) communicate with each other via a shared memory 166. In one embodiment of the invention the ISL is responsible for maintaining information about connections to remote servers. A record of such connections is kept in the shared memory. The ISH's use this information to allow invokes upon the remote servers. In return, the ISH's maintain the information in the shared memory by updating if to reflect closed or torn-down connections. The ISL then uses the updated information to better allocate incoming requests for invokes. A client seeking to invoke upon a remote sen/Ice calls a routing code 150. The routing code interacts with the ISL to determine whether a connection already exists, and if so passes it off to the respective ISH. If a connection does not already exist the ISL chooses an ISH to service the new connection.<br>
Figure 7 shows some of the sen/ices the ISL 160 advertises or makes available to the clients. Principally, a client may request via the routing codeto BIND 161 or UNBIND 162 from the ISL An error routine 163 handles failed requests. As shown in Figure 8, the routing code 180<br><br>
invokes a BIND 182 upon the ISL184 which considers the remote server and determines an appropriate ISH to use 1S8. It passes this information back to the client 186. The client thereafter invokes 187 upon the specified ISH. The ISH thereafter handles the communication between the client and the server. As further shown In Figure 9, when the client is finished 190 with the server instance, or requests the connection be closed, the application invokes an UNBIND 192 upon the ISL 194. The ISL then marks the connection closed 196. After a period of time the entry for that particular connection will be removed from the shared memeory in a garbage collection process.<br>
OUTBOUND HOP TYPES<br>
There are three different types of Outbound HOP:<br>
♦	Bi-directional Outbound HOP reusing the same connection<br>
Bi-directional-like Outbound HOP via a second paired connection<br>
*	Asymmetric Outbound HOP via a second connection<br>
Bi-directional Outbound HOP<br>
An embodiment of the invention includes ISL/ISH support 224, 226,228 for bi-directional MOP to objects contained in clients connected to the ISH (Figures 10). If the client ORB supports bi-directional GlOP 1.2, then the ISH will utilize the same connection to send requests and receive replies to/from the connected client. A client 222 will create an object reference and invoke on a native server. The client ORB will identify the connection as being bi-directional using the service context. The service context will travel with the message to the native server 236. When unmarshalling the object reference, the native serverwill compare the host/port in the service context with the host/port in the object<br><br>
reference. If they match, the ORB will add the ISH client identifier and other client information needed for routing to a tagged component in the object reference. This client information will travel with the object reference whenever it is passed to other native servers.<br>
At some point, a native server or native client will invoke on the object reference. The routing code will invoke on the appropriate iSH given the client information. The ISH send the request to the client over the same client connection. The client wiJJ execute the method and send the reply back to the ISH via the client connection. The ISH will receive the reply and send it to the native server.<br>
Outbound HOP Via Paired Second Connection<br>
The invention also includes ISH support for bi-directional-like HOP to objects contained in clients connected to the ISH (Figure 11). If the client ORB does not support bi-directional GIOP 1.2, then the client can call an API routine to notify the ISH of the listening port in the client The ISH then creates a separate paired outbound connection to send requests and receive replies to/from the connected client<br>
A client will create an object reference. It then calls a Bootstrap function passing the object reference. The ISH will get the host/port from the Interoperable Object Reference (IOR), and store it with the client context. The client will invoke on a native server passing the object reference. The ISH will create a service context containing the host/port from the register call. This service context travels with the message to the native server. When unmarshalling the object reference, the native server will compare the host/port in the service context with the host/port in the object reference. If they match, the ORB adds the ISH id and client information to a tagged component in the object reference. This client<br><br>
information travels with the object reference whenever it is passed to other native servers.<br>
At some point, a native server or native client will invoke on the object reference. The routing code will invoke on the appropriate ISH passing the client information. The ISH will create a second connection to the client. It will send the request to the client over ths second connection. The client will execute the method and send the reply back to the ISH via the client connection. The ISH wiil receive the reply and send it to the native server. If the client disconnects from the ISH, then the second connection will also be disconnected.<br>
Asymmetric Outbound HOP<br>
Embodiments of the invention also include iSL/ISH support for asymmetric outbound HOP to objects not contained in clients connected to an ISH (Figures 12). The ISL allows for concentration of requests from different native clients/servers that are going to the same remote server to go through the same connection. The ISL can allow for load balancing of requests so that a specific connection does hot get overburdened. A server 280 will get an object reference from some source, which couid be a naming service, or passed in through a client, but not located in that client. Since the object reference is not located in a client connected to an ISH, the outgoing call can not be made using the bi-directionai method.<br>
At some point, a native server or native client will invoke on the object reference. On the first invoke, there is no ISH id and client information contained within the object reference* The routing code will recognize the object key as a non-native server object reference. If no ISH id and client information is passed, then the routing code will invoke<br><br>
a service in the ISL 224 passing the host/port. The ISL will return a service name to use to unbind the object reference and the client information of the ISH 272. This is the client information of the ISH, not the client information of any client connected to the ISH.<br>
The ORB will invoke on the object reference. The infrastructure will invoke on the ISH. The ISH will get the connection identifier from the client information and determine 226 which outgoing connection to use to send the request to the client. If none is connected, then the ISH wiil create a separate connection to the host/port. The ORB will utilize the appropriate GIOP version for the version of HOP profile in the iOR. The client will execute the method and send the reply back to the ISH via the separate connection. The ISH will receive the reply and send it to the native server.<br>
PROCESS FLOW<br>
The following are detailed process flow descriptions, which illustrate how the client, ISL, and ISH interact in one embodiment of the invention:<br>
From the perspective of the native client<br>
At. object reference bind time the ORB determines if the object reference is remote. If so, the ORB is initialized with client information from the object reference {if present). If client information is not present, then a BIND flag is specified. Otherwise, no flag is specified.<br>
A routing code determines if it has a remote object reference.<br>
If the BIND flag is present: calls the BIND service. Stores returned ISH client Information and ISL information in shared memory.<br>
!f the BIND flag is not present: Stores client information in shared<br><br>
memory.<br>
The routing code looks in the shared memory for client identifier and invokes on it<br>
When the connection is torn down the system looks inside the shared memory for the appropriate entry and calls UNBIND.<br>
The !SL in turn marks connection as closing in shared memory so ISH closes it.<br>
From the perspective of the ISH<br>
The iSH is invoked using the client id.<br>
The ISH receives the message from the message queue. A request is handled in a inverse manner to a reply.<br>
The infrastructure switches the ISH to the appropriate context based on the client. If asymmetric Outbound HOP, then the context is the ISH context (0), not a client context.<br>
A copy of the HOP request is made, and the HOP request id is replaced with a unique Id, The request is placed on a list of outstanding requests for this context<br>
If the context is a client context, then it has a bi-directional connection or a paired second connection. If paired second connection and the connection does not yet exist, then one is created. Routines are called to send the HOP request to the client The routines buffer the request until the connection is completed. Else, routines are called to send the liOP request to the client.<br>
If the context is the ISH context, the connection index is used to determine the outbound connection. If there is not an existing connection, then one is created, Routines are called to send the HOP request to the client. The routines buffer the request until the connection<br><br>
is completed   if there is an existing connection, the routines are called to send the HOP request to the client.<br>
The ISH handles network and message queue events. When a reply comes back from a connection, the list of outstanding requests is searched for the corresponding request. The ISH replaces the unique id wfth the original request id and sends the reply back to the client.<br>
From the perspective of the ISL<br>
The ISL is invoked on the first invoke on an object reference.<br>
The service routine is called to bind the object reference. The parameters are the host, the port, and the client identifier.<br>
The ISL hashes the host/port and looks in the data structures to determine 'rf the host/port is already in use. If in use and not at the multiplex user limit, then the appropriate ISH client identifier, domain, client process identifier, client queue, ISL group and server identifier are returned.<br>
The user multiplex reference count is incremented.<br>
If not found and an existing ISH can handle the connection, then the existing ISH is assigned to handle the request. The appropriate ISH client id, domain, client process identifier, client queue, ISL group and server identifier are returned.<br>
If no ISH can handle the connection/then a new ISH is started. The appropriate ISH client identifier, client process identifier, client queue, ISL group and server identifier are returned.<br>
CONNECTION MANAGEMENT<br>
Connection management is the process by which embodiments of the invention handle connections between the clients and the servers,<br><br>
and specifically how the system handles connections it evaluates are not currently in use.<br>
One of the goals of the invention is that of scalability. Therefore, it is desired to minimize the number of outbound connections, For this reason, the system supports bi-directionai connections and paired second connections in order to have an efficient mechanism to invoke on objects contained within connected clients, These cases comprise the majority of outbound HOP traffic. However, there may still be scenarios where customers want to invoke on object references not contained in a currently connected client. This couid be object references ror foreign ORB servers; client/servers who connect and disconnect from the native domain; or any object reference obtained from a name server. In order to support these type of object references, but still provide scalability* the system relocates these TCP/IP connections from the caller pro cess to an ISH. The caller(native client or native server) invokes on the IOR and the native infrastructure is used to send the message to an ISH. The ISH then sends the message to the remote server using the TCP/IP connection. However, since these TCP/IP connections are no longer in the actual caller process, they are not automatically torn down when the caller (native client or native server) exits.<br>
Asymmetric outbound HOP connections (not currently used by any callers) should be torn down if the caller (native client or native server) exits. This could be immediately after the last caller exits or it could be after some timeout period. The different alternatives for managing asymmetric outbound HOP connections are described in the following sections.<br><br>
Reference Counting and Validation of Users<br>
This alternative works as follows;<br>
The native client or native server {user of the object reference) invokes on an object reference.<br>
On the first invoke, the ORB makes a call to the BIND service in the 1SL An entry for this host/port is added to the shared memory, An entn/ for the identifier of the user (native client identifier or native server group/srvid) is added to the shared memory. The ISL returns a connection identifier (maps to the host/port entry in the shared memory) and the appropriate client information for an ISH that will contain the TCP/IP connection to the remote server,<br>
The ORB uses the client information to send the message to the appropriate ISH. The ISH uses the connection identifier to determine which outbound HOP connection to use.<br>
The native client or native sen/er continues to perform" invokes on the object reference. • Each invoke results in a message sent to the ISH,<br>
If another native client invokes on an object reference with the same host/port, the BIND service will return the same connection identifier and the same client information as the first user. The reference count of the host/port entry will be incremented. An entry for the identifier of the second user (native client or native server) is added to the shared   memory.<br>
Eventually, the first and second users release the object reference. The first user release results in a call to the UNBIND sen/ice, which decrements the reference count of host/port entry and removes the identifier of the user On the second user<br><br>
release, the reference count of the host/port entry is decremented<br>
to zero. The ISL removes the host/port entry from the shared memory and marks the connection entry (different from host/port entry) as closing in the shared memory.<br>
The 1SH closes the connection when it sees that the<br>
connection entry in the shared memory is marked as closed. It marks the connection entry as unused.<br>
This is the case where the user exits normally and releases object references. Other cases include the user exitingwithout releasing object references and the user abnormally exiting. In order to ensure that connections are released when no longer needed, this alternative uses validation, in which the ISL validates the identifier of users of the connection; stores the id's in the shared memory; checks to see If a ser/er is inactive; and if on the local machine, the ISL will compare a tirnestamp to see if the native client is stili active; or uses a call to validate a native client that is not on the same machine as the ISL.<br>
Asymmetric Outbound Connection Timeout with No Unbind<br>
This alternative works as follows:<br>
The native client or native server (user of the object reference) invokes on an object reference.<br>
On the first invoke, the ORB calls the BIND service in the ISL, An entry for this host/port is added to the shared memory. The ISL returns a connection identifier (maps to the host/port entry in the shared memory plus an additional generation/timestamp field) and the appropriate client information<br><br>
for an !SH that will contain the TCP/IP connection to the remote<br>
server.<br>
•	The ORB uses the client information to send the message<br>
to the appropriate ISH. The ISH uses the connection identifier to determine which outbound HOP socket to use. If the connection identifier is no longer valid (due to connection timeout), then an error is returned.<br>
The native client or native server continues to perform invokes on the object reference. Each invoke results in a message sent to the ISH.<br>
If another native client invokes on an object reference with the same host/port, the BIND sen/ice will return the same connection identifier and the same client information ;as the first invoke. No reference counting will be performed on the host/port entry.<br>
Eventually, the first and second users release the object reference. No unbind service is called. The connection stays up.<br>
On each invoke, the ISH updates an activity timestarnp field in shared memory for the connection. On a regular basis, tie ISL will timeout the connection if no activity takes place within a user specified time period. The ISL will mark the connection as closed and remove the host/port entry. The ISH will disconnect the connection when it sees the connection has been marked as closed. It marks the connection entry as unused.If the users of an connection die or do not release object references, then the connection will stay up as long as it is active. It will be torn down when it has not been active for thespecified time period. An object reference may still be valid, but not used within the specified<br><br>
timeout period. In this case, the connection will be torn down and the host/port entry removed. The ISH will receive the request, validate the connection id, and return an error. This error will cause the ORB to rebind the object reference. This will involve a call to the ISL BIND service and an existing connection may be used or a new connection may be created. This rebind should not be visible to the user,<br>
Reference Count with Asymmetric Outbound Connection Timeout<br>
This is a combination of alternative 1 and 2. The main difference is that connections are torn down as soon as no one is using them. This alternative works ss follows:<br>
The native client or native server (user of the object reference) invokes on an object reference.<br>
On the first invoke, the ORB calls the BIND service in the ISL. An entry for this host/port is added to the shared memory. The ISL returns a connection identifier (maps to the host/pore entry in the shared memory plus an additional generation/timestamp field) and the appropriate ISH id and client information for an !SH that will contain the TCP/IP connection to the remote server.<br>
The ORB uses the ISH id and client information to send the message to the appropriate ISH. The ISH uses the connection identifier to determine which outbound HOP connection to use. if the connection identifier is no longer valid (due to connection timeout), then an error is returned.<br>
The native client or native server continues to perform invokes on the object reference. Each invoke results in a message sent to the ISH.<br><br>
If another native client invokes on an object reference with the same host/port, the BIND service will return the same connection identifier and the same client information as the first invoke. The reference count of the host/port entry will be incremented.<br>
Eventually, the first and second users release the object reference. The first user release results in a call to the UNBIND service. It decrements the reference count of host/port entry. On the second user release, the reference count of the host/port entry is decremented to zero. The ISL removes the host/port entry from the shared memory and marks the connection as closing in the shared memory.<br>
The ISH closes the connection when it sees that the connection entry in the shared memory is marked as dosed.<br>
It marks the connection entry as unused-<br>
■<br>
If the users of an connection die or do not release object referenced, then the connection will stay up as long as it is active. It will be torn down when it has not been active for the specified time period. An object reference may still be valid, but not used within the specified timeout period. In this case, the connection will be torn down and the host/port entry removed. On a subsequent invoke, the ISH will receive the request, validate the connection identifier, and return an error, This error will cause the ORB to rebind the object reference. This will involve a call to the ISL BIND service and an existing connection may be used or a new connection may be created. This rebind should not be visible to the user.<br><br>
ADDITIONAL FEATURES<br>
Use of Bi-directional Connections for Callout<br>
In some scenarios a client may connect, create a persistent subscription to an event, and then disconnects from the ISH. When the client reconnects to an ISH, it then expects to receive events for that persistent subscription.<br>
In one embodiment of the invention, the ISL knows about current bi-directional connections and then uses them instead of creating a separate connection to the host/port in the I OR. Notifying the ISL of bi-directional connections allows for the optimal use of resources. The ISH notifies the ISL of the bi-directional information. This requires locking of the shared memory or extra messages on connection creation and deletion.<br>
Client Disconnection<br>
•In this scenario, illustrated in Figure 13, the client has disconnected from the domain, but is still listening at the same host and port. The object reference contains the client information of the disconnected client When the ORB invokes upon an unavailable service, the infrastructure will return an error. The ORB will handle this error and rebind 304 the object reference. An ISH will be selected to create a new connection to the remote server, and the client information will be updated.<br>
Data Design<br>
The ISL and ISH each have data that they keep in memory. They also share memory for items that need to be persistent across the life of the ISL and its ISHs. If an ISL dies and restarts, it will reattach to the<br><br>
shared memory and will be able to recover any state that has been saved in that shared memory.<br>
Shared Memory<br>
The ISL shares memory with the ISHs that it controls. If asymmetric outbound NOP is enabled, then additional sections will be present in the shared memory table. This memory is used by the ISL to do appropriate concentration and load balancing and is used by the ISH to keep track of which connections it needs to create. The ISL is the primary writer of the shared memory.<br>
ISH Failure<br>
The ISH has to keep information around that does not need to be in shared memory. Among the information that does not need to be shared is areas for holding information about the current request, areas to map request ids to clients (server). The ISL is responsible for restarting an ISH. When it restarts the ISHt it will clear out the old shared . memor/ slots for the dead ISH and ensure that the ISH will connect to that ISL's shared memory.<br>
If a client invokes on an object reference bound to the ISH that failed, an error will occur. The caller will rebind, and an ISH will be selected to perform the invoke. This could be the restarted ISH or another ISH,<br>
ISL Failure<br>
The ISL will eventually restart if the system administrator started it with recommended settings. If an object code was Invoking the service, but has not yet selected the server, then an alternative ISL will<br><br>
be selected. If the object code was invoking the service and selected the server then the system returns an error to the client. When the ISL eventually restarts it will reconnect to the shared memory.<br>
Native Client (or server acting as a client) Failure<br>
The ISL will periodically scan the list of outbound connections. If a connection has not been active in the timeout period specified, then the corresponding entry will be freed and the outbound connection disconnected. This will ensure that outbound connections created by native clients or servers will always be torn down it the native client or server fails.<br>
Garbage Collection<br>
There are "events" that can cause some portion of shared<br>
memory to be cleaned up:<br>
Remote server fails. The ISH will return an error to the client (or clients if multiple clients were using the connection). When the client exits and the ISL is notified it will clean out the appropriate host and port slot and appropriate client identrfier slot(s).<br>
The ISH realizes that a connection has exceeded the timeout set by the administrator. The corresponding entry will be freed and the socket will be marked as closing. On the next invoke, an error will be returned to the caller, and the ORB will rebind the object reference. A new connection will be created and the invoke will occur.<br>
*	The ISH dies. The ISL restarts the ISH, On the next invoke<br>
on that bound object reference, an error will occur. The caller will<br><br>
rebind and an ISH will be selected to perform the invoke. The existing entries for the ISH will remain in the shared memory. On the first invoke, the restarted ISH will connect to the remote server.<br>
The ISL dies. At restart time, it checks all ISHs and cleans up entries for any ISH that has died.<br>
The ISL is shutdown. The ISL sends shutdown messages to the ISH. The ISL removes the shared memory.<br>
The machine crashes and ISL and all the ISHs die at the same time. The shared memory disappears.<br>
Other features, aspects and objects of the invention can be obtained from a review of the figures and the claims. It is to be understood that other embodiments of the invention can be developed and fall within the spirit and scope of the invention and claims.<br>
INDUSTRIAL APPLICABILITY<br>
The invention has particular use in the field of Object-Oriented systems, and specifically CORBA-compliant systems where n clients may invoke upon m servers. Typically this would require n x m number of connections to handle the requests. The invention described allows there to be only m connections on the server which significantly reduces resource requirements and allows scalability. The invention further allows for multiple intelligent master concentrator processes, to tackle concentrator failure and offer dynamic scalability.<br><br><br><br><br>
What is claimed is;<br>
1      A system for use in a distributed object environment for allowing ;  a local client application to invoke upon a remote seiver service, comprising:<br>
a concentrator which binds a request from the client application to invoke upon the remote service, identifies the remote seiver, and operabiy connects the client to that remote server.<br>
2.	The system of claim 1 wherein the concentrator further comprises:<br>
at least one connection handier, which handles the connection<br>
from the client to the server; and,<br>
a listener which determines which connection handler to use to handle the connection,<br>
3.	The system of claim 2 wherein the listener and connection handler ■communicate via a shared memory.<br>
4.	The system of claim 3 wherein the shared memory comprises a list of currently connected servers, and the connection handler handling each connection.<br>
5.	The system of claim 2 wherein the concentrator comprises a plurality of connection handlers.<br>
6.	The system of claim 5 wherein the listener determines which connection handler to use based on the entries in the shared memory.<br><br>
7.	A method for use in a distributed object environment for allowing<br>
a local client application to invoke upon a remote service on a remote<br>
server, comprising:<br>
binding a request from the client application invoking upon the remote service;<br>
identifying the remote server; and,<br>
operably connecting the client to that remote server through a connection handler.<br>
8.	The method of claim 7 further comprising:<br>
referencing a shared memory space to see if the remote server is currently connected to a connection handler.<br>
9.	The method of claim 8 further comprising:<br>
if the remote server is not currently connected to a connection handler, then connecting the remote serverto a-connection handier and updating the shared memory.<br>
10.	The method of claim 9 wherein the step of updating the shared memory comprises updating a list of currently connected servers, and the connection handier handling each connection.<br>
11.	The method of claim 7 wherein one of multiple connection handlers may be used to handle the connection.<br>
12.	The method of claim 11 further comprising the step of:<br>
determining  which  connection  handler should   handle  the<br>
connection by referencing the entries in the shared memory.<br><br>
13.	A system for use in a distributed object environment for allowing<br>
a local client application to invoke upon a remote server service,<br>
comprising:<br>
a concentrator, for binding an invoke request from a client application upon the remote service, said concentrator further including<br>
a plurality of connection handlers, for handling the connection from the client to the server;<br>
a listener which determines a particular connection handler of said plurality of connection handlers to handle the connection; and,<br>
a shared memory for allowing communication between said listener and said pluralrty of connection handlers, said shared memory including a list of currently connected servers, and the connection handler handling each connection.<br>
14.	The system of claim 13 wherein the local client application<br>
performs the steps of:<br>
determining, at object reference bind time, whether the object reference is remote, and if so initializing the ORB with client information from the object reference;<br>
if a bind flag is present binding the service and storing returned ISH client information and listener information in said shared memory;<br>
if a bind flag is not present storing client information in said shared memory;<br>
searching within said shared memory for a client identifier and invoking upon it; and,<br>
when the connection is torn down searching within said shared memory for the appropriate entry, and using said entry to unbind the service.<br><br>
15.	The system of claim 13 wherein said connection handler performs<br>
the steps of:<br>
receiving a message from the message queue;<br>
switching the handlerto either a client context or a handler context based on the client;<br>
making a copy of the HOP request, and replacing the IIO'P request id with a unique id;<br>
placing the request on a list of outstanding requests for this context;<br>
if the context is a client context, and if paired second connection and the connection does not yet exist, then creating one, and sending the HOP request to the client;<br>
if the context is the handler context, using a connection index to determine the outbound connection, and if one does not exist then creating one, and sending the HOP request to the client; and,<br>
when a reply comes back from a connection, searching the list of outstanding requests forthe corresponding request, replacing tie unique id with the original request id, and sending the reply back to the client<br>
16.	The system of claim 13 wherein said listener performs the steps<br>
of:<br>
calling a service routine to bind the object reference, together with<br>
host, port, and client identifier parameters;<br>
searching within the shared memory to determine if the host/port is already in use;<br>
incrementing a user multiplex reference count;<br><br>
if an existing handler can handle the connection, then assigning the existing handler to handle the request; and,<br>
if no existing handler can handle the connection, then starting a<br>
new handler.<br>
17.	The system of claim 13 wherein the client is any one of a native C++ client a Java client, a notification service, or a native server acting as a client.<br>
18.	The system of claim 13 wherein the remote server is any one of a native server, a native client registered for events, or a non-native CORBA-compliant ORB server.<br>
19.	A method for use in a distributed object environment for allowing a local client application to invoke upon a remote server service, comprising:<br>
providing a plurality of connection handlers, for handling the connection from the client to the server;<br>
determining, at a listener, which particular connection handler of said plurality of connection handlers to handle the connection; and,<br>
binding a request from the client application invoking upon the remote service, said step of binding includes;<br>
identifying the remote server, and, operably connecting the clientto that remote serverthrough said particular connection handler,<br>
20.	The method of claim 19 wherein said local client application<br>
performs the additional steps of:<br><br>
determining, at object reference bind time, whether the object reference is remote, and if so initializing the ORB with client information from the object reference;<br>
if a bind flag is present binding the service and storing returned ISH client information and listener information in said shared memory;<br>
if a bind flag is not present storing client information in said shared memory;<br>
searching within said shared memory for a client identifier and invoking upon it; and,<br>
when the connection is torn down searching within said shared memory for the appropriate entry, and using said entry to unbind the service.<br>
21, The method of claim 19 wherein said connection handler performs the additional steps of;<br>
receiving a message from the message queue;<br>
switching the handler to either a client context or a handler context based on the client;<br>
making a copy of the HOP request, and replacing the HOP request id with a unique id;<br>
placing the request on a list of outstanding requests for this context;<br>
if the context is a client context, and rf paired second connection and the connection does not yet exist, then creating one, and sending the HOP request to the Client;<br>
if the context is the handler context, using a connection index to determine the outbound connection, and if one does not exist then creating one, and sending the HOP request to the client; and,<br><br>
when a reply comes back from a connection, searching the list of outstanding requests forthe corresponding request replacing the unique id with the original request id, and sending the reply back to the client<br>
22.	The method of claim 19 wherein said listener performs the<br>
additional steps of:<br>
calling a service routine to bind the object reference, together with host port, and client identifier parameters;<br>
searching within the shared memory to determine if the host/port is already in use;<br>
incrementing a user multiplex reference count;<br>
if an existing handler can handle the connection, then assigning the existing handier to handle the request; and,<br>
if no existing handler can handle the connection, then starting a i   new handier.<br>
*<br>
23.	The method of claim 19 wherein the client is any one of a native<br>
C++ client a Java client, a notification service, or a native server acting<br>
as a client<br>
)<br>
24.	The method of claim 19 wherein the remote server is any one of<br>
a native server, a native client registered for events, or a non-native<br>
CORBA-compliant ORB sen/er.<br><br>
25. A system for use in a distributed object environment substantially as herein described with reference to the accompanying drawings.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">151-chenp-2003-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtYXNzaWduZW1lbnQucGRm" target="_blank" style="word-wrap:break-word;">151-chenp-2003-assignement.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtY2xhaW1zIGZpbGVkLnBkZg==" target="_blank" style="word-wrap:break-word;">151-chenp-2003-claims filed.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtY2xhaW1zIGdyYW50ZWQucGRm" target="_blank" style="word-wrap:break-word;">151-chenp-2003-claims granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtY29ycmVzcG9uZG5lY2Utb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">151-chenp-2003-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtY29ycmVzcG9uZG5lY2UtcG8ucGRm" target="_blank" style="word-wrap:break-word;">151-chenp-2003-correspondnece-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtZGVzY3JpcHRpb24oY29tcGxldGUpZmlsZWQucGRm" target="_blank" style="word-wrap:break-word;">151-chenp-2003-description(complete)filed.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtZGVzY3JpcHRpb24oY29tcGxldGUpZ3JhbnRlZC5wZGY=" target="_blank" style="word-wrap:break-word;">151-chenp-2003-description(complete)granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">151-chenp-2003-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtZm9ybSAxLnBkZg==" target="_blank" style="word-wrap:break-word;">151-chenp-2003-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtZm9ybSAxMy5wZGY=" target="_blank" style="word-wrap:break-word;">151-chenp-2003-form 13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtZm9ybSAxOC5wZGY=" target="_blank" style="word-wrap:break-word;">151-chenp-2003-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtZm9ybSAyNi5wZGY=" target="_blank" style="word-wrap:break-word;">151-chenp-2003-form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtZm9ybSAzLnBkZg==" target="_blank" style="word-wrap:break-word;">151-chenp-2003-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtZm9ybSA1LnBkZg==" target="_blank" style="word-wrap:break-word;">151-chenp-2003-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtb3RoZXIgZG9jdW1lbnQucGRm" target="_blank" style="word-wrap:break-word;">151-chenp-2003-other document.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxLWNoZW5wLTIwMDMtcGN0LnBkZg==" target="_blank" style="word-wrap:break-word;">151-chenp-2003-pct.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzLTE1MS1jaGVucC0yMDAzLmpwZw==" target="_blank" style="word-wrap:break-word;">abs-151-chenp-2003.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="212188-compound-of-formula-i-or-ii-for-treating-cognitive-disfunction.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="212190-process-for-spinning-and-winding-polyester-filaments.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>212189</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>151/CHENP/2003</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>02/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>11-Jan-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>26-Nov-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>24-Jul-2003</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>M/S. BEA SYSTEMS, INC</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2315 North First Street, San Jose, CALIFORNIA 95131</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>FERWERDA, Paul</td>
											<td>78 Graston Drive Bedford, NH 03110</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 9/46</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2001/022343</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2001-07-17</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/221,057</td>
									<td>2000-07-27</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/212189-system-and-method-for-concentration-and-load-balancing-of-requests by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:01:09 GMT -->
</html>
