<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/211098-a-method-for-configuring-and-initializing-a-memory-device-and-memory-channel by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:31:20 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 211098:A METHOD FOR CONFIGURING AND INITIALIZING A MEMORY DEVICE AND MEMORY CHANNEL</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD FOR CONFIGURING AND INITIALIZING A MEMORY DEVICE AND MEMORY CHANNEL</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A METHOD FOR CONFIGURING AND INITIALIZING A MEMORY DEVICE AND MEMORY CHANNEL A method for configuring and initializing a memory device and a memory channel comprising: initializing a memory controller; initializing a plurality of memory controller configuration registers; assigning serial identification numbers to a plurality of memory devices which are coupled to the memory controller; assigning device identification numbers to groups of the plurality of memory devices based at least in part on memory device sizes by: assigning a set of lowest identification .numbers to memory devices having a largest supported size; and assigning subsequent identification numbers to remaining memory devices having smaller sizes; programming registers in each of the plurality of memory devices to equalize a sum of a device response time and a propagation delay from each memory device to the memory controller for all of the plurality of memory devices; and enabling the plurality of memory devices.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT 1970<br>
[39 OF 1970]<br>
&amp;<br>
THE PATENTS RULES, 2003 COMPLETE SPECIFICATION<br>
[See Section 10; rule 13]<br>
A METHOD FOR CONFIGURING AND INITIALIZING A MEMORY DEVICE AND MEMORY CHANNEL<br>
INTEL CORPORATION, a Delaware corporation, of 2200 Mission College Boulevard, Santa Clara, California 95052, United States of America.<br>
The following specification particularly describes the invention and<br>
the manner in which it is to be performed:	<br><br>
This application is related to an application serial number 09/186,042 (Docket No. P6626), entitled 'A Method And Apparatus For Levelizing Transfer Delays For A Channel Of Devices Such As Memory Devices In A Memory Subsystem," application serial number 09/186,050 (Docket No. P6628), entitled "A Method And Apparatus For Configuring A Memory Device And A Memory Channel Using Configuration Space Registers," and US Patent No. 6230274 (Docket No. P6639), entitled "A Method And Apparatus For Restoring A Memory Device Channel When Exiting A Low Power State," all of which are filed concurrently herewith.<br>
BACKGROUND<br>
1.	Field of the Invention<br>
The present disclosure pertains to the field of data processing systems. More particularly, the present disclosure pertains to initializing or configuring memory devices in a memory channel.<br>
2.	Description of Related Art<br>
Memory devices and memory subsystems typically have certain initialization steps and/or register values that need to be programmed prior to normal operation. Recommended steps and values are often detailed in a memory specification provided to system designers who design other system hardware interfacing with the memory devices. If initialization routines are further optimized, however, initialization may conclude more quickly, advantageously allowing other system processing to commence sooner.<br>
One channel (i.e., a bus configuration) which requires a significant amount of initialization prior to proper operation is a Rambus™Direct Rambus Dynamic Random Access Memory Channel (a Direct RDRAM™ChanneI). This channel is described in detail in documentation available from Rambus Corporation of Mountain View, California. RDRAM memories and memory controllers interfacing with a Rambus channel have various registers that need to be set through the<br><br>
initialization process.<br>
It is clear from Rambus documentation that a number of initialization operations must be performed prior to using a Rambus channel. In general, the memory controller reads all the read-only registers in all RDRAMs, processes this information, and then writes all the read-write registers to place the RDRAMs into the proper operating mode. DevicelD and TRDLY registers are important read-write registers that respectively set the device address for memory transactions and the delay value for memory read data.<br>
A unique serial device identification value may be set for each RDRAM on the channel by looping through the entire serial chain and assigning sequential serial identification numbers (see, e.g., p. 28 of the Direct RDRAM™64/72 Mbit Data Sheet). A second ID value simply referred to as a device ID allows memory accesses through the Rambus channel during normal operation. A unique device ID also needs to be set for active devices on the channel; however no specific technique for assigning device IDs is described in the literature.<br>
Additionally, RDRAMs can execute refresh, precharge, current calibration, current sampling, and various other functions (see, e.g., pp. 8-9 of the Direct RDRAM™64/72 Mbit Data Sheet). While these commands are generally discussed in the Direct RDRAM™64/72 Mbit Data Sheet, a complete initialization sequence may not be provided. Additionally, details of initialization and/or configuration of specific memory controllers may not be available. Thus, the prior art may not provide an adequate or complete method and apparatus for configuring a set of memory devices in a memory channel.<br>
Summary<br>
A method for configuring and/or initializing memory<br><br><br>
devices is disclosed. A disclosed method initializes a memory controller and a plurality of memory controller configuration registers. Serial identification numbers are assigned to memory devices coupled to the memory controller. Additionally, groups of device identification numbers, which are based at least in part on the memory device sizes, are assigned to the  memory devices, and the memory devices are enabled.<br>
Brief Description of the Figures<br>
The present invention is illustrated by way of example and not limitation in the figures of the accompanying drawings.<br>
Figure 1 illustrates one embodiment of a system using configuration registers in a memory controller to designate initialization operations for memory initialization.<br>
Figure 2 illustrates a flow diagram of programming and executing initialization operations in one embodiment of the system of Figure 1.<br>
Figure 3 illustrates one embodiment of a memory control hub that performs memory initialization according to values loaded into control and data registers.<br>
Figure 4 illustrates a flow diagram for a memory device core initialization operation.<br>
Figure 5 illustrates one embodiment of a system implementing an initialization flow shown in Figures 6-9.<br><br><br>
Figure 6 illustrates a flow diagram of one embodiment of an overall initialization sequence for the memory subsystem of the system shown in-Figure 5.<br>
Figure 7 illustrates one embodiment of a serial device identification process.<br>
Figure 8A illustrates one embodiment of a first portion of a group device identification process.<br>
Figure 8B illustrates one embodiment of a group device assignment process (e.g., block 820 in Figure 8A).<br>
Figure 8C illustrates one embodiment of a second portion of the group identification process from Figure 8A.<br>
Figure 9 illustrates one embodiment of a memory device core initialization process.<br>
Figure 10 illustrates one embodiment of the process of returning from a suspend-to-RAM power management state.<br>
Detailed Description The following description provides a method and apparatus for initializing a memory device and a memory channel. In the following description, numerous specific details such as register names, memory types, bus protocols, specific types of components, and logic partitioning and integration choices are set forth in order to provide a more thorough understanding of the present invention. It will be appreciated, however, by one skilled in the art that the invention may be practiced without such specific details.   In other instances, control structures and gate level circuits have not<br><br><br>
been shown in detail in order not to obscure the invention. Those of ordinary skill in the art, with the included descriptions, will be able to implement ihe-necessary logic circuits without undue experimentation.<br>
Using the presently disclosed techniques, efficient and flexible memory initialization may be performed. Control and data registers may be programmed, thereby causing a memory control hub (MCH) to perform initialization operations (lOPs) according the values loaded in the registers. Since the registers may be programmed by software such as a basic input/output system (BIOS), the initialization may be altered with relative ease.<br>
Figure 1 illustrates one embodiment of a system utilizing registers to perform memory initialization. The system includes a processor 195 and a memory subsystem 104 that are coupled to a memory control hub (MCH) 100. Also coupled to the MCH 100 is a secondary bus 180 having coupled thereto an input device 190 and a non-volatile memory 185 containing BIOS routines. In some embodiments, either or both of the non-volatile memory 185 and the input device 190 may be coupled to the MCH 100 by a second control hub (not shown).<br>
In the illustrated embodiment, the memory subsystem 104 includes three memory modules 160, 170, and 175 coupled to the MCH 100 via a serial bus 142 and a memory bus 132 (also referred to as a channel). Each memory module may contain a set of individual memory devices. For example, the memory module 160 includes at least memory devices 160, 161, and 168. In one embodiment, the memory devices 160, 161, and 168 are Rambus DRAMs (RDRAMs), the memory modules are Rambus In-line Memory. Modules (RIMMs), and the channel operates according to protocols defined for RIMMs and RDRAMs.<br>
The MCH 100 includes a control register 112 and a data register 114 which may be used for initialization purposes. An initialization control circuit 120 executes initialization operands (lOPs) which are programmed into the control register 112. The control register 112 typically includes other fields to specify information about initialization operations, and some of the operations<br><br>
specified by the lOPs involve data exchange with devices in the memory subsystem (e.g., writing and reading of memory device control registers or-otherwise generating control signals).<br>
A serial interface circuit 140 generates serial command and data sequences on the serial bus 142. Some of the commands executed by the initialization control circuit 120 send commands and/or data to the memory subsystem via the serial bus 142. Control registers, including device registers for identification numbers, may be read and written via the serial interface circuit 140.<br>
A memory interface circuit 130 translates memory data to and from data packets which are exchanged with the memory subsystem. In one embodiment, the memory interface circuit is a Rambus ASIC Cell (RAC). functioning substantially as described in the "Direct RAC Data Sheet" available from Rambus Corporation of Mountain View, California. Briefly, the RAC converts the Rambus Signal Level (RSL) signals on the channel (bus 132) to signals which can be processed by other portions of the MCH 100. Similarly, the RAC converts the memory controller signals to RSL signal which can be processed by memory devices on the Rambus channel.<br>
A sequence of initialization events for the system of Figure 1 is illustrated in Figure 2. As the system is reset or turned on, the BIOS typically performs various initialization operations. In block 200, the BIOS reaches the memory configuration portion. Depending on the type of memory and the intended mode of usage, initialization operations will be selected (block 205) by the BIOS in a particular sequence. More details of one embodiment of an initialization sequence for a system utilizing RDRAMs are discussed with respect to Figures 5-9.<br>
As indicated in block 210, data (if any) for the particular initialization operation is stored in the data register 114, and the initialization operand itself with other control information is stored in the control register 112. In some embodiments, the BIOS may perform this function by writing to peripheral component  interconnect  (PCI)   configuration   registers.     Alternatively,   other<br><br><br>
registers may be used, or general purpose memory locations either within or without the MCH may be the control register. In fact, the control register may be any storage location accessible to the MCH prior to memory initialization that is capable of storing sufficient bits for lOPs and any other needed control information.<br>
The initialization operation may commence automatically when the proper initialization- operation and/or control information are programmed into the control register 112. For example, the execution of the initialization operation indicated in block 215 may be accomplished by setting an initiate initialization operation (IIO) bit when the initialization operand is loaded into the control register 112. The llO bit may be a field of the control register 112 so the same register write transaction may set the IIO bit and provide the IOP..<br>
Completion of the initialization operation may be signaled in any manner sufficient to alert or inform the BIOS that the initialization operation is complete. For example, the MCH may automatically clear the IIO bit when the initialization operation completes. If the BIOS polls the llO bit, it may determine when the initialization operation completes as indicated in block 220. If the initialization operation has not completed, the BIOS may continue polling the IIO bit. If the initialization operation has completed, the BIOS may select the next initialization operation in the initialization sequence in block 205.<br>
The input device 190 may either accept program instructions from a computer storage device 192 (e.g., an optical or magnetic disk or other storage device) or from a network or communications interface 194. BIOS code (i.e., computer instructions) causing the system to implement the disclosed techniques may be programmed into the non-volatile memory 185 in several ways. The BIOS may be programmed when the system is manufactured or may be later delivered via a computer readable medium through the input device<br>
190.      <br>
In cases where the BIOS is later delivered, the instructions may be delivered via a computer readable medium. With an appropriate interface device 190, either an electronic signal or a tangible carrier is a computer<br><br><br>
readable medium. For example, the computer storage device 192 is a computer readable medium in one embodiment. A carrier wave 196 carrying the computer instruction is a computer readable medium in another embodiment. The carrier wave 196 may be modulated or otherwise manipulated to contain instructions that can be decoded by the input device 190 using known or otherwise available communication techniques. In either case, the computer instructions may be delivered via a computer readable medium.<br>
Figure 3 illustrates additional details of a memory controller hub (MCH) 300. Details of specific register names, locations, sizes, field definitions, and initialization operations are given for one embodiment below. Other embodiments will be apparent to those of skill in the art. Several of the operations below invoke specific commands defined by Rambus in the 64/72-Mbit Data Sheet and the Direct RAC data sheet. These defined operations are operations that the Rambus RAC itself sends to RDRAMs when appropriate control signals are sent to the RAC, As detailed below, this embodiment of the MCH 300 invokes known RAC commands by previously unavailable hardware and in new methods or sequences.<br>
In this exemplary embodiment, the MCH 300 includes a RAC 330 and a serial interface 340. The serial interface 340 uses clock (SCK), serial frame (CMD), and bi-directional serial I/O pins (SIO0 and SIOI) to read and write RDRAM configuration registers as well as to perform other lOPs. The MCH also includes a device register data (DRD) register 314. The DRD register 314 is at address offset 90-91 h in PCI configuration space, the default value is OOOOh (16 bits), and the register is a read/write register. The fields of the DRD register are shown in Table 1.<br>
Table 1: An Embodiment of the DRD Register<br><br>
Bit<br><br>
Description<br><br><br><br>
15:0<br><br>
Register Data (RD): Bits 15:0 contain the 16 bit data to be written to a RDRAM register or the data read from a RDRAM register as a result of fOP execution. Data will be valid when the HO bit of RICM register transitions from 1 to 0<br><br><br>
The MCH 300 also includes a RDRAM Initialization Control Management (RICM) Register 312. The RICM Register is at address offset 94-96h in PCI configuration space, the default value is OOOOOOh (24 bits), and the register is a read/write register. The fields of the RICM register for this embodiment are set forth in Table 2.<br>
Table 2: An Embodiment of the RICM Register<br><br>
Bit	Description<br>
23	Initiate Initialization Operation (HO): When set to 1, the execution of the initialization operation specified by the IOP field (below) starts. After the execution is completed, the MCH clears the IIO bit to 0. A software program should check to see if this bit is 0 before writing to it. Data from operations which specify a register data read from the RDRAM will be valid in the DRD register when the IIO bit is cleared to 0.<br>
22:21	RESERVED: These bits are not used for normal initialization operations.<br>
20	Initialization Complete (IC): BIOS sets this bit to 1 after initialization of the RDRAM memory array is complete.<br>
19	Broadcast Address (BA): When BA is set to 1, the initialization operation (IOP) is broadcast to all devices in the channel. When BA is set to 1, the SDA field (below) is not used.<br>
17:9	Device Register Address (DRA): This field specifies the register address for the register read and write operations.                                                              .<br>
8:4	Serial Device/Channel Address (SDA): This 5 bits field specifies the following:<br>
•	the serial device ID of the RDRAM device for RDRAM Register Read, RDRAM<br>
Register Write, RDRAM Set Reset, RDRAM Clear Reset and RDRAM Set Fast<br>
Clock Mode IOP commands.<br>
•	the device ID for Powerdown Entry, Powerdown Exit, Nap Entry, Nap Exit,<br>
Current Calibrate and Current Calibrate &amp; Sample IOP commands.<br>
•	the bank address for Refresh and Precharge IOP commands<br><br><br><br>
Also illustrated in Figure 3 is an initialization control circuit 320 which includes an RDRAM lOP execution circuit 325. Details of the various IOPs executed by the control circuit 320 are illustrated in Table 3. In Table 3, the broadcast address (BA) field (bit 19) and the SDA field (bits 8:4) are listed either as one of the"following:<br>
NE:    This field has no effect on the initialization operation<br>
0:        This field is to be set to 0 for this initialization operation.<br>
1:       This field is to be set to 1 for this initialization operation.<br>
x: This field should be programmed as appropriate for the particular initialization operation.<br>
Table 3: lOP Operation Details<br><br>
Bits [18,3:0]	Operation Name	BA	SDA	Details<br>
0    0    0     0     0	RDRAM Register Read	0	X	This lOP performs the serial read of the RDRAM register specified by SDA and DRA fields. The data read will be available in DRD register when the HO bit is cleared to 0.<br>
0    0    0     0     1	RDRAM Register Write	X	X	This lOP performs the serial write of the RDRAM register specified by SDA and DRA fields. The write data is provided in the DRD register. A write operation to all RDRAM devices on the channel can be performed by setting the BA field to 1.<br>
0    0    0     10	RDRAM Set Reset	x	X	This lOP performs the serial setting of a reset bit in an RDRAM device specified by<br><br><br><br><br><br><br><br><br><br>
Bits [18, 3:0]	Operation Name	BA	SDA	Details<br>
				of all RDRAM devices. The bank address is specified by SDA field.<br>
.1     1   0      1      1	RDRAM Precharge	1	X	Upon receiving this IOP, the MCH sends a Precharge PCP packet to the specified bank of all RDRAM devices. The bank address is specified by SDA field.<br>
Details of operations conducted by one embodiment of the initialization control circuit 320 in response to receiving the RDRAM Core Initialization IOP (10000b) are shown in Figure 4. In block 400, a broadcast powerdown exit command is issued on the bus. Next, as per block 405, the sequence indicated by blocks 410 to 470 is repeated sixteen times for bank addresses zero to thirty-one. These numbers may be appropriate for a memory subsystem having one hundred and twenty-eight current calibration levels and up to thirty-two banks. In other embodiments, a different number of repetitions may be used if, for example, a larger or smaller number of current calibration levels are available. Similarly, differing numbers of banks may be available in different systems.<br>
In block 410, no operation is performed to ensure that the powerdown exit is complete and that the refresh operation (REFA command) is properly performed in block 415. In block 420, another no operation command is executed, followed by two more refresh operations (REFA) in blocks 425 and 430. Three more no operation commands are executed in block 435, allowing sufficient time to pass before a refresh precharge (REFP) command occurs. After another no operation command in block 445, another refresh precharge (REFP) command is executed in block 450.<br><br><br>
A calibrate (CAL) command is next executed in block 455. This command calibrates (drives) IOL current for the presently indicated device. As -indicated in blocks 460 and 465, this operation may be repeated twice. Then, as indicated in block 470, a sample (SAMR) command is executed. The sample command updates the IOL current for the presently indicated device. Until all sixteen repetitions for the thirty-two banks are performed, this process is repeated."<br>
Initialization Sequence<br>
With the above initialization operations, a system may be initialized. For example, the system shown in Figure 5, which implements a Rambus Direct RDRAM channel, may be initialized. In this system, a memory controller 500 (also referred to as a memory control hub or MCH) orchestrates initialization activities. The memory controller also initiates specific ROW/COLUMN packets on the channel. A serial interface 540 may be used to communicate with devices on the channel. For example, clock (SCK), serial frame (CMD), and bi¬directional serial I/O (SIO0 and SI01) pins may be used to read and write RDRAM configuration registers as well as to perform other lOPs.<br>
The memory controller includes a Rambus ASIC Cell (RAC) 530, a<br>
	control circuit 520, and a variety of registers.    The registers include a<br>
initialization registers 515, which are used to initialize the system memory, and<br>
powerdown restoration registers 510. The powerdown restoration registers<br>
contain timing and other information crucial to operating the memory channel.<br>
In other.words, the powerdown restoration registers are simply registers that<br>
need to be restored after powering down the memory controller 500 in order to<br>
resume accesses to the memory channel. The registers may be PCI<br>
configuration registers.  ......	<br>
The memory channel includes RIMM modules 560, 565, and 570 that are connected to the MCH 500 by a control and data bus 532 and a serial bus<br><br><br>
542.     The control and  data bus 532  may  be terminated by a resistive termination 533, and a Direct Rambus Clock Generator (DRCG) 580 may be -provided at the far end of the channel from the MCH 500 to provide clock signals over signal lines 582.<br>
Additionally, the system includes an Input/Output control hub (ICH) 505 which couples the MCH to a secondary bus 506 and may contain a second serial interface circuit 544 for interfacing with a second serial bus 546. A serial presence detect (SPD) memory 572 (a non-volatile memory such as an electrically erasable and programmable read only memory) for each module may be read via the serial interface 544 according to a serial presence detect protocol. The SPD memory 572 may provide information such as timing information, device organization, and device technology about each particular memory module. More details of the SPD protocol are discussed in the "Serial Presence Detect Application Brief as well as the Direct Rambus™ RIMM™ Module and the 64/72 Mbit Direct RDRAM™ data sheets available from Rambus.<br>
In one embodiment, the serial bus 546 is an I2C bus such as a system management bus (SMBus). This embodiment includes clock (SMBCLK) and data (SMBDATA) signals that follow the industry defined System Management Bus (SMBus) protocol as defined in the System Management Bus Specification, Revision 1.0, available from the Smart Battery Implemented Forum on the Internet at http://www.sbs-forum.org.<br>
The ICH has general purpose outputs (GPOs) which are used to control various system functions such as setting the frequency of the DRCG 580. A non-volatile memory 585 containing the BIOS may be coupled to the secondary bus 506, as well as a battery backed-up random access memory 590. The battery backed-up memory 590 may store powerdown restoration configuration values 592 for the MCH powerdown registers 510 so the MCH can resume accessing the RDRAM channel without performing the full initialization sequence detailed below.<br><br><br>
Briefly, the initialization process may be summarized as follows. After power up reset, the configuration information from Serial Presence Detection-(SPD) data on the RIMMs in a channel is read. For example, a storage device, SPD memory 572, stores configuration information for the RDRAMs 573, 574, 576, and 577 on the RIMM 570. The memory controller configuration registers are programmed with the appropriate values from the SPD information, and then the RDRAM device IDs are programmed such that each RDRAM device can be uniquely identified and accessed by the memory controller. Once a device has been initialized, it can be used.<br>
Each RDRAM device has two identification numbers that are used to uniquely select a device on the channel, the Serial Device ID, and the Group Device ID. These two IDs are used for distinct operations on the RDRAM channel. The serial device ID is used to select devices when the memory controller is sending initialization operations on the SCK, SIO, and CMD signals of the RDRAM channel. The group device ID is used by the memory controller to select a device when sending ROW packets and COLUMN packets on RQ[7:0] signals of the RDRAM channel. Both the serial device ID and the group device ID are programmed after reset and before devices may be individually addressed by initialization operations (lOPs) and ROW/COLUMN packets, respectively.<br>
Looking at the initialization process of the Rambus channel in more detail, a particular sequence may be followed to achieve correct operation of the RDRAM devices on the channel. Figure 6 illustrates a flow diagram for proper channel initialization in one embodiment, and Table 4 enumerates some of the variables used in this initialization flow.<br><br><br><br>
Table 4: Variables Used in Initialization<br><br>
Name	Width (bits)	Description<br>
RIMMMax	2	Maximum number of RIMMs present. 0    No RIMMs present 1-3 1-3 RIMM(s) present<br>
RIMMGount	2	Counter used during initialization to select a R1MM.<br>
RIMMDeviceCount	5	Number of RDRAM devices in a particular RIMM.<br>
MemberMax	5	Maximum number of devices present on a channel<br>
0-31      1 -32 RDRAM devices present on the channel<br>
MemberCount	5	Counter used during group device ID enumeration to indicate # of devices that have been assigned group IDs.<br>
SeriallDCount	5	Serial Device ID index used to select devices on a channel.<br>
0-31     Maps to serial device ID 0-31<br>
GroupDevicelDCount	5	Group Device ID index used during group device ID enumeration to assign a Group Device ID to the next RDRAM device.<br>
0-31      Maps to group device ID 0-31<br>
RIMMDeviceConfigNo	8	Byte indicating RDRAM technology definition. Bit definition matches GAR register.<br>
DRAMConfiglndex	3	Index into table of DRAM technologies supported by MCH. Used during group device ID enumeration assign group IDs to RDRAMs in a technology descending order.<br>
MchTrdly	3	Temporary storage of maximum Mch Trdly during channel levelization procedure. Bit definition matches the MCH's tRDLY field in the MCH RDT<br><br>
		register.<br>
DeviceTestAddress	32	32-bit CPU address used to test a RDRAM device during channel levelization.<br>
Templndex	8	Temporary index used during algorithm.<br>
In block 602, system reset occurs. The MCH resets all its state machines and prepares for initialization. In block 604, memory module configuration of the system is verified. The BIOS reads SPD data to determine the memory configuration. If only RIMMs are present, the RDRAM initialization sequence may proceed with block 608. If mixed memory modules are present, an error is posted to the user and the system is halted as indicated in 606.<br>
The clock generator is started in block 608. This operation may be accomplished by software querying the SPD data of every R1MM module present on the motherboard and determining a channel frequency at which all RIMMs may operate. The DRCG 580 may be set to the proper frequency by a general purpose output (i.e., GPOx as shown in Figure 5) from the ICH 505. In one embodiment, the BIOS waits at least 8ms between this step and the MCH RAC initialization.<br>
As indicated in block 610, the MCH RAC is next initialized. The channel clock from the DRCG should be stable prior to MCH RAC initialization. The MCH RAC initialization is accomplished by executing the MCH RAC initialization IOP. The RAC initialization lOP performs basic initialization to prepare the internal RAC of the memory controller for normal operation.<br>
In one embodiment, the BIOS provides a time out of 5ms for the llO bit to clear after the MCH RAC initialization IOP. If the IIO bit is not cleared by the MCH after 5ms, the BIOS should report the error, and the channel is unusable. An additional 5ms delay may be added after the MCH clears the HO bit due to completion of the MCH RAC initialization IOP. This allows sufficient time for the MCH clocks to stabilize and lock. Also in some embodiments, a bus in the RAC may need to be cleared before other operations commence. This may be<br><br>
accomplished by executing the MCH RAC Control Register Load IOP (DRD = OOOOOh).   It may also be possible to perform the RAC initialization at a later -point in the initialization sequence in some embodiments.<br>
As indicated in block 612, a number of MCH configuration registers may next be initialized. In one embodiment, the paging policy register RMC idle timer (PGPOL RIT) field (MCH 052h [2:0]) is set to 001b to ensure no pages are closed during channel levelization (discussed below). The PGPOL RIT field sets the number of host bus clocks that the memory controller will remain in the idle state before all open pages are closed, and a value of zero indicates that there will be an infinite latency before the memory controller starts closing pages.<br>
Additionally, in some embodiments, operating pools may be used to group RDRAMs based on defined RDRAM states. In order to reduce operating power, the RDRAM devices may be grouped into two operating pools called "Pool A" and "Pool B." In one embodiment, up to eight devices may be in Pool A at a time. In this embodiment, up to four out of eight devices in Pool A may be in Active Read/Write or Active states at a time, and the devices in Pool A are in either Active ReadA/Vrite, Active, or Standby states.<br>
The maximum number of devices in Pool A is programmable and is specified by a PAC field of the RDRAM power management register (RPMR) register (MCH 053h). All devices that are not in Pool A are members of Pool B. AH devices in Pool B are either in the Standby or Nap state. The state of the devices in Pool B is specified by a PBS field of a DRAM control (DRAMC) register (MCH 051 h). In one embodiment, the RPMR register is set to 00h, selecting a pool A of 1 device only, and Pool B operation is set for standby operation (MCH 051 h [6] = 0).<br>
Next," as indicated in block 614, additional channel initialization may be performed. This may include performing an SIO (serial interface) reset using the SIO reset IOP, and allowing sufficient delay for completion of the SIO reset sequence. Additionally, other registers which may need to be initialized for proper operation may be set at this point. For example, in some embodiments,<br><br><br>
a Test77 register may need to be written to with a zero value after the SlO reset as specified on page 37 of the Direct RDRAM 64/72 Mbit Data Sheet -(execute a Broadcast SlO Register Write IOP:  TEST77, DRA = 4Dh, DRD = OOOOh).<br>
Serial Device ID Assignment<br>
As indicated in block 620, serial device identification values (IDs) may be assigned next. In general, the software uniquely identifies each device on the channel to allow initialization operations to be targeted at individual devices. The serial device ID for each RDRAM is stored in the RDRAM 1NIT register (index 21 h) in bits 4-0. After SlO reset, the default value of the serial device ID is 1Fh in all RDRAMs on the channel. Also, after reset, the Serial Repeater (SRP bit (RDRAM 021 h[7]) is set to 1, enabling each RDRAM to propagate SlO data received on SIO0 to the RDRAM's SIOI pin, passing the SlO packet to the next RDRAM device. Since all devices have the same serial device ID after reset, an individual device may not be accessed prior to assigning unique serial! Ds.<br>
Further details of the serial device enumeration performed by one embodiment are shown in Figure 7. In block 700, the variable SeriallDCount is initialized to zero. Next, as indicated in block 705, the SlO repeaters of all devices on thechannel are disabled (Broadcast SlO Register Write IOP. INIT, DRA = 21 h, DRD = 001 Fh). This operation causes all serial device IDs to be set to Qlfh. -The SlO repeater bit is set to zero, so only the first device on the SlO channel can be accessed. <br>
  Starting  With block 710, the process loops through all devices on the channel and assigns a unique ID to each. The serial ID of the current device is set to SeriallDCount and the SlO repeater bit is enabled (SlO Register Write IOP:  INIT.SDCA =1Fh, DRA = 21h, DRD = 0080h + SeriallDCount).  Next whether the device is actually present and functioning in the system is tested<br><br><br>
as indicated in block 715. The RDRAM !NIT register is read to determine if the same value which was just written is properly read back out (SIO Register -Read IOP. INIT, SDCA = SeriallDCount, DRA = 21 h).<br>
If the data matches (as tested in block 720), seriallDcount is incremented (block 725), and the seriallDCount is checked to see whether a maximum number of devices (e.g., thirty-two) have been given IDs (block 730). If the seriallDCount still indicates a valid serial ID, the next device is identified in block 705.<br>
If the seriallDCount exceeds the maximum permissible value, or if the data did not match in block 720, then the last device has been given an ID, and a variable tracking the total number of devices may be set to the seriallDCount as indicated in block 735. Finally, to disable any additional devices beyond the last permitted device, the SIO repeater of the RDRAM with the highest serial ID is disabled as shown by block 740. Accordingly, any additional devices (i.e., improperly functioning devices or devices beyond the maximum, e.g., thirty-two) do not receive commands and therefore should not respond. As an additional check, the SPD information on the RIMMs may be examined to determine if the final device count is correct.<br>
Group Device ID Assignment<br>
Returning to Figure 6, after the unique serial IDs have been assigned and the SIO output of the last device disabled, group IDs are assigned based on memory device size as indicated in block 630. In one embodiment, the MCH supports up to thirty-two RDRAM devices and eight groups. Each group has up to four devices and has a group boundary access register (GBA) to define the group ID and the upper and lower addresses for each group. Thus, each GBA register may be programmed with a group ID and a nine bit upper address limit value. Unpopulated groups may have a value equal to the previous group and a group size of zero.<br><br><br>
Additionally, the flowchart in Figures 8A - 8C illustrates one embodiment<br>
of the process of enumerating group device IDs indicated in block 630.   As -<br>
indicated in block 800 in Figure 8A, a number of variables are initialized.<br>
Variables	Serial! DCount,	GroupDevicelDCount,	RIMMCount,<br>
RIMMDeviceCount, and RIMMDeviceConfigNo are initialized to zero. A DRAMConfiglndex variable is initialized to a value indicating the largest core technology supported by the MCH.<br>
As indicated in block 805, data is read from the SPD memory of a module (module number RIMMCount) identifying the core technology of that module. This information may include the number of rows per device, the number of columns per device, the number of banks per device, and whether the banks are dependent or independent. Next, as indicated in block 810, the RIMMDeviceConfigNo is set by translating the core technology value read from the SPD into a value in a Group Architecture (GAR) register equivalent value.<br>
Next, as indicated in block 815, the RIMMDeviceCount variable is set to the number of devices indicated by the SPD memory for that RIMM. Thereafter, the device IDs may be assigned and associated register values set as indicated in block 820. Further details of the process indicated in block 820 for one embodiment are shown in Figure 8B.<br>
In general, the enumeration process adds the number of RDRAM<br>
devices on a RIMM to the first Serial ID and then counts down until the RIMM<br>
is finished. . ..Therefore, as indicated in block 822, whether<br>
RIMMDeviceConfigNo equals the DRAMConfiglndex is tested to determine<br>
whether group device IDs have been assigned for all devices in a particular<br>
core technology. - If they are unequal, all devices for that core technology have<br>
group IDs, so the SeriallDCount is set to SeriallDCount plus<br>
RIMMDeviceCount (as indicated in block 830) and the process returns to<br>
Figure 8A as indicated in block 832. Additionally, if RIMMDeviceCount is zero<br>
(as tested in block 824) or MemberCount is zero (as tested in block 826), there<br>
are no more devices to give group IDs and the process returns to Fig. 8A as<br>
indicated in block 832.	'    •<br><br>
If RIMMDeviceCount and MemberCount are not zero, a GroupDevicelDCount is assigned to be the group device ID of the RDRAM with the serial ID equal to the present value of SeriallDCount as indicated in block 828. Next, the current group boundary address register (GBA) is updated to . reflect the addition of the new device to this group as indicated in block 830. This may be accomplished by adding a value indicative of the device size to the previous value stored in that GBA register.<br>
Next, the GroupDevicelDCount is compared to four (the maximum number of devices per group in one embodiment) in block 832. If the group is full, the MCH Group Architecture Register (GAR) for that group is updated as indicated in block 834. The GAR is updated to properly indicate the group configuration (i.e., the number of banks and the DRAM technology (size)). In. block 836, SerialDevicelDCount is incremented, MemberCount is decremented, GroupDevicelDCount is incremented, and RIMMDeviceCount is decremented. The process then returns to block 824.<br>
' Returning to Figure 8A, if either RIMMDeviceCount or MemberCount is zero, RIMMCount is incremented as indicated in block 850. If RIMMCount is less than a maximum RIMMCount, as tested in block 855, then the process returns to block 805. If the RIMMCount has reached the last RIMM, the process continues in Figure 8C as indicated by block 860.<br>
Turning to Figure 8C, if MemberCount is zero (as tested in block 865), the device ID enumeration process ends. If, however, MemberCount is not zero, the next MCH group is selected to start enumerating the devices in the next DRAM technology as indicated in block 870. GroupDevicelDCount may be updated by adding three and performing a logical AND operation of the resulting value and OFFFCh.<br>
If GroupDevicelDCount is a maximum number devices allowed in the channel (e.g., thirty-two as tested in block 872), then the group ID enumeration process ends. If, however, fewer devices have been given group ID numbers, the DRAMConfiglndex is set to the next smallest core technology supported by the MCH as indicated in block 874.   If the DRAMConfiglndex indicates that<br><br><br>
there are no smaller core technologies supported (e.g., DRAMConfiglndex is zero as tested in block 876), then the ID enumeration process ends.   If there -are more core technologies, seriallDCount and RIMMCount are reset to zero, as indicated in block 878, and the process returns to block 805 in Figure 8A.<br>
The psuedo-code below indicates operations that may be used to perform the group ID enumeration indicated by block 630 of Figure 6 in one embodiment. 630.   Enumerate MCH device groups.<br>
630.1. Loop through RIMM SPD memory and group the devices on the RIMMs. The largest technology devices must be grouped in the lowest groups, with the technology size decreasing as the group #s increase.<br>
630.1.1.	Set MemberCount = MemberMax<br>
630.1.2.	Set SeriallDCount = 0. This is the Serial Device ID counter<br>
630.1.3.	Set GroupDevicelDCount.= 0. This is the Group Device ID counter<br>
630.1.4.	Set RIMMCount = 0. This is the RIMM counter<br>
630.1.5.	Set RIMMDeviceCount = 0. This is the counter for the # of devices on a RIMM.<br>
630.1.6.	DRAMConfiglndex= Largest technology supported by<br>
MCH<br>
     630.1.7.   Compute RIMM #RlMMCount's core technology<br>
  630.1.7.1.RIMMDeviceConfigNo = core technology read from RIMMs SPD.         630.1.8.   RIMMDeviceCount = # of RDRAM devices in RIMM<br>
,    #RIMMCount, read from the RIMM's SPD EEPROM. 630.1.9.   Assign group device IDs and program MCH GAR and              GBA registers for RIMM.<br>
     630.1.630.1. If RIMMDeviceConfigNo !=<br>
DRAMConfiglndex, break to 630.1.10<br><br><br>
630.1.9.2.lf RIMMDeviceCount = 0, break to 630.1.10 630.1.9.3.lf MemberCount = 0, break to 630.1.10 630.1.9.4.SIO Register Write IOP. DEVID, SDCA =<br>
SeriallDCount, DRA = 40h, DRD =<br>
GroupDevicelDCount. 630.1.9.5.Program MCH GBA[GroupDeviceIDCount SHR<br>
2] = MCH GBA[GroupDevicelDCount SHR 2 - 1] +<br>
RIMM #RIMMCount device size. 630.1.9.6.lf GroupDevicelDCount AND 011 b = 0<br>
630.1.9.6.1.  Program MCH<br>
GAR[GroupDevicelDCount SHR 2] = RIMMDeviceConfigNo 630.1.9.7.lncrement GroupDevicelDCount 630.1.9.8.lncrement SeriallDCount 630.1.9.9.Decrement MemberCount<br>
630.1.9.10.	Decrement RIMMDeviceCount<br>
630.1.9.11.	Go to step 630.1.9.2<br><br>
630.1.10.	Increment RIMMCount<br>
630.1.11.	If RIMMCount 
630.1.12.	If MemberCount = 0 then break to step 10<br>
630.1.13.	Select next group for next RDRAM technology. 630.1.13.1.   GroupDevicelDCount =<br>
(GroupDevicelDCount + 011 b) AND 011 b<br>
630.1.14.	If GroupDevicelDCount = 32 then break to step 10<br>
630.1.15.	DRAMConfiglndex = next smallest DRAM technology<br>
630.1.16.	if DRAMConfiglndex = 0, then break to step 10<br>
630.1.17.	SeriallDCount = 0<br>
630.1.18.	RIMMCount = 0<br>
630.1.19.	Go to step 630.1.7. This will begin searching the RIMMs for the next smallest RDRAM technology.<br><br>
Returning to Figure 6, after the group IDs have been assigned, the individual RDRAM devices may be brought out of powerdown mode and put -into fast clock mode for normal operation as indicated in step 640. The individual RDRAM timing registers in the MCH and RDRAMs may be programmed. The REFB and REFR RDRAM control registers may also be initialized (Broadcast SIO Register Write IOP. REFB, DRA = 41 h, DRD = OOOOh; Broadcast SIO Register Write IOP. REFR, DRA = 42h, DRD = OOOOh).<br>
The RDRAM devices may be reset by executing a Broadcast Set Reset IOP, followed by an appropriate delay (e.g., 32 us), then executing a Clear Reset IOP, also followed by an appropriate delay (e.g., 4us) to allow for the reset operation to complete. The RDRAMs are brought out of powerdown by executing a broadcast RDRAM power down exit IOP, and the fast clock mode is entered by executing a broadcast RDRAM Set Fast Clock Mode Initialization IOP.<br>
Thereafter, the RDRAM cores may be initialized as indicated in block<br>
642. Further details of one embodiment of the RDRAM core initialization are<br>
shown in Figure 9. As indicated in block 900, the RDRAM devices are<br>
prepared for current calibration by writing an intermediate value to the<br>
appropriate RDRAM registers (Broadcast SIO Register Write IOP. CCA, DRA =<br>
43h, DRD = 0040h; Broadcast SIO Register Write IOP. CCB, DRA = 44h, DRD<br>
= 0040h). Forty hexadecimal may be an appropriate intermediate value in an<br>
embodiment that has one hundred and twenty-seven possible current<br>
calibration levels. Starting at this intermediate value limits the total number of<br>
calibration cycles needed since the calibration value could only be off by,<br>
approximately half than the full range of calibration values.	<br>
Next,, precharge operations are performed on each bank of each RDRAM device.   To perform the precharge operations, the MCH counts up       through the banks by two, first precharging odd banks, and then even ones. A bank index is set to zero in block 905.   A broadcast precharge IOP is then executed as indicated in block 910.  The bank index value is incremented by two as indicated in block 915, and the broadcast precharge is repeated for<br><br>
even banks until the bank index is found to be equal to a maximum number of banks (e.g., thirty two) in block 920.<br>
Once the maximum number of banks is reached, the bank index is set to one (as indicated in block 930), and all odd banks are precharged. Once the bank index exceeds the maximum number of banks, the RDRAM Core Initialization IOP is executed six times as indicated in block 940.<br>
Channel Levelization<br>
Returning to Figure 6, after the initialization of the RDRAM cores in block 642, the channel may be levelized as indicated in block 644. This process involves equalizing the sum of the RDRAM read response time and a propagation delay from the RDRAM to the MCH for all RDRAMs. In other words, once the channel is levelized, all RDRAMs will provide data at the memory controller in the same number of bus cycles.<br>
The following psuedo-code indicates a sequence of steps that may be performed in one embodiment to implement the levelization process indicated in block 644. 644.   Levelize the Rambus channel<br>
644.1. Phase 1: Determine MCH tRDLY field value.<br>
644.1.1.	SeriallDCount = MemberMax<br>
644.1.2.	MchTrdly = 0<br>
644.1.3.	Program MCH RDT:TRDLY field = MchTrdly.<br>
644.1.4.	Compute the 32 bit address to test the RDRAM device for levelization.<br>
644.1.4.1 .SIO Register Read IOP. DEVID, SDCA =<br>
SeriallDCount, DRA = 40h 644.1.4.2.The DRD (MCH 090h [15:0]) now contains the<br>
RDRAM's Device ID<br><br><br>
644.1.4.3.DeviceTestAddress = MCH GBA[(DRD SHR 2)-1] SHL 23 + ((DRD AND 011b) * device size in bytes (from GAR[DRD SHR 2])<br>
644.1.5.	Do QWORD write operation to address<br>
             DeviceTestAddress with TestPattem.<br>
644.1.6.	Do QWORD read operation to address DeviceTestAddress<br>
644.1.7.	If data read != TestPattem<br>
644.1.7.1.Increment MCH RDT:TRDLY field.          644.1.7.2. If MCH RDT:TRDLY field 
644.1.8.	Else (if data read = TestPattem)<br>
644.1.8.1 .MchTrdly = data read from MCH RDT:TRDLY                          field   <br>
       644.1.8.2,if MchTrdly = 4 then break to step 644.2<br>
644.1.9.	Decrement SeriallDCount<br>
644.1.10.	If SeriallDCount &gt;= 0 then go to step 644.1.3 <br>
644.2. Phase 2: Determine the RDRAM's fevelization timing values<br>
644.2.1.	SeriallDCount = MemberMax<br>
644.2.2.	Compute the 32 bit address to test the RDRAM device   for levelization. 644.2.2.1.SIO Register Read IOP. DEVID, SDCA=            SeriallDCount, DRA = 40h              <br>
644,.2.2.The DRD (MCH 090h [15:0]) now contains the<br>
           RDRAM's Device ID	<br>
      644i£2.3.DeviceTestAddress = MCH GBA[(DRD SHR 2) l] SHL 23 ,+ ((DRD AND 011b) * device size in bytes (from GAR[DRD SHR 2])    644.2.3.;Do QWORD write operation to address       DeviceTestAddress with TestPattem.<br><br><br>
644.2.4.	Do QWORD read operation to address DeviceTestAddress<br>
644.2.5.	If data read = TestPattern then break to step 644.2.8<br>
644.2.6.	If TCDLY field of RDRAMs 
&amp; TRDLY) according to the TCDLY support table. 644.2.6.2.Break to step 644.2.3<br>
644.2.7.	Mark the RDRAM device to be disabled.<br>
644.2.8.	Decrement SeriallDCount<br>
644.2.9.	If SeriallDCount &gt;= 0 then go to step 644.2.2<br>
After levelization completes, one embodiment stores a number of powerdown recovery memory initialization values in the battery backed-up memory 590 of Figure 5 as indicated in block 646. Notably, this operation may be performed at any other stage after the appropriate values have been determined by the initialization routine. The values are saved to preserve the initialization information determined by the initialization process to this point.<br>
When a low power state (e.g., suspend-to-RAM) is entered by the system, power to the MCH may be removed. Thus, if the initialization information is not preserved, the entire initialization process may have to be repeated. Storing key initialization information to a non-volatile memory may advantageously speed wake-up from such a low power state. The difficulty of storing such information is increased by the fact that the memory subsystem will not be functional until these values are restored.<br>
Any non-volatile memory which can be written to may be used to store the appropriate initialization information; however, a battery backed-up memory is present in many computer systems and therefore may be a convenient choice. In one embodiment, the registers below are stored in the memory 590. *    MCH Group Architecture (GAR) registers (040-047h): These registers<br>
indicate device configuration for each group such as the number of banks<br>
and the DRAM technology (size).<br><br><br>
•	MCH RDRAM Timing Register RDT (050h): This register defines the timing parameters for all devices in the channel.<br>
•	MCH DRAM Control (DRAMC) register (051 h): This register includes the Pool B Operation Select (PBS) bit, a memory transfer hub presence bit (MTHP), which specifies an operational mode of the MCH, and an Aperture Access Global Enable bit which prevents access to an aperture from any port before the aperture range and translation table are established.<br>
•	MCH Page Policy (PGPOL) Register (052h): This register specifies paging policy attributes include a DRAM Refresh Rate (DRR) and a RMC Idle Timer (RIT). The DRR field adjusts the DRAM refresh rate and the RIT field determines the number of host bus clock cycles that the memory controller will remain in the idle state before all the open pages are closed.<br>
•	MCH RPMR (053h): This register includes a Device Napdown Timer (DNT) field, an Active Devices in Pool A (ADPA) field, a Device Napdown Enable (DNE) field, and a Pool A Capacity (PAC) field. The DNT field specifies the number of host clocks the memory controller is idle before the least recently used device in Pool A is pushed out to Pool B. The ADPA field defines the maximum number of RDRAM devices in Pool A that can be in Active Read/Write or Active st00ate at a time. The devices in Pool A that are not in Active Read/Write or Active state are in standby state. The DNE bit (when set to 1) enables the channel inactivity counter to count continuous.. inactivity time. When the counter value exceeds the threshold specified by DNT, the least recently used device from Pool A is pushed to Pool B. The PAC field defines the maximum number of RDRAM devices that can reside in Pool A at a time. Devices that are not part of Pool A belong to Pool B.<br>
•	MCH Group Boundary Access (GBA) registers (060-6Fh): The GBA .-.-; registers contain a group ID and a value indicating the upper address limit for the group.<br>
•	MCH Configuration Registers MCHCFG (QBE-BFh): These registers contain the Rambus Frequency &amp; DRAM Data Integrity Mode fields.<br><br>
Also,    at   this    point    powerdown    configuration    options    may    be -programmed.   In one embodiment, the self refresh and low power self refresh options are set (for each SeriallDCount: SIO Register Write IOP. 1NIT, SDCA = SeriallDCount, DRA = 21 h, DRD = 400h (LSR, if SPD supports) + 200h (PSR) + 80h(SRP)).<br>
Normal operation may start, as indicated in block 650, after a few more registers are programmed for normal operation. The page policy register is set to operate normally (PGPOL RIT. field (MCH 052h [2:0]) to 001b) since the page closing timer was effectively disabled for leveiizing, and the power management features are enabled at this point via the RPMR register (MCH 053h). If the Pool B Select bit (MCH 051b [6]) is configured for NAP operation, a broadcast NAP entry IOP may be executed to put all devices to the NAP state. In the same I/O instruction that sets the HO bit, set the IC bit in RICM also to one so that normal operations of the MCH may commence.<br>
Restoring the Channel when Exiting a Low Power State<br>
After normal operation continues for some time, the system may enter a low power state due to system inactivity or for another reason, as indicated in block 1000 of Figure 10. One state which the system may enter is a suspend-to-RAM (STR) state in which the MCH loses values stored in its registers. After entering the STR state, an event which causes the system to exit STR may be sensed as indicated in block 1010. Accordingly, the BIOS powers up the MCH and other system components. The configuration registers of the MCH may be automatically reset to a default value in this process.<br>
Accordingly, to again access memory devices on the memory channel, at least some of the configuration register values are needed. The BIOS may cause the ICH 505 to access the battery backed-up memory 590 and restore the registers listed below (saved in block 646 of Figure 6).<br><br><br>
•	MCH GAR registers (040-047h)<br>
•	MCH RDT (050h)<br>
•	MCHDRAMC(051h)<br>
•	MCH PGPOL (052h)<br>
•	MCH RPMR (053h)<br>
.	MCH GBA registers (060-6Fh)<br>
-	MCH Configuration Registers MCHCFG (OBE-BFh)<br>
After restoring values to these registers, the MCH can once again access items stored in memory when the STR state was entered, including such items as the processor context if saved. The memory devices perform self-refresh in the STR state so other data is not lost.<br>
Next, the clock generator is started as indicated in block 1040. The proper Rambus channel frequency is read from the MCH MCHCFG register (MCH OBEh [11], which was restored in block 1030). After the clock is allowed to stabilize, the MCH RAC is initialized as indicated in block 1050. This may be accomplished by executing the MCH RAC Initialization IOP. Additionally, the DRD register may be loaded with OOOOh and the MCH RAC control register load IOP executed to initialize a bus in the RAC (as discussed with respect to block 610).<br>
Next, current calibration is performed as indicated in block 1060. This may be performed as discussed with respect to block 642 and Figure 9. In the final iteration indicated by block 940, however, the fC bit in the RICM register may be set, allowing normal operations to immediately commence once the current calibration has completed. Thus, the resume from STR sequence may be substantially faster than the entire initialization sequence required when the system is first powered up since channel levelization, SPD querying, ID assignment, and a number of other initialization operations may be avoided.<br>
In conclusion, a method and apparatus for initializing a memory device<br><br><br>
and a memory channel is disclosed. While certain exemplary embodiments have been described and shown in the accompanying drawings, it is to be understood that such embodiments are merely illustrative of and not restrictive on the broad invention, and that this invention not be limited to the specific constructions and arrangements shown and described, since various other modifications may occur to those ordinarily skilled in the art upon studying this disclosure.<br><br><br><br>
WE CLAIM:<br>
1.	A method for configuring and initializing a memory device and a<br>
memory channel comprising;<br>
initializing a memory controller;<br>
initializing a plurality of memory controller configuration registers;<br>
assigning serial identification numbers to a plurality of memory devices which are coupled to the memory controller;<br>
assigning device identification numbers to groups of the plurality of memory devices based at least in part on memory device sizes by:<br>
assigning a set of lowest identification numbers to memory devices having a largest supported size; and<br>
assigning subsequent identification numbers to remaining memory devices having smaller sizes;<br>
programming registers in each of the plurality of memory devices to equalize a sum of a device response time and a propagation delay from each memory device to the memory controller for all of the plurality of memory devices; and<br>
enabling the plurality of memory devices.<br>
2.	The method as claimed in claim 1 wherein initializing the memory controller optionally comprises resetting the memory controller and a memory interface circuit.<br>
3.	The method as claimed in claim 1, optionally comprising, before assigning serial identification numbers:<br>
resetting a serial interface.<br>
4.	The method as claimed in claim 1 optionally comprising:<br>
testing whether the plurality of memory devices are  of a pre-<br><br><br>
defined type of memory device; and signaling an error if one of the plurality of memory devices is of a type other than the pre-defined type.<br>
5.	The method as claimed in claim 4 wherein testing whether the<br>
plurality of memory devices are the first type of memory devices<br>
comprises:<br>
testing whether the plurality of memory devices are Rambus RDRAMS; and disabling any of the plurality of memory devices which are different types of memory devices.<br>
6.	The method as claimed in claim 1 wherein assigning device<br>
identification numbers to the plurality of memory devices optionally<br>
comprises:<br>
reading a value indicating a core technology size from a selected memory module; repeating, for each device on the selected memory module:<br>
assigning a device identification number that is a function of a group counter and the value indicating the core technology size; and<br>
incrementing the group counter.<br>
7.	The method as claimed in claim 6 optionally comprising:<br>
updating a group attribute register for each device in the selected<br>
memory module.<br>
8.	The method as claimed in claim I wherein assigning serial<br>
identification numbers to the plurality of memory devices optionally<br>
comprises:<br>
assigning sequential and unique serial identification numbers to the plurality of memory devices according to a serial sequence of the plurality of memory devices along a serial bus.<br><br><br>
9.	The method as claimed in claim 1 wherein assigning serial<br>
identification numbers optionally comprises:<br>
disabling a serial output of a last memory device having a serial identification number equal to a maximum device count.<br>
10.	The method as claimed in claim 1 wherein initializing the memory controller comprises initializing a Rambus Application Specific Integrated Circuit (ASIC) Cell (RAC).<br>
11.	A method for configuring and initializing a memory device and a memory channel comprising:<br>
initializing a memory controller;<br>
initializing a plurality of memory controller configuration registers;<br>
assigning serial identification numbers to a plurality of memory devices which are coupled to the memory controller;<br>
assigning device identification numbers to groups of the plurality of memory devices based at least in part on memory device sizes;<br>
programming registers in each of the plurality of memory devices to equalize a sum of a device response time and a propagation delay from each memory device to the memory controller for all of the plurality of memory devices; and<br>
enabling the plurality of memory devices.<br>
12.	A method for configuring and initializing a memory device and a<br>
memory channel comprising:<br>
initializing a memory controller;<br>
initializing a plurality of memory controller configuration registers;<br>
assigning serial identification numbers to a plurality of memory devices which are coupled to the memory controller;<br>
assigning device identification numbers to groups of the plurality of memory devices based at least in part on memory device sizes by:<br><br><br>
determining device size information for each of a plurality of memory modules;<br>
selecting a selected memory module based on its device size;<br>
assigning device identification numbers to at least one group of devices on the selected memory module; and<br>
repeating selecting a next selected memory module and assigning device identification numbers until all devices have device identification numbers; and<br>
programming registers in each of the plurality of memory devices to equalize a sum of a device response time and a propagation delay from each memory device to the memory controller for all of the plurality of memory devices.<br>
13.	A method for configuring and initializing a memory device and a<br>
memory channel comprising:<br>
initializing a memory controller;<br>
initializing a plurality of memory controller configuration registers by:<br>
initializing a group boundary address register; initializing a group architecture register; initializing a RDRAM timing register; initializing a RDRAM control register; initializing a RDRAM power management register; and initializing a RDRAM initialization control register<br>
assigning serial identification numbers to a plurality of memory devices which are coupled to the memory controller;<br>
assigning device identification numbers to groups of the plurality of memory devices based at least in part on memory device sizes; and<br>
enabling the plurality of memory devices.<br>
14.	A method for configuring and initializing a memory device and a<br>
memory channel comprising:<br>
initializing a memory controller;<br><br><br>
initializing a plurality of memory controller configuration registers;<br>
assigning serial identification numbers to a plurality of memory devices which are coupled to the memory controller;<br>
assigning device identification numbers to groups of the plurality of memory devices based at least in part on memory device sizes; enabling the plurality of memory devices by: resetting the plurality of memory devices;<br>
broadcasting a power down exit initialization operation; broadcasting a set fast clock mode initialization operation; and initializing a core of each of the plurality of memory devices<br>
15.	The method as claimed in claim 14 wherein initializing the core of<br>
each of the plurality of memory devices comprises:<br>
preparing the plurality of memory devices for current calibration; sending precharge operations to each bank of each memory device; and executing a core initialization operation.<br>
16.	The method as claimed in claim 15 optionally comprising:<br>
executing the core initialization operation five additional times.<br>
17 A method for configuring and initializing a memory device substantially as herein described with reference to and as illustrated in the accompanying drawings. Dated this 12th day of May,  2005.<br>
[RAJAN AILAVADI] OF REMFRY &amp; SAGAR ATTORNEY FOR APPLICANTS</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtYWJzdHJhY3QoMDUtMDQtMjAwNykucGRm" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-abstract(05-04-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtYWJzdHJhY3QoZ3JudGVkKS0oMDUtMDQtMjAwNykuZG9j" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-abstract(grnted)-(05-04-2007).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtY2FuY2VsbGVkIHBhZ2VzKDA1LTA0LTIwMDcpLnBkZg==" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-cancelled pages(05-04-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtY2xhaW1zKGdyYW50ZWQpLSgwNS0wNC0yMDA3KS5kb2M=" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-claims(granted)-(05-04-2007).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtY2xhaW1zKGdyYW50ZWQpLSgwNS0wNC0yMDA3KS5wZGY=" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-claims(granted)-(05-04-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtY29ycmVzcG9uZGVuY2UoMDUtMDQtMjAwNykucGRm" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-correspondence(05-04-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtY29ycmVzcG9uZGVuY2UoaXBvKS0oMTctMTAtMjAwNykucGRm" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-correspondence(ipo)-(17-10-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtZHJhd2luZygwNS0wNC0yMDA3KS5wZGY=" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-drawing(05-04-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtZm9ybSAxKDA1LTA0LTIwMDcpLnBkZg==" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-form 1(05-04-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtZm9ybSAxKDEyLTA1LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-form 1(12-05-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtZm9ybSAxOCgxMC0xMS0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-form 18(10-11-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtZm9ybSAyKGdyYW50ZWQpLSgwNS0wNC0yMDA3KS5kb2M=" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-form 2(granted)-(05-04-2007).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtZm9ybSAyKGdyYW50ZWQpLSgwNS0wNC0yMDA3KS5wZGY=" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-form 2(granted)-(05-04-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtZm9ybSAzKDExLTA1LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-form 3(11-05-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtZm9ybSA1KDExLTA1LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-form 5(11-05-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDE4LW11bW5wLTIwMDUtcG93ZXIgb2YgYXV0aG9yaXR5KDA1LTA0LTIwMDcpLnBkZg==" target="_blank" style="word-wrap:break-word;">418-mumnp-2005-power of authority(05-04-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="211097-portable-fumigator.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="211100-a-banknote-handling-system.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>211098</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>418/MUMNP/2005</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>20/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>16-May-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>17-Oct-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>12-May-2005</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTEL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2200 MISSION COLLEGE BOULEVARD, SANTA CLARA, CALIFORNIA 95052, UNITED STATES OF AMERICA.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>WILLIAM A. STEVENS</td>
											<td>111 ECONOME COURT, FOLSOM, CA 95360 USA</td>
										</tr>
										<tr>
											<td>2</td>
											<td>PUTHIYA K. NIZAR</td>
											<td>1762 DARWIN WAY, E1 DORADO HILLS, CA 95762, USA</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 12/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US99/24752</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>1999-10-22</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09/186,051</td>
									<td>1998-11-03</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/211098-a-method-for-configuring-and-initializing-a-memory-device-and-memory-channel by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:31:21 GMT -->
</html>
