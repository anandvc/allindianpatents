<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/213943-system-and-method-for-caching-data-for-a-mobile-application by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 07:01:39 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 213943:SYSTEM AND METHOD FOR CACHING DATA FOR A MOBILE APPLICATION</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">SYSTEM AND METHOD FOR CACHING DATA FOR A MOBILE APPLICATION</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A cache table comprises a set of access parameters and a set of data columns. One or more instances of a cache table are stored on a mobile computing device. Each instance includes an argument (a unique set of values for the access parameters) and a result set (a set of values for the data columns). Thus, each result in a result set comprises the argument and corresponding column values. Cached result sets have specified periods of validity, and may or may not be usable after becoming invalid. Valid cached data may be used regardless of whether a connection is available to a data source (e.g., data or application server). Invalid data may be used for a period of time if no connection is available to the data source. Data in a cache table may be selectively updated from a data source without synchronizing the entire local database. (FIG. 1)</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>SYSTEM AND METHOD FOR CACHING DATA<br>
FOR A MOBILE APPLICATION<br>
BACKGROUND<br>
This invention relates to the field of computer systems. More particularly, a<br>
system and methods are provided for caching data on a mobile device.<br>
Applications operated on mobile devices (e.g., laptop computers, personal digital<br>
assistants, mobile telephones) have generally been designed for either online or offline<br>
use. Both types of mobile applications tend to use some form of browser to interact with<br>
a user. Online applications enjoy continual access to an enterprise server (e.g., central<br>
database server). Offline applications, in contrast, operate with minimal or no contact<br>
with an enterprise server.<br>
More specifically, an online mobile application can access data on the enterprise<br>
server whenever needed, thereby possibly obviating any need to store data locally.<br>
However, because of the "always connected" nature of an online mobile application,<br>
connection costs (e.g., for wireless air time) can be quite high.<br>
Also, an online mobile application generally suffers from unpredictable latency.<br>
When the online application transmits a request to the server, the response time depends<br>
upon the level of usage of the mobile device"s wireless network in addition to any<br>
congestion at the server. Further, usage of the online application may be geographically<br>
limited, depending on the extent of the wireless network, and may be prohibited in some<br>
locations (e.g., airplanes, hospitals).<br>
Yet further, online mobile applications often access data in sets, such as entire<br>
web pages, data tables, etc. When a data item needs to be replaced, the entire dataset may<br>
be replaced rather than just the one item. This can be inefficient and increase the cost of<br>
operating the application.<br>
One reason mobile applications tend to access data in sets (e.g., entire web pages),<br>
is that the data are tightly coupled to the presentation of the data. In particular, when data<br>
are copied or downloaded to a client device for a mobile application, each collection of<br>
data (e.g., a table, a set of database rows or fields) is typically conveyed within the page<br>
in which it will be displayed. Thus, the data cannot be displayed on the client except in<br>
that page. Because each set or collection of data may be stored with a full display page,<br>
and many pages may be identical except for their encapsulated data, much storage on the<br>
client may be wasted.<br>
In contrast to an online application, an offline mobile application does not enjoy<br>
continual access to data maintained by the enterprise server. Some data (e.g., a snapshot)<br>
from an enterprise server may be copied onto or replicated on a mobile device. Although<br>
the offline application may always be usable (e.g., when offline from the server), it will<br>
not always have fresh data, and it can only access data that were copied to it.<br>
An offline mobile application configured to use data snapshots is usually required<br>
to synchronize its stored, offline data with an enterprise server on an occasional or<br>
periodic basis (e.g., once per day). The frequency of synchronization is generally<br>
unrelated to the frequency with which data items are accessed or modified on the mobile<br>
device. Thus, many transactions or operations may be performed on the mobile device<br>
using stale data. And, synchronization may entail high overhead, as a large amount of<br>
data will often be exchanged - even data that have not changed and do not need to be<br>
refreshed. For example, an entire web page or set of web pages may be downloaded or<br>
exchanged even though only one data item in a page needs to be updated.<br>
Because of the infrequent rate of data synchronization, offline mobile applications<br>
are not suitable for use with data that are highly dynamic. In addition, an offline mobile<br>
application is often required to maintain a transaction log of all data changes made by the<br>
application, in order to facilitate synchronization.<br>
In general, enterprise data stored on a mobile device, for use with a mobile<br>
application, may have varying longevity. Some data points or items may be valid for<br>
long periods of time (e.g., a product description, an address); other data points or items<br>
may be invalid after only a relatively short period of time (e.g., a stock quote, a currency-<br>
conversion rate). Existing mobile applications and client databases typically are not<br>
configured to recognize or consider the longevity of downloaded data.<br>
Further, mobile client applications that attempt to provide significant functionality<br>
to users tend to require robust software and/or hardware configurations (e.g., a Java<br>
Virtual Machine, an HTTP listener, a servlet engine). Such requirements prevent the use<br>
of smaller, more restrained client devices, such as Personal Digital Assistants (PDA) or<br>
smart telephones, and also add overhead to client operations.<br>
SUMMARY<br>
In one embodiment of the invention, a system and methods are provided for fine-<br>
grained caching of data for use with an application executing on a mobile (e.g., wireless)<br>
device configured for use in a third generation wireless network or other enterprise<br>
network. In this embodiment, the device need not always access a central or master<br>
source of the data (e.g., a data, web or application server) and can use the cached data in<br>
an online or offline mode. Traditional synchronization operations between the device and<br>
the data source are unnecessary, as data cached on the mobile device may be selectively<br>
refreshed when needed. Thus, benefits of both modes of operation (e.g., fresh data,<br>
acceptable connection costs) are obtained.<br>
In an embodiment of the invention, data are cached in cache tables implemented<br>
as part of a local DBMS (Database Management System) of a mobile device. In this<br>
embodiment, a cache table is a table whose content (e.g., rows) are retrieved from a<br>
server, on demand, and cached locally according to cache control instructions associated<br>
with the content. A subset of the columns (or attributes) of a cache table is designated as<br>
the "access parameters" for the cache table. To retrieve data from a cache table, a value is<br>
provided for each of the access parameters. These values constitute an argument for one<br>
instance of the cache table. If the row(s) with those argument values are not in the local<br>
database, or have expired, the DBMS will contact the corresponding server to retrieve and<br>
cache the rows.<br>
For example, if a cache table is configured to report inventory figures for various<br>
warehouse locations in response to a specified part number, the cache table columns may<br>
include a part number, a warehouse number, and a quantity of the part stored in a<br>
corresponding warehouse. The part number, which is supplied as part of a query, may be<br>
an access parameter for the cache table. For each unique part number, a separate instance<br>
of the cache table includes a set of rows (a result set) that reports quantities of the part<br>
stored in each warehouse.<br>
In an embodiment of the invention, data caching is separated from application<br>
logic by encapsulating data caching policies within the cache tables. This relieves<br>
application developers from having to code caching policies as part of the application<br>
logic, and permits a database administrator to define caching policies.<br>
In another embodiment of the invention, an algorithm is provided to define the<br>
data and transactional semantics of cache tables, in a manner that is consistent with the<br>
ACID (Atomicity, Consistency, Isolation, and Durability) properties of database<br>
transactions. In particular, data stored in a cache table have associated periods of validity,<br>
which may be specified by a data source from which the data were obtained. Data may<br>
also have associated cache control information indicating whether, and how long, they<br>
may be used after becoming invalid, if no connection to the server is available. When a<br>
local database operation affects a cache table, the algorithm is applied to determine<br>
whether to use the cached data or attempt to refresh the data from the data source. The<br>
algorithm may consider whether a connection is available to the data source, whether the<br>
data are locked by the same or another transaction, whether the data are invalid, whether<br>
the associated cache control information allows the data to be used while invalid, etc.<br>
Illustratively, an embodiment of the invention enables a mobile device and<br>
application to access local data offline, and selectively refresh specific data (e.g., cache<br>
table result sets) as needed. As a result, connection costs (e.g., to a data source) and the<br>
use of stale data are minimized. And, because the cache table is a table, all mobile<br>
database applications can reap the benefits afforded by cache tables without having to<br>
write extra code in the application logic.<br>
DESCRIPTION OF THE FIGURES<br>
FIG. 1 is a block diagram depicting a mobile computing environment suitable for<br>
implementation of an embodiment of the present invention.<br>
FIG. 2 is a block diagram of a client device configured to cache data on a mobile<br>
computing device, in accordance with an embodiment of the invention.<br>
FIGs. 3A-B comprise a flowchart illustrating one method of using and refreshing<br>
a cache table in accordance with an embodiment of the invention.<br>
FIG. 4 depicts a mobile client device equipped with an intelligent client agent, in<br>
accordance with an embodiment of the invention.<br>
FIG. 5A is a flowchart demonstrating a method of operating a dispatcher, within<br>
an intelligent client agent, to process a requested page, in accordance with an embodiment<br>
of the invention.<br>
I"IGs. 5B-C comprise a flowchart demonstrating a method by which a script<br>
engine may assemble a page within an intelligent client agent, in accordance with an<br>
embodiment of the invention.<br>
FIG. 6 depicts a cache table, according to one embodiment of the invention.<br>
FIGs. 7-11 demonstrate illustrative formats for communications between a client<br>
device operating a cache table and a data source associated with the cache table,<br>
according to one embodiment of the invention.<br>
DETAILED DESCRIPTION<br>
The following description is presented to enable any person skilled in the art to<br>
make and use the invention, and is provided in the context of particular applications of the<br>
invention and their requirements. Various modifications to the disclosed embodiments<br>
will be readily apparent to those skilled in the art and the general principles defined<br>
herein may be applied to other embodiments and applications without departing from the<br>
scope of the present invention. Thus, the present invention is not intended to be limited to<br>
the embodiments shown, but is to be accorded the widest scope consistent with the<br>
principles and features disclosed herein.<br>
The program environment in which a present embodiment of the invention is<br>
executed illustratively incorporates a general-purpose computer or a special purpose<br>
device such as a mobile computer, a PDA (Personal Digital Assistant), a telephone, etc.<br>
Details of such devices (e.g., processor, memory, data storage, display) may be omitted<br>
for the sake of clarity.<br>
It should also be understood that the techniques of the present invention may be<br>
implemented using a variety of technologies. For example, the methods described herein<br>
may be implemented in software executing on a computer system, or implemented in<br>
hardware utilizing either a combination of microprocessors or other specially designed<br>
application specific integrated circuits, programmable logic devices, or various<br>
combinations thereof. In particular, the methods described herein may be implemented<br>
by a series of computer-executable instructions residing on a suitable computer-readable<br>
medium. Suitable computer-readable media may include volatile (e.g.. RAM) and/or<br>
non-volatile (e.g., ROM, disk) memory, carrier waves and transmission media (e.g.,<br>
copper wire, coaxial cable, fiber optic media). Exemplary earner waves may take the<br>
form of electrical, electromagnetic or optical signals conveying digital data streams along<br>
a local network, a publicly accessible network such as the Internet or some other<br>
communication link.<br>
Introduction<br>
In one embodiment of the invention, a system and method are provided for fine-<br>
grained caching, on a mobile device, of data used by an application executing on the<br>
device. In this embodiment, application data are stored in a database (e.g., a DBMS)<br>
comprising one or more cache tables configured to monitor the validity and/or usability of<br>
cached data.<br>
In this embodiment, a cache table not only caches one or more data rows, but also<br>
stores, or is associated with, cache control information that describes the validity of the<br>
data, where or how to get a fresh copy of the data, etc. When an application accesses the<br>
cache table, the local DBMS inspects the desired data and, if still valid, serves it. If the<br>
cached data are no longer valid, the local DBMS requests updated data from the server if<br>
a connection to the server is available. Instead of retrieving a large set of data in order to<br>
update a single (invalid) data row, just that row may be retrieved.<br>
In an embodiment of the invention, a cache table is a database table of data that<br>
can be retrieved on demand from a data source (e.g., enterprise server, database server,<br>
web server, application server), and stored in a local (e.g., mobile) device.<br>
Communications between the server and the device may employ any suitable protocol,<br>
such as HTTP (Hyper Text Transport Protocol), SOAP (Simple Object Access Protocol),<br>
WAP (Wireless Access Protocol), etc. A server hosting a data source may be configured<br>
to execute CGI (Common Gateway Interface) programs, servlets, applets, Java methods<br>
or other modules to implement interfaces associated with cache table specifications<br>
described herein.<br>
In one embodiment of the invention, a cache table is compatible with a database<br>
programming model, so that a mobile application can access the cached data through a<br>
standard interface, such as ODBC (Open Data Base Connectivity) or JDBC (Java Data<br>
Base Connectivity). A mobile application that uses a local database of cache tables can<br>
therefore be written using a normal database model and interface. The database, through<br>
its cache table(s), manages data validity, retrieves updates for invalid data, and so on.<br>
The data and transactional semantics of cache table may be designed to follow industry<br>
standard transactional semantics.<br>
Because the mobile device may not always be actively communicating with an<br>
enterprise server (or other central/master data source), and because data retrievals can be<br>
limited to just those data items that are invalid, connection costs can be kept relatively<br>
low. And, because of the limited number of accesses that must be made to the enterprise<br>
server, there is less of a problem with erratic performance resulting from unpredictable<br>
latency.<br>
In another embodiment of the invention, an intelligent client agent is provided for<br>
enhancing operation of an offline application executed on a mobile computing device<br>
(e.g., a Personal Digital Assistant (PDA), a laptop or notebook computer, a smart<br>
telephone). In this embodiment, the client agent enhances the operation of the offline<br>
application by selectively enabling online access and separating application content from<br>
the presentation format of the content. Content and presentation may be separated by<br>
storing the data separately (e.g., in a cache table, snapshot or regular database table) from<br>
the presentation description or format of an application page. When an offline application<br>
needs a page, the client agent reconstructs the application page from the presentation<br>
description and data stored in the local database. The client agent may go online to<br>
retrieve volatile data and/or data that are stale; the client agent may also facilitate<br>
synchronization of a client snapshot with a server. Further, a client agent may enable a<br>
server to push information to a client cache table or database (e.g., using a push listener),<br>
and may also support voice-based interaction with a client application.<br>
FIG. I depicts an illustrative mobile computing/communication environment in<br>
which an embodiment of the invention may be implemented. In this embodiment,<br>
enterprise server 150 is accessible through a direct wireless link 130 and/or network 140,<br>
which may comprise the Internet. Users of mobile devices 102a - 102d therefore access<br>
server 150 directly or though a series of communication links. A user"s mobile device<br>
may be a laptop or other portable computer, a PDA, a telephone, a two-way pager or<br>
other device.<br>
In one embodiment of the invention, a client database or DBMS may include one<br>
or more snapshots of server data in addition to any cache tables. In this embodiment, a<br>
cache table stores data that may have originated anywhere (e.g., the client, any remote<br>
server or other system), along with information regarding the validity of the data. A<br>
snapshot stores data from a server or other source that is explicitly synchronized with the<br>
server. Illustratively, snapshot data may always be available when offline, while cache<br>
table may or may not be usable offline, depending on the validity of the data. Finally,<br>
regular database tables may be used store data generated by, and/or only used by, the<br>
client.<br>
Cache Table Concepts<br>
FIG. 2 is a block diagram of a mobile client device suitable for implementation<br>
with an embodiment of the invention. Device 200 comprises mobile application 210,<br>
database 220 and communication module 230.<br>
Mobile application 210 is an application that uses or draws upon data stored in<br>
database 220. Database 220 may be configured to store any type of data (e.g., textual,<br>
numerical, graphical, video) for use by application 210. Database 220 includes one or<br>
more cache tables for caching the data, such as cache table 222. Database 220 also<br>
includes associated cache control information 224. Further details regarding cache tables<br>
and cache control information are provided below.<br>
Communication module 230 is configured to access a server or data source that<br>
stores current or master versions of data cached in database 220. Thus, as described<br>
below, database 220 may periodically access the server, through communication module<br>
230, in order to download new data, fresh data, updates to cached data, etc.<br>
Communication module 230 may be directly operated by the database, or the database<br>
may access the communication module through application 210, an operating system or<br>
other entity. Thus, communication module 230 may be coupled to mobile application<br>
210 in addition to, or instead of, database 220.<br>
In embodiments of the invention described herein, database 220 is a DBMS<br>
(Database Management System) product offered by Oracle® Corporation, such as Oracle<br>
9i Lite.<br>
In an embodiment of the invention, a cache table can be characterized by a four-<br>
tuple in the form . In this form, S defines the schema or structure of the<br>
cache table, C defines constraints placed on the cache table, O represents a set of<br>
supported operations, and P represents a set of protocols for retrieving or updating cache<br>
table content (e.g., when the mobile device is connected or intermittently connected to a<br>
data source).<br>
CACHE TABLE SCHEMA<br>
In one embodiment of the invention, the schema, S, of a cache table is defined by<br>
three things: the name of the cache table, a list of column definitions describing the<br>
structure of the cache table, and a list of access parameters. A cache table name may<br>
adhere to table-naming conventions of SQL (Structured Query Language) databases.<br>
A column definition comprises an identifier and an associated data type. Each<br>
identifier corresponds to a column name of the cache table, and may follow a column-<br>
naming convention. The access parameter list is an ordered list of a subset of the column<br>
identifiers of the cache table.<br>
Because the cache table schema, S, describes the structure of a cache table, it also<br>
defines the structure of each instance of the cache table. In this embodiment of the<br>
invention, a cache table instance comprises all rows of the cache table that have identical<br>
values for the access parameter column(s) of the access parameters. An argument<br>
comprises a list of values - one for each access parameter of the cache table. Thus, an<br>
instance is a set of rows of the cache table with the same argument.<br>
The result set of a cache table instance comprises a set of rows of the instance,<br>
each row comprising a list of columns that are not in the access parameters. That is, a<br>
result set is a projection of a cache table instance on the non-access parameter columns of<br>
the cache table. A specific instance of a cache table may be indicated by the name of the<br>
cache table followed by the corresponding argument value.<br>
FIG. 6 depicts an illustrative cache table, according to one embodiment of the<br>
invention. Inventory cache table 600 includes three columns: Part// 602, Warehouse?/ 604<br>
and Quantity on Hand (QOH) 606. In this cache table, the access parameter comprises<br>
just Part// 602. Thus, two arguments are shown: the values 1234 and 9876.<br>
Based on the two arguments, two instance? of the Inventory cache table are<br>
shown. One instance comprises three rows having the Part# 1234, and the other<br>
comprises two rows having the Part# 9876. The columns of cache table 600 that are not<br>
part of the access parameter form the result sets for the two instances.<br>
In this embodiment of the invention, an illustrative cache table may be defined<br>
according to the following SQL (Structured Query Language) syntax:<br><create cache table> ::—<br>
CREATE CACHE TABLE <table name> ( <column list><br>
[ <constraint>]<br>
[, ACCESS PARAMETERS (<access parameter list>)J )<br>
USING <content spec><br>
whore<br><access parameter list> ::=<br><access parameter name> [ {, <access parameter> }... ]<br>
Using this illustrative SQL syntax, a sample cache table may be defined as<br>
follows:<br>
CREATE CACHE TABLE Inventory<br>
(part# char(4), warehouse char(8), qty number(10),<br>
PRIMARY KEY (part#, warehouse),<br>
ACCESS PARAMETERS (part#))<br>
USING InventoryTDP TYPE updateable AT MyCompanyDS;<br>
The schema. S, of the illustrated cache table is "Inventory (part# char(4),<br>
warehouse char(8), qty number (10))." One access parameter is specified: part#. The<br>
result set for the cache table comprises a set of rows, each of which contains two<br>
columns: a warehouse identifier and the quantity of the specified part that is stored in the<br>
warehouse. Following sub-sections describe portions of this sample cache table<br>
definition in further detail.<br>
In general, the schema for a cache table T may be written as T(a1, ..., am, r1, ...,<br>
rn), where T is the cache table name, a1, ..., am is the list of access parameters and r1, ...,<br>
rn are the cache table result set columns. Thus, the sample cache table may be represented<br>
as:<br>
lnventory(part#, warehouse, qty)<br>
An instance of a cache table may be written as T(V1. ..., vm), where vs is a value<br>
for access parameter a,. In this instance, the tuple <v1 ... vm> constitutes the argument<br>
of a specific cache table instance, and each row of the corresponding result set is of the<br>
form <r1 ...>. Each row of a result set may be considered a separate result. The term<br>
"cache table" may be used herein to refer to a cache table having a particular structure<br>
(schema), or an instance of that cache table.<br>
A set of instances of a cache table may be termed an "extension" of the cache<br>
table. An extension of a cache table is defined to include all instances of the cache table<br>
that are stored in the local database or DBMS. The extension of a cache table T may be<br>
written as E(T).<br>
For a cache table, two predicates are defined with relation to each row of its<br>
extension: is Valid and isUsable. As described further below, the isValid predicate may<br>
be used to determine whether a row is valid (e.g., at the time of a query execution), while<br>
isUsable may be used to determine whether the row is usable. Illustratively, if a row is<br>
valid, then it is usable, but if it is invalid, it may or may not be usable.<br>
In one embodiment of the invention, a cache table may be used in multiple ways<br>
in an SQL statement. A reference to the cache table name alone (e.g., Inventory) is<br>
interpreted as a reference to the extension of the cache table. Thus, the SQL statement<br>
"Select * from Inventory" will return all rows of all result sets of all instances of the<br>
cache table Inventory that are currently stored in the local database. The local DBMS<br>
may not check for validity of usability of the rows nor make any attempt to refresh cache<br>
table instances. Illustratively, this type of reference may be limited to queries, and may<br>
not be usable for updates. It may be considered a "dirty read" of the cache table.<br>
A reference to a cache table that includes a full set of argument values (e.g.,<br>
constants) for an access parameter will return one instance of the cache table. Thus, the<br>
statement<br>
Select * from Inventory("P123")<br>
will return a table of "part//", "warehouse" and "qty" data for part number "P123." With<br>
this type of reference, the local DBMS will use the flowchart shown in Figures 3 A and<br>
3B (described below) to refresh the instance if needed.<br>
Another reference to a cache table, within an SQL statement, may include at least<br>
one variable within the argument. If the reference (e.g., in a query) is valid (i.e., a value<br>
can be bound to the variable), this type of reference returns one or more instances of the<br>
cache table. Thus, the statement<br>
Select p#, partName, warehouse, qty From part P. Inventory(P.p#)<br>
can be used to obtain result sets of inventory for pail numbers in the part table. If no<br>
values can be bound to the variable, the query is considered invalid. With this type of<br>
reference, the local DBMS will use the flowchart shown in figures 3A and 3B to refresh<br>
the instances if needed.<br>
The preceding example demonstrates how a cache table access parameter can be<br>
bound to a column or expression of another table, including a result set of another cache<br>
table. Illustratively, a fully qualified column specification of a cache table column may<br>
use an alias for the cache table name, as in the following:<br>
SELECT P.p#, P.pname, Inv.qty<br>
FROM P, Inventory(P.p#) Inv<br>
WHERE Inv.qty &gt; 100<br>
CONSTRAINTS<br>
In an embodiment of the invention, constraints may be defined on any cache table<br>
extension (i.e., set of cache table instances). Thus, the column list of a cache table can be<br>
used to define constraints on the cache table. For example, primary and foreign key<br>
constraints may be defined in the definitions of columns of the cache table (e.g., if they<br>
are single attribute keys), or may be defined in a Primary Key or Foreign Key clause in<br>
the constraints portion of the cache table definition.<br>
The sample Inventory cache table defined above includes one constraint, a<br>
primary key consisting of part# and warehouse. This means that, for a given part#, the<br>
result set may contain many rows or results, but no two rows in the result set will have the<br>
same warehouse value.<br>
When defining the constraints, C, of a cache table, there are several options. For<br>
example, a single primary key may be defined as a combination of all of the access<br>
parameters or as a combination of all of the access parameters and some of the result set<br>
identifiers. Illustratively, if access parameter "part#" of the Inventory cache table was<br>
defined as a primary key for the cache table, then the data returned for a particular value<br>
of "part#" could contain, at most, a single row. In contrast, if a primary key was defined<br>
as a combination of "part#" and "warehouse," then multiple rows could be returned for a<br>
given value of "part#," but the values for "warehouse" would be unique for each value of<br>
"part#."<br>
For every cache table in one embodiment of the invention, a non-null system<br>
constraint is automatically defined for each access parameter. Additional constraints may<br>
be defined on an extension of the cache table. The DBMS will perform data integrity<br>
checks based on these constraints whenever a result set is received from a data source and<br>
instances are constructed from them. Integrity constraints may also be used to optimize<br>
storage of a cache table. For example, and as stated above, if a primary key is defined on<br>
any (or all) of the access parameters of a cache table, then each result set will contain at<br>
most one row for an argument, and the extension of the cache table may be stored in one<br>
physical table.<br>
Conceptually, a constraint on a cache table T is a constraint defined on E(T). In<br>
an embodiment of the invention, if a primary key is defined on any (or all) of the access<br>
parameters of a cache table, the DBMS may store E(T) in a single physical table. All<br>
constraints defined on that cache table may be considered constraints on E(T).<br>
Illustratively, refreshing a cache table instance includes retrieving the result set of<br>
the instance from the corresponding TDP (Table Data Processor - described below) of a<br>
data source, creating a row from the argument for each result, and inserting the row in<br>
E(T). Constraint checking may be conducted in a normal manner for insert, delete and<br>
update operations on E(T).<br>
When a cache table has a foreign key referring to a primary key that comprises an<br>
entire argument of another cache table, the DBMS may check the foreign key constraint<br>
by opening a cursor on the instance of the second cache table. If the instance exists, and<br>
is valid or locked, then the constraint is deemed satisfied. If the instance does not exist,<br>
or is invalid, then the DBMS will try to retrieve or refresh the result set from the data<br>
source. If the data source returns a result, it is cached and the constraint is deemed<br>
satisfied. If there is no connection to the data source, an error is reported.<br>
OPERATIONS<br>
In an embodiment of the invention, the operations, O, that are supported for a<br>
cache table may be defined in a ""Using" clause of the cache table definition.<br>
Illustratively, a Using clause may specify: the name of a data source, the name of a table<br>
data processor (TDP), and the type of the TDP.<br>
Implementations of cache table operations reside on a server or other location that<br>
hosts a data source and is regularly accessible to the mobile application. The<br>
implementations are invoked by the local DBMS when the corresponding operations are<br>
performed on a cache table. Alternatively, some operation implementations may reside<br>
oil the mobile device.<br>
In one embodiment of the invention, a Using clause portion of a cache table<br>
creation may employ the following SQL syntax:<br>
USING <table data processor name>
<br>
TYPE {read-only j updatcable | insertable | deletable }<br>
AT <data source name><br>
In this embodiment of the invention, two types of TDPs are supported: read-only<br>
and modifiable. A modifiable TDP may be any combination of insertable, deletable, and<br>
updateable. An insertable TDP allows rows to be inserted into the cache table extension<br>
and implements the insert method that the local DBMS will call after rows have been<br>
inserted into the cache table instance. Similarly, a deletable TDP implements the delete<br>
method and allows rows to be deleted from the cache table, and an updatable TDP<br>
implements the update method and allows rows to be updated (e.g., to change column<br>
values). As stated above, a TDP models an operation that can be performed on a cache<br>
table.<br>
Illustratively, a read-only TDP implements the "select" method only, which takes<br>
an argument (i.e., set of values for a cache table"s access parameters) and returns a set of<br>
rows comprising a result set. A protocol that may be used is described in a following<br>
section.<br>
In contrast, a modifiable TDP must implement "insert," "delete" and/or "update""<br>
methods, depending on the type of the TDP declared in the corresponding Using clause,<br>
as well as the "select" method. In an embodiment of the invention, when a client device<br>
or application attempts to update a cache table, the local database first determines whether<br>
the content is still valid (as described below). If valid, the contents are updated and the<br>
corresponding method on the TDP is invoked. If the method returns a failure, the update<br>
is rolled back to the point before the operation started. If the contents were invalid, the<br>
database sends a request (e.g., insert, delete, update) to the TDP and indicates that a new<br>
result set should be returned.<br>
The "data source name" field refers to a data source that may be separate from the<br>
local database. A data source is configured to provide sufficient information to the local<br>
DBMS to enable the DBMS to understand the capabilities and protocol(s) of the source.<br>
A data source may also specify a period of validity and/or usability of a result set of a<br>
cache table instance. Illustratively, a data source may comprise a web server, an<br>
application server, a database server or other source.<br>
A data source may implement one or more TDPs; each TDP provides one or more<br>
methods to facilitate operations, on the data source, on behalf of the cache table. In this<br>
. embodiment of the invention, each TDP is responsible for supplying the result set of a<br>
cache table instance when called by the client DBMS. A TDP may implement logic to<br>
perform insertions, deletes, updates, and/or other operations.<br>
In association with the sample cache table creation described above (cache table<br>
"Inventory"), a data source may be defined using the following extended SQL syntax:<br><create data source> ::= CREATE DATA SOURCE <data source name><br>
TYPE <type name> PROTOCOL <protocol name><br>
[ <authentication> ]<br><destination><br>
where<br><type name> ::= local | basic | auth | database<br><protocol name> ::= omc | http j https | SOAP<br><authentication> ::= {USING | USER} { CURRENT USER | <user name> }<br>
{IDENTIFIED BY | PASSWORD} <password><br><destination> ::= AT <uri><br>
The "data source name" field will be unique within a database schema.<br>
The data source TYPE field defines the capability of the data source (e.g., local,<br>
basic, auth, database).<br>
Illustratively, a "local" data source may be a data server implemented on the client<br>
(mobile) device, and may be used to access a PIM (Personal Information Management)<br>
database, electronic mail, address book, etc. A local DBMS may preload a local data<br>
source for a given client device. In this embodiment, the protocol employed for a local<br>
data source (specified in the "protocol name" field above) is OMC (Oracle Mobile<br>
Client).<br>
A "basic" data source is a simple data source that can accept http, a web service<br>
request, or a similar request. It is generally a session-less server, and may not<br>
authenticate a requestor or support transactions. Therefore, the <authcntication> clause<br>
may be omitted for a basic data source.<br>
In this embodiment, an "auth" data source is a data source that requires client<br>
authentication (e.g., the client must login and obtain a session object). The<br><authentication> clause for an auth data source provides a user name and password for<br>
logging into the source. A server that provides an auth data source will support login and<br>
logout methods, and the login method will return a session object.<br>
A "database" data source is an authenticating data source that may support<br>
database operations such as "beginTransaction," "prepareToCommit," ""commit" and<br>
"rollback." The data source may be transactional if the server hosts at least one TDP that<br>
supports cache table updates (e.g., insertion, deletion or update of rows in the cache<br>
table).<br>
In connection with the cache table creation illustrated above, the data source<br>
MyCompanyDS that was identified in the Using clause of the cache table creation may be<br>
defined as follows:<br>
CREATE DATA SOURCE MyCompanyDS<br>
TYPE basic PROTOCOL http<br>
AT "MyCompany.com/DS";<br>
PROTOCOL<br>
In an embodiment of the invention, the protocol(s) for communicating between a<br>
local DBMS and a data source or TDP are defined in part P of a cache table"s four-tuple.<br>
In particular, P identifies one or more protocols (e.g., SOAP, HTTP, etc.), plus XML tags<br>
or other devices (e.g., HTML tags) used in a response from a data source or TDP.<br>
The client DBMS may communicate with the data source using any one of the<br>
supported protocols. Regardless of the protocol used, in one embodiment of the invention<br>
the client DBMS may exchange any or all of the data items of TABLE 1 with the data<br>
source.<br>
If the protocol used is HTTP, the argument of a cache table instance may be sent<br>
in an XML document as part of the POST method. The result of the select method may<br>
be an XML (Extensible Markup Language) document containing a header and a body.<br>
The header may contain cache control information, and the body may contain a set of<br>
rows that constitute the result set. Illustratively, the body may be encoded as an XML<br>
document according to the OMC Cache Table Result Set format, or it may be encoded as<br>
a more compact Oracle Lite CSV (Comma-Separated Values) file.<br>
The insert and delete methods may accept an argument (i.e., set of access<br>
parameter values) and a list of column values representing a single row that the client<br>
wants to, or previously did, insert into the cache table. The update method may take the<br>
argument and a list of column values that represent a single old row, and another list that<br>
represents an update. All the data for all the methods are sent as an XML document with<br>
the HTTP POST method.<br>
In one embodiment of the invention, the request format is an HTTP POST request<br>
and the URL used is that of the data source. The user agent string is "Oracle Lite". So<br>
for example, an HTTP request to obtain the instance of Inventory cache table for the<br>
argument "p123" may be as follows:<br>
POST http://MvCompany.com/DS \r<br> content-length: ...Ar<br><br>
User-Agent: Oracle Lite \r<br> ...<br>
\r<br>\r<br><br><cachetablerequestop><br><br><instance><br><arg><br><p art>P 123 </p>
<br></arg><br></instance><br><br>
A request header may contain some additional information such as If-Modified-<br>
Since.<br>
I he response to a request is an XML document that contains a header and a body.<br>
The format for the response is described in appendix B.<br>
The response header in an embodiment of the invention may contain any or all of<br>
the following information:<br>
Response Date - date of the response in an 3 HTTP formats (e.g., RFC1123)<br>
according to the data source clock;<br>
Last-Modified - date when the data were last modified on the data source (also in<br>
HTTP date format);<br>
Expires (or Expiration Date) - date until which the data should be considered<br>
valid;<br>
Time-To-Live — how long the data can be considered valid, expressed in seconds;<br>
Staleness — an integer number greater than zero that indicates whether and how<br>
long a stale (expired) result set can be used if there is no network<br>
connection to refresh the result set. A Staleness value of 1 is default and<br>
indicates that the stale result set cannot be used at all. If the staleness<br>
values is n, it indicates that the stale result set can be used for up to n times<br>
the Time-To-Live value.<br>
As described in TABLE 1, FIGs. 7-11 demonstrate sample forms of XML<br>
documents that can be used for communicating between a client device and a data source.<br>
FIGs. 7A-B demonstrate sample Response Document Format 702, 704. Each<br>
format includes a header and a body. The header may include a server identification,<br>
client identification, cache information (e.g., Date Last-Modified, Expires, Time-To-Live,<br>
Staleness), TDP name, an argument for a result set, the cache table schema, date format,<br>
etc. The body contains one or more row sets, each of which may identify the row set<br>
format, an action (e.g., replace, insert, delete, update), a separator character, etc. The<br>
body of response format 702 is in XML format, while the body of response format 704 is<br>
in CSV format.<br>
FIG. 8 demonstrates sample Select Request Document 800. FIG. 9 demonstrates<br>
sample Insert Request Document 900. FIG. 10 demonstrates sample Delete Request<br>
Document 1000. FIG. 11 demonstrates sample Update Request Document 1100.<br>
Cache Table Operation<br>
As described above, in one embodiment of the invention, when a client<br>
application issues an operation (e.g., a query) involving a cache table, the local database<br>
or DBMS determines whether the instance for the cache table with the given set of access<br>
parameters is already cached and is still valid. If so, the cached result set may be used for<br>
the operation. Otherwise, as just illustrated above, the database will call the select<br>
method on the TDP defined for the cache table in order to retrieve the result set. A<br>
response from a TDP may include a header containing any or all of the cache control<br>
parameters mentioned in the previous section.<br>
FIGs. 3A-B comprise a flowchart demonstrating an algorithm for determining<br>
whether to update, retrieve or refresh a cache table instance, according to one<br>
embodiment of the invention. In this algorithm, Current Date refers to the current<br>
date/time on the client machine.<br>
In the algorithm of FIGs 3A-B, a cached instance of a cache table may be<br>
considered "valid" if it is used before its expiration (e.g., as defined by the Time-To-Live<br>
or Expiration Date parameter). The instance may be considered "usable"" by a transaction<br>
if (1) it is ""valid", (2) it is locked by the transaction, or (3) if it has expired but is being<br>
used (because a communication link to the data source is unavailable) before it is stale (as<br>
computed from the Staleness parameter). More formally:<br>
Usable = valid OR locked OR (no connection to data source AND<br>
(Response Date + (Time-To-Live * Staleness) &gt;= Current Date))<br>
In state 300, an operation (e.g., a query) is received by the local database or<br>
DBMS (Database Management System). The operation concerns one or more cache table<br>
instances the database is configured to store.<br>
In state 302, the DBMS determines whether this is the first operation involving the<br>
argument provided as part of the operation. More generally, the DBMS may determine<br>
whether it has a result set corresponding to the argument, regardless of whether the result<br>
set is valid, usable, stale, or in some other condition. If this is the first operation for this<br>
argument (e.g., the database contains no result set associated with the argument), the<br>
illustrated method continues at state 304; otherwise, the method advances to state 310.<br>
In state 304, the DBMS issues a request to a data source, to be directed to the<br>
Table Data Processor associated with the cache table, for the result set corresponding to<br>
the argument.<br>
In stale 306, a new cache table instance is generated in the DBMS for the result<br>
set, and is used to satisfy the operation. Illustratively, caching headers may be stored on<br>
the client device. The method then ends. If the data source could not be contacted to<br>
obtain the result set (e.g., in state 304), an error may be signaled by the database.<br>
In state 310, a previous result set pertaining to the argument was located in the<br>
cache table, and the DBMS determines whether it is presently locked by the current<br>
transaction. In this embodiment of the invention, if the transaction isolation level of the<br>
current transaction is "Repeatable Read" or "Serializable" (which would account for the<br>
result set being locked), the DBMS will not refresh the result set for the current<br>
transaction. If the current transaction has locked the result set, the illustrated method<br>
advances to state 316.<br>
Otherwise, in state 312, the DBMS determines whether the current transaction has<br>
an active cursor on the cached result set. In this embodiment of the invention, if the<br>
transaction isolation level of the current transaction is "Read Committed" (which would<br>
account for the active cursor and no lock), the DBMS will not update the result set, so as<br>
to provide read consistency and cursor stability. If the current transaction has an active<br>
cursor open on the result set, the method advances to state 316.<br>
Otherwise, in state 314, the DBMS determines whether the cached result set is<br>
valid. As specified above, the result set may be considered valid if a Time-To-Live<br>
parameter or Expiration Date for the result set has not yet been exceeded (e.g., Response<br>
Date + Time-To-Live &gt;- Current Date). If the cached result set is not valid, the<br>
illustrated method continues at state 316; otherwise, the method advances to state 322.<br>
In state 316, the DBMS determines whether a connection is available to a data<br>
source (e.g., TDP) associated with the cache table. If a connection is available, the<br>
method proceeds to state 324.<br>
In state 318, no connection is available to the data source, and the cached result<br>
set is known to be invalid-, so the database determines whether the result set is usable or<br>
stale. Illustratively, the result set may be considered stale if (Response Date -f (Time-To-<br>
Live * Staleness) 
method continues to state 322.<br>
Otherwise, the cached result set is not valid and is stale, and there is no connection<br>
available to a data source that can refresh the cache table instance. Therefore, in state 320<br>
the DBMS signals an error and the method ends.<br>
In state 322, the existing result set in the DBMS is used to satisfy the current<br>
operation. The procedure then ends.<br>
In state 324, the presently cached result set has been deemed invalid, but a<br>
connection is available to the data source, so a refresh operation is requested.<br>
Illustratively, a refresh request may include an If-Modified-Since header reflecting the<br>
Last Modified date of the previous refresh of the result set. If the Last Modified date<br>
value is not available from the last refresh or update, then Response Date may be used<br>
instead.<br>
In state 326, the DBMS determines whether any updates are received in response<br>
to the request. Illustratively, if the TDP (via the data source) finds that the result set has<br>
not been updated since the last time it was provided to the local DBMS, then no updates<br>
will be sent. If any updates were received, the illustrated method proceeds to state 330.<br>
Otherwise, no updates were received, and so in state 328 the cache control<br>
information is updated appropriately and the cached result set is used for the current<br>
operation. Illustratively, any cache control information received with the response will be<br>
used to update or overwrite existing cache control information. The method then ends.<br>
In state 330, the DBMS determines whether the cached result set is currently in<br>
use by another transaction.<br>
In state 332, the result set is in use. and so the DBMS copies it and marks the copy<br>
as the latest version of the result set. Copies other than the latest version may be marked<br>
to be deleted when the transactions using them are terminated.<br>
Then, in state 334. the DBMS updates the result set according to the update(s)<br>
received from the data source, and uses the updated result set for the current operation.<br>
The illustrated method then ends.<br>
In an embodiment of the invention in which synchronization of local and server<br>
(data source) clocks is a problem, a Local Date value may be computed and used in place<br>
of Response Date. Also, Response Date and Expiration Date may be used to compute the<br>
Time-To-Live value (if not included in a response).<br>
READ-ONLY CACHE TABLE<br>
In one embodiment of the invention, when a query or other cache table operation<br>
refers to cache table T by name only (i.e., without an argument), a cursor is opened on<br>
E(T) (i.e., the extension of the cache table). The cursor iterates through the latest version<br>
of each instance within E(T), without regard to whether the instance is usable. The local<br>
DBMS will not attempt to refresh or lock an instance. An instance within E(T) may be<br>
refreshed, however, if some other transaction opens a cursor on it. It should be recalled<br>
that an update operation must provide an argument, and will therefore not refer to a cache<br>
table by name alone.<br>
When a query refers to a specific cache table instance, such as T(v1, ..., vm),<br>
where each V1 is a constant, the DBMS will check whether the instance is usable. If so, a<br>
cursor is opened on it; if not, the DBMS will try to refresh it. If there is no connection<br>
available to the requisite data source, an error may be returned.<br>
In an embodiment of the invention, if a transaction that issues a query against a<br>
cache is in "Read Committed" isolation level, and the query includes an argument, no<br>
lock will be applied to the affected cache table instance. If the transaction is in<br>
"Repeatable Read" isolation level, a read lock is applied to the instance. If the transaction<br>
is in "Serializable" isolation level, a read lock may be applied to the instance and E(T).<br>
If a given transaction closes a cursor on a cache table and then reopens it, the<br>
refresh policy may depend on the transaction isolation level. Illustratively, if the<br>
transaction isolation level is Read Committed, then the cached content will be refreshed if<br>
the cache became unusable before the cursor was reopened. If the transaction level is<br>
either Repeatable Read or Serializable (a read lock is applied to the instance), the same<br>
content may be used for the reopened cursor, regardless of whether or not the content has<br>
expired.<br>
For a cache table T, different instances may have differing periods of validity. For<br>
example, the period of validity of a cache table instance Ti(v1. ..., vm) may be one hour,<br>
while the period of validity of cache table instance T2(u1, .... um) may be thirty minutes.<br>
In this example, (v1. .... vm) and (u,, .... um) are arguments. Illustratively, the validity<br>
period of an instance is set by a data source from which the result set was obtained, and a<br>
client DBMS may not refresh cache table content that is still valid.<br>
In an embodiment of the invention, the local DBMS makes a Closed World<br>
Assumption regarding the validity period of a result set, and will not refresh any cache<br>
table content (result set) if still valid. It also assumes that any content obtained from a<br>
data source during a refresh comprises data that have been committed at the source.<br>
UPDATEABLE CACHE TABLE<br>
For an updateable cache table, in one embodiment of the invention only one<br>
transaction may update a cache table instance at a time. In this embodiment, a write lock<br>
is applied to an updateable cache table instance.<br>
When a transaction updates an updateable cache table instance, the update is first<br>
applied to the result set if it is still valid or is already locked for this transaction. Then the<br>
corresponding update method of the TDP is invoked at the data source. Illustratively, the<br>
update fails if the method fails.<br>
If no connection to the data source is available when a cache table instance is<br>
updated, an error is reported. And, if there is any error during application of an update,<br>
the DBMS will rollback the transaction at the data source.<br>
An instance of a cache table T is a unit of read consistency for queries, stability of<br>
cursors and, in this embodiment, is the smallest object that can be locked for concurrency<br>
control of updateable cache tables. Formally, a cache table instance is a subset of E(T),<br>
wherein all rows in the subset have the same argument:<br><br>
A cache table instance is valid in this embodiment if, and only if, the cursor<br>
opened on the instance is opened before the end of the time period marked by the sum of<br>
Response Date and Time-To-Live:<br><br>
A result set of cache table instance is usable in this embodiment if, and only if, it<br>
is either (1) valid, (2) locked by a transaction for update, or (3) there is no connection<br>
available to the data source when a cursor is opened on the instance and the instance has<br>
not. yet passed its Staleness limit:<br><br>
In an embodiment of the invention, whenever a cursor is positioned on a row of an<br>
instance, that instance cannot be modified. If another transaction attempts to open a<br>
cursor on the same instance, the local DBMS will retrieve the result set for that instance<br>
from the data source and create a new instance. The new instance becomes the latest<br>
version of the instance and all other versions will be purged when their cursors are<br>
moved.<br>
An Intelligent Client Agent<br>
In one embodiment of the invention, an intelligent client agent is provided to<br>
facilitate operation of an offline or mobile application on a mobile client device. More<br>
particularly, in this embodiment, a client agent enhances a mobile application with one or<br>
more features, such as: voice interaction with a user, pushing data from a server to the<br>
client, and selective online access to remote data (i.e., data stored elsewhere than on the<br>
client).<br>
The client agent may also enable the separation of content to be presented to a<br>
user from the format in which the content is to be presented. Illustratively, the latter<br>
benefit allows the client to generate pages on the fly from a specified presentation format<br>
and one or more sets of data that can be displayed using the format. The pages may then<br>
be displayed by a suitable client browser.<br>
For example, in an embodiment of the invention implemented for a mobile<br>
application involving access to inventory data, a client agent allows a presentation<br>
description or format for the data to be stored separate from the inventory data. Thus, the<br>
presentation format may be configured to present information such as a part name,<br>
description, price, quantity on hand, and so on, for a given part number. The data may be<br>
stored in a database, cache, cache table or other structure. When a user provides a<br>
particular part number, the corresponding data are retrieved and combined with the<br>
presentation format for display to the user.<br>
Illustratively, a presentation format or presentation description page may be<br>
populated with variables, field names or other placeholders representing data or content<br>
items, as well as commands in a script language that can be used to control how the data<br>
in the local database can be used to replace the placeholders. A script engine of the<br>
intelligent client agent executes the script language in the page to replace the placeholders<br>
with actual values before the page is returned to the browser.<br>
One skilled in the art will appreciate that previous mobile or offline applications<br>
were configured to store static, monolithic pages combining content with a presentation<br>
format. As a result, each set of content was stored as a separate page, thereby requiring<br>
greater storage capacity and providing less flexibility. For example, if just one data item<br>
in a stored page needed to be updated, the entire page containing that item had to be<br>
retrieved. And, if that one item was part of multiple pages, each of those pages had to be<br>
retrieved.<br>
Implementing an intelligent client agent in a mobile client device along with a<br>
cache table facilitates development and use of a hybrid online/offline application that<br>
accesses data locally (e.g., offline) but which can also avail itself of online access to<br>
selected (e.g., highly volatile) data. A mobile application may also be operated fully<br>
offline, and submit data changes, completed forms and other information when placed<br>
back online. Yet further, content and applications may be dynamically downloaded, and<br>
may even be pushed to the client (e.g., a new travel itinerary, a change to a set of tasks).<br>
In an embodiment of the invention, content stored on a mobile client device may<br>
be stored in accordance with a predetermined schema. According to the schema, the<br>
content may be stored in a database table, a snapshot of data server contents, a cache table<br>
or other structure. For example, storing data in a database table allows the client agent to<br>
easily and explicitly load and refresh the data. Storing data in a snapshot may facilitate<br>
the push of new/updated data to the client from a server (as described further below).<br>
Storing data in a cache table, as described in previous sections, allows the use of an<br>
intelligent refresh policy for the data as well as on-demand loading from virtually any<br>
source (e.g., a server). The schema may include or be associated with a URL (Uniform<br>
Resource Locator) indicating a location of data to be retrieved, loaded, updated, etc.<br>
As mentioned above, besides separating content from the presentation format for<br>
that content, an embodiment of a client agent allows a user to interact with a mobile<br>
application using voice. In the above example, for instance, a user may speak a part<br>
number and the mobile application may respond by speaking the associated inventory<br>
data. This may be of particular value when the user is operating a vehicle or otherwise<br>
cannot divert his or her eyes or hands from another task. In this embodiment of a client<br>
agent, voice utilities or components of speech-to-text and text-to-speech converters (e.g.,<br>
grammar checker, phonemes) may be installed as part of a client device"s operating<br>
system or as part of the mobile application.<br>
The process of configuring a client device for an embodiment of the invention<br>
may involve downloading to the device a set of application pages or modules, content or<br>
data for the application, schema page(s), utilities (e.g., voice application or utilities), a<br>
browser, etc. An application page designed to elicit data or content from a user, or<br>
provide data or content to a user, may be expressed as a presentation description or format<br>
(as described above). For a mobile application configured according to this embodiment<br>
.of the invention, a download page may identify some or all of the application pages<br>
(presentation formats), voice files, schema pages, and so on. Loading or browsing the<br>
download page may automatically trigger the loading or retrieval of each component.<br>
In an embodiment of the invention, a download page comprises a program written<br>
in a suitable script language. The program includes special tags or markers (e.g.,<br>
"import," "schema") to identify items to be downloaded and actions to be taken. Thus,<br>
the download page is more than a mere list of pages or other content to be cached.<br>
FIG. 4 depicts a mobile client device equipped with an intelligent client agent,<br>
according to one embodiment of the invention. In this embodiment, client device 400<br>
may be a PDA, a smart telephone, a handheld, laptop or notebook computer, or some<br>
other mobile computing device.<br>
Client 400 includes database 420, client agent 440 and a browser. The client<br>
browser may be compatible with HTML (Hypertext Markup Language), XML<br>
(Extensible Markup language), or any other markup language now known or hereafter<br>
developed. The browser is configured with suitable protocol identification and handling<br>
as described below. Client agent 440 interacts with database 420 using ODBC (Open<br>
Database Connectivity), JDBC (Java Database Connectivity) or some other interface.<br>
Although client agent 440 may frequently operate in an offline mode, it may also<br>
operate online when needed (e.g., as described below), at which time it may interface<br>
with one or more servers through a wireless (or wired) network. Client agent 440 may<br>
operate as described below for one or more embodiments of the invention without<br>
requiring a Java Virtual Machine (VM) on client 400.<br>
Database 420 includes one or more cache tables 422, described in a previous<br>
section, and corresponding cache control information 424. The database may also<br>
comprise one or more snapshots 426 of data copied from a server, and data tables 428.<br>
Illustratively, database 420 may be Oracle 9i, 9iLite, or another DBMS offered by Oracle<br>
Corporation.<br>
In one implementation of the illustrated embodiment of the invention, database<br>
tables such as table(s) 428 contain locally useful data that are not synchronized with a<br>
data server. Snapshot(s) 426 contain a subset of data (from the data server) that may be<br>
synchronized periodically with the data server. Cache table(s) 422 include data having<br>
specified periods of validity and may be refreshed as described in a previous section (e.g.,<br>
when requested cache table content is stale).<br>
Cache 442 of client agent 440 is configured to store presentation descriptions or<br>
formats of pages to be displayed by the browser. As described above, a presentation<br>
format may be populated with multiple different sets of content, as needed, thereby<br>
eliminating the need to store each assembled page. Cache 442 may also cache selected<br>
data from database 420.<br>
Dispatcher 444 implements an interface defined by the browser to register itself as<br>
a protocol handler. The dispatcher receives page requests from the browser and passes<br>
assembled pages to the browser. In one embodiment of the invention, dispatcher 444<br>
only receives page requests corresponding to one or more specified protocols. For<br>
example, the browser may be configured to send page requests for an Oracle Mobile<br>
Client (OMC) protocol to the dispatcher; such requests may comprise URLs in the form<br>
"omc://www.oracle.com." Illustratively, regular HTTP (Hypertext Transport Protocol)<br>
requests (e.g., "http://vvAvw.oracle.com") may be submitted by the dispatcher 444 to a<br>
server (e.g., through a wireless network). If a requested page is cached, dispatcher 444<br>
will forward the assembled page to the browser; if the requested page is not cached, the<br>
request may be forwarded to a remote server. A request sent to a remote server may be<br>
handled by requestor 450 and/or processed through queue 452.<br>
The dispatcher may, before serving a page to the browser, inspect information<br>
contained in the request and in the header of the page, such as the MIME (Multipurpose<br>
Internet Mail Extension) type of the page, and call an appropriate request handler. The<br>
request handler will perform the appropriate action, which may produce a valid page in a<br>
markup language supported by the browser, which may then be given to the browser by<br>
the dispatcher. Client agent 440 may be configured with a request handler for OTL<br>
(Offline Tag Library) pages, which use tags that may contain SQL (Structured Query<br>
Language) tags referring to database tables, snapshots and/or cache tables. In FIG. 4,<br>
script engine 446 may comprise a handler for OTL MIME type.<br>
in the illustrated embodiment of the invention, script engine 44(5 performs<br>
assembly of pages that are to be presented to a user graphically via the browser (i.e., not<br>
via voice). When the script engine receives a request for a cached page (e.g., from<br>
dispatcher 444), it retrieves the page"s presentation format (e.g., from cache 442) and the<br>
appropriate data (e.g., from database 420). The data are then bound to the corresponding<br>
variables or placeholders of the presentation format to produce an assembled page. The<br>
assembled page may then be returned to the dispatcher and passed to the client browser.<br>
The script engine 446 is configured to work with voice engine 448. When the<br>
script engine encounters a voice tag such as <say ...> or <prompt...>, it prepares the<br>
arguments to the appropriate method of the voice engine and calls the method. The voice<br>
engine then responds aurally to the method call and returns the control and the result of<br>
the method call to the script engine.<br>
Page requestor 450 may handle interaction with a remote system (e.g., a data<br>
server) to retrieve a requested page (e.g., a presentation format) and/or content that is not<br>
stored locally or that is stored locally but is stale. Queue 452 may store requests and/or<br>
other communications to be exchanged with remote systems.<br>
Push listener 454 may be configured to listen for pushed content, pages (e.g.,<br>
presentation formats), download pages, application pages, and/or other items. Pushes<br>
may be received as SMS (Short Message Service) communications or in some other<br>
format recognizable to client 400. As just one example of a push, a data server may push<br>
an SMS message containing a series of SQL statements. Push listener 454 may execute<br>
the statements or pass them to dispatcher 444 or some other component of client agent<br>
440 for execution. Illustratively, the statements may cause new or updated data to be<br>
stored in database 420.<br>
FIGs. 5A-C depict methods of operating a mobile application with an intelligent<br>
client agent, according to one embodiment of the invention. In this embodiment, the<br>
mobile application is executed on a mobile or portable (e.g., wireless) computing device<br>
(such as client device 400 of FIG. 4). The mobile application is configured for offline<br>
operation (e.g., without any active connection to a remote server or other computer<br>
system), but can take advantage of an available connection to retrieve data that are stale<br>
or unavailable (e.g., not stored on the mobile device).<br>
FIG. 5A demonstrates a method of operating a dispatcher (e.g., dispatcher 444 of<br>
FIG. 4). FIGs. 5B-C demonstrate a method of operating a script engine (e.g., script<br>
engine 446 of FIG. 4).<br>
In state 502 of FIG. 5A, the intelligent client agent (e.g., dispatcher 444 of FIG. 4)<br>
receives a request from a caller, typically the client browser. Illustratively, the request<br>
may be submitted in one of a set of predetermined protocols (e.g., OMC) associated with<br>
the client agent.<br>
In state 504, the dispatcher determines whether the requested page or other item is<br>
currently cached. In particular, the dispatcher may examine a client agent cache (e.g.,<br>
cache 442 of FIG. 4) to determine if it contains a presentation description or format for<br>
the requested page. If a format for the requested page is in the cache, the illustrated<br>
method proceeds to state 510.<br>
Otherwise, if not cached, then in state 506 the client agent forwards the request to<br>
a requestor (e.g., requestor 450 of FIG. 4) to pass to a remote system. If the mobile<br>
device is currently offline, this state may entail queuing the request until a connection is<br>
available.<br>
In state 508. a page (e.g., a presentation page) returned from the remote server is<br>
put into the cache.<br>
In state 510, the dispatcher determines whether the requested page should be<br>
returned as-is to the caller (e.g., the browser) or whether it should be sent to one of the<br>
handlers for further processing. Illustratively, if the page is an OTL page, the dispatcher<br>
will call the script engine, which acts as the handler of OTL pages. If no further<br>
processing is required, the illustrated method proceeds to state 516.<br>
In state 512, the dispatcher invokes a handler (e.g., the script engine) to process<br>
the page. FIG. 5B demonstrates one method according to which the script engine may-<br>
operate.<br>
In state 514, the dispatcher checks to see if the handler has returned a page. If not,<br>
the method advances to state 518.<br>
In state 516, the requested page is delivered to the caller. The illustrated<br>
dispatcher method then ends.<br>
In state 518, the dispatcher may signal an error, thus ending the method. Or, the<br>
dispatcher may wait an additional period of time for the page to be provided by the<br>
handler or may retry the operation.<br>
FIG. 513 depicts the operation of an OTL handler, such script engine 446 of FIG.<br>
4, according to one embodiment of the invention. In this embodiment, the script engine<br>
receives an OTL page as input. OTL pages typically contain the presentation formal, of a<br>
page. The presentation format may serve as a sort of page template. Instead of<br>
containing actual data, however, the data arc represented by their variables, field or<br>
column names, table names or other placeholders. The OTL page may contain tags to<br>
download other pages or resources (e.g., an image file), tags to create the database<br>
schema if needed, lags to interact with the voice engine, tags to execute SOL statements<br>
and bind the result to variables, tags to write the value of the variables to the output file,<br>
and tags that provide the flow control needed to program the generation of the output<br>
page.<br>
In state 530, the OTL handler creates an empty output page. As the illustrated<br>
method proceeds, the output page will be populated with content from the input page<br>
and/or other content.<br>
In state 532, it starts scanning the input page or content. Illustratively, the<br>
scanning may be performed tag-by-tag.<br>
In state 534 it examines a tag to see if it is an OTL tag. If it is an OTL tag, the<br>
method continues at state 540.<br>
Otherwise, in state 536, the tag is not an OTL tag and so the script engine copies<br>
characters from the input page to the output page until an OTL tag is encountered in the<br>
input or the end of the page is reached. If an OTL tag is reached, the method advances to<br>
state 540.<br>
Otherwise, if the end of the input is reached, in state 538 the output page is closed<br>
and returned to the caller (e.g., the dispatcher), and the method ends. The output page<br>
may be empty.<br>
In state 540, the script engine tests the tag to see if it is a "download" tag. If not.<br>
the method continues at state 544.<br>
But. if the tag is a download tag, then in state 542 the script engine calls the<br>
dispatcher to download the page at the LJRL given as an attribute to the download tag. In<br>
the illustrated embodiment of the invention, a downloaded page is not parsed or executed<br>
at this point. After downloading the page, the script engine returns to state 532.<br>
In state 544, the tag is tested to see if it is an "import" tag. If not, the method<br>
advances to state 548.<br>
Otherwise, if the lag is an import tag, in state 546 the dispatcher is called to import<br>
a page associated with a URL provided as an attribute to the import tag.<br>
Illustratively, the script engine sets an import mode to ""on." Turning the import<br>
mode ";on" indicates to the dispatcher and possibly to the script engine (if the dispatcher<br>
makes the call to the script engine) that it is processing an import page. The script engine<br>
then makes a recursive call to the dispatcher and provides the URL of the page to be<br>
imported. When the dispatcher returns control to the script engine, the import mode is set<br>
to "off" and the illustrated method resumes at state 532.<br>
In state 548, if the tag is not an "import" tag then the script engine tests the tag to<br>
see if it is a "schema" tag. If not a schema tag, the method advances to state 554.<br>
In state 550, the script engine examines a local database to see if the schema<br>
already exists. If it does, the method returns to state 532.<br>
Otherwise, in state 552 the script engine calls the dispatcher to process the page at<br>
the URL given by the "schema" tag. After state 552, the method returns to state 532.<br>
In state 640 the script engine determines whether import mode is on or off. If the<br>
import mode is on, this indicates that the page being processed is a download page.<br>
Therefore, the script engine will not attempt to process the other tags in the page and will<br>
instead resume operation from state 520. Illustratively, this helps ensure that imported<br>
pages are not executed right away and that any pages they depend on are also downloaded<br>
or imported and any schema they depend on are created.<br>
In state 556, the OTL tag is examined to see if it an "SQL" tag. If not, the method<br>
proceeds to state 562.<br>
Otherwise, in state 558 the script engine calls the client DBMS to execute the<br>
query that accompanies the tag.<br>
Then, in state 560 the script engine binds the result of the query (e.g., a table) to<br>
the variable included in the "SQL" tag. The method then returns to state 532 where it<br>
continues the scanning of the input page.<br>
In state 562, if the tag encountered is not a "submit" tag, the script engine<br>
advances to state 566.<br>
Otherwise, in state 564, the script engine responds to the submit tag by submitting<br>
the output page to the queue (e.g., queue 452 of FIG. 4), which will forward the page to a<br>
specified server.<br>
In this embodiment of the invention, the submit tag has at least three attributes.<br>
The first attribute is the URL of the server to which the page is submitted. The second<br>
attribute identifies the return code from the server that will indicate a successful<br>
submission. The third is the URL of the page that will be called if the return code from<br>
the server is anything other than the code identified in the second attribute.<br>
When the Queue has a connection to the server, it will submit any queued<br>
requests. If there is an error, it will call the error-handling page and pass it the URL of<br>
the server and the returned code.<br>
In state 566, the tag is examined to see if it is a voice tag. If not, the illustrated<br>
method advances to state 570.<br>
Otherwise, if it is a voice tag, in state 568 the script engine prepares parameter<br>
values, from variables in the script, to call the necessary voice engine methods. As the<br>
result of calling the method, the voice engine will speak a message to the user (if the<br>
voice tag was a "say" tag) or aurally prompt the user for an input (if the tag was a<br>
"prompt" tag). If the tag is a prompt, then the voice engine will accept aural input and<br>
then try to recognize it and translate it into a text string. This text string is returned as the<br>
result of the method. The script engine then returns to state 532 to continue scanning the<br>
input page.<br>
In state 570, the script engine tests the tag to see if it is an "out" tag. An ""out" tag<br>
tells the script engine to output a value (a constant or a value bound to a variable).<br>
If the tag is an "out" tag, in state 572 the script engine writes the value to the<br>
output page and then returns to state 532.<br>
If the tag is not an "out" tag, then in state 574 the script engine processes it as one<br>
of the statements that it supports and then returns to state 532.<br>
While implementing the method of FIGs. 5B-C, the script engine retrieves the<br>
data for the requested page. For example, if the data are currently stored in a client<br>
database (e.g., in a table, cache table or snapshot) and are valid, they may be retrieved<br>
from the database during state 558. However, if any data items are not currently in the<br>
database, or if a necessary data item is stale, then the client engine may initiate a<br>
connection to a remote system to retrieve one or more data item(s). In this method of the<br>
invention, it may be noted that the connection to the remote system is minimized by<br>
retrieving just the necessary data. In particular, the client engine may avoid downloading<br>
other data (e.g., data that are locally available and not stale) and non-data components<br>
(e.g., the presentation description or format) of the requested page.<br>
The foregoing descriptions of embodiments of the invention have been presented<br>
for purposes of illustration and description only. They are not intended to be exhaustive<br>
or to limit the invention to the forms disclosed. Accordingly, the above disclosure is not<br>
intended to limit the invention; the scope of the invention is defined by the appended<br>
claims.<br>
CLAIMS<br>
WE..CLAIM:<br>
1. A method of facilitating the caching of data from a data source (150), on a<br>
mobile computing device (200) coupled to the data source with a discontinuously<br>
available communication link, comprising:<br>
configuring a cache table (222) within a database (220) on the mobile<br>
computing device (200), wherein said cache table includes:<br>
access parameters (602) comprising a first set of columns of a dataset on a<br>
data source; and<br>
result columns (604,606) comprising a second set of columns of the dataset<br>
distinct from the first set of columns of the dataset;<br>
generating one or more instances of said cache table within the database,<br>
wherein each said cache table instance comprises a set of rows, wherein each said<br>
row comprises:<br>
an argument, said argument comprising a value for each column of the access<br>
parameters; and<br>
a result set comprising a value for each column of the result columns, wherein<br>
each row in a set of rows comprises the same argument,<br>
receiving a first operation (300) involving a first set of data including a result set<br>
cached in the cache table of the mobile computing device;<br>
determining (314) at the mobile computing device whether said first set of data<br>
is valid;<br>
if said first set of data is invalid, determining (316) whether said discontinuously<br>
available communication link is available;<br>
if said first set of data is invalid and said less than continuously available<br>
communication link is unavailable, determining (318) whether said first set of data is<br>
usable; and<br>
retrieving (324) an update for said first set of data from the data source only if:<br>
said first set of data is invalid; and<br>
said less than continuously available wireless link is available,<br>
said retrieving method including identifying one or more logical data tables on<br>
the data source (150),<br>
for each logical data table, maintaining a table data processor configured to<br>
provide access to the logical table from the mobile computing device;<br>
receiving an argument at the data source (150) from the mobile computing<br>
device (200), wherein the argument comprises values for one or more columns of a<br>
first logical table;<br>
identifying a set of rows of the first logical table, wherein each row in the set of<br>
rows contains the argument;<br>
filtering the set of rows, wherein said filtering comprises:<br>
excluding any rows that have not been modified since a last time the argument<br>
was received from the mobile computing device; and<br>
removing from the rows the one or more columns corresponding to the<br>
argument; and<br>
returning to the mobile computing device, in response to the argument, the<br>
filtered set of rows, the method further comprising:<br>
for each said cache table instance, storing one or more parameters for<br>
determining whether said result set of said cache table instance may be used in the<br>
first data set for a data operation, and wherein said parameters include a time-to-live<br>
parameter configured to indicate a first period of time during which said result set is<br>
valid;<br>
wherein said resutt set becomes invalid at the end of said first period of time.<br>
2. The method of claim 1, wherein said parameters include a response date<br>
indicating when said resutt set was received from the data source.<br>
3. The method of claim 1, wherein said parameters include a last modification date<br>
Indicating when said result set was last modified at the data source.<br>
4. The method of claim 1, wherein said first data set is used for said data<br>
operation if said first data set is valid, regardless of whether the discontinuously<br>
available communication link is available.<br>
5. The method of claim 1, wherein said parameters include a staleness parameter<br>
configured to indicate a second period of time, following said first period of time, during<br>
which said result set is usable; and<br>
wherein said result set becomes stale at the end of said second period of time.<br>
6. The method of claim 5, wherein the first data operation involves a first cache<br>
table instance, the method further comprising using said result set of said first cache<br>
table instance in the first data set if.<br>
(a) said result set of said first cache table instance is valid; or<br>
(b) said result set of said first cache table instance is invalid and:<br>
(1) said result set of said first cache table instance is usable; and<br>
(2) the less than continuously available communication link is not available.<br>
7. The method of claim 6, further comprising:<br>
retrieving a replacement result set for said result set of said first cache table<br>
instance only if said result set of said first cache table instance is invalid.<br>
8. The method of claim 7, further comprising:<br>
signalling (320) an error if:<br>
said result set of said first cache table instance is invalid:<br>
said result set of said first cache table instance is stale; and<br>
the less than continuously available communication link is not available.<br>
9. The method of claim 1, wherein said dataset is one of a database table and a<br>
view.<br>
10. A method according to any of the preceding claims, wherein the communication<br>
link is a wireless link.<br>
11. The method of claim 1, further comprising:<br>
determining (310) whether said first set of data is locked by a first transaction;<br>
wherein said first operation was initiated by said first transaction,<br>
12. The method of claim 1, further comprising:<br>
determining (312) whether an active cursor is open on said first set of data by a<br>
first transaction;<br>
wherein said first operation was initiated by said first transaction.<br>
13. The method of claim 1, wherein said determining whether said first set of data is<br>
usable comprises:<br>
accessing a staleness parameter associated with said first set of data, wherein<br>
said staleness parameter is configured to indicate a second time, after said first<br>
time, when said first set of data becomes stale; and<br>
comparing said time of said first operation with said second time;<br>
wherein said first set of data is usable between said first time and said second<br>
time.<br>
14. A system for caching data on a mobile computing device, wherein the mobile<br>
computing device is configured for connection to a data source (150) on a<br>
discontinuous basis, the system comprising:<br>
a database including a cache table configured to cache data, from the data<br>
source, on the mobile computing device, the cache table being defined by:<br>
a set of access parameters corresponding to a first set of attributes of the data<br>
source; and<br>
a second set of attributes of the data source;<br>
within the database, one or more instances of said cache table, wherein each<br>
said cache table instance comprises:<br>
an argument comprising a value for each of said access parameters; and<br>
a set of results, wherein each said result comprises a value for each of said<br>
second attributes of the data source;<br>
one or more entries in said cache table, each said entry comprising a set of<br>
data from the data source;<br>
for each entry in said cache table, a validity parameter for determining a period<br>
of time during which said set of data is valid;<br>
for each entry in said cache table, a usability parameterfordotermining whether<br>
said set of data is usable after said period of time during which said set of data is valid;<br>
and<br>
a communication module configured to connect the mobile computing device<br>
io the data source on a less than continuous basis, wherein said validity parameter is<br>
conf gured to identify a first time at which said set of data becomes invalid;<br>
wherein, until said first time, said set of data is used for an operation involving<br>
said cache table entry, regardless of whether the mobile computing device is<br>
connected to the data source.<br>
15. The system of claim 15, wherein the database is configured to not retrieve said<br>
result set from the data source during said period of time during which the data is valid.<br>
16. The system of claim 15, wherein said parameters comprise:<br>
a first parameter configured to indicate when said result set becomes invalid;<br>
and<br>
a second parameter configured to indicate when said result set becomes stale.<br>
17. The system of claim 15, further comprising:<br>
a queue configured to store operations on said one or more cache table<br>
instances prior to transmission of the operations to the data source;<br>
wherein the operations are stored in said queue when the data source is not<br>
accessible through the communication connection.<br>
18. The system of claim 15, wherein said information for a first result set of a first<br>
cache table instance comprises one or more of:<br>
a response-date parameter configured to indicate when said first result set was<br>
last provided to the database from the data source;<br>
a last-modified-date parameter configured to indicate when said first result set<br>
was last modified at the data source; and<br>
a staleness parameter configured to indicate a second period of time, starting<br>
at the expiration of said first period of time, during which said first result set may be<br>
usable.<br>
i$. The system of claim 15, wherein:<br>
a first operation involving said first cache table instance is received at a time 0;<br>
said first period of time ends at a time V;<br>
said second period of time ends at a time U; and<br>
said result set is usable for said first operation if:<br>
O is earlier than V; or<br>
O is later than V and O is earlier than U and said database is operated<br>
in the off-line mode with respect to the data source.<br>
20. The system of claim 15, wherein said database operates in an on-line mode<br>
with the data source to receive a first result set for a first cache table instance only<br>
when:<br>
said first result set does not exist in the database; or<br>
said first result set exists in the database, but is not usable.<br>
21. The system of claim 15, wherein:<br>
if a first result set of a first cache table instance is valid, said database operates<br>
in an off-line mode during an operation involving said first cache table instance<br>
regardless of whether the wireless link to the data source is available.<br>
22. The system of claim 15, wherein said usability parameter is configured to<br>
identify a second time at which said set of data becomes stale;<br>
wherein, after said first time and until said second time, said set of data is used<br>
for an operation involving said cache table entry, only if the mobile computing device<br>
is not connected to the data source.<br>
23. The system of claim 15, wherein said communication module is configured to<br>
connect the mobile computing device to the data source for a maximum of one cache<br>
table entry operation at a time.<br>
24: The system of claim 24, wherein the mobile computing device is not connected<br>
to the data source for an operation involving a cache table entry that is valid.<br>
A cache table 222 comprises a set of access parameters and a set<br>
of data columns. One or more Instances of a cache table are<br>
stored on a mobile computing device. Each instance Includes an<br>
argument (a unique set of values for the access parameters) and a<br>
result set (a set of values for the data columns). Thus, each result<br>
in a result set comprises the argument and corresponding column<br>
values. Cached result sets have specified periods of validity, and<br>
may or may not beusable after becoming invalid. Valid cached<br>
data may be used regardless of whether a connection is available<br>
to a data source (e.g. data or application server). Invalid data<br>
may be used for a period of time if no connection Is available to<br>
the data source, Data in a cache table may be selectively updated<br>
from a data source without synchronizing the entire local<br>
database.
    

    </prompt...></say></cachetablerequestop></authentication></authcntication></uri></destination></password></user></authentication></protocol></type></destination></authentication></protocol></type></data></create></data>
</table>
<br><span id="LblCompatibility" style="color:White;font-family:Arial;font-size:Small;">Best View in Resolution of 1024x768 or later. Enable Javascript for Better Performance.</span>
        
    

<script type="text/javascript">
//<![CDATA[
(function() {var fn = function() {$get("ToolkitScriptManager_HiddenField").value = '';Sys.Application.remove_init(fn);};Sys.Application.add_init(fn);})();//]]>
</script></r1></v1></access></access></access></content></access></constraint></column>
</table></create></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLWFzc2lnbm1lbnQucGRm" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLWNvcnJlc3BvbmRlbmNlLnBkZg==" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLWV4YW1pbmF0aW9uIHJlcG9ydC5wZGY=" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLWZvcm0gMTgucGRm" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLWZvcm0gMi5wZGY=" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-form 2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLWZvcm0gMjYucGRm" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLWxldHRlciBwYXRlbnQucGRm" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-letter patent.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLXJlcGx5IHRvIGV4YW1pbmF0aW9uIHJlcG9ydC5wZGY=" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-reply to examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLXNwZWNpZmljYXRpb24ucGRm" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-specification.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDEta29sbnAtMjAwNS1ncmFudGVkLXRyYW5zbGF0ZWQgY29weSBvZiBwcmlvcml0eSBkb2N1bWVudC5wZGY=" target="_blank" style="word-wrap:break-word;">41-kolnp-2005-granted-translated copy of priority document.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="213942-a-method-of-producing-a-multilayer-seal-and-a-multilayer-seal-thereby-obtained.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="213944-method-of-preventing-or-reducing-aluminosilicate-scale-in-a-bayer-process.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>213943</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>00041/KOLNP/2005</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>04/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>25-Jan-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>23-Jan-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>17-Jan-2005</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>ORACLE INTERNATIONAL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>M/S.50 P 7,500 ORACLE PARKWAY USA.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>AHAD,RFIUL</td>
											<td>863 HUNTER LANE FREMONT USA</td>
										</tr>
										<tr>
											<td>2</td>
											<td>CHIANG JERRY</td>
											<td>37201, PASEO PADRE PARKWAY USA</td>
										</tr>
										<tr>
											<td>3</td>
											<td>KIBIREV LOEG</td>
											<td>3033 LA SELVA STREET USA</td>
										</tr>
										<tr>
											<td>4</td>
											<td>PRAKASH RAVINDRA</td>
											<td>1170 ALDERBROOK LANE SAN JOSE USA</td>
										</tr>
										<tr>
											<td>5</td>
											<td>REHNMAN SAMUELOSON</td>
											<td>3217 SANTTAGO STREET SAN FRANDISCO USA</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>B64 11/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US03/020050</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2003-06-25</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/197.760</td>
									<td>2002-07-17</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/213943-system-and-method-for-caching-data-for-a-mobile-application by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 07:01:40 GMT -->
</html>
