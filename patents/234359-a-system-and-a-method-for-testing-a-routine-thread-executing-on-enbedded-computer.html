<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/234359-a-system-and-a-method-for-testing-a-routine-thread-executing-on-enbedded-computer by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:12:46 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 234359:A SYSTEM AND A METHOD FOR TESTING A ROUTINE/THREAD EXECUTING ON ENBEDDED COMPUTER</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A SYSTEM AND A METHOD FOR TESTING A ROUTINE/THREAD EXECUTING ON ENBEDDED COMPUTER</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>&quot;A SYSTEM AND A METHOD FOR TESTING A ROUTINE/THREAD EXECUTING ON ENBEDDED COMPUTER&quot; A system and method for providing seamless communication with threads executing on an embedded computer (104). Using a DAT system (100), a programmer can test the communication iterfaces of a thread via either a scripting program, any COM-compliant program, or a graphical test utility. The DAT system (100) automattically formats a block of data that is transmitted between the embedded computer (104) and a host computer (108) and accounts for machine specific enumeration sizes, machine specific pointer sizes, machine specific structure alignment boundaries, machine specific integer sizes, and machine specific byte ordering.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
DEVELOPMENT AND TESTING SYSTEM AND METHOD<br>
Background of the Invention Field of the Invention<br>
The field of the invention relates to development and testing.  More particularly, the field of the invention relates to the development and testing of software  Description of the Related Technology An embedded device typically includes a microprocessor and application software. The application software runs under the control of a real-time operating system (RTOS) and is typically partitioned into one or more threads. A thread is an independent unit of executable software that shares the control of the microprocessor with other defined threads within the embedded system. In many embedded devices, a thread is allocated its own stack space, given a "priority", and assigned other resources that enable the thread to run as an "independent" entity. Stack space is a section of memory reserved for temporary storage of local variables. Priorities are used by the RTOS to determine which thread gets control of the microprocessor if more than one thread is waiting. Resources can include miscellaneous items such as queues, flags, etc., that are required by the RTOS to manage a thread. Other common terms used for a thread are "task" and "process." A process also implies a separate address space which protects different processes from adversely affecting each other. An example of a process running on a desktop computer using Microsoft's Windows Operating System (OS) is Microsoft Word.<br>
A common method for threads to communicate with each other is via a messaging application programming interface (API) that is provided by the operating system. A message typically includes an event and optionally a block of data that is sent between at least two threads. For example, a thread ("the sender") builds a message and invokes a specific API food the RTOS. The RTOS notifies the other thread ("the receiver") that some type of event has occurred. The receiving thread then reads the incoming message. Another common method for threads to communicate is via a function call. Using a function call provided by one thread can be invoked by another thread. Likewise functions can be called by other functions that co-exist in the same thread. Other common terms for a function include a subroutine, a procedure, or a method. As used herein, the term "communication interface" is intended to embrace any interface for communicating data between two threads, such as via either messaging or remote function call communication.<br>
There are several problems associated with known development and testing systems for embedded devices as described above. First, known testing systems require the use of the embedded device that has an operational RTOS to test the communication interfaces of the threads<br><br>
and to test the execution of the threads themselves. Disadvantageously, known systems do not have the ability to simulate communication interfaces and the corresponding threads that support them.<br>
Second, when using more than one platform to host running threads, there is a compatibility problem representing interfaces on different machines. Different types of machines store messages differently in their respective memory space. Known testing systems do not automatically format data for transmission to different platforms. An example of incompatibility between two computers is when one computer stores a 16-bit integer (2 bytes) with the least significant byte in low memory (Little Endian) and the other computer stores the least significant byte in high memory (Big Bndian). When the applications want to exchange this 16-bit integer, the value of the integer is interpreted differently depending on the computer.<br>
Third, known systems require the creation of a custom desktop tool that can communicate with the embedded software. The process of building interface functionality for a specific embedded application is a time consuming and manual process. The desktop tool and the embedded software both require manual updates to their application to enable them to communicate with each other. Thus, there is no seamless and automatic access via a desktop tool to the interfaces for an embedded software application.<br>
Fourth, desktop applications developed in other programming languages that are incompatible with standard C/C++ interface definition files cannot interact with the embedded computer seamlessly. Typically, interface definition files define the format of the messages expected by the embedded software. Languages such as Visual Basic, LabVIEW, etc., cannot use standard C interface definition files that define the format of the interfaces. Thus, software engineers that use these languages cannot test the threads executing on the embedded device.<br>
Thus, there is a need for improved devices for development and testing of embedded software that do not have the foregoing limitations.<br>
Summary of the Invention<br>
One aspect of the invention comprises a system for transmitting data. The system comprises: a host computer, a first application executing on the host computer, an embedded computer, a second application executing on the embedded computer, and a database. The database identifies at least one interface characteristic of a plurality of interfaces of the first application and the second application. The database is automatically generated in response to a user request and is based, at least in part, upon an interface description file that is provided by the user.<br>
The system also comprises a communication module that defines an interface for communication with the embedded computer. The first application communicates with the second<br><br>
application via the communication module. The host computer stores host computer machine characteristic information for the embedded computer. The host machine characteristic information includes information selected from the group comprising: an enumeration size, an adaptive enumeration indicator, a short size, a long size, a float size, a double size, a double long size, a pointer size, a structure alignment boundary, an integer size, a byte ordering, a Boolean size, and a character size.<br>
The host computer stores embedded computer machine characteristic information for the host computer. The embedded computer machine characteristic information includes information selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering. In response to receiving a communication from the second application that is targeted for the first application, the communication module modifies the communication prior to transmitting the communication to the first application, and wherein the modification is based, at least in part, upon the host computer machine characteristic information, the embedded computer machine characteristic information, and the interface characteristic.<br>
Another aspect of the invention comprises a method of transmitting data. The method comprises automatically generating a database wherein the database includes interface information that describes a plurality of interfaces. The method also comprises receiving a communication from an embedded computer and formatting the communication, based at least upon the interface information and machine characteristic information that describes at least one characteristic of the embedded computer.<br>
Another aspect of the invention comprises a method of transmitting data. The method comprises: receiving a communication from an embedded computer and formatting the received communication, wherein the formatting is based at least in part upon interface information that describes at least one characteristic of the communication and information that describes at least one characteristic of the embedded computer.<br>
One aspect of the invention comprises a method of building a database, the method comprises: reading an interface description file that defines at least one communication interface of an application thread and extracting communication information from the communication interface. Extracting communication information from the communication interface comprises: reading a unique identifier that is associated with the communication interface, determining a size of a communication that is transmitted via the communication interface, determining a name of each of the data fields in the communication, determining a method of transmitting the memory that is associated with the communication interface, identifying pointer data that is associated with the commemoration interface, determining a management method of the communication interface, and determining a type of the communication interface, whether it is message based or a function<br><br>
call. The method also comprises storing the extracted interface information in a communication database and storing at least one machine characteristic of an embedded device in the communication database. The machine characteristic of the embedded computer is selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering. The method also comprises storing at least one machine characteristic of a host computer in the communication database.<br>
Another aspect of the invention comprises a method of building a database. The method comprises: reading an interface description file that defines at least one communication interface, extracting communication information from the communication interface, storing the extracted communication information in a communication database, storing at least one machine characteristic of an embedded device in the communication database, and storing at least one machine characteristic of a host computer in the communication database.<br>
Yet another aspect of the invention comprises a database. The database comprises interface information describing at least one characteristic of a communication interface of an application thread. The database also comprises host computer information that describes at least one characteristic of a host computer and embedded computer machine information that describes at least one characteristic of an embedded computer.<br>
Yet another aspect of the invention comprises a database, comprising: interface information describing at least one characteristic of a communication interface of an application thread that is defined in an interface description file; and a predefined interface for providing viewing and testing the comiViunication interface using at least in part the interface information.<br>
Yet another aspect of the invention comprises a system for providing a communication interface that is accessible by a plurality of components, the system comprising: a scripting program; a COM-compliant object; and at least one communication module which is configured to provide an application programming interface for the scripting program to communicate with the COM-compliant object.<br>
One aspect of the invention comprises a system for providing communication between a host computer and an embedded computer. The system comprises: an embedded computer executing a plurality of threads that provide a communication interface, each communication interface having a plurality of data fields; a script engine for executing script instructions; a communication database identifying each of the communication interfaces, wherein the communication database is automatically generated, at least in part, from information comprising: an interface description file that defines the communications interfaces; machine characteristics of the embedded device; and machine characteristics of a platform that is executing the script engine; a communication module for providing an application programming interface for the script<br><br>
instructions to access the communication interface. The communication module is automatically generated based upon information from information from the communication database. The script instructions identify at least one of the communication interfaces in the communication database and invoke a function with respect to at least one field in the identified communication interface via the application programming interface. The function is selected from the group comprising: storing data in one of the data fields, reading data from one of the data fields, and testing a data field.<br>
Yet another aspect of the invention comprises a system for providing communication with a thread. The system comprises: a plurality of threads that each provide a communication interface; a communication database identifying each of the communication interfaces; a communication module for providing an application programming interface for the script instructions to access the communication interfaces. The communication module is automatically generated based, at least in part, upon information from the communication database. The script instructions communicate with a thread using at least one of the communication interfaces in the communication database via the application programming interface.<br>
Yet another aspect of the invention comprises a system for providing communication between a host computer and an embedded computer. The system comprises: an embedded computer executing a plurality of threads that provide a communication interface, each communication interface having a plurality of fields; a communication database identifying each of the communication interfaces; and a communication module for providing an application programming interface for the script instructions to access the communication interface. The communication module is automatically generated based in part from information that is maintained in the communication database. The script instructions identify at least one of the communication interfaces in the communication database and invoke a function with respect to at least one field in the identified communication interfaces via the application programming interface.<br>
Yet another aspect of the invention comprises a method of providing communication with a thread, the method comprising: retrieving a reference to a communication object, wherein the communication object provides a read method for a scripting program to access a communication interface; and invoking a read method of the communication object thereby receiving stored data that is provided via the communication interface by a thread that is executing on an embedded computer.<br>
Yet another aspect of the invention comprises a method of providing communication with a thread, the method comprising: generating a communication database that describes at least one communication characteristic of a communication interface that is defined in an interface<br><br>
description file; retrieving a reference to a communication object, wherein the communication object provides an application programming interface for a scripting program to access a communication interface that is provided by a thread that is executing on an embedded computer; and storing data in at least one data field in the communication via the use of the application programming interface.<br>
Yet another aspect of the invention comprises a method of providing communication with a thread, the method comprising: retrieving a reference to a communication object, wherein the communication object provides a application programming interface for a scripting program to access a communication interface that is provided by a thread that is executing on an embedded computer; and storing data in at least one data field in the communication via the use of the application programming interface.<br>
Yet another aspect of the invention comprises a system for providing a communication interface that is accessible by a plurality of components, the system comprising: a scripting program in a first scripting language, a scripting program in a second scripting language; and at least one communication module which is configured to provide an application programming interface for the first scripting program to communicate with the second scripting program.<br>
One aspect of the invention comprises a system for providing communication between a host computer and an embedded computer. The system comprises an embedded computer executing a plurality of threads that provide a plurality of communication interfaces, each communication interface having a plurality of data fields and a communication database identifying each of the comthunication interfaces. The communication database is automatically generated, at least in part, from information comprising: an interface description file that defines the communications interfaces; machine characteristics of the embedded device; and machine characteristics of a host platform. The system also comprises a communication module for providing an application programming interface for a COM-compliant application to access the communication interface. The communication module is automatically generated based upon information food the communication database. An object in the COM-compliant application identifies at least one of the communication interfaces in the communication database and invokes a function with respect to at least one data field in the identified communication interface via the application programming interface. The function is selected fool the group comprising: storing data in one of the data fields, reading data from one of the data fields, and testing a data field.<br>
Another aspect of the invention comprises a system for providing communication between a host computer and an embedded computer. The system comprises: an embedded computer executing a plurality of threads that each provide a communication interface; a communication database identifying the communication interface of each of the threads; and   a COM object<br><br>
configured to provide a plurality of functions to a COM-compliant application for a conununicating with each of the communication interfaces, wherein the COM object is automatically generated based, at least in part, upon the communication interfaces in the messaging database.<br>
Another aspect of the invention comprises a method of providing access to a communication, the method comprising: providing a communication object that comprises at least one function for accessing a communication interface from a COM-compliant application; and accessing the communication interface via the COM-compliant application.<br>
Yet another aspect of the invention comprises a system for providing access to a communication. The system comprises: means for providing a communication object that comprises at least one function for accessing a communication interface from a COM-compliant application; and means for accessing the communication interface via the COM-compliant application.<br>
Yet another aspect of the invention comprises a system for providing a communication interface that is accessible by a plurality of components, the system comprises: a COM-compliant object; at least one thread executing on an embedded computer; and at least one communication module which is configured to provide an application programming interface for the COM-compliant object to communicate with the thread.<br>
One aspect of the invention comprises a system for testing a thread executing on an embedded computer. The system comprises: a host computer; a first thread executing on the host computer; and an embedded computer executing a thread. The embedded computer monitors a plurality of conununications that are sent to the thread and transmits data from the monitored communications to the host computer. The host computer stores the data from the monitored communications in a plurality of data sets.<br>
Another aspect of the invention comprises a method of testing a thread. The method comprises :monitoring a plurality of communications that are sent to a thread that is executing on an embedded computer; transmitting the monitored communications to a host computer; storing the monitored communications in a plurality of data sets; and transmitting at least one of the data sets to the monitored thread.<br>
Yet another aspect of the invention comprises a method of testing a thread, the method comprising: monitoring a plurality of communications from a first thread to a second thread, wherein the communication comprise a plurality of data elements; storing each of the communications in a data set; and transmitting each of the stored data elements to the first thread.<br>
One aspect of the invention comprises a method of generating code., The method comprises: reading an interface definition file and identifying at least one communication<br><br>
interface. The communication interface defines at least a pointer that is passed via the communication interface. The method also comprises automatically generating code to invoke the communication interface. The generated code includes code to invoke a routine to define at least one attribute of the pointer.<br>
Another aspect of the invention comprises a system for generating code. The system comprises: means for reading an interface definition file; means for identifying at least one remote function call interface in the interface definition file; means for automatically generating a first code for execution on a first platform, wherein a first program executing the first code communicates with a second program executing a second code via a messaging interface; and means for automatically generating a second code for execution on a second platform, wherein the generated second code invokes a routine via the remote function call interface.<br>
Brief Description of the Drawings<br>
Figure 1 is a block diagram illustrating a development and testing system for testing an embedded computer.<br>
Figure 2 is a block diagram illustrating certain components of a communication database that is part of the development and testing systemic of Figure 1.<br>
Figure 3 is a block diagram illustrating another embodiment of the development and testing system of Figure 1.<br>
Figures 4A and 4B are a diagram of an exemplary script that can be used to communicate with the embedded computer of Figure 3.<br>
Figure S is a block diagram illustrating another embodiment of the development and testing system of Figure 1.<br>
Figure 6 is a block diagram illustrating the exemplary contents of the communication database of Figure 1.<br>
Figure 7 is a block diagram illustrating an exemplary object hierarchy of the generated component of Figure 5.<br>
Figure 8 is a flowchart illustrating a process of modifying a source file for use with the development and testing system of Figure 1.<br>
Figure 9 is a flowchart illustrating a process of building the communication database of Figure 1.<br>
Figure 10 is a flowchart illustrating a process of using the host platform communication module of Figure 1.<br>
Figure 11 is a flowchart illustrating a process of formatting a communication.<br>
Figures 12A-12D illustrate exemplary methods of managing pointer data when transmitting the pointer data between two platforms having different machine characteristics.<br><br>
Figure 13 is a flowchart illustrating a process of using a scripting file to communicate with threads executing on the embedded computer.<br>
Figure 14 is a flowchart illustrating a process of loading the messaging automation component of Figure 3.<br>
Figure 15 is a flowchart illustrating a process of registering a thread executing in a script with the development and testing system of Figure 3.<br>
Figure 16A is a flowchart illustrating a process of sending a message communication from a script to the development and testing system of Figure 3.<br>
Figure 16B is a flowchart illustrating a process of sending a invoking a function call from a script to the development and testing system of Figure 3.<br>
Figure 17A is a flowchart illustrating a process of a script receiving a message via a script from the development and testing system of Figure 3.<br>
Figure 17B is a flowchart illustrating a process of a script receiving a communication via remote function call from the development and testing system of Figure 3.<br>
Figure 18 is a flowchart illustrating a process or utilizing the generated component of Figure 5.<br>
Figure 19 is a flowchart illustrating a process of launching the COM composer of Figure 5.<br>
Figure 20 is a flowchart illustrating a process of building the generated component of Figure 5.<br>
Figure 21 is a flowchart illustrating a process of generating an interface of the generated component of Figure 1.       Figure 22 is a flowchart illustrating a process of using the generated component of Figure 5 from any COM-compliant language.<br>
Figure 23 is a flowchart illustrating a process of testing one of the communication interfaces that is identified by the communication database of Figure I.<br>
Figure 24 is a flowchart illustrating a process of generating data sets of information based upon monitoring communications that are transmitted between at least two threads.<br>
Figure 25 is an exemplary user interface for testing messages.<br>
Figure 26 is an exemplary user interface for testing remote function calls.<br>
Figure 27 is a flowchart illustrating a process of generating template code for use with the development and testing system of Figure I.<br>
Figure 28 is a flowchart illustrating a process of generating code for handling a message that is defined by a predefined communication interface.<br>
Figure 29 is a flowchart illustrating a process of generating message handling code.<br><br>
Figure 30 is a flowchart illustrating a process of generating code to send a message to a predefined communication interface.<br>
Figure 31 is a flowchart illustrating a process of generating code for handling inter-platform messaging in response to a function call.<br>
Figure 32 is a block diagram illustrating exemplary generated code.<br>
Figure 33 is a block diagram illustrating exemplary generated code.<br>
Detailed Description of Certain Embodiments of the Invention<br>
The following detailed description is directed to certain specific embodiments of the invention. However, the invention can be embodied in a multitude of different ways as defined and covered by the claims. In this description, reference is made to the drawings wherein like parts are designated with like numerals throughout.<br>
Figure 1 is a block diagram illustrating one embodiment of a DAT system 100. The development and testing ("DAT") system 100 allows developers to have automatic and seamless access to their defined communication interfaces. In addition, the DAT system 100 enables threads to run on distributed platforms, and allows any programming language seamless access to the interfaces.<br>
The DAT system 100 comprises an embedded computer 104 that is in data communication with a host computer 108. The embedded computer 104 executes an embedded computer communication module 112 that is used to route communications to threads 114 executing on the embedded computer 104. The host computer 108 executes a host computer communication module 116 that is used to rqute messages to threads 120 executing on the host computer 108. The embedded computer communication module 112 and the host computer communication module 115 are able to route to each other messages and/or other communications sent via other interfaces originating from one platform that are destined for transmission to the other platform. In one embodiment of the invention, all communications from one platform to the other platform are transmitted via the embedded computer communication module 112 and the host computer communication module 116.<br>
The embedded computer 104 can reside on a telephone, a card on a peripheral device, an automobile, a refrigerator, or any other electronic device. The host computer 108 can include any computing device that includes a display and an input device, e.g., mouse, keyboard.<br>
The host computer 116 also comprises a communication database 124 that automatically compiles the embedded and host's interface definition files to capture the "characteristics" of a communication interface.<br>
The DAT system 100 provides a standardized API for messaging and tracing, contains a protocol suite used to implement a seamless messaging and tracing environment, and implements<br><br>
the communication link between the two platforms. In one embodiment of the invention, the API that is provided by the DAT system 100 includes interfaces for the following: (i) registering a message; (ii) reading a message; (iii) sending command data; (iv) sending response data; (v) broadcasting a message; (vi) subscribing to a message; (vii) returning the list of messages stored in the communication database; (viii) returning the message format of a specific message; and (ix) returning the name and/or identifier of a specific message. Further exemplary API of the DAT system 100 are described below.<br>
A studio module 128 provides a graphical user interface and testing environment for testing the communication interfaces that are identified by the communication database 124. The DAT system 100 provides complete visibility and control of all the messages and remote function calls defined by an embedded software application. As an example, using the studio module 128, a developer can scan the entire list of messages and/or remote function calls within the database and display them on a screen. Once a specific message or remote function call is selected, the communication database 124 can be queried to return the element types and names associated with the message.<br>
Upon execution, each of the threads in the embedded computer 104 and the host computer 108 register with the DAT system 100. Registration enables the DAT system 100 to dynamically, route messages without having to "hardcode" a routing table. Threads at anytime can call a specific application programming interface "API" that is offered by the DAT system 100 to inform the DAT system 100 that the requesting thread "owns" a selected message. Owns, in this context, means that the specific thread receives the message anytime another thread and or application sends it. When a request to send a message is issued, the DAT system 100 determines whether the owning thread is local or on the other platform. If the platform is local, the message is directly routed to the owning thread. If the platform is remote, the message is directly routed to the other platform. If the message originates at the embedded computer 104, upon receipt, the host computer 108 formats the message to be compatible with the machine characteristics of the host computer 108. If the message originates at the host computer 108, the host computer 108 formats the messages to be compatible with the machine characteristics of the embedded computer 104.<br>
The embedded computer communication module 112, the host computer communication module 116, and the studio module 128 each comprise various sub-routines, procedures, definitional statements, and macros. The computer communication module 112, the host computer communication module 116, and the studio module 128 may be written in any programming language such as C, C-H-, BASIC, Java, Pascal, and Fortran and may be run under the well-known operating system. C, C++, BASIC, Pascal, Java, and Fortran are industry standard programming languages for which many commercial compilers can be used to create executable code.<br><br>
The embedded computer 104 may execute under the control of any off-the-shelf or proprietary real-time operating system such as: VxWorks, Nucleus, ThrcadX, Windows CE, RTXC, and Embedded Linux.<br>
The host computer 108 may execute under the control of any off-the-shelf or proprietary operating system, such as: UNIX, LINUX, Disk Operating System (DOS), OS/2, PalnOS, VxWorks, Windows 3.X, Windows 95, Windows 98, Windows NT, Windows CE, and Windows XP. Each of the threads on embedded computer 104 and the host computer 108 can conununication respectively with the embedded computer communication module 112 and the host computer communication module 116 via a predefmed application programming interface API. Set forth below are described certain routines provided by the API. It is to be appreciated that other routines may also be provided.<br><br>
Application Programming Interfaces Owner Methods<br>
Methods<br>
Broadcast	Broadcasts a response to all subscribed Users. (Broadcast message type only)<br>
Read Command	Reads the Command sent by a User (One-way &amp; Two-way message types only)<br>
Register	Registers ownership of the service associated with the message (One-way &amp; Two-way message types only)<br>
Send Response	Sends the response. (Two-way message type only)<br>
Un-register	Un-registers ownership of the service. (One-way &amp; Two-way message types only)<br>
User Methods<br>
Methods<br>
Read Response	Reads the Response sent from the owner. (Two-way and Broadcast message types only)<br>
Send and Read	Combines the Send Command and Read Response methods (Two-way message type only)<br>
Send Command	Sends the Command to the registered Owner (One-way and Two-way message types only)<br>
Subscribe	Subscribes to the service associated with the Message. Once  subscribed  the  Message  object  will   receive  all broadcasts sent by any owner of the service. (Broadcast message type only)<br>
Un-subscribe	Un-subscribes to the service.<br><br>
Spy API	<br>
Methods	<br>
Read Command	Reads (spies on) a copy of a command sent from a User to the Register Owner<br>
Read Response	Reads (spies on) a copy of a Response sent from the Owner to the User<br>
Register	Register as a spy of the interface to thereafter receive copies of all Commands and Responses sent by Owners and Users of the Service.<br>
Un-register	Un-register the object as a spy<br><dataset methods>	Defined below<br><br>
Owner Functions API	<br>
Methods	<br>
Register	Registers ownership of the service associated with the function<br>
Read Parameter List	Reads the Parameter List sent by the Caller<br>
Return	Sends the Return Value to the Caller (User).<br>
Un-register	Un-registers ownership of the function.<br><dataset methods>	Defined below<br>
User Function API	<br>
Methods	<br>
Call	Calls the remote function with the Object's Parameter List<br>
Read Return Value	Reads the Return Value returned by the Owner.<br>
\	<br>
Spy Function API	<br>
Methods	<br>
Read Parameter List	Reads (spies on) a copy of the Parameter List sent by the Caller<br>
Read Response	Reads (spies on) a copy of the Response sent from the Owner to the User<br>
Register	Register the Object as spy of the interface to thereafter receive copies of all Calls and Returns made between users and owners of the function.<br>
Un-register	Un-register the object as a spy.<br><dataset methods>	Defined below<br><br>
Datasets	<br>
Methods	<br>
Clear All Datasets	Clears / Deletes all datasets associated with either the Command or Response (Messages), or Input or Output (Functions)<br>
Delete Datasets	Deletes a specified number of datasets<br>
Insert Datasets	Inserts a specified number of datasets.<br>
Load Datasets	Loads datasets firom the database and associates them with the interface object.<br>
Store Datasets	Stores the datasets currently associated with the interface object into the database.<br><br>
Miscellaneous API	<br>
Methods	<br>
Pointer Setup	Specify the attributes of a the pointer, e.g., IN, IN/OUT, OUT, pooled, private.<br>
Pointer Attach	Invoiced each time a pointer address or size is modified<br>
Figure 2 presents a functional block diagram of the communication database 124. The communication database 124 includes a compiler 200 and an access engine 204. The communication database 124 parses standard interface definition files, such as in C, C++, or other programming language, and automatically extracts out the interface and tracing information. The interface definition files contain the formats of the interfaces that are used for thread communication and software tracing. In one embodiment of the invention, a programmer can define these characteristics iA the interface definition file via the use of compiler pragmas.<br>
The information from the interface definition files is organized and stored in the communication database 124 such that it that can be accessed by other desktop applications via the host computer communication module 116. An exemplary process of building the communication database 124 is described below with respect to Figure 9.<br>
In one embodiment of the invention, the DAT system 100 provides seamless and automatic ability for an application on the host computer 108 to make a remote function call to a routine that is on the embedded computer 104 and vice-versa, without requiring modification of the application other than to link the libraries and header files of the DAT system 100. An exemplary process of automatically generating code in support of a remote function call is described below with reference to Figure 31.<br>
Figure 3 is a block diagram illustrating another exemplary embodiment of the invention. The embodiment of the invention shown in Figure 3 allows scripting languages to seamlessly access threads that are executing on the embedded computer 104 and the host computer 108.<br><br>
With respect to the embodiment of the invention shown in Figure 3, the DAT system 100 also comprises a messaging automation component ("MAC") 304 and a script engine 312 for executing a script. In one embodiment of the invention, the MAC 304 is a COM-compliant object that provides interfaces for performing the following functions: designating ownership of an interface, generating a data set, sending a field of information, sending a data set, receiving a message, and listing each of the messages that are managed by the DAT system 100. The script engine 312 can be any proprietary or off-the-shelf engine that supports scripting languages such as: JavaScript, Visual Basic, VBScript, Tel, JScript, Python, etc.<br>
Set forth below is a description of the various objects that are provided by the MAC 304 for communication. In one embodiment of the invention, there are 6 classes of interface objects: (i) owner message objects; (ii) user message objects; (iii) spy message objects; (iv) owner function objects; (v) user function objects; and (vi) spy function objects. It is to be appreciated that other type of objects may also be used.<br>
The application programming interfaces of the MAC 304 are set forth below.<br><br>
Owner Message Object<br>
Methods<br>
Broadcast	Broadcasts a response to all subscribed Users. (Broadcast message type only)<br>
Read Command	Reads the Command sent by a User (One-way &amp; Two-way message types only)<br>
Register	Registers ownership of the service associated with the message (One-way &amp; Two-way message types only)<br>
Send Response	Sends the response. (Two-way message type only)<br>
Un-register	Un-registers ownership of the service. (One-way &amp; Two-way message types only)<br><dataset methods>	Defined below<br>
Properties<br>
Name	Name of the Interface<br>
SUID	STRIDE Unique Identifier for the Interface<br>
Command Payload	Command payload of the Message Object.<br>
Response Payload	Response payload of the Message Object.<br>
Out Pointer Data	Out pointer data - defined as part of the Command payload, populated as apart of the Response.<br><dataset properties>	Defined below<br><br>
User Message Object<br>
Methods<br>
Read Response	Reads the Response sent from the owner. (Two-way and Broadcast message types only)<br>
Send and Read	Combines the Send Command and Read Response methods (Two-way message type only)<br>
Send Command	Sends the Command to the registered Owner (One-way and Two-way message types only)<br>
Subscribe	Subscribes to the service associated with the Message. Once  subscribed  the Message  object will  receive  all broadcasts sent by any owner of the service. (Broadcast message type only)<br>
Un-subscribe	Un-subscribes to the service.<br><dataset methods>	Defined below<br>
Properties<br>
Name	Name of the Interface<br>
SUID	STRIDE Unique Identifier for the Interface<br>
Command Payload	Command payload of the Message Object.<br>
Response Payload	Response payload of the Message Object.<br>
Out Pointer Data	Out pointer data - defined as part of the Command payload, populated as apart of the Response.<br><dataset properties>	Defined below<br><br>
Spy Message Object<br>
Methods<br>
Read Command	Reads (spies on) a copy of a command sent from a User to the Register Owner<br>
Read Response	Reads (spies on) a copy of a Response sent from the Owner to the User<br>
Register	Register as a spy of the interface to thereafter receive copies of all Commands and Responses sent by Owners and Users of the Service.<br>
Un-register	Un-register the object as a spy<br><dataset methods>	Defined below<br>
Properties<br>
Name	Name of the Interface<br>
SUID	STRIDE Unique Identifier for the Interface<br>
Command Payload	Command payload of the Message Object.<br>
Response Payload	Response payload of the Message Object.<br>
Out Pointer Data	Out pointer data - defined as part of the Command payload, populated as apart of the Response.<br><dataset properties>	Defined below<br><br>
Owner Function Object<br>
Methods<br>
Register	Registers ownership of the service associated with the function<br>
Read Parameter List	Reads the Parameter List sent by the Caller<br>
Return	Sends the Return Value to the Caller (User).<br>
Un-register	Un-registers ownership of the function.<br><dataset methods>	Defined below<br>
Properties<br>
Name	Name of the Interface<br>
SUID	STRIDE Unique Identifier for the Interface<br>
Parameter List	List of parameters for the Function Object.<br>
Return Value	Return value for the Function Object.<br>
Out Pointer Data	Out pointer data - defined as part of the Parameter List, populated as apart of the Output.<br><dataset properties>	Defined below<br><br>
User Function Object<br>
Metliods<br>
Call	Calls the remote function with the Object's Parameter List<br>
Read Return Value	Reads the Return Value returned by the Owner.<br><dataset methods>	Defined below<br>
Properties<br>
Name	Name of the Interface<br>
SUID	STRIDE Unique Identifier for the Interface<br>
Parameter List          \	List of parameters for the Function Object.<br>
Return Value	Return value for the Function Object.<br>
Out Pointer Data	Out pointer data - defined as part of the Parameter List, populated as apart of the Output.<br><dataset properties>	Defined below<br><br>
Spy Function Object	<br>
Methods	<br>
Read Parameter List	Reads (spies on) a copy of the Parameter List sent by the Caller<br>
Read Response	Reads (spies on) a copy of the Response sent from the Owner to the User<br>
Register	Register the Object as spy of the interface to thereafter receive copies of all Calls and Returns made between users and owners of the function.<br>
Un-register	Un-register the object as a spy.<br><dataset methods>	Defined below<br>
Properties	<br>
Name	Name of the Interface<br>
SUID	STRIDE Unique Identifier for the Interface<br>
Parameter List	List of parameters for the Function Object.<br>
Return Value	Return value for the Function Object.<br>
Out Pointer Data	Out pointer data - defined as part of the Parameter List, populated as apart of the Output.<br><dataset properties>	Defined below<br><br>
Datasets<br>
Methods<br>
Clear All Datasets	Clears / Deletes all datasets associated with either the Command or Response (Message Objects), or Input or Output (Function Objects)<br>
Delete Datasets	Deletes a specified number of datasets<br>
Insert Datasets         \	Inserts a specified number of datasets.<br>
Load Datasets	Loads datasets from the database and associates them with the interface object.<br>
Store Datasets	Stores the datasets currently associated with the interface object into the database.<br>
In one embodiment, for message objects, datasets are sets of data associated with either the command (command payload) or response (response payload and out pointer data). One-way messages have command datasets, broadcast messages have response datasets, and two-way messages have both. For function objects, datasets are associated with either the input (parameter list) and/or the output (return value and out pointer data).<br>
Scripting languages allow developers to customize, automate testing, and add macro capabilities. Scripting languages, in general, are easy to use for this type of functionality. Scripting languages also contain much of the same capability found in compiled languages such as loops, conditional statements, etc. A script program is text written in a script language that is executed by a script engine. The messaging automation component 304 provides a script program seamless and<br><br>
msiani access lo me commumcauon mieriaces oi eacn ui mc uircaus in uic cmucuucu v;uiiipuier 104 and the host computer 108. Using the messaging automation component 304, fields in a message or parameters in a remote function call can be set, read, tested against, or used in expressions. Via the messaging automation component 304, the scripting program can also transmit and receive communications seamlessly with software running on either an embedded computer 104 or the host computer 108. Furthermore, establishing such communication does not require code changes of the threads executing on either the embedded computer 104 and/or the host computer 108.<br>
In one embodiment of the invention, the script program is launched via an interface that is provided by the studio module 128. In another embodiment of the invention, the script program does not have to be launched by the studio module 128, but instead, can be launched and communicate directly with the host computer communication module 116.<br>
Figures 4A and 4B illustrate exemplary scripts that can execute in the script engine 312 to communicate with one of the threads 114 that are executing on the embedded computer 104 and/or the host computer 108. Code block 404 illustrates exemplary code that may be used to send a two way message. On line 3 of code block 404, the script sets an object "msg" equal to one of the messages that is maintained in the communication database 124. At line 6, the script sets a field in a payload that is associated with the message. As is known in the art, a payload is structured data. At line 9, the script sends a command message and waits for a response. At line 11, the script retrieves the response data. Code block 408 illustrates exemplary code that may be used to subscribe to a broadcast. COfie block 412 illustrates exemplary code that may be used to invoke a function. Code block 416 illustrates exemplary code that may be used to register ownership of a function.<br>
Figure 5 is a block diagram illustrating another embodiment of the invention. A COM composer 504 automatically builds a generated component 508 that serves as an interface between a COM-compliant application 512 and the host computer communication module 116. COM is a Microsoft technology that enables different applications to communicate with each other using a known interface, independent of the languages that the applications were developed in. For compatibility purposes, COM specifies the particular format and protocol of the interfaces.<br>
The generated component 508 provides the COM-compliant application 512 seamless and instant access to the communication interfaces of an embedded application through predefined API. Using the generated component 508, the COM-compliant application 512 seamlessly communicates with threads executing on the embedded computer 104 and the host computer 108. The host computer communication platform 116 automatically formats communication in a form<br><br>
suitable for its destination.  An exemplary process of formatting a communication is described below with reference to Figure 11.<br>
Set forth below is a description of the application programming interfaces that are provided by the generated component 508.<br><br>
Owner Message Object<br>
Methods<br>
Broadcast	Broadcasts a response to all subscribed Users. (Broadcast message type only)<br>
Read Command	Reads the Command sent by a User (One-way &amp; Two-way message types only)<br>
Register	Registers ownership of the service associated with the message (One-way &amp; Two-way message types only)<br>
Send Response	Sends the response. (Two-way message type only)<br>
Un-register	Un-registers ownership of the service. (One-way &amp; Two-way message types only)<br><dataset mcthods>	Defined below<br>
Tropertics<br>
Name	Name of the Interface<br>
SUID	STRIDE Unique Identifier for the Interface<br>
Command Payload	Command payload of the Message Object.<br>
Response Payload	Response payload of the Message Object.<br>
Out Pointer Data	Out pointer data - defined as part of the Command payload, populated as apart of the Response.<br><dataset properties>	Defined below<br><br>
User Message Object<br>
Methods<br>
Read Response	Reads the Response sent from the owner. (Two-way and Broadcast message types only)<br>
Send and Read	Combines the Send Command and Read Response methods (Two-way message type only)<br>
Send Command	Sends the Command to the registered Owner (One-way and Two-way message types only)<br>
Subscribe	Subscribes to the service associated with the Message. Once   subscribed  the   Message  object will  receive  ali broadcasts sent by any owner of the service. (Broadcast message type only)<br>
Un-subscribe	Un-subscribes to the service.<br><dataset methods>	Defined below<br>
Properties<br>
Name	Name of the Interface<br>
SUID	STRIDE Unique Identifier for the Interface<br>
Command Payload	Command payload of the Message Object.<br>
Response Payload	Response payload of the Message Object.<br>
Out Pointer Data	Out pointer data - defined as part of the Command payload, populated as apart of the Response.<br><dataset properties>	Defined below<br><br>
Spy Message Object<br>
Methods<br>
Read Command	Reads (spies on) a copy of a command sent from a User to the Register Owner<br>
Read Response	Reads (spies on) a copy of a Response sent from the Owner to the User<br>
Register	Register as a spy of the interface to thereafter receive copies of all Commands and Responses sent by Owners and Users of the Service.<br>
Un-register	Un-register the object as a spy<br><dataset methods>	Defined below<br>
Properties<br>
Name	Name of the Interface<br>
SUID	STRIDE Unique Identifier for the Interface<br>
Command Payload	Command payload of the Message Object.<br>
Response Payload	Response payload of the Message Object.<br>
Out Pointer Data	Out pointer data - defined as part of the Command payload, populated as apart of the Response.<br><dataset properties>	Defined below<br><br>
Owner Function Object	<br>
Methods	<br>
Register	Registers ownership of the service  associated with the function<br>
Read Parameter List	Reads the Parameter List sent by the Caller<br>
Return	Sends the Return Value to the Caller (User).<br>
Un-register	Un-registers ownership of the function.<br><dataset methods>	Defined below<br>
Properties	<br>
Name	Name of the Interface<br>
SUID	STRIDE Unique Identifier for the Interface<br>
Parameter List	List of parameters for the Function Object.<br>
Return Value	Return value for the Function Object.<br>
Out Pointer Data	Out pointer data - defined as part of the Parameter List, populated as apart of the Output.<br><dataset properties>	Defined below<br><br>
User Function Object	<br>
Methods	<br>
Call	Calls the remote function with the Object's Parameter List<br>
Read Return Value	Reads the Return Value returned by the Owner.<br><dataset methods>	Defined below<br>
Properties	<br>
Name	Name of the Interface<br>
SUID	STRIDE Unique Identifier for the Interface<br>
Parameter List          \	List of parameters for the Function Object.<br>
Return Value	Return value for the Function Object.<br>
Out Pointer Data	Out pointer data - defined as part of the Parameter List, populated as apart of the Output.<br><dataset properties>	Defined below<br><br>
spy Function Object	<br>
Methods	<br>
Read Parameter List	Reads (spies on) a copy of the Parameter List sent by the Caller<br>
Read Response	Reads (spies on) a copy of the Response sent from the Owner to the User<br>
Register	Register the Object as spy of the interface to thereafter receive copies of all Calls and Returns made between users and owners of the function.<br>
Un-register	Un-register the object as a spy.<br><dataset methods>	Defined below<br>
Properties	<br>
Name	Name of the Interface<br>
SUID	STRIDE Unique Identifier for the Interface<br>
Parameter List	List of parameters for the Function Object.<br>
Return Value	Return value for the Function Object.<br>
Out Pointer Data	Out pointer data - defined as part of the Parameter List, populated as apart of the Output.<br><dataset properties>	Defined below<br><br>
Datasets<br>
Methods<br>
Clear All Datasets	Clears / Deletes all datasets associated with either the Command or Response (Message Objects), or Input or Output (Function Objects)<br>
Delete Datasets	Deletes a specified number of datasets<br>
Insert Datasets          \	Inserts a specified number of datasets.<br>
Load Datasets	Loads datasets from the database and associates them with the interface object.<br>
Store Datasets	Stores the datasets currently associated with the interface object into the database.<br>
It is noted, that in one embodiment, the MAC 304, the studio module 128, the generated component 508, can be utilized together to provide a communication system for various types of applications. For example, using the application programming interface of the MAC 304, a scripting program in a first language can communicate with a scripting program in the same or a second language, a COM-compliant application 512 via the generated component 508, a thread executing on the embedded computer 104, a thread executing on the host computer 108, and the studio module 128.<br>
Furthermore, for example, using the application programming interface of the generated component 508, a COM-compliant application can communicate with a scripting program via the<br><br>
MAC 304, another COM-compliant application, a thread executing on the embedded computer 104, a thread executing on the host computer 108, and the studio module 128.<br>
Furthermore, for example, using the studio 128, a user can send and receive messages to and from the COM-compliant application 512, a scripting program, a thread executing on the host computer 108, a thread executing on the embedded computer 104.<br>
Figure 6 is a representational block diagram illustrating one embodiment of the communication database 124. Depending on the embodiment, additional types of information may be added to the database and/or certain types of information may be omitted.<br>
The communication database 124 includes a platform-specific configuration section 604. The platform-specific configuration section 604 contains embedded computer machine characteristics and host computer machine characteristics. The characteristics can include items, such as: an indication of whether the platform is big or little Endian, enumeration sizes, pointer sizes, structure alignment boundaries, etc. It is noted that in one embodiment of the invention, the embedded computer machine characteristics and the host computer machine characteristics are stored in a location other than the communication database 124, such as the host computer communication module 116 or the embedded computer 104.<br>
The communication database 124 also includes a messages section 608 and a prototypes section 610. The messages section 608 and the prototypes section 610 respectively describe the characteristics of each of the messages and remote function calls on the embedded computer 104 and the host computer 108. The characteristics can include: (i) the unique name and or identifier of the message; (ii) the total ^ize of the message; (iii) the type of the communication, e.g., one-way message, two-way message, broadcast message, remote function call; and (iv) the types of data are passed as part of the communication. A one way message is sent from a "user" of the communication to the "owner" of the communication. A thread can request ownership of a message via a registration routine that is provided via an application programming interface of the host computer communication module 116. A two way message comprises a "command" that is sent from the user to the owner and a "response" that is sent from the owner to the user. A broadcast message is sent to all threads that have registered to receive the broadcast.<br>
The communication database 124 also includes a trace points section 612 for maintaining trace points. The communication database 124 also includes a description of the data types that are supported by the messages identified in the messaging section 608 and the functions listed in the prototypes section 610.<br>
The data types section 616 includes: (i) a description of the data types in the data structures that are part of a message or remote function call, e.g., integer, character. Boolean, floating-point.<br><br>
arrays, etc; (ii) the field name of each of the elements in each of the messages; (iii) and a description of characteristics of embedded pointers that may be part of the message.<br>
Figure 7 is a block diagram illustrating an exemplary component hierarchy of the generated component 508. The COM-compliant object 512 initially accesses the generated component 508 via a root object 704. Via the root object 704, the COM-compliant object 512 can send commands and receive responses from particular messages and remote function calls that are defined in the communication database 124. For example, as is shown in Figure 7, the COM-compliant object has access to an object 708 that is associated with "MESSAGE 1" and an object 712 that is associated with "MESSAGE 2." Using predefined interfaces associated with these message objects, the COM-compliant object 512 can send and receive payloads with threads that are executing on the embedded computer 104.<br>
Figure 8 is a flowchart illustrating a process of modifying source code to communicate with the DAT system 100. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged. Starting at a step 804, a programmer adds API calls to invoke a registration method that is provided by the DAT system 100. In one embodiment of the invention, a registering thread provides a unique thread identification code.<br>
Next, at a step 808, the programmer adds API calls to invoke a read method that is provided by the DAT system 100. Continuing to a step 812, the programmer adds, where applicable, API calls to invoke a send method that is provided by the DAT system 100.<br>
Continuing to a state 816, the programmer adds API calls to "subscribe" to a message. Subscribing to a message allipws a subscriber to bind to a specific message and thereafter receive<br>
t<br>
all broadcast transmissions. Other messaging APIs may be provided by the DAT system 100 such as for the following: sending a command; sending a response; broadcasting a message; and defining the data (content) and meta-data (characteristics) of the payload of a message.<br>
Figure 9 is a block diagram illustrating an exemplary process of building the communication database 124. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged. In one embodiment of the invention, the process shown in Figure 9 is performed in response to a user request.<br>
Starting at a state 904, the studio module 128 reads and extracts information fi-om each of a plurality of interface definition files that are provided by the user. Next, at a step 908, the studio module 128 extracts the communication interfaces from each of the interface definition files. Information that is extracted can include: (i) the type of the communication, e.g., one-way, two-way, broadcast, remote function call; (ii) the types of data are passed as part of the communication; (iii) a description of the data types in the data structures that are part of a message or remote function call, e.g., integer, character, Boolean; (iv) a description of characteristics of<br><br>
embedded pointers that may be part of the message, e.g., whether the memory is "pooled" or "private", a method of transmitting the memory that is associated with the communication interface, and pointer data that is associated with the communication interface.<br>
Next at a step 916, the studio module 128 stores the embedded computer machine characteristics. The embedded computer machine characteristics can be provided by user entry, automatic diagnosis of the embedded computer 104, or automatically provided by the embedded computer 104. Examples of the embedded computer machine characteristics are described above with respect to Figure 6. In one embodiment, it is assumed that these characteristics are fixed, i.e., exactly the same on each connection.<br>
Proceeding to a step 920, the studio module 128 stores the host computer machine characteristics. The host computer machine characteristics can be provided by user entry or automatic diagnosis of the host computer 108. Examples of the host computer machine characteristics are described above with respect to Figure 6.<br>
Figure 10 is a flowchart illustrating a process of using the DAT system 100. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged. Starting at a step 1004, the DAT system 100 receives registration information from each thread. Next, at a step 1008, the DAT system receives a payload for a particular message.<br>
Continuing to a step 1012, the DAT system 100 formats the payload for transmission to its destination thread. It is noted that if the destination thread is local to the transmitting thread, then formatting may be unnecessary. An exemplary process of formatting data for transmission to a remote platform is described below with reference to Figure 11. Moving to a step 1016, the DAT system 100 transmits the formatted payload to the destination thread.<br>
Figure 11 is a flowchart illustrating a process of formatting data for use on an different platform. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged. In one embodiment of the invention, the process that is performed by Figure 11 is performed by the host computer communication module 116 of the DAT system 100. Furthermore, Figure 11 is directed to a process of formatting a payload for transmission from one platform, e.g., the host computer 108 to another, e.g., the embedded computer 104.<br>
The use of the process shown in Figure 11 provides interoperability between applications communicating with each other on distributed heterogeneous computing platforms. In one embodiment of the invention, to reduce processing and memory requirements on embedded devices, the DAT system 100 performs all data formatting on the host computer 108.<br>
The host computer 108 uses the platform characteristics of the embedded computer 104 and the host computer 108 and the individual interface definition information ("the communication<br><br>
interface information") to properly map messages when two applications on the different computers are communicating. In one embodiment, the embedded computer 104 always sends and receives messages in its native form, i.e., the form in which the message is stored in its memory. The host computer 108 maps these messages into its form when receiving them, and transforms the messages into the embedded computer 104 platform's native form when transmitting the messages to the embedded computer 104.<br>
Starting at a decision state 1104, the host computer communication module 116 determines whether the destination thread is local or remote. If the thread is local, the process proceeds to a step 1108 and the payload is queued for transmission to the destination thread. If the transmission is local, no further modification of the payload is necessary.<br>
Referring again to the decision step 1104, if the destination thread is not local, the process proceeds to a step 1112, wherein the host computer communication module 116 copies data in payload and data referenced by pointers into a message for transmission to the embedded computer 104. An exemplary process of managing pointer data is described in further detail below with reference to Figures 12A, 12B, 12C, and 12D.<br>
Continuing to a step 1116, the host computer communication module 116 formats, if necessary, the byte order of the elements in data in the payload. For example, if the host computer 108 is Big Endian, and the embedded computer 104 is Little Endian, or vice-versa, the host computer communication module 116 reverses the order of the bits in the data.<br>
Proceeding to a step 1124, the host computer communication module 116 formats the size of the data types in the paylpad. For example, if the embedded computer 104 uses a certain bit-length for certain data types and the host computer uses a different bit-length, the host computer communication module 116 adjusts the size of the data for transmission to the other platform. Moving to a step 1128, the host computer communication module 116 adjusts alignment of the data structures according to any requirement of the receiving platform.<br>
Figures 12A-12D each illustrate an exemplary method of managing pointers in a payload that are passed from one platform to another. Figure 12A is directed to a process of receiving a payload from a thread on the embedded computer 104 in connection with a "command" message. In one embodiment. Figure 12A is performed with respect to each of the pointers in the payload. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged. In one embodiment of the invention, the method shown in Figure 12 is performed by the host computer communication module 116. It is noted that a similar process as shown in Figure 12 is performed on the embedded computer communication module 112 when the embedded computer communication module 112 receives a command message. However, in one embodiment, for such a process the embedded computer communication module 112 does not<br><br>
perform any of inter-platform formatting of the received data as such formatting is performed by the host computer communication module 116.<br>
Before starting at a state 1204, a thread on the embedded computer 104 has invoked a send command that is part of the application programming interface of the embedded computer communication module 112. In response, the embedded computer communication module 112 has built and then transmitted an inter-platform message to the host computer communication module 116. The inter-platform message includes the payload that was identified as part of the send command and, if applicable, the data that is referenced by the pointers in the payload.<br>
Starting at a step 1204, the host computer communication module 116 gets the embedded pointer attributes of a selected pointer in the payload of the transmitted communication. In one embodiment of the invention, the attribute information is stored in the transmitted communication. A first attribute of each pointer is whether the pointer is classified as "IN", "OUT', or "IN/OUT". The "IN" attribute designates that the data referenced by the pointer is passed from the sender of the command to the owner of the message but no data is to be returned by the owner of the message. The "OUT" attributes designates that the sender of the command will not transmit any data that is referenced by the pointer but data Will be returned by the owner and stored in the address referenced by the pointer. The "IN/OUT" attribute indicates that the data that is referenced by the pointer will be sent from the sender of the command and that the owner of the message will return data that is stored in the memory referenced by the pointer.<br>
A second attribute of each pointer is whether the pointer is "private" or "pooled." Management (freeing of the Kiemory when not in use) of "private" memory is handled by the DAT system 100. Management of "pooled" memory is handled by the user and/or the owner of a message.<br>
Continuing to a step 1210, the host computer communication module 116 creates a local buffer to hold the pointer data. Continuing to a decision step 1212, the host computer communication module 116 determines whether the pointer attribute is either "IN" or "IN/OUT". If the pointer attribute is "IN" or "IN/OUT", the process proceeds to a step 1214. Continuing to a step 1214, the host computer communication module 116 copies the pointer data that was transmitted from the embedded computer 104 into the local buffer. At this step, the host computer communication module 116 formats the pointer data in accordance with the process described above with reference to steps 1116, 1124, and 1128.<br>
Next, at a step 1218, the host computer communication module 116 copies the address of the buffer into the payload. Proceeding to a decision step 1220, the host computer communication module 116 determines whether the first attribute of the pointer is "IN". If the first attribute of the pointer is "IN" the process proceeds to a decision step 1222.  At the decision step 1222, the host<br><br>
computer communication module 116 determines whether the second attribute of the pointer is "private". If the second attribute of the pointer is private, the process proceeds to a step 1228. Otherwise if the second attribute of the pointer is not private, /.e., pooled, the process ends.<br>
Referring again to the decision step 1212, if the first attribute is not "IN" or "IN/OUT", the attribute is the "OUT" and the process proceeds to a step 1216. At the step 1216, the host computer communication module 116 copies the address of the local buffer into the payload. From step 1216, or from decision step 1220 (if the first attribute is "IN/OUT"), the process proceeds to a step 1224. At this step, the host computer communication module 116 waits for thread on the host computer 108 to invoke a response command that is provided by the application programming interface of the DAT system 100. Upon receiving the response, the process proceeds to a step 1226. At this step, the response data is formatted for transmission to the embedded computer 104.<br>
From either step 1226 or from the decision step 1222 (if the second attribute of the pointer is "private"), the process proceeds to a step 1228 wherein the host computer communication module 116 waits for a thread on the host computer 104 to invoke a read complete command that is in the application programming interface of the host computer communication module 116. Upon receipt of the read complete command, the process proceeds to a step 1230 wherein the host computer communication module frees the memory.<br>
Figure 12B is directed to a process of managing pointers in a payload in a command message that is sent from a thread on the host computer 108 to a tliread on embedded computer 104. Figure 12B illustrates in further detail the steps that occur in step 111 of Figure 11. In one embodiment. Figure 12B ii performed with resect to each of the pointers in the payload. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged. A similar process is performed by the embedded computer when transmitting a command message from a thread on the embedded computer 104 to the host computer 108. However, in this process, the embedded computer communication module 112 does not perform any formatting of the transmitted payload since the formatting is performed by the host computer communication module 116 upon receipt of the payload.<br>
Starting at a step 1230, the host computer communication module 116 creates a buffer to hold an inter-platform message for transmission to the embedded computer 104. Also, at this step, the host computer communication module 116 creates a header in the inter-platform message for the embedded pointer. Furthermore, at this step, the host computer communication module 116 stores the pointer attributes of the pointer in the inter-platform message.<br>
Continuing to a decision step 1232, the host computer communication module 116 determines whether the pointer attribute of the pointer is "OUT". If the attributes of a selected pointer is "OUT", the process ends. However, if the pointer attribute is not "OUT", i.e., it is "IN"<br><br>
or "IN/OUT", the process proceeds to step 1244. At the step 1244, host computer communication module 116 copies the data referenced by the pointer into the header. Furthermore, the host computer communication module 116 formats the data for use by a thread on the embedded computer 108. For example, the host computer communication module performs the steps described above with respect to steps 1116, 1124, and 1128.<br>
Next, at a decision step 1236, the host computer communication module 116 determines whether the pointer attributes is "IN." If the pointer attribute is "IN", the process proceeds to a step 1240. At this step, the host computer communication module 116 frees the memory, if warranted, i.e., the attributes of the pointer designate "pool". However, if the pointer attribute is not "rN", the proceeds ends.<br>
Figure 12C is directed to a process of receiving a response message from the embedded computer communication module 112. Figure 12C illustrates in further detail the steps that occur in step 111 of Figure 11. In one embodiment. Figure 12C is performed with resect to each of the pointers in the payload. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged. A similar process is performed by the embedded computer 104 when transmitting a command message from a thread on the embedded computer 104 to the host computer 108. However, in this process, the embedded computer communication module 112 does not perform any formatting of the transmitted payload since the formatting is performed by the host computer communication module 116 upon receipt of the payload.<br>
Before starting at a itate 1250, a thread on the embedded computer 104 has invoked a send response command that is part of the application programming interface of the embedded computer communication module 112. In response, the embedded computer communication module 112 has built and then transmitted an inter-platform message to the host computer communication module 116. The inter-platform message includes the payload that was identified as part of the send response and, if applicable, the data that is referenced by the pointers in the payload.<br>
Starting at a decision step 1250, the host computer communication module 116 determines whether the pointer attributes of the pointer in the inter-platform message designate the attribute "IN". If the pointer attributes designate the attribute "IN", the process proceeds to a step 1252, and the host computer communication module 116 formats the received data for use with the host computer 108. For example, in one embodiment, the host computer communication module 116 performs the steps described above with respect to steps 1116, 1124, and 1128.<br>
However, if the pointer attributes do not designate "IN", i.e., the pointer attributes designate "IN/OUT" or "OUT", the process proceeds to a step 1254. At the step 1254, the host computer communication module 116 creates a local buffer to store the pointer data that was<br><br>
transmitted by the embedded computer 104. Continuing to a step 1256, the host computer communication module 116 copies the pointer data from the inter-platform communication into the local buffer. Next, at step 1258, the host computer communication module 116 copies the address of the buffer into the received payload.<br>
Proceeding to a decision step 1260, the host computer communication module 116 determines whether it should free the pointer. In one embodiment of the invention, this is determined by reading the pointer attributes. If the pointer attributes designate "private" the host computer communication module 116 decides to free the memory. However, if the pointer attributes designate "pooled" the host computer communication module 116 allows the user to free the memory.<br>
If the host computer communication module 116 determines in step 1260 to free the memory, the process proceeds to a step 1262, wherein the host computer communication module 116 waits for a thread on the host computer 108 to invoke the read complete command. Continuing to a step 1264, the host computer communication module 116 frees the local buffer. From either decision step 160 (if the host computer communication module 116 does not free the pointer) or the step 1264 the process ends.<br>
Figure 12D is directed to an exemplary process of managing pointers in a payload in a response message that is sent from a thread on the host computer 108 to a thread on embedded computer 104. Figure 12D illustrates in further detail the steps that occur in step 1112 of Figure 11. In one embodiment. Figure 12D is performed with resect to each of the pointers in the payload. Depending on the Embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged. A similar process is performed by the embedded computer 104 when transmitting a response message from a thread on the embedded computer 104 to the host computer. However, in this process, the embedded computer communication module 112 does not perform any formatting of the transmitted payload since the formatting is performed by the host computer communication module 116 upon receipt of the payload.<br>
Before starting, a thread on the embedded computer 104 has sent a command message and a thread on the host computer 108 has responded by invoking the send response routine of API of the DAT system 100.<br>
Starting at a step 1265, the host computer communication module 116 allocates space in an outgoing buffer ("a header") to store the data that is referenced by the pointer. The outgoing buffer is part of an inter-platform message that is sent from the host computer communication module 116 to the embedded computer communication module 112. Proceeding to a decision step 1266, the host computer communication module 116 determines whether the pointer attributes designate "IN". If the pointer attributes do designate "IN", i.e., they do not designate "OUT" or "IN/OUT",<br><br>
the process proceeds to a decision step 1267. At the decision step 1267, the host computer communication module 116 determines whether to free memory that is associated with the memory that was allocated during the corresponding send command. In one embodiment of the invention, this is determined by reading the pointer attributes. If the pointer attributes designate "pool" the host computer communication module 116 decides to free the memory. However, if the pointer attributes designate "private" the host computer communication module 116 allows the user to own and eventually free the memory (via an routine provided by the local operating system). If the host computer communication module 116 determines it should free the memory, the process proceeds to a step 1268, and the host computer communication module 116 frees the memory. From either step 1268 or decision step 1266 (if the pointer attributes does not designate "IN"), the process proceeds to a step 1270 and the host computer communication module 116 formats the data referenced by the pointer for transmission to the embedded computer. For example, in one embodiment, the host computer communication module 116 performs the steps described above with respect to steps 1116, 1124, and 1128. As part of the formatting, the formatted data is stored in the header (step 1265).<br>
Figure 13 is flowchart illustrating a process of using the DAT system 100 from a script in the script engine 312. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged. Starting at a step 1304, the studio module 128 has received a request from a user to load a script file and it does so here. Next, at a step 1312, studio determines script type that is associated with the script file. The script type can be determined in different wa^s, including examining the extension of the identified script file or from the contents of the script itself. Exemplary types of scripting languages include: JavaScript, Visual Basic, VBScript, Tel, JScript, Python, etc.<br>
Moving to a step 1316, the studio module 128 identifies the corresponding script engine 312 that is associated with the script type. Continuing to a step 1320, the studio module 128 initializes the script engine 312.<br>
Next, at a step 1324, the studio module 128 loads the messaging automation component ("MAC") 304. The process of loading the MAC 304 is described below with reference to Figure 14. Proceeding to a step 1328, the MAC 304 is "exposed" to the script engine 312. In one embodiment of the invention, exposing the MAC 304 includes providing the script engine 312 a handle to the MAC 304. Next, at a step 1332, the script engine is launched, allowing the script loaded in a step 1304 to access the API of MAC 304. Moving to a step 1336, a script program can communicate with threads 114 using the API of the MAC 304. An exemplary process of using the MAC 304 is described below with respect to Figure 15.<br><br>
Figure 14 is a flowchart illustrating a process of loading the MAC 304. Figure 14 illustrates in further detail the steps that occur in step 1324 of Figure 13. Starting at a step 1404, the studio module 128 calls the initialization routine of the MAC 304 and passes as a parameter a handle to the communication database 124. Next, at a step 1408, the MAC 304 generates a messaging automation component "MAC" database object. The MAC database object contains certain of the information from the communication database 114. The MAC database is used by the scripting program to access application programming interfaces of the MAC 304.<br>
Figures 15-17 are flowcharts illustrating a process of communicating with the MAC 308 using a scripting language. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged. Figure 15 is a flowchart directed to a process of registering a particular message with the MAC 304. Starting at a step 1504, a script that is executing in the scripting engine 312 invokes a register method of the MAC 304. Proceeding to a step 1508, the MAC object calls the register API of the host computer communication module 116. Figure 16A is a flowchart illustrating a process of sending a message via the MAC 304. Starting at a step 1604, the script retrieves reference to a MAC database object. Next, at a step 1606, the script requests the MAC database object to provide a reference to a message object. The message object is used by the script program to communicate with a owner of a communications or to receive communications from others. Using the message object, a script can set fields of the message, send a message, receive a message, and perform other standard messaging functions.<br>
Continuing to a step 1610, the MAC database object retrieves the message definition information from the comn^unication database 124. In one embodiment of the invention, the message definition information is retrieved via the host computer communication module 116. In another embodiment of the invention, the message definition information is retrieved directly from the communication database 124. The message definition information includes: (i) the type of the communication, e.g., one-way, two-way, broadcast, remote function call and (ii) the types of data that are passed as part of the communication. Next, at a step 1614, the MAC database object creates a MAC message object based upon the prototype definition retrieved from the communication database 124.<br>
Proceeding to a step 1618, the MAC database object retrieves any data sets from the communication database that are stored with respect to the requested message object. Next, at a step 1622, the MAC database object adds the data sets to the message object (created in step 1614). Moving to a step 1624, the MAC database object returns a reference to the message object to the script. Next, at a step 1628 the script can set the data fields of the message using reference to the message object. The script has access via the MAC database object to a plurality of readable and writeable data sets.  At this step, the script can identify one of the data sets for subsequent<br><br>
usage. Continuing to a step 1632, the script invokes a send method of the method object. Proceeding to a step 1636, the MAC database object sends a data set that is referenced by the current index to the thread that owns the message.<br>
Next, at a decision step 1640, the MAC database object determines whether auto-increment is enabled. Auto-increment enables a script to send different data sets with each send command. If auto-increment is enabled, the process proceeds to a step 1644, and the MAC database object selects the next data set. Referring again to the decision step 1640, if auto-increment is not enabled, the process ends.<br>
Figure 16B is a flowchart illustrating a process of invoking a function via the MAC 304. Starting at a step 1650, the script retrieves reference to the MAC database object. Next, at a step 1654, the script requests the MAC database object to provide a reference to a remote function call object. The remote function call object is used by the script program to communicate with the thread that handles the remote function call. Using the remote function call object, a script can set the parameters that will be passed upon invoking the remote function call.<br>
Continuing to a step 1658, the MAC database object retrieves the remote function call prototype definition information from the communication database 124. In one embodiment of the invention, the prototype definition information is retrieved via the host computer communication module 116. In another embodiment of the invention, the message definition information is retrieved directly from the communication database 124.<br>
Next, at a step 1662, the MAC database object creates a MAC remote function call object based upon the remote fuAction call prototype definition retrieved from the communication database 124.<br>
Proceeding to a step 1664, the MAC database object retrieves any data sets fi-om the communication database that are stored with respect to the requested remote function call object. Next, at a step 1666, the MAC database object adds the data sets to the MAC remote function call object.<br>
Moving to a step 1668, the MAC database object returns a reference to the remote function call object to the script. Next, at a step 1670, the script can set the data fields (parameters) of the remote function call using the remote function call object. The script has access via the MAC database object to a plurality of readable and writeable data sets. At this step, the script can identify one of the data sets for subsequent usage. Continuing to a step 1672, the script invokes a call method of the remote function call object. Proceeding to a step 1674, the MAC database object sends a data set that is referenced by the current index to the thread that handles the remote function call.<br><br>
Next, at a decision step 1676, the MAC database object determines whether auto-increment is enabled. Auto-increment enables a script to send different data sets with each send command. If auto-increment is enabled, the process proceeds to a step 1678, and the MAC database object selects the next data set. Referring again to the decision step 1676, if auto-increment is not enabled, the process ends.<br>
Figure 17A is a flowchart illustrating a process of a script receiving a message via the MAC 304. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged.<br>
Starting at a step 1700, the script calls a read method of the MAC database object. Next, at a step 1704, the MAC database object calls a read API of the host computer communication module 116. Continuing to a step 1708, the host computer communication module 116 waits for a message to be received. Proceeding to a step 1712, the MAC database object receives the message and a message identifier from the host computer communication module 116. Next, at a step 1720, the MAC database object returns a message object to the script, which can in turn access the contents of the requested message.<br>
Figure 17B is a flowchart illustrating a process of a script receiving a communication via function call application programming interfaces that are provided by the MAC 304. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged. Starting at a step 1750, the script calls a read method of the MAC database object. Next, at a step 1754, the MAC database object calls the read API of the host computer communication module 116. Continuing to a step 1758, the MAC database object waits for a remote function call command message to be received. Next, at a step 1762, the MAC database object receives the remote function command message and the function identifier.<br>
Proceeding to a step 1764, a remote function call object is returned to the script program. Next, at a step 1766, the script program access the input parameters of the remote function call object.<br>
Moving to a step 1768, the MAC database object returns a reference to the remote function call object to the script. Next, at a step 1770, the script invokes a return method of the remote function call object. Continuing to a step 1772, the remote function call object calls the send application programming interface of the host computer communication module 116. Proceeding to a step 1774, the MAC database object sends a data set that is referenced by the current index to the thread that handles the remote function call.<br>
Next, at a decision step 1776, the MAC database object determines whether auto-increment is enabled.  Auto-increment enables a script to send different data sets with each send<br><br>
command. If auto-increment is enabled, the process proceeds to a step 1778, and the MAC database object selects the next data set. Referring again to the decision step 1776, if auto-increment is not enabled, the process ends.<br>
Figure 18 is a flowchart illustrating a process of interfacing with the DAT system 100 firom any COM-compliant language. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged. Starting at a step 1804, a user loads "launches" the COM composer tool 504 (Figure 5). An exemplary process of loading the COM composer tool is described below with reference to Figure 19.<br>
Next, at a step 1808, the COM composer builds the generated component 508 (Figure 5). The generated component 508 is a COM object that is accessible by other COM compliant programs. Using the generated component 508, a COM-compliant program can easily: test a interface, send a communication to a thread that is executing on the embedded computer 104 or the host computer 108, receive a communication that is sent from a thread this executing on the embedded computer or the host computer 108, and other functions as described herein. The generated component 508 provides a plurality of predefined interfaces for performing each of the foregoing functions. An exemplary process of building the generated component 508 is described below with reference to Figure 20.<br>
Continuing to a step 1816, the generated component 508 is accessible via any COM-compliant language. An exemplary process of using the generated component is described below with reference to Figure 22.<br>
Figure 19 is a flowchart illustrating an exemplary process of launching the COM composer tool 504. Figure 19 illustrates in further detail certain steps that occur in step 1804 of Figure 18. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged.<br>
Starting at a step 1904, a user identifies a database. The DAT system 100 can support multiple databases for multiple projects. Continuing to a step 1908, the user selects which messages or functions of the selected database are to be included in the generated COM object. In one embodiment of the invention, the user selects the messages and/or remote function calls via a graphical user interface utility.<br>
Proceeding to a step 1912, the user selects the compiler version. The COM composer 504 needs to know the version of the compiler that is being used to build the generated component 508 to provide the proper control files in the proper format. Moving to a step 1916, the COM composer 504 requests the user to designate the type of build, e.g., release or debug.<br>
Figure 20 is a flowchart illustrating an exemplary process of building the generated component 508.   Figure 20 illustrates in further detail certain steps that occur in step 1808 of<br><br>
Figure 18. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged.<br>
Starting at a step 2004, the COM composer tool loads the data that was identified by the user (step 1904) into memory. Next, at a step 2008, the COM composer tool begins a process that is performed with respect to the following: (i) all of the messages and/or remote function calls identified by the user (step 1908), (ii) all of the payloads of the identified messages and/or remote function calls, and (iii) the root object that is used to access all other objects in the generated component 508. In one embodiment, steps 2012, 2016, 2020, and 2024 are performed for each of the foregoing objects.<br>
At the step 2012, the COM composer 504 generates a software interface for each of the objects. An exemplary process of generating an interface is described below with reference to Figure 21. Next, at a step 2016, the generated component generates a COM class definition for the object, otherwise known as a co-class. Proceeding to a step 2020, the COM composer generates a COM class implementation for each of the COM objects. For further information regarding generating software interfaces, COM class definitions, and a COM class implementations, please see the following references: DON BOX, ESSENTIAL COM (1998), and BRENT RECTOR, CHRIS SELLS &amp; JIM SPRINGFIELD, ATL INTERNALS (1999).<br>
Moving to a decision step 2024, the COM composer 504 determines whether it has processed all of the messages/remote function calls, payloads, and the root object. If all of these items have not been processed, the process returns to the step 2012 (discussed above). However, if all of the items have been processed, the COM composer 504 proceeds to a step 2028 and provides any compiler specific files that are needed, if any.<br>
Next, at a step 2032, the COM composer 504 launches the selected compiler to build the generated component 508. In one embodiment of the invention, the COM component is provided in a dynamic link library ".DLL". Moving to a step 2036, the COM composer 504 registers the dynamic link library with a registry in the host computer 108.<br>
Figure 21 is a flowchart illustrating a process of generating an interface. Figure 21 illustrates in further detail the steps that occur in step 2012 of Figure 20. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged.<br>
Starting at a step 2104, the COM composer 504 generates method definitions for "built-in" member functions. Next, at a step 2108, the COM composer 504 generates accessor function for child objects 2108. For example, the children of the root object includes each of the messages and/or remote function calls. Furthermore, for example, the children of a message object and/or a remote function call object includes one or more payloads that are associated with the object.<br><br>
Moving to a step 2112, the COM composer 504 generates interface for setting and getting properties of objects.<br>
Figure 22 is a flowchart illustrating a process of using the generated component 508 Figure 22 illustrates in further detail certain steps that occur in step 1816 of Figure 18. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged.<br>
Before starting at a step 2216, the user has opened a COM development environment and located the via the COM development environment the generated component 508.<br>
Starting at the step 2216, the user creates a reference to the generated component 508. Next, at a step 2220, the user creates an instance of the root object. Moving to a step 2224, the user can use the root object accessor function to retrieve a desired message object or remote function call object. Continuing to a step 2228, the user can use the accessor function of the object to select a desired payload object.<br>
Proceeding to a step 2232, the user invokes a method of the payload object to get or set properties of the payload object. For, example, the user can store data in the payload object. Next, at a step 2236, the user invokes methods on the message object or the remote function call object to send a communication. The user may also invoke other methods on a message object such as register the message such any broadcast on the message is received by the invoking process. Other methods are described above with reference to Figure 5. Next, at a step 2240, the user implements an event handler to receive asynchronous communications that are received, if any.<br>
Figure 23 is a flowc5art illustrating a process of using the studio module 128. The studio module 128 provides a graphical user interface control panel for testing each of the communication interfaces that are identified by the communication database 124. Starting at a step 2304, a user loads a selected communication database 124. A user may have different communication databases for different projects. Once loaded, a user may view and select any of the communication interfaces in the communication database 124. After a is selected, the user can perform a number of functions with respect to the database such as: designating ownership of a communication interface (step 2312), generating a data set (state 2316), sending a field of information (step 2320), and sending a data set (step 2324).<br>
Figure 24 is a flowchart illustrating a process of generating a data set based upon monitoring the communication between two threads executing under the DAT system 100. It is noted that the process of generating a data set can be initiated by a user either: (i) the studio module 128, (ii) C language source code that invokes a method of the host computer communication module 116, (iii) a script executing in the script engine 312, or (iv) a COM-compliant application via the generated component 508.<br><br>
Starting at a step 2404, the user specifies the communication data paths that are to be traced. For example, the DAT system 100 can trace that data is sent via a message or via a remote function call.<br>
Next, at a step 2408, the DAT system 100 monitors and stores the data that is transmitted across each of the designated communication paths. In one embodiment of the invention, the data is stored in a persistent test data object. Proceeding to a step 2412, any thread can then select and retrieve the contents of any of persistent test data objects and use the data for testing. Continuing to a step 2416, one of the threads of the DAT system 100 uses one of the persistent data object to transmit data from one of the selected persistent data object across one of the communication data paths.<br>
Figure 25 illustrates an exemplary user interface 2500 that is provided by the studio<br>
module 128. The user interface 2500 includes an interface window 2504 that lists all of the<br>
interfaces that are maintained in the communication database 124. Each entry in the in the<br>
interface list is selectable by a user. In response to user selection, a communication window 2508<br>
is displayed on the screen. The communication window 2508 includes an register icon 2510 that<br>
allows a user to register ownership of a message or remote function call. In one embodiment, if a<br>
message is a two-way message, the communication window is divided into a command window<br>
2508 and a response window 2510. The command window and the response window include one<br>
or more data set fields 2512. The number of data set fields is configurable by the user. The data<br>
sets show the contents of the most recent payload and a user configurable number of previously<br>
received payloads.	Using the data set fields 2512, the user can build a payload for a particular command message and set the payload of the response message. Furthermore, the user can select a "store data set" icon 2514 to store the values in the data set fields 2512 in the communication database 124. Later, the user can select a "load data set" icon 2516 to load the stored values. Furthermore, the user may select a clock icon 2518 to have the studio module 128 automatically iterate and transmit the data values in sequence at a user configurable time interval.<br>
Figure 26 illustrates an exemplary user interface 2600 that allows a user to view and test the parameters that are transmitted as part of a function call. Using a register icon, a user can register ownership of a function. A user window 2608 displays a plurality of parameter fields 2610 that allow a user to set the values of parameters in the function. An owner window 2610 displays the parameters that have been passed to the function. The user interface 2600 allows the saving and loading of data sets as described above with reference to Figure 25.<br>
Figure 27 is a flowchart illustrating a process of automatically generating templates of source code for use with the embedded computer communication module 112 or the host computer<br><br>
communication module 116. In one embodiment ol the invention, the process or figure ii is performed by the studio module 128. In another embodiment of the invention, the process of Figure 37 is performed by a standalone tool, such as a code generator. For convenience of description, the following description refers to a code generator. However, it is to be appreciated that such function could be provided by the studio module 128 or the communication database 124. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged.<br>
Starting at a step 2704, the user identifies one or more interface definition files that define the communication interface. For example, in code block 3200 of Figure 32 illustrates a portion of an interface definition file.<br>
Continuing to a step 2708, the user selects one or more of the communication interfaces in the selected interface definition files. In one embodiment of the invention, a code generator provides a graphical user interface utility for selection of the communication interfaces.<br>
Next, at a step 2716, a code template of a "thread" is generated for handling each of selected messages in the interface definition file. An exemplary process of generating a thread is described below with reference to Figure 28. An exemplary template is shown in code block 3204 of Figure 32.<br>
Moving to a step 2720, a template of a thread is generated for each of the selected<br>
functions in the interface definition file. An exemplary process of generating a thread is described<br>
below with reference to Figure 31. An exemplary template is shown in code block 3204 of Figure<br>
32.	Figure 28 is a flowchart illustrating a process of generating a thread for each of the identified messages in an interface definition file. Figure 28 illustrates in further detail the steps that occur in step 2716 of Figure 27. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged.<br>
Before starting at a step 2800, a message handling routine is created to handle all messages that have been identified by the user. The message handling routine includes a loop and, subsequent to the loop, a switch statement. See e.g., code block 3204. Starting at a step 2800, a loop is entered and steps 2804, 2808, and 2812 are performed for each of the identified messages. Continuing to a step 2804, the code generator adds a line of code to register each of the messages. See e.g., code block 3204. In one embodiment of the invention, the source code includes code to invoke a registration routine that is provided by the embedded computer communication module 112 or the host computer communication module 116. The call to invoke the registration route is placed prior to the generated switch statement.<br><br>
Next, at a step 2808, the code generator generates message handling code for each of identified messages. An exemplary process of generating message handling code is described below with reference to Figure 29. Continuing to a step 2812, the code generator creates routines for sending a message. An exemplary process of creating a routing for sending a message is described below with reference to Figure 30.<br>
Figure 29 is a flowchart illustrating a process of generating message handling code. Figure 29 illustrates in further detail the steps that occur in step 2908 of Figure 28. Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged. The process shown in Figure 29 is performed with respect to each of the messages identified by the user in step 2708 of Figure 27.<br>
Starting at a step 2904, the code generator generates a case statement. Proceeding to a step 2908, the code generator generates a comment to the user to instruct the user to add code.<br>
Proceeding to a decision step 2912, the code generator determines whether the message is "two-way". If the message is "two-way", the process proceeds to a step 2916. Otherwise, the process proceeds to a step 2920.<br>
At the step 2916, the code generator adds code in the generated case statement to invoke a send response routine. As an example, code block 3204 of Figure 32 includes a call to the "SendMesessageTwoWayResponse" routine. The process of generating a response routine, such as the "SendMesessageTwoWayResponse" routine, is described below with reference to 3016 of Figure 30. In one embodiment of the invention, the generated code will invoke an API, e.g., SendResponseO, of the DAT^ system 100. At this step, the code generator may also generate other APIs for convenience of the user, e.g., routines to setup and attach pointers. Moving to a step 2920, the code generator may also generate code to invoke a release routine that is provided by the API.<br>
Figure 30 is a flowchart illustrating a process of generating a template of a routine for sending a message via the communication interface identified by the user in step 2708 of Figure 27. Figure 30 illustrates in further detail the steps that occur in step 2812 of Figure 28. Starting at a step 3008, the code generator determines whether the message is one-way, two-way, or broadcast. If the message is one-way or two-way, the process proceeds to a step 3010. At the step 3010, the code generator generates a function to send a command to invoke a send command. An exemplary generated code template is shown in code block 3208 of Figure 32. Continuing to a decision step 3012, the code generator determines whether the communication is one-way or two-way. If the message is not one-way, i.e., two- way, the process proceeds to a step 3016. At the step 3016, the code generates a function for sending a response. The generated code invokes the API to send a response.<br><br>
Referring again to the decision step 3008, the code generator determines whether message is a broadcast message. If the message is a broadcast, the process proceeds to a step 3020. At the step 3020, the code generator adds code to invoke an broadcast routine that is part of the API of the embedded computer communication module 112 and the host computer communication module 116. From steps 3012 (if the communication is "one-way"), 3020, and 3016 the process proceeds to a step 3024. At the step 3024, the code generator determines whether there are pointers present in the payload of the message. If pointers are present, the process proceeds to a step 3028. At the step 3028, the code generator generates code to invoke a pointer setup command that is part of the communication library API. Next, at a step 3032, the code generator generates code to invoke the API attach pointer. It is noted that the generated commands during steps 3032 and 3028 are inserted into the generated code prior to the generated send response command (step 3016).<br>
Figure 31 is a flowchart illustrating a process of generating template code for communicating across platforms via a remote function call. In one embodiment of the invention, inter-platform function calls invoke a local function that communicates with the remote function of the same name via messaging that is provided by the embedded computer communication module 112 and the host computer communication module 116.<br>
Depending on the embodiment, additional steps may be added, others removed, and the ordering of the steps rearranged. Starting at a step 3104 a loop is performed with respect to steps 3108, 3112, and 3116. In the loop, template code is generated for exestuation on a local platform, i.e., either the embedded computer 104 or the host computer 108. The local platform in this context is defined to be the computer that does not have the routine that is to be invoked. Steps 3108, 3112, and 3116 arc performed with respect to each of the functions identified by the user in step 2708 of Figure 27. At the step 3108, the code generator generates a send command. Next, at a step 3112, the code generated generates a read command. Proceeding to a step 3116, the code generator generates code to return a response. An exemplary code block resulting from steps 3108, 3112, and 3116 is shown in code block 3212 of Figure 33.<br>
Next, at a step 3120, a loop is performed with respect to steps 3124, 3128, 3132, 3136, and 3140. In this loop, template code is generated for execution on the remote platform. Proceeding to a step 3124, the code generator generates code to invoke a registration routine of the API. Moving to a step 3128, the code generator generates code that invokes the local API that was requested by the thread on the other platform and sends a response message. An exemplary code block resulting from steps 3124, 3218, 31332, 3136. and 3140 is shown in code block 3214.<br>
Next, at a decision step 3132, the code generator determines whether there are any pointers in the parameters of the function. If there are no pointers in the parameters of the function, the process ends.   However, if there are pointers, the process proceeds to a step 3136 and the code<br><br>
generator generates code to invoke the API to setup a pointer. Moving to a step 3140, the code generator generates code to invoke the API to attach a pointer. The process then ends.<br>
The DAT system 100 provides a single virtual environment that enables threads to be located on different platforms and still seamlessly communicate with each other. The DAT system 100 provides communication interoperability between the two platforms by automatically transforming the data depending on the machine characteristics of the embedded computer 104, the host computer 108, and the communication interfaces that are stored in the communication database 124. The DAT system 100 provides automatic and seamless access to the message-based and remote function call interfaces designed into the embedded computer's software application. The DAT system 100 automatically extracts interface information and builds a database of messaging and remote function call information.<br>
Using the studio module 128, a user has complete visibility and control of the embedded application's interfaces without having to address the following issues: (i) updates to a desktop tool to accommodate new messages; (ii) updates to the embedded software to support the desktop tool's new functionality; (iii) what target compiler is used; (iv) what RTOS is used; and (iv) what platform the thread(s) are executing on. The DAT system 100 allows seamless access to interfaces stored in the communication database 124 via scripting languages or any COM-compliant application.<br>
While the above detailed description has shown, described, and pointed out novel features of the invention as applied to various embodiments, it will be understood that various omissions, substitutions, and changes in he form and details of the device or process illustrated may be made by those skilled in the art without departing from the spirit of the invention. The scope of the invention is indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.<br><br><br>
I CLAIM:<br>
I.	A system for transmitting data, the system comprising:<br>
a host computer;<br>
a first application executing on the host computer;<br>
an embedded computer <br>
a second application executing on the embedded computer;<br>
a database that identifies at least one interface characteristic of a plurality of interfaces of the first application and the second application, wherein the database is automatically generated in response to a user request and is based  at least in part, upon an interface description file that is provided by the user;<br>
a communication module that defines an interface for communication with the embedded computer, wherein the first application communicates with the second application via the communication module;<br>
wherein the host computer stores host computer machine characteristic information for the embedded computer, wherein the host machine characteristic information includes information selected from the group comprising: an enumeration size, an adaptive enumeration indicator, a short size, a long size, a float size, a double size, a double long size, a pointer size, a structure alignment boundary, an integer size, a byte ordering, a Boolean size, and a character size;<br>
wherein the host computer stores embedded computer machine characteristic information for the Most computer, wherein the embedded computer machine characteristic information includes information selected food the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering; and<br>
wherein in response to receiving a communication fool the second application that is targeted for the first application, the communication module modifies the communication prior to transmitting the communication to the first application, and wherein the modification is based, at least in part, upon the host computer machine characteristic information, the embedded computer machine characteristic information, and the interface characteristic.<br>
2.	A system for transmitting data, the system comprising:<br>
a host computer;<br>
a first application executing on the host computer; an embedded computer;<br>
a second application executing on the embedded computer; and interface information describing characteristics of a plurality of communication interfaces of the<br><br>
first application and the second application, wherein the host computer receives machine characteristic information for the embedded computer, and wherein in response to receiving a communication from the second application that is targeted for the first application, the host computer modifies the communication prior to transmitting the communication to the first application, wherein the modification is based, at least in part, upon the machine characteristic information and the interface information.<br>
3.	The system of Claim 2, wherein the machine characteristic information includes information that is selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering.<br>
4.	The system of Claim 2, wherein modification includes reversing a byte order of at least one element of data in the communication.<br>
5.	A system for transmitting data, the system comprising:<br>
a host computer;<br>
a first application executing on the host computer;<br>
an embedded computer;<br>
a second application executing on the embedded computer; and<br>
interface information describing characteristics of a plurality of communication interfaces of the first application and the second application, wherein the host computer receives machine characteristic information for the embedded computer, wherein in response to receiving a communication from the first application that is targeted for the second application, the host computer modifies the communication prior to transmitting the communication to the first application, and wherein the modification is based, at least in part, upon the machine characteristic information and the interface information.<br>
6.	The system of Claim 5, wherein the machine characteristic information includes<br>
information selected from the group comprising: an enumeration size, a pointer size, a structure<br>
alignment boundary, an integer size, and a byte ordering.<br>
7.	A system for transmitting data, the system comprising:<br>
a host computer;<br>
a first application executing on the host computer;<br>
an embedded computer;<br>
a second application executing on the embedded computer; and<br>
interface information describing characteristics of a plurality of predefined interfaces of the first application and the second application, wherein the embedded computer transmits to the host computer a connection message that includes machine characteristic information for the embedded computer, wherein in response to receiving a<br><br>
communication from the second application that is targeted for the first application, the host computer modifies the communication prior to transmitting the communication to the first application, and wherein the modification is based, at least in part, upon the machine characteristic information and the interface information.<br>
8.	The system of Claim 7, wherein the machine characteristic information includes<br>
information selected from the group comprising: an enumeration size, a pointer size, a structure<br>
alignment boundary, an integer size, and a byte ordering.<br>
9.	A system for transmitting data, the system comprising:<br>
a host computer for executing a first application;<br>
an embedded computer for executing a second application; and  machine characteristic information;<br>
wherein in response to receiving a communication from the second application that is targeted for the first application, the host computer modifies the communication prior to transmitting the communication to the first application, wherein the modification is based, at least in part, upon the machine characteristic information.<br>
10.	A method of transmitting data, the method comprising:<br>
automatically generating a database  wherein  the  database includes  interface<br>
information that describes a plurality of interfaces;<br>
receiving a communication from an embedded computer; and<br>
formatting the communication, based at least upon the interface information and<br>
machine characteristic information that describes at least one characteristic  of the<br>
embedded computer.<br>
11.	The method of Claim 10, wherein formatting the communication comprises reversing the byte order of at least one data field in the communication.<br>
12.	The method of Claim  10, wherein formatting the communication comprises modifying a number of bits of a data structure in the communication.<br>
13.	The method of Claim 10, wherein formatting the communication comprises modifying a stmcture alignment boundary.<br>
14.	The method of Claim 10, wherein automatically generating a database comprises parsing at least one interface description file.<br>
15.	A system for transmitting data, the system comprising:<br>
means for automatically generating a database, wherein the database includes interface information that describes at least one characteristic of a communication interface that is provided by an application thread;<br>
means for receiving at least one communication from an embedded computer; and<br><br>
means for formatting the received communication, wherein the formatting is based, at least in part, upon the characteristic of the communication interface and machine characteristic information that describes at least one characteristic of the embedded computer.<br>
16.	The system of Claim 15, wherein the means for formatting the communication comprises means for reversing the byte order of at least one element in the communication.<br>
17.	The system of Claim 15, wherein the means for formatting the communication comprises means for modifying a number of bits of a data structure in the communication.<br>
18.	The system of Claim 15, wherein the means for formatting the communication comprises means for modifying a structure alignment boundary.<br>
19.	The system of Claim 15, wherein the means for automatically generating a database comprises means for parsing at least one interface description file.<br>
20.	A method of transmitting data, the method comprising:<br>
receiving a communication from an embedded computer; and<br>
formatting the received communication, wherein the formatting is based at least in part upon interface information that describes at least one characteristic of the communication and information that describes at least one characteristic of the embedded computer.<br>
21.	The method of Claim 20, wherein formatting the communication comprises reversing the byte order of at least one data field in the communication.<br>
22.	The method \ of Claim 20, wherein formatting the communication comprises modifying a number of bits of a data structure in the communication.<br>
23.	The method of Claim 20, wherein  formatting the communication comprises modifying a structure alignment boundary.<br>
24.	A method of building a database, the method comprising:<br>
reading an interface description file that defines at least one communication interface of an application thread;<br>
extracting communication information from the communication interface, wherein extracting communication information food the communication interface comprises:<br>
reading a unique identifier that is associated with the communication interface,<br>
determining a size of a communication  that  is transmitted via the communication interface,<br>
determining a name of each of the data fields in the communication,<br><br>
determining a method of transmitting the memory that is associated with the communication interface,<br>
identifying pointer data that is associated  with the  communication interface,<br>
determining a management method of the communication interface, and determining a type of the communication interface, whether it is message based or a function call;<br>
storing the extracted interface information in a communication database; storing at least one  machine  characteristic of an embedded device  in the communication database, wherein the machine characteristic of the embedded computer is selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering; and<br>
storing at least one machine characteristic of a host computer in the communication database, wherein the machine characteristic of the host computer is selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering.<br>
25.	A method of building a database, the method comprising:<br>
reading an interface description file that defines at least one communication interface;<br>
extracting communication information from the communication interface;<br>
storing the extracted communication information in a communication database;<br>
storing at least one machine characteristic of an embedded device in the communication database; and<br>
storing at least one machine characteristic of a host computer in the communication database.<br>
26.	The method of Claim 25, wherein extracting communication information from the communication interface comprises reading a name of the communication interface.<br>
27.	The method of Claim 25, wherein extracting communication information from the communication interface comprises reading a unique identifier that is associated with the communication interface.<br>
28.	The method of Claim 25, wherein extracting communication information from the communication interface comprises determining a size of a communication that is transmitted via the communication interface.<br><br>
29.	The method of Claim 25, wherein extracting communication information from the communication interface comprises determining a name of each of the data fields in a communication that is transmitted via the communication interface.<br>
30.	The method of Claim 25, wherein the machine characteristic of the embedded computer is selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering.<br>
31.	The method of Claim 25, wherein the machine characteristic of the host computer is selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering.<br>
32.	A system for building a database, the system comprising:<br>
means for reading an interface description file that defines at least one communication interface of an application thread;<br>
means for extracting communication information from the communication interface, wherein means for extracting communication information from the communication interface comprises:<br>
means  for reading  a  unique  identifier  that   is   associated  with  the<br>
communication interface,<br>
means for determining a size of a communication that is transmitted via<br>
the communication interface, and<br>
means   for determining  a  name  of each  of the   data   fields   in  the<br>
communication;<br>
means for storing the extracted interface information in a communication database;<br>
means for storing at least one machine characteristic of an embedded device in the communication database, wherein the machine characteristic of the embedded computer is selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering; and<br>
means for storing at least one machine characteristic of a host computer in the communication database, wherein the machine characteristic of the host computer is selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering.<br>
33.	A system for building a database, the system comprising:<br>
means for reading an interface description file that defines at least one communication interface;<br>
means for extracting communication information from the communication interface;<br><br>
means for storing the extracted communication information in a communication database;<br>
means for storing at least one machine characteristic of an embedded device in the communication database; and<br>
means for storing at least one machine characteristic of a host computer in the communication database.<br>
34.	The system of Claim 33, wherein the means for extracting communication information from the communication interface comprises means for reading a name of the communication.<br>
35.	The system of Claim 33, wherein the means for extracting communication information from the communication interface comprises means for reading a unique identifier that is associated with the communication.<br>
36.	The system of Claim 33, wherein the means for extracting communication information from the communication interface comprises means for determining a size of the communication.<br>
37.	The system of Claim 33, wherein the means for extracting communication information from the communication interface comprises means for determining a name of each of the data fields in the communication.<br>
38.	The system of Claim 33, wherein the machine characteristic of the embedded computer is selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering.<br>
39.	The system of Claim 33, wherein the machine characteristic of the host computer is selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering.<br>
40.	A database, comprising:<br>
interface information describing at least one characteristic of a communication interface of an application thread;<br>
host computer information that describes at least one characteristic of a host computer, wherein the host computer information is selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering; and<br>
embedded computer machine information that describes at least one characteristic of an embedded computer, wherein the embedded computer machine information is selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering.<br><br>
41.	The database of Claim 40, additionally comprising an interface for accessing the interface information, the host computer machine information, and the embedded computer machine information.<br>
42.	A database, comprising:<br>
interface information describing at least one characteristic of a communication interface of an application thread that is defined in an interface description file; and<br>
a predefined interface for providing viewing and testing the communication interface using at least in part the interface information.<br>
43.	A system comprising:<br>
a database, comprising:<br>
interface information describing at least one characteristic of a communication interface of an application thread;<br>
host computer information that describes at least one characteristic of a host computer, wherein the host computer information is selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an integer size, and a byte ordering; and<br>
embedded computer machine information that describes at least one characteristic of an embedded computer, wherein the embedded computer machine information is selected from the group comprising: an enumeration size, a pointer size, a structure alignment boundary, an meter size, and a byte ordering; and a module prdlviding a user interface for testing the communication interface.<br>
44.	The system of Claim 43, wherein the user interface includes an interface that allows a user to send data via the communication interface.<br>
45.	The system of Claim 43, wherein the user interface includes an interface that allows a user to view data that is received via the communication interface.<br>
46.	The system of Claim 43, wherein the user interface includes an interface that allows a user to view all of the communication interfaces that are stored in the database.<br>
47.	The system of Claim 43, wherein the user interface includes an interface that allows a user to view a communication format of the communication interface.<br>
48.	The system of Claim 43, wherein the user interface includes an interface that allows a user to view an identifier that is associated with the communication interface.<br>
49.	The system of Claim 43, wherein the user interface includes an interface for simulating the communication interface.<br>
50.	The system of Claim 43, wherein the user interface includes an interface for associating data with the communication interface.<br><br>
51.	The system of Claim 43, wherein the user interface includes an interface for logging tracing information to a file.<br>
52.	The system of Claim 43, wherein the user interface includes an interface for measuring a difference in time between two selected interfaces are invoked.<br>
53.	The system of Claim 43, wherein the user interface includes an interface for communicating with a script.<br>
54.	A system for providing a communication interface that is accessible by a plurality of components, the system comprising:<br>
a scripting program;<br>
a COM-compliant object; and<br>
at least one communication module which is configured to provide an application programming interface for the scripting program to communicate with the COM-compliant object.<br>
55.	A system for providing communication between a host computer and an embedded<br>
computer, the system comprising:<br>
an embedded computer executing a plurality of threads that provide a communication interface, each communication interface having a plurality of data fields;<br>
a script engine for executing script instructions;<br>
a communication database identifying each of the communication interfaces, wherein the communication database is automatically generated, at least in part, fi-om information comprising:<br>
an interface description file that defines the communications interfaces;<br>
machine characteristics of the embedded device; and<br>
machine characteristics of a platform that is executing the script engine;<br>
a communication module for providing an application programming interface for the script instructions to access the communication interface, wherein the communication module is automatically generated based upon information from information fi-om the communication database; and<br>
wherein the script instructions identify at least one of the communication interfaces in the communication database and invoke a function with respect to at least one field in the identified communication interface via the application programming interface, wherein the function is selected fi-om the group comprising: storing data in one of the data fields, reading data firom one of the data fields, and testing a data field. 56.        A system for providing communication with a thread, the system comprising:<br>
a plurality of threads that each provide a communication interface;<br><br>
a communication database identifying each of the communication interfaces;<br>
a communication module for providing an application programming interface for the script instructions to access the communication interfaces, wherein the communication module is automatically generated based, at least in part, upon information from the communication database; and<br>
wherein the script instructions communicate with a thread using at least one of the communication interfaces in the communication database via the application programming interface.<br>
57.	A system for providing communication with a thread, the system comprising:<br>
a plurality of threads that each provide a communication interface;<br>
an interface description file identifying each of the communication interfaces;<br>
a communication module for providing an application programming interface for the script instructions to access the communication interfaces, wherein the communication module is automatically generated based, at least in part, upon information from the interface description file; and<br>
wherein the script instructions communicate with a thread using at least one of the communication interfaces via the application programming interface.<br>
58.	A system for providing communication with a thread, the system comprising:<br>
a plurality of threads that each provide a communication interface, each communication interface having a plurality of data fields;<br>
a communicallion database identifying each of the communication interfaces;<br>
a communication module for providing an application programming interface for the script instructions to access the communication interfaces, wherein the communication module is automatically generated based, at least in part, upon information from the communication database; and<br>
wherein the script instructions identify at least one of the communication interfaces in the communication database and invoice a function with respect to at least one field in the identified communication interfaces via the application programming interface.<br>
59.	The system of Claim 58, wherein the database is generated, at least in part, from information that is retrieved from at least one interface description file that defines the communication interfaces.<br>
60.	The system of Claim 61, wherein the function is selected from the group comprising: storing data in one of the data fields, reading data from one of the elements, and testing a data field.<br><br>
61.	A system for providing communication between a host computer and an embedded<br>
computer, the system comprising:<br>
an embedded computer executing a plurality of threads that provide a communication interface, each communication interface having a plurality of fields;<br>
a communication database identifying each of the communication interfaces;<br>
a communication module for providing an application programming interface for the script instructions to access the communication interface, wherein the communication module is automatically generated based in part from information that is maintained in the communication database; and<br>
wherein the script instructions identify at least one of the communication interfaces in the communication database and invoke a function with respect to at least one field in the identified communication interfaces via the application programming interface.<br>
62.	The system of Claim 61, wherein the function is selected firpm the group<br>
comprising: setting a field, reading a field, and testing a field.<br>
63.	A system for providing communicafion with a thread, the system comprising:<br>
a plurality of threads that communicate via a communication interface;<br>
a communication module for providing an application programming interface for the script instructions to access the communication interface; and<br>
wherein the script instructions communicate with a thread via the application programming interface.<br>
64.	The system dif Claim 63, wherein accessing includes transmitting a payload via the<br>
communication interface.<br>
65.	A method of providing communication with a thread, the method comprising:<br>
retrieving a reference to a communication object, wherein the communication<br>
object provides an application programming interface for a scripting program to access a communication interface that is provided by a thread that is executing on an embedded computer;<br>
storing data in at least one data field via the application programming interface; and<br>
transmitting the stored data to the thread via application programming interface and the communication interface.<br>
66.	A method of providing communication with a thread, the method comprising:<br>
retrieving a reference to a communication object, wherein the communication<br>
object provides a read method for a scripting program to access a communication interface; and<br><br>
invoking a read method of the communication object thereby receiving stored data that is provided via the communication interface by a thread that is executing on an embedded computer.<br>
67.	A method of providing communication with a thread, the method comprising:<br>
generating a communication database that describes at least one communication<br>
characteristic of a communication interface that is defined in an interface description file;<br>
retrieving a reference to a communication object, wherein the communication object provides an application programming interface for a scripting program to access a communication interface that is provided by a thread that is executing on an embedded computer; and<br>
storing data in at least one data field in the communication via the use of the application programming interface.<br>
68.	A method of providing communication with a thread, the method comprising:<br>
retrieving a reference to a communication object, wherein the communication<br>
object provides a application programming interface for a scripting program to access a communication interface that is provided by a thread that is executing on an embedded computer; and<br>
storing data in at least one data field in the communication via the use of the application programming interface.<br>
69.	A method of providing access to a communication, the method comprising:<br>
providing a ^communication object that comprises at least one function for<br>
communicating with a thread that is executing on an embedded computer, wherein the function is invoked from a scripting program; and<br>
accessing the communication object via the scripting program.<br>
70.	A system for providing access to a communication, the method comprising:<br>
a communication object that comprises at least one function for communicating with an thread that is executing on an embedded computer, wherein the function is invoked from a scripting program; and<br>
means for accessing the communication object via the scripting program.<br>
71.	An executable communication object, the communication object comprising:<br>
a plurality of interfaces for accessing a communication from a scripting program, wherein at least one of the interfaces is selected from the group comprising: a broadcasting interface for broadcasting the communication, a sending interface for sending the communication, an interface for reading the communication,<br><br>
an interface for retrieving persistent data from a communication database, a registration interface for registering the communication as available for use, and<br>
a subscription interface for subscribing to the communication; and wherein each of the plurality of interfaces are automatically generated based, at least in part, from information that is stored in an interface description file that describes a communication interface.<br>
72.	An executable communication object, the communication object comprising:<br>
a database storing test data; and<br>
an application programming interface for communicating via a communication interface from a scripting program, wherein when the communication interface is invoked, the test data from a database is transmitted via the communication interface.<br>
73.	A system for providing a communication interface that is accessible by a plurality<br>
of components, the system comprising:<br>
a scripting program in a first programming language;<br>
a scripting program in a second programming language; and<br>
at least one communication module which is configured to provide an application<br>
programming interface for the first scripting program to communicate with the second<br>
scripting program.<br>
74.	A system for providing communication between a host computer and an embedded<br>
computer, the system comprising:<br>
an embedded computer executing a plurality of threads that provide a plurality of communication interfaces, each communication interface having a plurality of data fields;<br>
a communication database identifying each of the communication interfaces, wherein the communication database is automatically generated, at least in part, from information comprising:<br>
an interface description file that defines the communications interfaces; machine characteristics of the embedded device; machine characteristics of a host platform; and a communication module for providing an application programming interface for a COM-compliant   application   to   access   the   communication   interface,   wherein   the communication module is automatically generated based upon information from the communication database;<br>
wherein an object in the COM-compliant application identifies at least one of the communication interfaces in the communication database and invokes a function with<br><br>
respect to at least one data field in the identified communication interface via the application programming interface, wherein the function is selected from the group comprising: storing data in one of the data fields, reading data from one of the data fields, and testing a data field.<br>
75.	The system of Claim 74, wherein the communication interface is either a message-based or a remote function call-based interface.<br>
76.	A system for providing communication between a host computer and an embedded computer, the system comprising:<br>
an embedded computer executing a plurality of threads that each provide a communication interface;<br>
a communication database identifying the communication interface of each of the threads; and<br>
a COM object configured to provide a plurality of functions to a COM-compliant application for a communicating with each of the communication interfaces, wherein the COM object is automatically generated based, at least in part, upon the communication interfaces in the messaging database.<br>
77.	The system of Claim 76, wherein the messaging database is generated, at least in<br>
part, from information from an interface description file.<br>
78.	A system for providing communication between a host computer and an embedded<br>
computer, the system comprising:<br>
a plurality oi^threads that each provide a communication interface; a communication database identifying each of the communication interfaces; and a COM object providing a plurality of functions for communicating with each of the communication interfaces, wherein the COM object is automatically generated based, at least in part, upon communication interfaces in the communication database.<br>
79.	The system of Claim 78, wherein the communication database is generated, at least<br>
in part, from information from an interface description file.<br>
80.	A method of providing communication with a thread, the method comprising:<br>
retrieving a reference to a communication object, wherein the communication<br>
object provides an interface for a COM-compliant application to access a communication interface that is owned by a thread that is executing on an embedded computer; and storing data in at least one data field in the communication interface.<br>
81.	The method of Claim 65, additionally comprising invoicing a send method of the<br>
communication object thereby transmitting the stored data to the thread that is executing on the<br>
embedded computer.<br><br>
82.	A method of providing communication with a thread, the method comprising:<br>
retrieving a reference to a communication object, wherein the communication<br>
object provides an interface for COM-compliant application to access a communication; and<br>
invoking a read method of the communication object thereby receiving via the interface a communication that is provided by a thread that is executing on an embedded computer.<br>
83.	The method of Claim 82, wherein the communication is a message.<br>
84.	A method of providing communication with a thread, the method comprising: generating a communication database that describes at least one communication<br>
characteristic of a communication interface that is defined in an interface description file;<br>
requesting a database object to provide an identifier for each of the communications interfaces;<br>
requesting the database object to access a selected one of the communications interfaces;<br>
retrieving a reference to a communication object, wherein the communication object provides an interface for a COM-compliant application to access a communication that is owned by a thread that is executing on an embedded computer; and<br>
storing data in at least one data field in the communication.<br>
85.	A method of providing communication with a thread, the method comprising:<br>
retrieving a preference to a communication object, wherein the communication<br>
object provides an interface for a COM-compliant application to access a communication interface that is managed by a thread that is executing on an embedded computer; and storing data in at least one data field in the communication.<br>
86.	A method of providing access to a communication, the method comprising:<br>
providing a communication object that comprises at  least one function for<br>
accessing a communication interface from a COM-compliant application; and<br>
accessing the communication interface via the COM-compliant application.<br>
87.	The method of Claim 86, wherein the communication interface is owned by an<br>
embedded thread that is executing on an embedded computer, and wherein accessing the<br>
communication interface via the COM-compliant application comprises transmitting to the<br>
embedded thread at least one element of data from a thread that is executing remotely.<br>
88.	A system for providing access to a communication, the method comprising:<br>
a communication object that comprises at least one function for accessing a communication interface from a COM-compliant application; and<br><br>
means for accessing the communication interface via the COM-compliant application.<br>
89.	The system of Claim 70, wherein the communication interface is owned by an embedded thread that is executing on an embedded computer, and wherein the means for accessing the communication interface via the COM-compliant application comprises means for transmitting to the embedded thread at least one element of data from a thread that is executing on a host computer.<br>
90.	An executable communication object, the communication object comprising;<br>
at least one application programming interface for accessing a communication interface from a COM-compliant application, wherein the application programming interface is selected from the group comprising:<br>
a broadcasting interface for broadcasting the communication, :'   an interface for sending the communication,<br>
a registration interface for registering the communication, and a subscription interface for subscribing to the communication, wherein each of the plurality of interfaces are automatically generated based, at least in part, information that is stored in an interface description file that describes a communication interface.<br>
91.	A system for communicating with a thread, the system comprising:<br>
means for generating a communication database that describes at least one communication characteristic of a communication interface that is defined m an interface description file;<br>
means for requesting a database object to provide an identifier for each of the communications interfaces;<br>
means for requesting the database object to access a selected one of the communications interfaces;<br>
means for retrieving a reference to a communication object, wherein the communication object provides an interface for a COM-compliant application to access a communication that is owned by a thread that is executing on an embedded computer; and<br>
means for storing data in at least one data field in the communication.<br>
92.	A system for providing communication with a thread, the system comprising:<br>
means  for retrieving  a  reference  to  a communication  object,   wherein  the<br>
communication object provides an interface for a COM-compliant application to access a communication interface that is owned by a thread that is executing on an embedded computer; and<br><br>
means for storing data in at least one data field in the communication.<br>
93.	The system of Claim 93, wherein the communication interface is a remote function call.<br>
94.	The system of Claim 93, wherein the communication interface is a message.<br>
95.	A system for providing access to a communication, the system comprising:<br>
means for providing a communication object that comprises at least one function<br>
for accessing a communication interface from a COM-compliant application; and<br>
means for accessing the communication interface via the COM-compliant application.<br>
96.	A system for providing a communication interface that is accessible by a plurality<br>
of components, the system comprising:<br>
a COM-compliant object;<br>
at least one thread executing on an embedded computer; and at least one communication module which is configured to provide an application programming interface for the COM-compliant object to communicate with the thread.<br>
97.	A system for providing a communication interface that is accessible by a plurality<br>
of components, the system comprising:<br>
a scripting program; and<br>
at least one communication module which is configured to provide an application<br>
programming interface for the COM-compliant object to communicate with the scripting<br>
program.	98.	A system for providing a communication interface that is accessible by a plurality<br>
of components, the system comprising:<br>
a scripting program; and<br>
at least one communication module which is configured to provide an application programming interface for the COM-compliant object to communicate with the scripting program.<br>
99.	A system for testing a thread executing on an embedded computer, the system<br>
comprising:<br>
a host computer;<br>
a first thread executing on the host computer; and<br>
an embedded computer executing a thread, wherein the embedded computer monitors a plurality of communications that are sent to the thread and transmits data from the monitored communications to the host computer, wherein the host computer stores the data from the monitored communications in a plurality of data sets.<br><br>
100.	A method of testing a thread, the method comprising:<br>
monitoring a plurality of communications that are sent to a thread that is executing on an embedded computer,<br>
transmitting the monitored communications to a host computer; storing the monitored communications in a plurality of data sets; and transmitting at least one of the data sets to the monitored thread.<br>
101.	A system for testing a thread, the system comprising:<br>
means for monitoring a plurality of communications that are sent to a thread that is executing on an embedded computer;<br>
means for transmitting the monitored communications to a host computer; means for storing the monitored communication in a plurality of data sets; and means for transmitting the data sets to the monitored thread.<br>
102.	A method of testing a thread, the method comprising:<br>
monitoring a plurality of communications from a first thread to a second thread, wherein the communication comprise a plurality of data elements; storing each of the communications in a data set; and transmitting each of the stored data elements to the first thread.<br>
103.	The method of Claim 102, wherein the first thread and the second thread are each executing on an embedded computer.<br>
104.	A system for testing a thread, the system comprising:<br>
means for mi^nitoring a plurality of communications from a first thread to a second thread, wherein the communications comprise a plurality of data elements; means for storing each of the data elements in a data set; and means for transmitting at least one of the stored data elements to the first thread.<br>
105.	A method comprising:<br>
invoking an application programming interface thereby storing structured data in a communication database; and<br>
invoking the application programming interface thereby transmitting the stored structured data via a predefined communication interface.<br>
106.	The method of Claim  105, additionally comprising invoking the application programming interface to register ownership of the message.<br>
107.	The method of Claim 105, additionally comprising automatically incrementing an index in the database to another item of structured data.<br><br>
108.	The method of Claim 105, additionally comprising:<br>
invoking   the    application   programming    interface    thereby    automatically incrementing an index in the database to a second item of structured data; and transmitting the second item of structured data.<br>
109.	The method of Claim 105, additionally comprising invoking the application programming interface so that an index references a particular item of structured data in the communication database.<br>
110.	The method of Claim 105, wherein the application programming interface is invoked by a scripting program.<br>
111.	A system comprising:<br>
means for invoking an application programming interface so as to store structured data in a communication database; and<br>
means for invoking the application programming interface so as to transmit the stored structured data via a predefined communication interface.<br>
112.	The system of Claim 111, additionally comprising means for invoking the application programming interface to register ownership of the message.<br>
113.	The system of Claim 111, additionally comprising means for automatically incrementing an index in the database to another item of structured data.<br>
114.	The system of Claim 111, additionally comprising:<br>
means for invoking the application programming interface so as to automatically increment an index ii^the database to a subsequent item of structured data; and transmitting the second item of structured data.<br>
115.	A method of generating code, the method comprising:<br>
reading an interface definition file;<br>
identifying at least one communication interface, wherein the communication interface defines at least a pointer that is passed via the communication interface; and<br>
automatically generating code to invoke the communication interface, wherein the generated code includes code to invoke a routine to define at least one attribute of the pointer.<br>
116.	A system for generating code, the system comprising:<br>
means for reading an interface definition file;<br>
means for identifying at least one communication interface, wherein the communication interface defines at least a pointer that is passed via the communication interface; and<br><br>
means for automatically generating code to invoke the communication interface, wherein the generated code includes code to invoke a routine to define at least one attribute of the pointer.<br>
117.	A method of generating code, the method comprising:<br>
reading an interface definition file;<br>
identifying at least one communication interface; and<br>
automatically generating code to invoke the communication interface.<br>
118.	A method of generating code, the method comprising:<br>
reading an interface definition file;<br>
identifying at least one remote function call interface in the interface definition file;<br>
automatically generating a first code for execution on a first platform, wherein a first program executing the first code communicates with a second program executing a second code via a messaging interface; and<br>
automatically generating a second code for execution on a second platform, wherein the generated second code invokes a routine via the remote function call interface.<br>
119.	The method of Claim 118, wherein the first generated code includes a function that<br>
has a name that is the same as the function.<br>
120.	A system for generating code, the system comprising:<br>
means for reading an interface definition file;<br>
means for idlentifying at least one remote function call interface in the interface definition file;<br>
means for automatically generating a first code for execution on a first platform, wherein a first program executing the first code communicates with a second program executing a second code via a messaging interface; and<br>
means for automatically generating a second code for execution on a second platform, wherein the generated second code invokes a routine via the remote function call interface.<br>
121.	The system of Claim 120, wherein the first generated code includes a fimction that<br>
has a name that is the same as the function.<br><br>
122.      A system for transmitting data, substantially as hereinabove described and illustrated with reference to the accompanying drawings.<br><br></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></dataset></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1jaGVucC0yMDAzICAgY29tcGxldGUgc3BlY2lmaWNhdGlvbiBhcyBncmFudGVkLnBkZg==" target="_blank" style="word-wrap:break-word;">1661-chenp-2003   complete specification as granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1jaGVucC0yMDAzICBhYnN0cmFjdCBvcmlnaW5hbC5wZGY=" target="_blank" style="word-wrap:break-word;">1661-chenp-2003  abstract original.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1DSEVOUC0yMDAzICBBQlNUUkFDVC5wZGY=" target="_blank" style="word-wrap:break-word;">1661-CHENP-2003  ABSTRACT.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1jaGVucC0yMDAzICBjbGFpbXMgZ3JhbnRlZC5wZGY=" target="_blank" style="word-wrap:break-word;">1661-chenp-2003  claims granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1jaGVucC0yMDAzICBkcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">1661-chenp-2003  drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1DSEVOUC0yMDAzICBGT1JNLTIucGRm" target="_blank" style="word-wrap:break-word;">1661-CHENP-2003  FORM-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1jaGVucC0yMDAzIGNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">1661-chenp-2003 claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1jaGVucC0yMDAzIGNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">1661-chenp-2003 correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1jaGVucC0yMDAzIGNvcnJlc3BvbmRlbmNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">1661-chenp-2003 correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1jaGVucC0yMDAzIGRlc2NyaXB0aW9uKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">1661-chenp-2003 description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1jaGVucC0yMDAzIGRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1661-chenp-2003 drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1jaGVucC0yMDAzIGZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">1661-chenp-2003 form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1jaGVucC0yMDAzIGZvcm0tMTgucGRm" target="_blank" style="word-wrap:break-word;">1661-chenp-2003 form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1jaGVucC0yMDAzIGZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">1661-chenp-2003 form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1jaGVucC0yMDAzIGZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">1661-chenp-2003 form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1jaGVucC0yMDAzIG90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">1661-chenp-2003 others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTY2MS1jaGVucC0yMDAzIHBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">1661-chenp-2003 pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="234358-a-wireless-communication-system.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="234360-an-improved-process-for-the-preparation-of-an-intermediate-for-anti-alzhemier-drug-donepezil-hydrochloride.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>234359</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1661/CHENP/2003</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>29/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>17-Jul-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>26-May-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>20-Oct-2003</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>S2 TECHNOLOGIES, INC</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2053 SAN ELIJO AVENUE, CARDIFF, CA 92007</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>UNDERSETH, MARK</td>
											<td>3420 CAMINO ALEGRE, CARLSBAD, CA 92009</td>
										</tr>
										<tr>
											<td>2</td>
											<td>HANDA, BRAD</td>
											<td>3919 CORTE MAR DE BRISA, SAN DIEGO, CA 92130</td>
										</tr>
										<tr>
											<td>3</td>
											<td>TRAN, PETER</td>
											<td>5930 LANA DRIVE, SAN DIEGO, CA 92117</td>
										</tr>
										<tr>
											<td>4</td>
											<td>FERTITTA, KIRK</td>
											<td>3435 LEBON DRIVE, # 1134, SAN DIEGO, CA 92122</td>
										</tr>
										<tr>
											<td>5</td>
											<td>VALOIS, HUGUES</td>
											<td>11078 CAMINITO ALVAREZ, SAN DIEGO CA 92126</td>
										</tr>
										<tr>
											<td>6</td>
											<td>HOWELL, ROBERT</td>
											<td>12872 SALMON RIVER ROAD, SAN DIEGO, CA 92129</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F9/46</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US02/08810</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2002-03-22</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/278,212</td>
									<td>2001-03-23</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/363,436</td>
									<td>2002-03-11</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>3</td>
									<td>60/299,555</td>
									<td>2001-06-19</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/234359-a-system-and-a-method-for-testing-a-routine-thread-executing-on-enbedded-computer by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:12:47 GMT -->
</html>
