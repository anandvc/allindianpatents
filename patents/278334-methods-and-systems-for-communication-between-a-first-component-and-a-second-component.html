<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/278334-methods-and-systems-for-communication-between-a-first-component-and-a-second-component by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 22:42:55 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 278334:METHODS AND SYSTEMS FOR COMMUNICATION BETWEEN A FIRST COMPONENT AND A SECOND COMPONENT</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHODS AND SYSTEMS FOR COMMUNICATION BETWEEN A FIRST COMPONENT AND A SECOND COMPONENT</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>ABILITY FOR DEVELOPERS TO EASILY FIND OR EXTEND WELL KNOWN LOCATIONS ON A SYSTEM A method and data structure for creating and accessing folders stored in well known locations. The data structure and method utilizes a set of APIs to create and manage well known folders on a system and/or to locate specific well known folders. The invention provides interfaces to create, locate, extend, and enumerate well known folders. In addition, the invention allows a developer and/or user to customize properties of well known folders.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br>
<br>
<br>
FIELD OF THE INVENTION<br>
The invention generally relates to creating and managing folders stored in well known locations with a set of application programming interfaces.<br>
BACKGROUND OF THE INVENTION<br>
Today developers and users typically store data from various applications in certain well known folders such as the My Documents folder or the My Pictures folder. These well known folders provide easy access across multiple applications and computer network environments in order for developers and users to access information. These well known folders are utilized in operating systems, such as Windows® brand Operating Systems.<br>
For example, many applications utilize specific well known folders such as the My Documents folder for storing data applicable to the particular application being installed. The use of the My Documents folder enables other applications the ability to access the stored information. For instance a jpeg file may be used by several photo publishing applications. A particular photo publishing application may store the jpeg file in a well known folder such as the My Documents folder so that other photo publishing applications may access the jpeg file. However, placement of numerous application files and folders under the My Documents folder creates an unorganized list of folders making searching for particular folders and data cumbersome and time consuming.<br>
Existing operating systems such as Microsoft® Windows® utilize a Shell to organize data objects such as folders and files into a hierarchical namespace structure through a user interface or an application. The Shell may contain special folders whose location and existence may be known to the system and access to which is provided from numerous places in the Shell such as the Start Menu. The Shell may provide a set of SHFolderPath APIs to manage these well known folders for developers and users. The SHFolderPath APIs may utilize a fixed set of CSIDLs. The CSIDLs comprise ordinal values used to identify folders and provide<br>
 <br>
a unique system-independent way to identify special folders used frequently by applications. A table is utilized to map the CSIDLs with the location of the well known folders on a disk or drive. In current versions of existing operating systems, such as Microsoft® Windows® XP, known folders are not extendable as the CSIDLs are not extendable. Moreover, the addition of new properties to existing known folders in existing operating systems is not possible.<br>
Thus, it would be an advancement in the art to provide a method and data structure in which developers and users may create their own known folders for use by various applications. Additionally, it would be an advancement to add new or custom properties to existing as well as new known folders which may be utilized by developers or users. These custom properties may, for example, inform developers or users of a known folders intended usage. Furthermore, the method and data structure should enable a user to discover and utilize other known folders created by various applications which may be located on the same computer or on a network with a minimal amount of effort.<br>
BRIEF SUMMARY OF THE INVENTION<br>
The inventive method and data structure overcome the problems of the prior art by providing a set of APIs to enumerate well known locations on a system and/or to locate specific well known locations. In particular, the invention provides the functionally to locate, extend, and enumerate well known folders. In addition, the invention allows a developer and/or user to customize properties of well known folders.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
A more complete understanding of the present invention and the advantages thereof may be acquired by referring to the following description in consideration of the accompanying drawings, in which like reference numbers indicate like features, and wherein:<br>
Figure 1 illustrates an example of a suitable computing system environment on which the invention may be implemented.<br>
 <br>
Figure 2 illustrates an interface as a conduit through which first and second code segments communicate.<br>
Figure 3 illustrates an interface as comprising interface objects.<br>
Figure 4 illustrates a function provided by an interface that may be subdivided to convert communications of the interface into multiple interfaces.<br>
Figure 5 illustrates a function provided by an interface that may be subdivided into multiple interfaces.<br>
Figure 6 illustrates an example of ignoring, adding, or redefining aspects of a programming interface while still accomplishing the same result.<br>
Figure 7 illustrates another example of ignoring, adding, or redefining aspects of a programming interface while still accomplishing the same result.<br>
Figure 8 illustrates merging code segments in relation to the example that is shown in Figure 2.<br>
Figure 9 illustrates merging interfaces in relation to the example that is shown in Figure 3.<br>
Figure 10 illustrates middleware that converts communications to conform to a different interface.<br>
Figure 11 illustrates a code segment that is associated with a divorce interface.<br>
Figure 12 illustrates an example in which an installed base of applications is designed to communicate with an operating system in accordance with an interface protocol, in which the operating system is changed to use a different interface.<br>
Figure 13 illustrates rewriting interfaces to dynamically factor or otherwise alter the interfaces.<br>
| Figure 14 illustrates an extended API that may provide functionality such as retrieving a Knownfolder PIDL for the specified KnownFolderlD in accordance with an aspect of the invention.<br>
 <br>
Figure 15 illustrates an additional extended API that may provide functionality such as providing a caller with the actual file system path of a Knownfolder in accordance with an aspect of the invention.<br>
Figure 16 illustrates a third extended API that may provide functionality such as allowing a caller to set the path for a given known folder in accordance with an aspect of the invention.<br>
Figure 17 illustrates an IKnownFolder API that may provide functionality such as granting an application the ability to get the GUID value and/or a PIDL value for a defined knownfolder in accordance with an aspect of the invention.<br>
Figure 18 illustrates an IKnownFolderManager API that may provide the ability to create or delete a knownfolder in accordance with an aspect of the invention.<br>
Figure 19 illustrates the KnownFolderDefinition structure in accordance with an aspect of the invention.<br>
Figure 20 illustrates an IEnumKnownFolder() API that may provide the ability to enumerate knownfolders in accordance with an aspect of the invention<br>
Figure 21 illustrates an IKnownFolderHandler() API that may provide the ability for other components to add special code for the creation and/or deletion of a knownfolder in accordance with an aspect of the invention.<br>
Figure 22 illustrates a requesting component utilizing a program interface call to an operating system in accordance with an aspect of the invention.<br>
Figure 22a illustrates another aspect of the invention wherein an application transmits a request along with a identification of a known folder to determine the location of a known folder in accordance with an aspect of the invention.<br>
Figure 23 illustrates a method of creating a new knownfolder in accordance with an aspect of the invention.<br>
DETAILED DESCRIPTION OF THE INVENTION<br>
In order to clarify the disclosure of the invention, definitions of several relevant terms are provided herein.<br>
 <br>
Profile:	Provides operating system and applications with a per-u3er location<br>
to store user specific data and settings.<br>
Known Folder/KnownFolder: A category of folders which are made known to the Windows Shell and other components and applications.<br>
SHFolderPathO APIs: A set of Shell folder APIs which include<br>
SHGetFolderLocation(), SHGetFoIderPath(), and SHSetFolderPath().<br>
CSIDLs	Ordinal values used to identify folders and provide a unique system-<br>
independent way to identify special folders used frequently by applications.<br>
Figure 1 illustrates an example of a suitable computing system environment 100 on which the invention may be implemented. Computing system environment 100 is only one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should the computing environment 100 be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment 100.<br>
With reference to Figure 1, an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer 110. Components of computer 110 may include, but are not limited to, a processing unit 120, a system memory 130, and a system bus 121 that couples various system components including the system memory to the processing unit 120. The system bus 121 may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.<br>
Computer 110 typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer 110 and includes both volatile and nonvolatile media, removable and non-removable media.   By way of example, and not limitation, computer readable media may<br>
 <br>
comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer 110. Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term "modulated data signal" means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.<br>
The system memory 130 includes computer storage media in the form of volatile and/or nonvolatile memory such as read only memory (ROM) 131 and random access memory (RAM) 132. A basic input/output system 133 (BIOS), containing the basic routines that help to transfer information between elements within computer 110, such as during start-up, is typically stored in ROM 131. RAM 132 typically contains data and/or program modules that are immediately accessible to and/or presently being operated on by processing unit 120. By way of example, and not limitation, Figure 1 illustrates operating system 134, application programs 135, other program modules 136, and program data 137.<br>
The computer 110 may also include other removable/non-removable, volatile/nonvolatile computer storage media. By way of example only, Figure 1 illustrates a hard disk drive 140 that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive 151 that reads from or writes to a removable, nonvolatile magnetic disk 152, and an optical disk drive 155 that reads from or writes to a removable, nonvolatile optical disk 156 such as a CD ROM or<br>
 <br>
other optical media. Other removable/non-removable, volatile/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive 141 is typically connected to the system bus 121 through a non-removable memory interface such as interface 140, and magnetic disk drive 151 and optical disk drive 155 are typically connected to the system bus 121 by a removable memory interface, such as interface 150.<br>
The drives and their associated computer storage media discussed above and illustrated in Figure 1, provide storage of computer readable instructions, data structures, program modules and other data for the computer 110. In Figure 1, for example, hard disk drive 141 is illustrated as storing operating system 144, application programs 145, other program modules 146, and program data 147. Note that these components can either be the same as or different from operating system 134, application programs 135, other program modules 136, and program data 137. Operating system 144, application programs 145, other program modules 146, and program data 147 are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer 110 through input devices such as a keyboard 162 and wireless pointing device 161, commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit 120 through a user input interface 160 that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor 191 or other type of display device is also connected to the system bus 121 via an interface, such as a video interface 190. In addition to the monitor, computers may also include other peripheral output devices such as speakers 197 and printer 196, which may be connected through an output peripheral interface 190.<br>
The computer 110 may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer 180. The remote computer 180 may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of<br>
 <br>
the elements described above relative to the computer 110, although only a memory storage device 181 has been illustrated in Figure 1. The logical connections depicted in Figure 1 include a local area network (LAN) 171 and a wide area network (WAN) 173, but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.<br>
When used in a LAN networking environment, the computer 110 is connected to the LAN 171 through a network interface or adapter 170. When used in a WAN networking environment, the computer 110 typically includes a modem 172 or other means for establishing communications over the WAN 173, such as the Internet. The modem 172, which may be internal or external, may be connected to the system bus 121 via the user input interface 160, or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer 110, or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation, Figure 1 illustrates remote application programs 185 as residing on memory device 181. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used. A peripheral interface 195 may interface to a video input device such as a scanner (not shown) or a digital camera 194, where output peripheral interface may support a standardized interface, including a universal serial bus (USB) interface.<br>
The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.<br>
The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures,<br>
 <br>
etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.<br>
A programming interface (or more simply, interface) may be viewed as any mechanism, process, or protocol for enabling one or more segment(s) of code to communicate with or access the functionality provided by one or more other segment(s) of code. Alternatively, a programming interface may be viewed as one or more mechanism(s), method(s), function call(s), module(s), object(s), etc. of a component of a system capable of communicative coupling to one or more mechanism(s), method(s), function call(s), module(s), etc. of other component(s). The term "segment of code" in the preceding sentence is intended to include one or more instructions or lines of code, and includes, e.g., code modules, objects, subroutines, functions, and so on, regardless of the terminology applied or whether the code segments are separately compiled, or whether the code segments are provided as source, intermediate, or object code, whether the code segments are utilized in a runtime system or process, or whether they are located on the same or different machines or distributed across multiple machines, or whether the functionality represented by the segments of code are implemented wholly in software, wholly in hardware, or a combination of hardware and software.<br>
Notionally, a programming interface may be viewed generically, as shown in Figure 2 or Figure 3. Figure 2 illustrates an interface Interface 1 as a conduit through which first and second code segments communicate. Figure 3 illustrates an interface as comprising interface objects II and 12 (which may or may not be part of the first and second code segments), which enable first and second code segments of a system to communicate via medium M. In the view of Figure 3, one may consider interface objects II and 12 as separate interfaces of the same system and one may also consider that objects II and 12 plus medium M comprise the interface. Although Figures 2 and 3 show bi-directional flow and interfaces on each side of the flow, certain implementations may only have information flow in one direction (or no information flow as described below) or may only have an interface object on one<br>
 <br>
side. By way of example, and not limitation, terms such as application programming interface (API), entry point, method, function, subroutine, remote procedure call, and component object model (COM) interface, are encompassed within the definition of programming interface.<br>
Aspects of such a programming interface may include the method whereby the first code segment transmits information (where "information" is used in its broadest sense and includes data, commands, requests, etc.) to the second code segment; the method whereby the second code segment receives the information; and the structure, sequence, syntax, organization, schema, timing and content of the information. In this regard, the underlying transport medium itself may be unimportant to the operation of the interface, whether the medium be wired or wireless, or a combination of both, as long as the information is transported in the manner defined by the interface. In certain situations, information may not be passed in one or both directions in the conventional sense, as the information transfer may be either via another mechanism (e.g. information placed in a buffer, file, etc. separate from information flow between the code segments) or non-existent, as when one code segment simply accesses functionality performed by a second code segment. Any or all of these aspects may be important in a given situation, e.g., depending on whether the code segments are part of a system in a loosely coupled or tightly coupled configuration, and so this list should be considered illustrative and non-limiting.<br>
This notion of a programming interface is known to those skilled in the art and is clear from the foregoing detailed description of the invention. There are, however, other ways to implement a programming interface, and, unless expressly excluded, these too are intended to be encompassed by the claims set forth at the end of this specification. Such other ways may appear to be more sophisticated or complex than the simplistic view of Figures 2 and 3, but they nonetheless perform a similar function to accomplish the same overall result. We will now briefly describe some illustrative alternative implementations of a programming interface.<br>
A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in Figures 4 and 19. As shown, some interfaces can<br>
 <br>
e described in terms of divisible sets of functionality.    Thus, the interface<br>
mctionality of Figures 2 and 3 may be factored to achieve the same result, just as<br>
ne may mathematically provide 24, or 2 times 2 times 3 times 2. Accordingly, as<br>
lustrated in Figure 18, the function provided by interface Interfacel may be<br>
ubdivided to convert the communications of the interface into multiple interfaces<br>
nterfacelA, Interface IB, Interface 1C, etc. while achieving the same result. As<br>
[lustrated in Figure 5, the function provided by interface II may be subdivided into<br>
nultiple interfaces I la, lib, lie, etc. while achieving the same result. Similarly,<br>
nterface 12 of the second code segment which receives information from the first<br>
•ode segment may be factored into multiple interfaces I2a, I2b, I2c, etc. When<br>
factoring, the number of interfaces included with the 1st code segment need not<br>
natch the number of interfaces included with the 2nd code segment. In either of the<br>
cases of Figures 4 and 5, the functional spirit of interfaces Interfacel and II remain<br>
the same as with Figures 2 and 3, respectively. The factoring of interfaces may also<br>
follow associative, commutative, and other mathematical properties such that the<br>
factoring may be difficult to recognize. For instance, ordering of operations may be<br>
unimportant, and consequently, a function carried out by an interface may be carried<br>
out well in advance of reaching the interface, by another piece of code or interface,<br>
or performed by a separate component of the system. Moreover, one of ordinary<br>
skill in the programming arts can appreciate that there are a variety of ways of<br>
making different function calls that achieve the same result.<br>
In some cases, it may be possible to ignore, add or redefine certain aspects (e.g., parameters) of a programming interface while still accomplishing the intended result. This is illustrated in Figures 6 and 7. For example, assume interface Interfacel of Figure 2 includes a function call Square(input, precision, output), a call that includes three parameters, input, precision and output, and which is issued from the 1st Code Segment to the 2nd Code Segment. If the middle parameter precision is of no concern in a given scenario, as shown in Figure 6, it could just as well be ignored or even replaced with a meaningless (in this situation) parameter. One may also add an additional parameter of no concern. In either event, the functionality of square can be achieved, so long as output is returned after input is squared by the second code segment. Precision may very well be a meaningful parameter to some downstream or other portion of the computing system; however, once it is<br>
 <br>
recognized thai precision is not necessary for the narrow purpose of calculating the square, it may be replaced or ignored. For example, instead of passing a valid precision value, a meaningless value such as a birth date could be passed without adversely affecting the result. Similarly, as shown in Figure 7, interface II is replaced by interface IT, redefined to ignore or add parameters to the interface. Interface 12 may similarly be redefined as interface 12', redefined to ignore unnecessary parameters, or parameters that may be processed elsewhere. The point here is that in some cases a programming interface may include aspects, such as parameters, that are not needed for some purpose, and so they may be ignored or redefined, or processed elsewhere for other purposes.<br>
It may also be feasible to merge some or all of the functionality of two separate code modules such that the "interface" between them changes form. For example, the functionality of Figures 2 and 3 may be converted to the functionality of Figures 8 and 9 , respectively. In Figure 8, the previous 1st and 2nd Code Segments of Figure 2 are merged into a module containing both of them. In this case, the code segments may still be communicating with each other but the interface may be adapted to a form which is more suitable to the single module. Thus, for example, formal Call and Return statements may no longer be necessary, but similar processing or response(s) pursuant to interface Interface 1 may still be in effect. Similarly, shown in Figure 9, part (or all) of interface 12 from Figure 3 may be written inline into interface II to form interface II". As illustrated, interface 12 is divided into I2a and I2b, and interface portion I2a has been coded in-line with interface II to form interface II". For a concrete example, consider that the interface II from Figure 3 performs a function call square (input, output), which is received by interface 12, which after processing the value passed with input (to square it) by the second code segment, passes back the squared result with output. In such a case, the processing performed by the second code segment (squaring input) can be performed by the first code segment without a call to the interface.<br>
i A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in Figures 10 and 11. As shown in Figure 10, one or more piece(s) of middleware (Divorce Interface(s), since they divorce functionality<br>
and / or interface functions from the original interface) are provided to convert the<br>
11<br>
 <br>
communications on the first interface, Interface 1, to conform them to a different interface, in this case interfaces Interface2A, Interface2B and Interface2C, This might be done, e.g., where there is an installed base of applications designed to communicate with, say, an operating system in accordance with an Interface 1 protocol, but then the operating system is changed to use a different interface, in this case interfaces Interface2A, lnterface2B and Interface2C. The point is that the original interface used by the 2nd Code Segment is changed such that it is no longer compatible with the interface used by the 1st Code Segment, and so an intermediary is used to make the old and new interfaces compatible. Similarly, as shown in Figure 11, a third code segment can be introduced with divorce interface DI1 to receive the communications from interface II and with divorce interface DI2 to transmit the interface functionality to, for example, interfaces I2a and I2b, redesigned to work with DI2, but to provide the same functional result. Similarly, DI1 and DI2 may work together to translate the functionality of interfaces II and 12 of Figure 3 to a new operating system, while providing the same or similar functional result<br>
Yet another possible variant is to dynamically rewrite the code to replace the interface functionality with something else but which achieves the same overall result. For example, there may be a system in which a code segment presented in an intermediate language (e.g. Microsoft IL, Java ByteCode, etc.) is provided to a Justin-Time (JIT) compiler or interpreter in an execution environment (such as that provided by the .Net framework, the Java runtime environment, or other similar runtime type environments). The JIT compiler may be written so as to dynamically convert the communications from the 1st Code Segment to the 2nd Code Segment, i.e., to conform them to a different interface as may be required by the 2 Code Segment (either the original or a different 2nd Code Segment). This is depicted in Figures 12 and 13. As can be seen in Figure 12, this approach is similar to the Divorce scenario described above. It might be done, e.g., where an installed base of applications are designed to communicate with an operating system in accordance with an Interface 1 protocol, but then the operating system is changed to use a different interface. The JIT Compiler could be used to conform the communications on the fly from the installed-base applications to the new interface of the operating system. As depicted in Figure 13, this approach of dynamically rewriting the<br>
 <br>
interface(s) may be applied to dynamically factor, or otherwise alter the interface(s) as well.<br>
It is also noted that the above-described scenarios for achieving the same or similar result as an interface via alternative embodiments may also be combined in various ways, serially and/or in parallel, or with other intervening code. Thus, the alternative embodiments presented above are not mutually exclusive and may be mixed, matched and combined to produce the same or equivalent scenarios to the generic scenarios presented in Figures 2 and 3. It is also noted that, as with most programming constructs, there are other similar ways of achieving the same or similar functionality of an interface which may not be described herein, but nonetheless are represented by the spirit and scope of the invention, i.e., it is noted that it is at least partly the functionality represented by, and the advantageous results enabled by, an interface that underlie the value of an interface.<br>
A user interface gives users access to objects necessary for running applications and managing the operating system. These objects may include folders and files that may reside on a computer's disk drives. A Shell organizes these objects into a hierarchical namespace structure through the user interface or through an application. The Shell may contain special folders whose location and existence may be known to the system and access to which is provided from numerous places in the Shell such as the Start Menu.<br>
In an aspect of the invention, a GUID (globally unique identifier) may be utilized to specify each individual known folder on a system. The known folders may belong to one of four categories which include virtual folders, fixed file-system folders, common folders, and per-user folders.<br>
The virtual folders may be virtual shell folders which appear in the shell namespace and may not have any actual file system folders associated with them. For example, the Control Panel Folder and the Printer folders may be virtual folders which are not backed up by any actual file system folders but only exist in the shell virtual namespace. The fixed file folder may be file system folders that are not managed by the Shell and whose location is fixed when the system is installed. For example, the "Windows" folder and the "Program Files" folders are fixed folders. The common folders may be file system folders that may be used for sharing data and settings<br>
 <br>
between users. For example, all users of a machine may share a common desktop folder. Finally, the per-user folders may be file system folders which are located under an individual's profile and owned by the individual user. For example, the "%USERPROFILE%\Pictures" is a folder for the current user's pictures.<br>
In an aspect of the invention, the knownfolder functionality may be provided for both Win32 and Com APIs. The Win32 APIs may provide backwards compatibility with the SHFolderPath APIs. The SHFolderPath APIs may be wrappers of the Com APIs with a hard coded mapping list of CSIDL to the new FOLDERIDs for those respective folders.<br>
To support backwards compatibility, the knownfolder interface may support three Win32 API calls which include the SHGetFolderLocationEx(), SHGetFolderPathEx(), and SHSetFolderPathEx().<br>
The SHGetFolderLocationEx() API subsumes the SHGetFolderlocation() API and may provide a caller with additional ability such as retrieving the Knownfolder PIDL for the specified KnownFolderlD and/or the ability to specify to create the Knownfolder requested, if it does not already exist. The SHGetFolderLocationEX() API 1400 is shown in figure 14. The SHGetFolderLocationEX() API 1400 parameters may include rfid parameter 1401. The rfid parameter 1401 may represent a GU1D identity for the known folder. The dwFlags parameter 1402 may specify special options to be performed when the folder is referenced. The default value for the dwFlag parameter 1402 may be zero. Other exemplary values for dwFlag parameters 1402 are shown in Table 1 below:<br>
 <br>
The hToken parameter 1403 may specify the owner of the per-user known folder. Some of the known folders, for example, the "My Documents" folder, are per-user folders. Every user may have a different path for their "My Documents" folder. If<br>
 <br>
hToken parameter 1403 has a value of NULL, the API may try to access the current user (the caller)'s instance of the folder. If hToken parameter 1403 has a valid user token, the API will try to impersonate the user using this token and try to access that user's instance. Moreover, if the hToken parameter 1403 has a value of-1, then the API may try to access the default user's folder. The ppidl parameter 1404 may return the PIDL of the requested known folder.<br>
The SHGetFolderPathEx() API subsumes the SHGetFolderPath() API and may provide a caller with the actual file system path of the known folder. The SHGetFolderPathEx() API 1500 is shown in figure 15. The SHGetFolderPathEx() API 1500 parameters may include similar parameters as discussed above with the SHGetFolderLocationEx() API 1400 such as rfid parameter 1401, dwFlags parameter 1402, and hToken parameter 1403. In addition, the SHGetFolderPathEx() API 1500 may also include a pszPath parameter 1508 and a cchPath parameter 1509. The pszPath parameter 1508 may return the path of a known folder whereas; the cchPath parameter 1509 may specify the buffer size of pszPath parameter 1508. In addition, the SHGetFolderPathEx() API 1500 may have additional dwFlag values available to use as shown in Table 2 below:<br>
 <br>
The SHSetFolderPathEx() API 1600 subsumes the SHSetFolderPath() API and may allow    a    caller   to    set    the    oath    for    a   given    known    folder.        The<br>
 <br>
SHSetFolderPathEx()API 1600 is shown in figure 16. The SHSetFolderPathEx() API 1600 parameters may include similar parameters as discussed above with the SHGetFolderLocationExQ API 1400 such as rfid parameter 1401, dwFlags parameter 1402, and hToken parameter 1403. In addition, the SHSetFolderPathEx() API 1600 may also include a pszPath parameter 1608 which may be used to specify a redirected path for a knownfolder. In addition the ShSetFolderPathEx() API 1600 may have additional dwFlag values available to use as shown in Table 3 below:<br>
 <br>
As stated above, in another aspect of the invention, the knownfolder functionality may be provided for by Com APIs. The COM interfaces may include an IKnownFolder API, an IKnownFolderManager API, an IEnumKnownFolder interface, and IKnownFolderHandler.<br>
As shown in Figure 17, the IKnownFolder API 1700 may provide an application the ability to get a GUID value and/or a PIDL value for a defined knownfolder. Moreover, the IKnownFolder API 1700 may get or set the path for the defined knownfolder. The IKnownFolder API parameters may include a GetID() parameter 1701. The GetID() parameter 1701 may obtain the GUID for a specified knownfolder. The GetCategory() parameter 1702 may retrieve a knownfolder category for a specified knownfolder. The knownfolder categories may include a virtual folder category, a fixed-file system category, a common folder category, and/or a per-user folder category.<br>
Additional parameters of the IKnownFolder API 1700 may include a GetPath() parameter 1703, a SetPath() parameter 1704, a GetLocation() parameter 1705, and a Getltem() parameter 1706. The GetPath() parameter 1703 may obtain the path for a given knownfolder. The SethPath() parameter 1704 may set a path for a knownfolder.   The GetLocationQ parameter 1705 may provide a PIDL associated<br>
 <br>
with a knownfolder, whereas, the GetltemQ parameter 1706 may retrieve Shell Interfaces associated with a specified folder.<br>
[n addition, redirection may be provided by the IKnownFolder API 1700. Redirection may be specified through the use of an IsRedirectable() parameter 1707, IsValidFolderPath() parameter 1708, RedirectO parameter 1709, and RedirectWithUlQ parameter 1710. The IsRedirectableQ parameter 1707 may be provided to check to see if the specified known folder is allowed to be redirected. The IsValidFolderPath() parameter 1708 may verify if the provided path is a valid path for redirection. The Redirect() parameter 1709 may redirect the specified knownfolder to the specified path. The RedirectWithUI() parameter 1710 may show an user interface while redirecting the knownfolder to the specified path.<br>
In another aspect of the invention, an IKnownFolderManager API may be provided. As shown in Figure 18, the IKnownFolderManager API 1800 may provide the ability to create or delete a knownfolder. The IKnownFolderManager API 1800 may also manage the definitions of a knownfolder such as descriptions of a knownfolder, category of the knownfolder, ownership information of the knownfolder, and/or relative path of a knownfolder. Moreover, the IKnownFolderManager API 1800 may also provide the ability to enumerate all knownfolders available on a computing system or on a computing system environment. For example, the IKnownFolderManager API 1800 may enumerate all of the well knownfolders available to a user having access to a computer network.<br>
According to an aspect of the invention, the IKnownFolderManager API 1800 may include a number of parameters. For instance, the IKnownFolderManager API 1800 may include a FolderIdFromCSIDL() parameter 1801. The FolderIdFromCSIDL() parameter 1801 may be used to retrieve the KnownFolderlD associated with a specified CSIDL. The FolderIdFromCSIDL() parameter 1801 may therefore provide a translation between the CSIDL and the KnownFolderJD. Similarly, a FolderIdToCSIDL() parameter 1802 may also be defined to obtain a CSIDL value for a specified KnownFolderlD.<br>
A GetFolder() parameter 1803 may also be defined as a parameter of the IKnownFolderManager API 1800. The GetFolder() parameter 1803 may be utilized to obtain information for a particular knownfolder directly where the ID of the<br>
 <br>
knownfolder is available. The GetFolder() parameter 1803 may return a IKnownFolder pointer in order to obtain information such as a GUID value for a knownfolder, a knownfolder category, a knownfolder path, and/or PIDL associated with the knownfolder. Similar to the GetFolder() parameter 1803, a GetFolderForUser() parameter 1804 may also be defined that provides a caller with the ability to get paths for a knownfolder belonging to a specific user.<br>
Referring to Figure 18, a GetFolderDefinition() parameter 1805 may be provided in order to obtain all properties associated with a specified KnownFolderlD. According to an aspect of the invention, a KnownFolderDefinition structure 1900 may be defined as shown in Figure 19. The KnownFolderDefinition structure 1900 may contain a number of defined fields as illustrated in Figure 19 and as further described in Table 4. These fields may include category 1910, pszName 1911, pszCreator 1912, pszDescription 1913, pfidParent 1914, pszRelativePath 1915, pszParsingName 1916, pszTooltip 1917, pszLocalizedName 1918, pszlcon 1919, pszSecurity 1920, dwAttributes 1921, pszLegacyPath 1922, clsidHandler 1923, and kfdFlags 1924.<br>
 <br>
 <br>
 <br>
Referring to Figure 18, parameters such as RegisterFolder() parameter 1806 and UnregisterFolder() parameter 1807 may be provided in order to create or delete a knownfolder for the system. The RegisterFolder() parameter 1806 may require a user or caller to specify a valid KnownFolderDefmition. The UnregisterFolder() parameter 1808 may delete the KnownFolderDefinition definition when requested.<br>
Additional parameters such as the GetEnumKnownFolders() parameter 1809 and GetEnumKnownFoldersForUser() parameter 1810 may also be defined for use with the IKnownFolderManager API 1800. The GetEnumKnownFolders() parameter 1809 may return a pointer to enumerate all knownfolders on a system whereas, the GetEnumKnownFoldersForUser() parameter 1810 may provide a caller with the ability to enumerate knownfolders for a specific user. Finally, a FindFolderFromPath() parameter 1811 may return a known folder pointer to obtain an associated known folder ID for the file system path provided.<br>
In another aspect of the invention, an IEnumKnownFolder() API may be provided. As shown in Figure 20, the IEnumKnownFolder() API 2000 may provide the ability to enumerate knownfolders. The GetEnumKnownFolders() parameter 1809 and GetEnumKnownFoldersForUser() parameter 1810 may return a pointer to the IEnumKnownFolder() API 2000 to get an enumeration of all knownfolders on the system. The IEnumKnownFolder() API 2000 may include parameters such as NextO 2001, Skip() 2002, Reset() 2003, and Clone() 2004. The Next() parameter 2001  may retrieve a specified number of item identifiers in the enumeration<br>
 <br>
sequence and advance the current position by the number of retrieved items. The SkipQ parameter 2002 may skip over a specified number of elements in the enumeration sequence. The Reset() parameter 2003 may return the interface to the beginning of the enumeration sequence. The Clone() parameter 2004 may create a new enumeration object with the same contents and state as the current one.<br>
In another aspect of the invention, an IKnownFolderHandler() API may be provided. As shown in Figure 21, the IKnownFolderHandler() API 2100 may provide the ability for other components to add special code for the creation and/or deletion of a knownfolder. The IKnownFolderHandler() API 2100 may include parameters such as GetDefaultLocation() 2101, FolderCreated() 2102, and FolderRemoved() 2103. The GetDefaultLocation() parameter 2101 may retrieve the default location for a knownfolder. The FolderCreated() parameter 2102 may initiate a handler when the specificed knownfolder is created. Moreover, a FolderRemoved() parameter 2103 may initiate the handler when the specified knownfolder is deleted. This may provide the ability for an application to run custom code when a known folder created by the application is created or deleted.<br>
Figure 22 illustrates a requesting component 2201 utilizing a program interface call to an operating system 2202 in accordance with an aspect of the invention. In this aspect of the invention, requesting component 2201 is an application, although with other embodiments, requesting component 2201 may be integrated within peripheral hardware of computer 110 as shown in Figure 1.<br>
Requesting component 2201, upon installation by a developer or user, may decide to create, enumerate, or manage existing knownfolders on computer 110. For example, an application 2201 of Figure 22 may create a new folder inside a users profile by adding the new knownfolders directly to registry 2203 when an application is installed. In addition, the new knownfolders may be added through the KnownFolder APIs 2210 such as the IKnownFolderManager API. A developer or user, through the application 2201 may call 2250 an API such as the IKnownFolder Manager API 1800 to create a new knownfolder. The developer or user may through the application provide a GU1D 2251, which will be the unique identifier for the new knownfolder. The developer or user may also define additional properties 2252 over and beyond the standard properties that will be associated with the new<br>
 <br>
knownfolder. Referring to Figure 22, application 2201 transmits a call 2250 such as a call to KnownFolder APIs 2210. In response to input 2250, the IKnownFolderManager API 1800 registers with the operating system 2202 the new knownfolder with registry 2203 of operating system 2202. The operating system, in response, may transmit a path 2260 of the new knownfolder to the application 2201.<br>
Figure 22a illustrates another aspect of the invention. Referring to Figure 22a, an application 2201 utilizing a program interface call may transmit a request along with identification 2260 for the location of a known folder via the known folder APIs 2210. The known folder APIs 2210 may search a registry 2203 for a listing 2280 of known folder IDs along with their corresponding storage locations. Known folder APIs 2210 may verify that the storage location specified in the registry is valid, via a request 2261 to a particular storage device such as local storage 2255 wherein the known folder may be located. Upon verifying the location, the Knownfolder API may return the path of the requested Known Folder back to the application. For example, the My Pictures 2270 known folder may be requested by application 2201 via call 2260. Known folder APIs 2210 may determine the location of the Pictures 2270 known folder through examination of registry listing 2280. The known folder APIs 2210 may verify that the location does exist via a request 2261 to local storage 2255 and on confirmation may return the path to the Pictures location 2262 on the local storage 2255 to the application 2201.<br>
The My Pictures known folder 2270 may be moved 2290 from local storage 2255 to Network Storage 2256. The relocation of the My Pictures known folder 2270 changes the location path for the My Pictures known folder 2270. The location of the My Pictures known folder 2270 may be updated in registry 2203. Similarly, the movement 2295 of the My Pictures known folder 2270 to another location such as a website location 2257 may also initiate the updating of registry 2203 with the new location of the My Pictures known folder 2270.<br>
Figure 23 illustrates a method of creating a new knownfolder in accordance with an aspect of the invention. Referring to Figure 23, a component such as an operating system may receive at step 2301 a call having a GUID from a first component. The first component may include an application program being installed or initialized by a developer or user. Upon receipt of the call by the operating system, the operating<br>
 <br>
system may at step 2302 extract a GUID provided by the application program. The call may also include additional information such as properties for use in the creation of the new knownfolder. The properties may include information to define the new knownfolders such as a category, a pszName, a pszCreator, a pszDescription, a pfidParent, a pszRelativePath, a pszParsingName, a pszTooltip, a pszLocalizedName, a pszlcon, a pszSecurity, a dwAttributes, a pszLegacyPath, a clsidHandler, and a kdfFlags.<br>
Based on the extracted GUID and additional information provided, a new knownfolder at step 2303 may be created. The new knownfolder may be included in the registry of the operating system as indicated in step 2304, The operation system in step 2405 may transmit a path of the new knownfolder to the application program. The application program may enumerate all of the existing knownfolders on the local or network system.<br>
While the invention has been described with respect to specific examples including presently preferred modes of carrying out the invention, those skilled in the art will appreciate that there are numerous variations and permutations of the above described systems and techniques that fall within the spirit and scope of the invention as set forth in the appended claims.<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
We Claim:<br>
1.	A method of communication between a first component and a second<br>
component comprising:<br>
(a)	receiving a call from a first component including the identification of a known folder;<br>
(b)	searching a registry for the location of the known folder; and<br>
(c)	accessing data from the known folder at a determined location.<br>
<br>
2.	The method of claim 1, wherein the determined location comprises a local hard drive.<br>
3.	The method of claim 1, wherein the determined location comprises a network drive.<br>
4.	The method claim 1, wherein the determined location comprises a website.<br>
5.	The method of claim 1, further comprising creating a new known folder if the received known folder identification is not valid and providing a location of the new known folder to the second component<br>
6.	A method of communication between a first component and a second component comprising:<br>
<br>
(a)	receiving a call having a GU1D from the first component;<br>
(b)	extracting the QUID;<br>
(c)	creating a new knownfolder based on the extracted GUID;<br>
(c)	registering the new knownfolder within a registry; and<br>
(e)       transmitting a path of the new knownfolder to the second component.<br>
7.	The method claim 6, wherein the first component comprises an application program.<br>
8.	The method of claim 6, wherein the call further includes properties for use in the creation of the new knownfolder.<br>
9.	The method of claim 8, wherein the properties of the new knownfolder are selected from the group consisting of a category, a pszName, a pszCreator, a pszDescription,  a  pfidParent,  a pszRelativePath,  a pszParsingName,  a pszTooltip,  a<br>
 <br>
pszLocalizedName,   a   pszlcon,   a   pszSecurity,   dwAttributes,   a   pszLegacyPath,   a clsidHandler, and kfdFlags.<br>
10.	The method of claim 6, further comprising:<br>
(f)       receiving a call setting the location of a specified knownfolder.<br>
11.	The method of claim 6, further comprising:<br>
(f)       receiving a call querying a category type of a specified knownfolder.<br>
12.	The method of claim 6, further comprising:<br>
(f)       receiving a request for the enumeration of all knownfolders.<br>
13.	The method of claim 6, wherein the second component comprises an operating system, the operating system storing a set of application programming interfaces (APIs).<br>
14.	The method of claim 13, wherein the set of application programming interfaces are selected from the group consisting of an IKnownFolder, an IKnownFolderManager, an lEnumKnownFolder interface, and an IKnownFolderHandler.<br>
15.	The method of claim 13, wherein the set of application programming interfaces are selected from the group consisting of SHGetFolderLocationEx(), SHGetFolderPathEx(), and SHSetFolderPathEx().<br>
16.	An application programming interface embodied on one or more computer readable media, comprising:<br>
<br>
(a)	one set of application programming interfaces related to knownfolders, the one set of application programming interfaces providing call support for legacy components; and<br>
(b)	a second set of application programming interfaces related to knownfolders, the second set of application programming interfaces providing creation of new knownfolders.<br>
<br>
17.	The application programming interface embodied on one or more computer readable media of claim 16, wherein the second set of application programming interfaces provides properties for the new knownfolders.<br>
18.	The application programming interface embodied on one or more computer readable media of claim 17, wherein the properties of the new knownfolders are selected<br>
 <br>
from the group consisting of a category, a pszName, a pszCreator, a pszDescription, a pfidParent, a pszRelativePath, a pszParsingName, a pszTooltip, a pszLocalizedName, a pszlcon, a pszSecurity, dwAttributes, a pszLegacyPath, a clsidHandler, and kfdFlags.<br>
19.	The application programming interface embodied on one or more computer<br>
readable media of claim 16, wherein the second set of application programming interfaces<br>
related to knownfolders provides redirection of a specified knownfolder.<br>
20.	The application programming interface embodied on one or more computer<br>
readable media of claim 16, wherein the redirection occurs across a computer network.<br>
 <br>
</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=Ecg4cuG+Hkb0JB44EPFSGg==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=Ecg4cuG+Hkb0JB44EPFSGg==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==</a></p>
		<br>
		<div class="pull-left">
			<a href="278333-method-system-and-server-for-receiving-email.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="278335-method-of-conveying-furnace-bottom-mantle-for-blast-furnace.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>278334</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>4206/CHENP/2007</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>53/2016</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>23-Dec-2016</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>20-Dec-2016</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>24-Sep-2007</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>MICROSOFT TECHNOLOGY LICENSING, LLC</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>One Microsoft Way, Redmond, Washington 98052</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>WENTZ, BRIAN, D</td>
											<td>ONE MICROSOFT WAY REDMOND, WASHINGTON 98052-6399, USA.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>DE VORCHIK, DAVID, G</td>
											<td>ONE MICROSOFT WAY REDMOND, WASHINGTON 98052-6399, USA.</td>
										</tr>
										<tr>
											<td>3</td>
											<td>BREZAK, JOHN, E</td>
											<td>ONE MICROSOFT WAY REDMOND, WASHINGTON 98052-6399, USA.</td>
										</tr>
										<tr>
											<td>4</td>
											<td>ZHU, MING</td>
											<td>ONE MICROSOFT WAY REDMOND, WASHINGTON 98052-6399, USA.</td>
										</tr>
										<tr>
											<td>5</td>
											<td>SAMJI, MOHAMMED, A</td>
											<td>ONE MICROSOFT WAY REDMOND, WASHINGTON 98052-6399, USA.</td>
										</tr>
										<tr>
											<td>6</td>
											<td>RAWAT, ANSHUL</td>
											<td>ONE MICROSOFT WAY REDMOND, WASHINGTON 98052-6399, USA.</td>
										</tr>
										<tr>
											<td>7</td>
											<td>GUZAK, CHRIS, J</td>
											<td>ONE MICROSOFT WAY REDMOND, WASHINGTON 98052-6399, USA.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F17/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2005/026858</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-07-28</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>11/096,871</td>
									<td>2005-04-01</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/278334-methods-and-systems-for-communication-between-a-first-component-and-a-second-component by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 22:42:56 GMT -->
</html>
