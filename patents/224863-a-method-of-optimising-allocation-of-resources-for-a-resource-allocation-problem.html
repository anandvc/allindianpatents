<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/224863-a-method-of-optimising-allocation-of-resources-for-a-resource-allocation-problem by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 00:24:35 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 224863:A METHOD OF OPTIMISING ALLOCATION OF RESOURCES FOR A RESOURCE ALLOCATION PROBLEM</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD OF OPTIMISING ALLOCATION OF RESOURCES FOR A RESOURCE ALLOCATION PROBLEM</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>This invention concerns a problem modeling tool for building a model of a problem that involves a plurality of variables, whereby a heuristic search method can be carried out to optimize a solution for the modeled problem, and wherein the model of a problem comprises a plurality of expressions defines as corresponding one or more declarative statements and at least some of the expressions are dependent on at least one of said variables. In embodiments of the invention, the problem modeling tool includes means for ~utomatically updating the, or each, declarative statement in response to changes to the or each variable associated therewith.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>Background<br>
Typically a problem can be dehned by decision variables, an elective function and funct.ona, constraints. Decision variables are used to represent decisions that need to be made, while constraints describe the logical or physical conditions that the decision variab.es must obey. When configuring a system to solve or optimise a problem, these variab,es and constraints are input to the system. For example considering the workforce management problem, a workforce manager may want to know which engineers to schedule to which task, and a corresponding decision vanabJe may include a discrete variable with possible values comprising the different engineers, while the constraints may include the complexity of the tasks invoked skill level of technician, the duration of tasks and travel time etc.<br>
Conventionally/a model of the problem is set up using a digital processor and the model, or problem model, is subject to at least some of the aforementioned constraints. Different solutions to the problem can be obtained by changing decision vanables of the model. For example, in the engineer-scheduling problem, the order in which engineers are scheduled to complete their tasks can be changed and other variables, such as the duration of the day during which they work, can be altered The resulting scheduies can be tested against certain objective values such as the amount of time that individual engineers are idle or are travelling, and a schedule may be chosen on the basis of whichever schedule solution best satisfies the objective values for the solution.<br>
Thus, the problem model can be used to calculate a number of candidate solutions which are then compared on the basis of their corresponding objective values to determine the best solution.<br><br>
It would be possible to compute each possible solution for the range of values of al! of the variables and then search amongst the resulting solutions for a solution which best meets the objective values. This is known as an exact searching method. 5 Sophisticated exact searching methods normally use a tree representation for enumerating all candidate solutions. Relational constraints are used to prune parts of the tree that lead to infeasible solutions, thus reducing the searching effort.<br>
Exact search techniques such as linear programming may be applied to the problem i model. With linear programming methods are applied to complex problems, which have many and disparate types of input variables, a significant data processing overhead is involved. In more sophisticated systems, specialised mechanisms may be devised which, after a change has been made to some of the input variables, restrict the computations to only the affected parts of the problem model. These mechanisms need to be coded for each particular problem requiring expert knowledge from the programmer. Furthermore, they are tedious to implement and maintain for realistic problems, which are of complex nature.<br>
As an alternative to exact search methods, a heuristic search can be' carried out. In a heuristic search method, rather than compute or enumerate each possible candidate solution, an individual candidate solution is taken, and then one or more of the values of the decision variables used in the computation of the candidate solution is changed. A new solution is computed on the basis of the changed variables and a determination is made of whether the newiy computed solution is better than the first. The process may be repeated a number of times until the resulting solution results in optimisation of the objective values.<br>
A number of different heuristic searching techniques are known in the art for optimising the solution for the problem model. For example, in a so-called single solution or local search technique, a first solution is taken and then perturbed to determine whether a better solution can be obtained when processed by the problem model.     In  a  so-called  population  search  technique,   a  number of  solutions   are<br><br>
obtained and a so-called genetic algorithm may be used to combine parts of the solutions into new solutions to be tested with the problem model.<br>
Hitherto, heuristic search methods have been used to optimise solutions to complex, real-world problems involving large numbers of variables. For example, proposals have been made to use heuristic search methods to optimise schedules used in workforce management, where field service engineers may need to perform repair tasks at different locations at different time of the day, according to a schedule. The schedule needs to be optimised as a function of the travel required by the engineers to complete their allocated tasks, the number of tasks left unallocated given the available number of engineers, and delays in task execution, the engineer skills and how well they match to task requirements and other factors such as the urgency of the individual tasks. Heuristic search methods have also been proposed for optimising the scheduling of telephone calls, e.g. incoming calls to operations in a call centre, and also for the allocation of frequency bands for use by radio transmitters e.g. in a cellular mobile telecommunications network.<br>
However, difficulties have been encountered in formulating suitable problem models for use with heuristic search optimisation methods, and an individual problem model usually needs to be specially crafted and set up for a particular problem. Furthermore it has been found that different heuristic searching techniques have different levels of efficiencies for different problem models so that, when a particular problem model has been designed and a particular heuristic search technique associated with it, it is extremely difficult to change the configuration without extensive reprogramming.<br>
The present invention seeks to overcome these difficulties.<br>
Summary of the invention<br>
The invention provides a method of optimising allocation of resources for a resource allocation problem, the problem being defined by problem variables, problem expressions, problem constraints and an objective function to be optimised in accordance   with   a   predetermined   optimisation   criterion,   wherein   the   problem<br><br>
variables are representative of at least some of resources to be allocated, temporal parameters associated with allocation of the resources, tasks to be performed, cosu associated with allocation of resources, capabilities of the resources and capacity of the resources, the problem expressions are representative of relationships between the problem variables, and the problem constraints are representative of constraints placed upon the problem variables.   The method comprises:<br>
i.        building a model of said resource allocation problem in accordance with said problem variables, problem expressions, problem constraints, and objective function, ii.       generating a solution to the modelled problem, the initial solution comprising<br>
a set of values representative of at least some of the problem variables, iii.      applying a change to the solution by modifying one or more values in the<br>
set, iv.      identifying problem expressions directly and/or indirectly dependent on the<br>
modified values, v.       of the dependent problem expressions identified at step (M,<br>
a.	selecting an identified problem expression from the dependent problem<br>
expressions identified at step (iv),<br>
b.	evaluating whether one or more inputs to the selected problem<br>
expression has changed,<br>
c.	if the or each input has not changed, marking the selected problem<br>
expression, and all problem expressions dependent on the said<br>
selected problem expression as unchanged,<br>
d.	selecting the next problem expression identified at step (iv), and<br>
e.	repeating steps (b) - (d) until there are no further problem expressions<br>
to be selected.<br>
The invention also provides a problem modelling tool for building a model of a problem where the problem involves a plurality of variables and a heuristic search method can be carried out to optimise a solution for the modelled problem. The model of a problem comprises a plurality of expressions defined as corresponding one or more declarative statements and at least some of the expressions are dependent on at least one of said variables. The problem modelling tool includes<br><br>
m-ans for automatically updating tne or each ^^ ^^ ^ ^^ changes to the or each variable associated therewith.<br>
By the use of declarative statements ,n accordance with the invention a problem model can  be built in which consents  and objective va,Ues can be declarative* presented   in  the programs,   resulting  in  a  significant  simpiification of  the mode, Furthermore, the declarative statement may be defined using a p,ura,ity of operators including Boolean, arithmetic, logical, string, object and set operators.<br>
The variables comprise dynamic parameters and static parameters. Dynamic parameters include decision variables, which comprise part of the candidate solution to be optimised and are thus modified during the heuristic search method Static parameters include user-specified parameters, which are unchanged by the heuristic search method, e.g. number of resources available.<br>
Each declarative statement used in the problem mode, may be so arranged that a declarative statement based on a first set of variables, representing a first candidate solution, can be modified in response to a second set of variables, corresponding to a second candidate solution, causing update of a second declarative statement -e.g. based on changes to the second set of variables. Declarative statements can therefore themselves be dependent on other declarative statements, and updated in response to changes in other declarative statements. In this way, the processing overhead associated with producing more than one candidate solution for use in a heuristic search method, is significantly reduced.<br>
Preferably, the problem modelling tool further includes a heuristic searching means arranged to perform a heuristic search through candidate solutions for the problem model, in order to search for an optimised solution to the modelled problem. The heuristic searching means conveniently includes a plurality of different heuristic searching parts configured so that the heuristic searching algorithm can be constructed from a selected plurality of the heuristic searching parts. The problem modelling tool additionally includes means adapted to evaluate the candidate solutions in the heuristic search for optimising a solution to the problem.<br><br>
Heuristic searching parts include computer code that can carry out operations such as search methods, where the search methods include local search or population-based search methods. The parts can be joined with one or more other parts to form a heuristic search algorithm.<br>
Preferably the invention further includes a heuristic searching means arranged to perform a heuristic search through candidate solutions for the problem model, to search for an optimised solution to the modelled problem, wherein the heuristic searching means includes a plurality of different heuristic searching parts configured so that the heuristic searching algorithm can be constructed from a selected plurality of the heuristic searching parts.<br>
The invention also includes a method of constructing a model of a problem, making use of the aforesaid modelling tool, and optimising a solution to the problem being modelled. The method of constructing the model comprises defining a plurality of expressions as corresponding one or more declarative statements, where at least some of the expressions are dependent on at least one of said variables and describe at least in part the conditions, constraints and objectives of said problem. The method of optimising a solution comprises constructing a heuristic searching algorithm from a plurality of heuristic searching parts and applying the constructed heuristic search algorithm to the constructed model.<br>
The heuristic searching parts may be defined by object classes stored in a library of parts.<br>
Brief description of the drawings<br>
Further aspects, features and advantages of the present invention will be apparent<br>
from the following description of preferred embodiments of the invention, which are<br>
given by way of example oniy and with reference to the accompanying drawings, in<br>
which:<br>
Figure 1 is a schematic diagram of a processor configuration for running a problem<br>
modelling tool according to the invention;<br><br>
Figure 2 is a schematic diagram of object packages for the problem modelling tool; Figure   3   is   a   schematic   diagram   of   actors   -for   use   in   modelling   a   workforce scheduling problem;<br>
Figure 4 is a schematic flow diagram of process steps performed in carrying out the modelling;<br>
Figure 5 is a schematic diagram of the problem modelling tool and its solution; Figure  6  is  a  schematic   illustration  of  the  invariants  and   input variables  for  a workforce scheduling problem, arranged in invariant blocks; Figure 7 illustrates a mark phase associated with the configuration of Figure 6; Figure 8 illustrates an evaluation phase associated with the configuration of Figure 7; Figure 9 is a schematic illustration of a tree of heuristic searching methods; Figure  10 is an extension  of Figure  2,  and shows a visualisation package and a library of search parts for the problem modelling tool;<br>
Figure 11  is an output of the visualisation package used by the problem modelling tool.-Figure   12a is a further output of the visualisation package  used by the problem modelling tool, before an on-screen modification; and<br>
Figure  12b is a further output of the visualisation  package  used by the problem modelling tool, after an on-screen modification.<br>
Detailed description<br>
In the following description, an example of a modular software modelling tool is described. The software which forms the tool can be run on any suitable data processing apparatus such as the configuration shown in Figure 1, which comprises a conventional workstation or personal computer 1 shown in dotted outline, which, as well known in the art includes a visual display 2, keyboard 3, mouse 4, processor 5, storage in the form of a floppy disc, hard disc or CD/DVD 6, read-only memory 7 random access memory 8, all connected by a common bus 9. The configuration may also include a network connection 10 which may provide a connection to processors at remote locations through a network 1 1.<br>
Programs which make up the software modelling tool may be stored on the storage device 6 and run by the processor 5 under the control of the keyboard 3 and mouse<br><br>
4, so as to provide an output on the display 2. The programs may also be run according to different regimes, for example in a distributed manner through the network 11 or in other configurations evident to those skilled in the art. in the following example, it is assumed that the programs which make up the modelling tool are stored in the storage device 6.<br>
The software tool according to the invention adopts an object oriented approach and is programmed in an object oriented language. In the following example, the Java Programming language is used, although C+ + or other procedural and/or object-oriented languages could be utilised. The tool is configured in object packages as shown in Figure 2. The software includes a package P1 that includes an object class relating to problem modelling, to enable a particular problem to be modelled. Examples include:<br>
a car sequencing problem 12, Which models the constraints for sequencing cars on the same production line, each one with different mechanical and electrical components options to be fitted;<br>
radio frequency allocation problem 13, which models the allocation of frequencies to transmitters for use in a mobile telephone network;<br>
graph colouring problem 14, to model the application of assigning different '    colours to regions of a graphical display; and<br>
a grouping problem 15, which models the partition of a set of persons to groups subject to various constraints and preferences of these persons.<br>
The software modelling tool also includes a package P3 of Invariants. This comprises a library of Invariant object classes which are used for model building as will be explained in more detail hereinafter.<br>
The Invariants in package P3 are declarative expressions that represent problem constraints, conditions and objectives. In declarative programming, or with "declarative languages," the programmer tells the computer what the probiem is and the computer works out how to solve it. Thus users concentrate on defining the input and output rather than the program steps required in a procedural language such as C++, COBOL or Visual Basic. Examples of declarative languages include<br><br>
,uery lavages, report „ritBrs.  interactive database ^^  ^^ application generators.<br><br>
"9<br>
Invariant  constraints   are   essentially   conditions   and   objectives,   the  semantics  of which  are specified  by the  user,   but  the  processing  and   updating  of  which  are handled   by   the   computer.    Importantly,    the   computer    handles   this   update independently  of  any  processing   of  decision  variables  that   are featured  in  thc constraints.  For example consider decision  variables  x,  y,   for  which the problem objective is to minimise abs(x*y). This [abs(x*y)) is an invariant, which is to say that the package of invariants P3  includes a constraint satisfaction algorithm that will ensure abs(x*y) is updated every time x or y change.  For example, package PI, which includes the package of problem modeling code, includes procedural computer code that applies heuristic  search  methods to the decision  variables  x,  y  in an attempt to satisfy a problem objective. This code essentially modifies x and y by applying  changes  to  the  decision  variables  in  accordance   with  a  predetermined procedure defined by the code- Meanwhile, every time a change is made to x and/or y,   problem   objective   abslx'y)   is   automatically   and   independently   updated   by package P3.<br>
A  further package   P5   includes   an  object   class   for  scheduling.     Objects   of  the scheduling package P5 may extend objects of the problem modelling package P1.<br>
The object classes of the scheduling package P5 may be suitable for modelling, for example:<br>
shop job scheduling 1 6 for scheduling the processing of job orders in a shop floor over a number of machines subject to sequencing and other constraints;<br>
routing schedules 17 for vehicles for e.g. package delivery vehicles, and workforce scheduling 18, where individual work schedules are created for a number of technicians to carry out tasks such as repair tasks.<br>
The modelling of a workforce scheduling problem will now be considered in more detail by way of example. Examples of at least some of the problem attributes are shown in Figure 3, and may comprise a number of resources 20, typically comprising<br><br>
field engineers who are required to carry out a number of activities 21, e.g. repair tasks which each have a start time 22 (e.g. leaving the company depot], a tabk description 23, may involve a break 24, and have an end time 25 fe.g, returning to the company depot).<br>
The objective is to produce an activity schedule for the resources 20. For example, the objective may be to derive a schedule, which details times allocated to individual telephone network repair tasks for individual field service engineers, while minimising time that the resources (engineers) spend between jobs. Typically repair tasks are automatically reported by a computer and are allocated individual priorities. These tasks, together with their times and priorities, are input to the problem modelling package P1, which is used to set up a problem model for solving this optimisation problem.<br>
In order to model the scheduling problem, a number of object classes are utilised from the packages PI, P3, P5 shown in Figure 2.<br>
Instances of the following classes may be used.<br>
Class WSP (Workforce Scheduling Problem)<br>
This  class  is  held   in the  scheduling   package   P5   and  extends   an  object   class "Schedule" which in its turn extends the object class Problem found in package P1. In the nomenclature of Java, the class can be expressed as: com.bt.examples, wsp Class WSP Java. lang. Object<br>
i<br>
+ --com.bt.mdf. Problem<br>
+ -com. bt.sch. Schedule<br>
Class JOB<br><br>
This extends an object class Task, which in its turn extends a class Activity found ir&gt; the package P5. In the nomenclature of Java, the class can be expressed as: com.bt.examples, wsp Class Job i    Java.lang.Object<br>
+ -com .bt.sch. Activity<br>
+ -com, bt.sch. Task<br>
Class TECH<br>
This  corresponds to   an  individual  technician  and   inherits  from   an   object  class Resource found in the scheduling package P5. in the nomenclature of Java, the class can be expressed as; com.bt.examples, wsp Class Tech Java. lang. Object<br>
f<br>
+ -corn.bt.sch.Resource<br>
As stated above, objects from the Invariant library package P3 are used to provide declarative programming capabilities within the programming language used to define the problem i.e. the scheduling model. As an example, the object of Activity will be considered in more detail, the object Activity has associated decision variables "previous" and "next". Also, Activity has associated invariants "start time" (st) and "end time" (et). These invariants define the start and end times for a particular Activity (e.g. a job to be carried out by an engineer) for use in solving the scheduling problem.<br>
In accordance with the invention, by using the Invariants defined in the Invariant library package P3, a declarative relationship between the start and end time for successive jobs in the schedule can be defined as follows:<br><br>
St = previous.et + delay<br><br>
(D<br><br>
Thus, the start time for a particular Activity can be defined in terms of the end time of the  previous  activity  time  (s-e.  for  a  previous task)  pius  a  delay  which  may &gt;    correspond to a travel time or a set up time.  The delay time may be a constant i.e. a fixed time period.<br>
Similarly, the end time for the Activity may be defined as follows:<br>
et = st + duration	(2[<br>
AISD, the Activity may be subject to a constraint e.g. must be completed before a particular time e.g. 8 p.m..  This can be expressed as follows:<br>
et
These relationships effectively constitute one-way data flow constraints and can be expressed in the Java programming language using the Invariant relationships from the Invariants package P3.<br>
The Invariant library provides a large number of different declarative functions (operators - listed and described below), which can be used in defining the problem model. The advantage of using invariants is that when multiple solutions are derived from the model, the computing time required to compute the successive solutions, after modifications, is significantly reduced; previously, in Java, it would have been necessary to procedurally define ail of the steps corresponding to the invariants, which would involve significantly more processing time when computing/changing individual solutions to the modelling framework. Furthermore, in formulating complex problem models, the programmer would have had to handle (write code) updating of any variables that depend on other variables, in response to changes in these other variables. This is not required with invariants, as they fully automate this task.<br><br>
Details of some of the classes from the Invariant library are set out below for the package P3, which is named hereinafter as "Inv":<br>
Package com.bt.inv<br>
P3 provides a,, of ,he necessary classes for impiemen.ing .ri.hme.ic and symbolic invariants in Java.<br><br><br><br><br><br><br><br><br>
Equation (3)<br>
BooleanExp ervd_time_constraint = inv.lt(et, 8);<br>
The operator etem returns the i-th element of a vector, where i is an expression cr a variable. In the example above, elem is used to return the end time belonging to the "previous" activity from the vector structure holding the values of all activity end times ef vector. Also the It operator stands for "less than", translating the equation (3) directly into code.<br>
As stated above, the advantage of using invariants is that all expressions are automatically and efficiently updated when an input variable, such ss "previous", changes, thus implementing a declarative programmingparadigm inside a procedural language such as Java.<br>
The invariant package P3 also includes means for handling the updating of variables and for making changes to the problem models. These means are known as interfaces:<br><br><br>
Figure 4  illustrates schematically the steps  involved  in setting  up and  running a problem model, which in this case comprises a work scheduling problem model: At  step  St,   object  classes  are   selected  from  the  scheduling   package   P5   and optionally from the problem modelling package PI depending on the tasks involved. At step S2, objects are created as appropriate for the model concerned e.g. TECH, JOBS, WSP.<br>
Then,  at step  S3 the problem  variables  and  problem  objectives  are defined  in a Solution class object for the model.<br>
Figure 5  is  a  schematic illustration  of  a  problem  model PMT   created  using  the software modelling tool.    It will be understood that in this example, the problem<br><br>
model PM1 represents a workforce scheduling problem. At step S4, solution object 26 (defined at step S3), which contains a specific set of values of decision variables for the model i.e. number of engineers, number of tasks, task sequence for each engineer, type of tasks, task location, is run through the problem model PM I to produce one or more objective values 27 which constitute a measure of the suitability of the candidate Solution 26. The problem model may also provide an output 28 indicative of whether the candidate solution satisfies the various problem constraints.<br>
The running of the program at step S4 firstly involves running a constraint satisfaction algorithm, where changes to decision variables in the current solution object are automatically transferred to the invariants.<br>
This is handled internally by the invariant package P3. Two common one-way constraint satisfaction schemes, which are methods for handling the updating of the constraints, for one-way constraints are the mark/sweep strategy and the topological ordering strategy. If the constraints are evaluated only when their values are requested, the sweep phase is known as a "lazy" evaluator. If all out-of-date constraints are evaluated as soon as the mark phase is complete, the sweep phase is called an "eager" evalustor. It has been found that mark/sweep algorithms have the advantage of being more flexible in supporting both "eager" and "lazy" evaluation modes and because of their simplicity they can be implemented efficiently.<br>
These methods are described in Hudson, S., Incremental Attribute Evaluation: A Flexible Algorithm for Lazy Update, ACM Transactions on Programming Languages and Systems, Vol. 13, No. 3, pp. 315-341, July 1991; and Hoover, R., Incremental Graph Evaluation. PhD thesis, Department of Computer Science, Cornell University, Ithaca, NY, 1987 respectively. A mark/sweep algorithm has two phases: a mark and a sweep phase. In the mark phase, constraints that depend upon a changed variable are marked out-of-date. In the sweep phase, constraints whose values are requested are evaluated and the constraints are marked as up-to-date,<br><br>
The mark phase includes identifying all constraints (problem expressions) that are directly or indirectly dependent on changed variables, and essentially identifies which of the constraints may potentially need to be updated. The sweep phase is essentially a recursive evaluation process, in which, for each of the problem expressions identified in the mark phase, the following steps are carried .out:<br>
1.	the value of the "marked" problem expression is requested,<br>
2.	the inputs to this problem expression, if any, are identified,<br>
3.	the identified inputs are evaluated<br>
The sweep phase is recursive because step 3 essentially involves returning to step 2 for the input itself, and repeating steps 2, 3 until there are no further inputs to the input.<br>
At any stage of the recursive process, when the identified inputs are evaluated, the algorithm identifies whether any of the input values have actually changed. If none of the inputs have changed value, there is no need to evaluate any of the problem expressions that depend on that input. Thus expressions ere only evaluated when, at least one of its inputs has changed value. Preferably this evaluation is incremental, so that, for example, if the problem expression - x1 +x2 + x3 + ... + xn, and the only changed input is x2, the new value of the problem expression is computed from Problem expression^ ~ Problem express!anew - x2ou + x2ne«<br>
The invariant  package P3  includes different incremental update mechanisms lor different operators.<br>
A specific example of mark and sweep strategy will now be described with reference to Figures 6, 7 and 8 in relation to the workforce scheduling problem, Figure 6 illustrates first and second jobs that are carried out in a tour by an engineer, as part of the workforce scheduling problem. Each job is subject to the expressions and the constraint previously described with reference to equations (1) - (3). Thus, one job is characterised by lnv.1 and lnv.2 which correspond to equations 11} and (2) respectively, together with constraint CI which corresponds to equation (3). The job has input variables 11, - 14, in which:<br>
11	= previous.et, namely the end time of the previous job<br>
12	= delay following the end time of the previous job<br><br>
13	= the duration of the job<br>
14	= a deadline by which the job must be completed e.g. 8pm.<br>
The  next job  is  similarly defined  in  terms  of expressions  and  constraints  and  is J     subject to input variables 15 - IS wherein:<br>
15	= the end time (of et?) of the previous job<br>
16	= the deiay following the previous job<br>
17	= duration of the job and<br>
IS  = a deadline by which the job must be completed e.g. 10pm<br>
It will be understood that the end time of the previous jab i.e. the outcome of lnv.2 corresponds to the value of 15, as shown by the dotted arrow. The delay 16 may cj.vaspond to the time taken for the engineer to travel from first job to the second job.<br>
It will also be understood that 15 may not only be an input variable but also a decision variable in order to allow the job to be reordered, if necessary, to achieve a better solution to the problem.<br>
If the jobs are similar, the same invariant block shown in Figure 6 may be replicated many times for each job with each invariant block feeding the next with data. Alternatively, more than one type of job may be included in which case different invariant blocks may be coupled together using the same general methodology. Figure 7 illustrates that mark phase for a single one of the invariant blocks shown in Figure 6, the other block being omitted to simplify the description. In this example, it is assumed that the duration of the job has changed i.e. the value of 13 has altered. During the mark phase, the invariants which will be altered by the change in value of the duration 13, are identified as "influenced" and are marked accordingly. In the schematic illustration of Figure 7, the influenced invariants are shown having a cross-hatched pattern, namely lnv,2 and C1.<br><br>
Figure 8 illustrates the evaluation phase. During the evaluation phase, the influenced invariants identified during mark phase shown in Figure 7, are updated, Only the marked invariants are updated, thereby reducing the processing load.<br>
i The evaluation phase can be started arbitrarily at any of the invariants that have been marked, or the choice may depend upon the invariant properties. Assuming that the process starts at invariant CI, then et needs to be updated first. To update et, the condition lnv.2 needs to be updated using the new value of 13. (Note that if lnv.1 had been influenced by the change to 13, it would also be necessary to backtrack to lnv.1; however, as Invl.l is not marked as being influenced, it is not necessary to go back further). Since the duration 13 has changed, et will also change and becomes "affected" and is marked with a tick in Figure 8. When et gets its new value, the value of C1 is then re-evaluated. The expression eKdeadline may or may not remain true and therefore may or may not be affected according to the specific values of the variables in the problem.<br>
Thus the advantage of this mark and sweep strategy is that only the influenced invariants need to be re-evaluated and of these influenced invariants, not all of them are necessarily affected. For typical changes to the workforce scheduling problem, less than 0.5% of the invariants are influenced and an even smaller number are typically affected, meaning that only a small number of unnecessary evaluations occur. Thus, the computation lime is significantly reduced as compared with a complete re-calculation of the entire model.<br>
Referring back to Figure 4, a Solution object is then tested against problem objectives and problem constraints, and, at step S.5, if, for example, the solution object does not satisfy one or more problem objectives, the solution (decision variables) can be manipulated by a selected heuristic search algorithm. If a change is applied to any of the decision variables {i.e. to the solution object], step S.4 is rerun, so that the effect of the changed decision variable is propagated through corresponding expressions and constraints.<br><br>
The following example illustrates the effect of steps S.4 and S.5: consider a problem having decision variables x, y, an invariant x 
As is disclosed in another of our applications EP01 303274.3, each heuristic search algorithm that is applied to a solution object is built from one or more heuristic search parts. Each heuristic search part is a particular type of heuristic search method; as is known in the art, there are a number of different heuristic search methods and an overview is given below. In general each of these methods is represented by a part in a library of heuristic search parts 1.1, shown schematically in Figure 9.<br>
Local search schemes/methods<br>
A small change is applied to a current solution, so as to move from the current solution to a nearby solution. Local search methods differ in the criteria used to determine whether or not the "nearby" solution then becomes the "current solution". Examples of local search methods include simulated annealing, hill climbing.<br>
A number of different techniques are known to be suitable for implementing and processing a (oca! search method, including<br>
•	Initial solution generation, for generating an initial solution, s,<br>
•	Neighbourhood, a subset of all possible solutions (S), designated N{s), which is   _ associated with each solution s e S,<br>
•	Neighbourhood   search,    which   is    a    search    among   the   solutions    in   the neighbourhood,<br>
•	Aspiration  criterion,  an example of a  criterion  for selecting a solution  in the neighbourhood,<br><br>
•	Move, which contains ail pertinent information necessary for a Neighborhood N(s) to move from a current solution s to a destination solution s',<br>
•	Dynamic objective function, which is a Function to be optimised, e.g. s = m'm{f(s) j s £ S) , where f is an objective function with domain S, the set of possible solutions to a given problem, and s is one solution to the problem.<br>
and others; for more information  refer to E.H.L  Aarts, J.K.  Lenstra.(1 997), Lozal search in combinatorial optimization, John Wiley &amp; Sons, Chichester.<br>
New solutions, generated by applying local search methods, are evaluated through the problem model to identify which solution best satisfies the objective function(s). Referring to the example solution 26 shown in Figure 5, it will be understood that the solution comprises individual values of the decision variables DVarl ...DvarN, such that the attempt to improve the solution involves applying moves to individual values of the decision variables.<br>
Population based schemes/methods (Genetic algorithms)<br>
A population of parent solutions interact with each other to produce a population of child (or offspring) solutions: the selection of parent solutions for interaction is often dependent on the quality of solutions, and the scheme by which they interact (e.g. type of cross-over) is dependent on the problem. !n addition to inter-solution interactions, mutations can be applied to the children. The new population of offspring solutions is then considered as a population of parents for the next iteration of the method. This is repeated many times in search of (a) solutionis) having optimal quality of solution.<br>
A number of different techniques are known to be suitable for implementing and processing a population based techniques, including<br>
•	initial population generation for generating an initial population,<br>
•	crossover for crossing elements of one solution with elements of another,<br>
•	mutation for applying a small change to an existing solution,<br>
•	selection restart population method for re-starting a search method<br>
and others; for further reading refer to D. E. Goldberg.!! 989), Genetic Algorithms in Search, Optimization, and Machine Learning, Addison-Wesley, Reading, MA.<br><br>
As stated above, parts corresponding to these methods are stored in a "library" of. parts L1 and can then be selected when creating a search algorithm so that userc can "plug and play" parts together, enabling creation and testing of wide-ranging types of algorithms in a relatively short time. As a result, even 3 non-expert can easily build a heuristic search algorithm by selecting individual heuristic search parts and combining thern to provide a particular form of a heuristic search algorithm, and the understanding, tuning and comparison of heuristic search algorithms can readily be carried out. An example of a heuristic search algorithm, built using the parts in the parts library, is shown in Figure 6. This is a hybrid algorithm (local search plus population based search) that uses a local method to apply a mutation.<br>
More details of the library of search parts LI, readily available in the form of object classes, are set out in the Appendix.<br>
Invariants and heuristic search parts<br>
Known optimisation methods include tools that apply exact search methods (such as<br>
linear programming methods) to problem models to identify optimum solutions.<br>
As   stated   in  the  introductory   part  of  the description,   relational  constraints  are<br>
particularly well suited to exact search methods, where the main goal is a reduction<br>
in   the   search   space  to   be  explored,   since  relational   constraints  can   propagate<br>
reductions in the domain of one decision variable to the domain of other decision<br>
variables, thereby efficiently reducing the number of feasible alternatives.<br>
However,  relational  constraints  are  not well suited  to  Heuristic  search  methods<br>
because relational constraints carry much unnecessary functionality for the task (e.g.<br>
domains,        multi-way	propagation,	etc.!	resulting	in	sub-optimal<br>
performances/implementations for the applications in question.<br>
Heuristic search techniques require an efficient way to access the impact of incremental solution changes to the problem's constraints (i.e. constraint checks) and also the value of the objective function. Invariants are particularly adept at this task since they can incorporate specialized incremental update mechanisms for the different operators applied to solutions, in addition to the general algorithms available<br><br>
for restricting the parts of the constraint graph that need to  be updated after a change in the input variables (decision variables in this case).<br>
In particular, the modular aspects of the heuristic search parts are particularly well suited to invariants. The library of search parts LI preferably includes detector parts that plug into search parts and listen for results of applying moves and changing decision variables, and then act on the results. As described above, invariants provide automatic updating of all of the decision variables, so that the detector parts can react in real-time to changes applied by heuristic search parts. Because each heuristic search algorithm comprises a plurality of search parts plugged together, detectors can be plugged into any level of the algorithm, thereby providing a facility for reacting at a much finer scale than with other optimisation systems. Advantages include being able to evaluate and stop the algorithm at any part-to-part boundary in the algorithm rather than having to progress through the whole algorithm before evaluating it.<br>
interactive visualisation tool<br>
Embodiments of the invention optionally include a visualisation package P7, shown in Figure 10, which includes various visualisation object classes - e.g. object classes to invoke a Gantt chart 31, a capacity chart 32 and a map chart 33 - and a means 34 for connecting the visualisation objects to a problem model. A Gantt chart is a horizontal bar chart developed as a production control tool and is fully described in "A Professional's Guide to Systems Analysis", Martin E. Modell, 2nd. Ed. McGraw Hill, 1996. Capacity and map charts are problem specific visualisation applications, that are used to display vehicle capacity and routes relating to vehicle scheduling. For a specific problem model, the means 34 connects these applications into parts of the invariant class (via the Transaction interface class described above), so that the solution 26 can be visualised by a user. Figure 8 shows a Gantt chart plugged into a vehicle scheduling problem,  where allocation of vehicles, with respect to time, is visualised. In the vehicle scheduling problem the decision variables comprising the solution 26 include time allocated to task, inter-job route and travel time, and task duration.<br><br>
The following illustrates how a Gantt chart object can be configured to receive and display updates to decision variables (e.g. to allow a user to watch changes made b1* heuristic search algorithms):<br>
This class represents a task entry in the Gantt Chart, public class TaskEntry implements Java.util.Observer {<br>
Task t; //1 is the task as defined in the problem model<br>
Connect the TaskEntry with the underlying Task Object used to request receipt of notifications from the problem model relating to the task for specific invariants, e.g. startTime and endTime, so that visualization object knows where to display the task in a task timeline.<br><br>
TaskEntry object denoted by this is added as an observer of the startTime and endTime invariants, so that a TaskEntry object registers interest with the startTime and endTime invariants (startTime and endTime are invariants as defined in Equations 1 and 2).<br>
By virtue of the TaskEntry object registering interest with the startTime and endTime invariants, the following "update" method is invoked when the value of any of the above invariants changes: public void update(){<br><br>
Thus suppose that the StartTime and the EndTime changed, this method will set its startUnit and endUnit to the new values obtained straight from the problem model. (setStariUnitO and setEndUnitQ additionally contain code manipulating the graphics displayed on the screen and the in particular the portion of the Gantt Chart affected. Suitable code could readily be written by one skilled in the art).<br><br>
In addition to visualising the decision variables comprising the solution 26, the applications can receive inputs from the user, and pass these inputs to the invariants via the connecting means 34. For example, considering the Gantt chart visualisation of the vehicle scheduling problem shown in Figure 11, the user can drag and drop, in a known manner, tasks anywhere within the Gantt chart. As the Gantt chart object is plugged into the problem model via connecting means 34, movement of tasks by the user has the effect of changing the corresponding decision variables. In effect, these changes are handled in an identical manner to the handling of a heuristic search method, so that changes to decision variables are received by the InvariantManager class and propagated through the constraint satisfaction algorithm as described above.<br>
An example of the control aspect, which defines how the user manually interacts with the Gantt Chart, is given below. In this example, the code that checks whether a task entry can be dragged and dropped from one part of the Gantt Chart to another - i.e. Package P7 includes a method called isGaadDrapfl for checking whether a drop action is allowed or not. The code below includes excerpts from code that assesses the validity of user action - e.g. dropping a task:<br><br><br>
Package P7 also includes code for handling validated dropping of a task to another, or to the same, resource (when the drop has been validated as described above):<br><br>
Figures 12a and 12b respectively show "before" and "after" making a change in task allocation by dragging a task from vehicle 10 and dropping it on vehicle 11. Referring to Figures 12a and 1 2b, the InvariantManager propagates changes to corresponding decision variables, updating the constraints and problem objectives, and automatically adjusts the required travel times between tasks, as can be seen from the changes to the thick lines.<br><br><br>
   WECLAIM:<br>
!.	A method of optimising allocation of resources  for a resource allocation<br>
problem, the problem being defined by problem variables, problem expressions, problem constraints and an objective function to be optimised in accordance with a predetermined optimisation criterion,<br>
wherein the problem variables are representative of at least some of resources to be allocated, temporal parameters associated with allocation of the resources, tasks to be performed, costs associated with allocation of resources, capabilities of the resources and capacity of the resources,<br>
wherein the problem expressions are representative of relationships between the problem variables,<br>
wherein the problem constraints are representative of constraints placed upon the problem variables, and<br>
wherein said problem variables, problem expressions, problem constraints and objective function are stored on a memory, the method being carried out by a data processor and comprising the steps of:<br>
(i)      building a model of said resource allocation problem in accordance with said<br>
problem  variables,    problem    expressions,    problem    constraints,    and  objective<br>
function and storing said model in said memory,<br>
(ii) generating a solution to the modelled problem and storing said solution in said<br>
memory, the solution comprising a set of values representative of at least some of the<br>
problem variables,<br>
(iii)     applying a change to the generated solution by modifying one or more<br>
values in the set,<br>
(iv)        identifying problem expressions directly and/or indirectly dependent on the<br>
modified values,<br><br>
(v)    of the dependent problem expressions identified at step (iv),<br>
(a)	selecting an identified problem expression from the dependent problem<br>
expressions identified at step (iv),<br>
(b)	evaluating whether one or more inputs to the selected problem expression has<br>
.changed,<br>
(c)	if the or each input has not changed, marking the selected problem expression, and all problem expressions dependent on the said selected problem expression as unchanged,<br>
(d)	selecting the next problem expression identified at step (iv), and<br>
(e)	(«) repeating steps (b) - (d) until there are no further problem expressions to be selected; (vi)	generating a further solution to the modelled problem in accordance with the modified one or more values in the set applied in step (iii) and the problem expressions identified in step (iv);<br>
(viii) determining whether the generated further solution better satisfies the objective function and if so, setting the generated further solution as the solution to be modified in step (iii);<br>
(vii)       repeating steps (iii) to (vi) until a predetermined number of solutions have been generated;<br>
(ix) outputting the solution which best satisfies the objective function as a solution to the modelled problem.<br>
2.	A method  according to claim   1, wherein,  if the input has changed, the<br>
method comprises evaluating the selected problem expression and evaluating all problem expressions directly and indirectly dependent on said selected problem<br>
expression.<br>
3.	. A method according to claim 2, wherein the method comprises<br>
assessing whether  the  objective  function satisfies the  predetermined optimisation<br><br>
criterion as a result of the change applied at step (iii), and, if not, repeating step (iii) until the objective function is deemed to satisfy the predetermined optimisation criterion.<br>
4.	A method according to claim 2 or claim 3, wherein evaluating whether an<br>
input to the selected problem expression has changed comprises recursively<br>
identifying and evaluating inputs to the input.<br>
5.	A method according to any one of claims 2 to 4, wherein evaluation of the<br>
selected problem expression comprises the steps of:<br>
i.        calculating a difference between the value of the changed input before and after<br>
the change, and ii.       ii. adding the difference to the or each problem expressions dependent thereon.<br>
6.	A method of constructing a model of a problem that involves a plurality of<br>
variables, the problem being definable by predetermined conditions, constraints and<br>
objectives, the method being carried out by a data processor and comprising the step<br>
of:<br>
defining a plurality of expressions as corresponding one or more declarative statements, wherein at least some of the expressions are dependent on at least one of said variables and describe at least in part the conditions, constraints and objectives of said problem.<br>
7.	A method according to claim 6, in which the, or each, declarative statement is<br>
defined using one of a plurality of operators.<br><br>
8.	A method of optimising a model of a problem constructed according to claim 6<br>
or claim 7, comprising the step of constructing a heuristic searching algorithm from a plurality of heuristic searching parts and applying the constructed heuristic search algorithm to the constructed model in order to optimise a solution for the modelled<br>
problem.<br><br><br><br><br><br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIGFic3RyYWN0LmpwZw==" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 abstract.jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIGFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIGNsYWltcy1kdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 claims-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIGNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIGNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIGNvcnJlc3BvbmRlbmNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIGRlc2NyaXB0aW9uIChjb21wbGV0ZSktZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 description (complete)-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIGRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIGRyYXdpbmdzLWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 drawings-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIGRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIGZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIGZvcm0tMTgucGRm" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIGZvcm0tMjYucGRm" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIGZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIGZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIG90aGplcnMucGRm" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 othjers.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIHBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 pct.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA1NC1jaGVucC0yMDAzIHBldGl0aW9uLnBkZg==" target="_blank" style="word-wrap:break-word;">1054-chenp-2003 petition.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="224862-lubricating-oil-composition-comprising-ss-dithiophosphorylated-propionioc-acid-triaryl-phosphate-and-base-oil.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="224864-system-for-online-purchasing.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>224863</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1054/CHENP/2003</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>49/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>05-Dec-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>23-Oct-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>08-Jul-2003</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>BRITISH TELECOMMUNICATIONS PUBLIC LIMITED COMPANY</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>81 NEWGATE STREET, LONDON EC1A 7AJ,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>DORNE, RAPHAEL</td>
											<td>25 NAVARRE STREET, IPSWICH, SUFFOLK IP1 3JD,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>VOUDOURIS, CHRISTOS</td>
											<td>25 ICKWORTH CRESCENT, RUSHMERE ST. ANDREW, IPSWICH, SUFFOLK IP4 DPQ,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06N5/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/GB02/00051</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2002-01-08</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>01300150.8</td>
									<td>2001-01-09</td>
								    <td>U.K.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>0111725.8</td>
									<td>2001-05-14</td>
								    <td>U.K.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/224863-a-method-of-optimising-allocation-of-resources-for-a-resource-allocation-problem by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 00:24:36 GMT -->
</html>
