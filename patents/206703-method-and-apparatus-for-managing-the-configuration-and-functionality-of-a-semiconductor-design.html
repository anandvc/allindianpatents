<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/206703-method-and-apparatus-for-managing-the-configuration-and-functionality-of-a-semiconductor-design by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:53:55 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 206703:METHOD AND APPARATUS FOR MANAGING THE CONFIGURATION AND FUNCTIONALITY OF A SEMICONDUCTOR DESIGN</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD AND APPARATUS FOR MANAGING THE CONFIGURATION AND FUNCTIONALITY OF A SEMICONDUCTOR DESIGN</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method of managing the configuration, design parameters and functionality of an Integrated circuit (IC) design using a hardware description language (HDL). Instructions can be added, subtracted, or generated by the designer Interactively during the design process, and customized HDL descriptions of the IC design are generated through the use of scripts based on the user-edited instruction set and Inputs. The customized HDL description can then be used as the basis for generating &quot; make-files&quot; for purposes of simulation and/or logic level synthesis. The method further affords the ability to generate an HDL model of a complete device, such as a microprocessor or DSP. A computer program implementing the aforementioned method and a hardware system for running the computer program are also disclosed.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br><br><br>
METHOD AND APPARATUS FOR MANAGING THE CONFIGURATION AND FUNCTIONALITY OF A SEMICONDUCTOR DESIGN<br>
Background of the Invention,<br>
The present application claims priority to U.S. Provisional Patent Application Serial Number 60/104,271, entrtted "Method and Apparatus for Managing the Configuration and Functionality of a Semiconductor Oesign" filed October 14. 1998.<br>
1.	Feild of the Invention<br>
The invention relates generally to the fiefd of semiconductor design and layout and computer automated design (CAD) for semiconductors. More specifically, the invention provides a method for managing the configuration, design parameters, and functionality of an integrated circuit design in which custom instructions and other elements may be arbitrarily controlled fay the designer.<br>
2.	Description of Related Technology<br>
Several types of computer aided design (CAD) tools are available to design and fabricate integrated circuits (IC). Such computer-aided or automated IC design tools can include modules or programs addressing both the synthesis and optimization processes. Synthesis is generally defined as an automatic method of converting a higher level of abstraction to a lower level of abstraction, and can include any desired combination of synthesis techniques which occur at various levels of abstraction. So-called "behavioral synthesis' is a design tool wherein the behavior (eg. inputs, outputs,- and functionality) of a desired IC are entered into a computer program to design a device that exhibits the desired behavior. Such tools permit IC designers to produce increasingly complex and capable devices, sometimes having logic gate counts in the tens of millions, with few or no errors and in a much shorter time period than would be otherwise possible with manual design techniques such as hand layouts.<br>
Examples of synthesis processes which involve different levels of abstraction include architectural level synthesis and logic level synthesis, both of which may be incorporated into the IC design process.<br>
Architectural level synthesis is primarily concerned with the macroscopic structure of the circuit it utilizes functional blocks (including information relating to their interconnections and internal functionality). Architectural level synthesis includes register transfer level (RTL) synthesis, which can have multi-bit components such as registers and operators.<br>
Logic level synthesis, on the other hand, is concerned with gate (evel design. Logic level synthesis determines a microscopic structure of a circuit and transforms a logic model into an interconnection of instances of library ceils. The result of the logic level synthesis is a netlist of logic devices and their interconnections. Logic-level synthesizers (so-called synthesis "engines') are available from several commercial vendors.<br>
The synthesis process generally begins with the designer compiling a set of IC specifications based on the desired functionakty of the target device. These specifications are then encoded in a hardware description language (HDL) such as VHDL* (VHS1C hardware description language) available from IEEE of New York, NY, or Verilog® available from Cadence Design Systems, Inc. of Santa Clara, CA. The specifications define an IC m terms of the desired inputs<br>
1-<br><br>
and outputs, as wail as desired functionality such as available memory or dock speed. From the HOL. the designer then generates a "nethst" including a list of gates and their interconnections, which is descriptive of the circuitry of the desired IC. Ultimately, the design is compiled and masks fabricated for producing the physical IC. Figure 1 illustrates a typical prior art IC design and fabrication approach.<br>
Unfortunately, white well suited for simpler devices and single components, the aforementioned prior art approaches to automated IC design suffer several limitations, especially when applied to the design of more complex ICS such as CPU-based processors. These problems stem largely from the requirement that the instruction set be fixed prior to, and not modifiable during, the design and synthesis processes, thereby reducing the flexibility and capability afforded the designer both during and after the design process. These problems are highlighted by the practice of supplying predefined CPU designs to users desiring to integrate a processor into their systems Integrated Circuit design. Specifically, by not being able to consider certain instructions, functions, or components in the design during synthesis, the designer ts required to attempt to "badcfrt" these elements to the design, which often times creates compatibility issues or other problems. This disability also effectively precludes optvnizatton of the design far certain parameters (such as die size or clock speed) since the resulting design necessarily has a higher gate count, and does not have the benefit of customized instructions specific to the desired architecture and functionality. Furthermore, such prior art systems are incapable of automatically assembling a HDL model of the complete processor and simulating its operation, an approach which can greatly increase the efficiency and effectiveness of the design process.<br>
Based on the foregoing, an improved method (and associated apparatus) is needed for managing the configuration, design parameters, and functionality of an integrated circuit design in which the instruction set can be interactively varied by the user. Specifically, such an improved method would permit the user to add or subtract existing instructions, as wel as generate new instructions specifically adapted for use with the design, while retaining the ability to verify the accuracy and correctness of the VHDL model and the subsequent synthesized logic or layout. Additionally, the improved method would allow the user to generate descriptive models of the complete processor as opposed to just individual logic circuits or modules, thereby further enhancing the simulation and synthesis processes, furthermore, the user could automatically or interactively select various design parameters (such as the existence of a memory interface or peripheral component) during the design and synthesis processes to preclude having to retrofit or modify the design at a lator time. This latter ability would greatly enhance the integration of such components into the design, thereby effectively eliminating incompatibilities, and reducing the resulting IC to its smallest possible dimension, clock speed, and power consumption, with the least amount of effort and cost.<br>
Summary of the Invention<br>
The present invention satisfies the aforementioned needs by providing an automated means of managing the configuration, design parameters, and functionality of an integrated circuit design, through the use of an interactive computer program.<br>
In a first aspect of the invention, an improved method for managing the configuration, design parameters, and functionafity of an integrated circuit design is disclosed. In one embodiment of the disclosed method, the user inputs<br>
-2-<br><br>
information relating to the design hierarchy and HDL library files, and generates i computer program scnpt based on these inputs. Custom instructions and other elements (such as special-purpose registers, new condition code choices, local scratchpad RAM, or " library of multimedia extensions for 30 or DSP applications) may be arbitranly added to the existing -HOI instruction set by the designer as well during the design process. Unlike adding an external ASIC or other component post-synthesis, these instructions become included within the processor instruction and register set so as to eliminate integration problems, and allow maximal optimization based on one or more selected attributes. Ultimately, the generated script is run, and a customized HDL model of the IC is produced based on the user-defined instruction set. This customized HDL model is then used at the basis for further simulation andlor synthesis as desired fay the designer. This method further affords the designer the ability to generate an HDL model of the entire IC, thereby greatly enhancing the efficiency of the design process. This ability is especially useful for complex CPU- based processor designs, although it may readily be applied to other types of components.<br>
In a second aspect of the invention, the aforementioned method is further embodied in a menu-driven computer program which may be used in conjunction with a microcomputer or other similar device for designing and managing the configuration of integrated circuits. In one exemplary embodiment, this menu-driven computer program comprises a series of routines or "modules" which perform various sets or groups of related functions. An interactive architecture module gathers information about the designer's system, available libraries, and the design configuration to be generated. A hierarchy generation module assists in ordering logical blocks or entities and routing signals within the design, as well as ultimately generating a netfist. An HDL generation module generates a merged HDL file descriptive of the design. In the exemplary embodiment, these modules are connected together via computer programs scripts or user initiated execution of the individual modules. In yet another embodiment these modules may also be compiled into one comprehensive program, and bundled with other software tools that facilitate rapid and integrated design of the subject 1C on a standard microcomputer.<br>
In a third aspect of the invention, an apparatus for generating, simulating, and/or synthesizing an integrated circuit design using the aforementioned method is disclosed. In a first embodiment, a microcomputer having a microprocessor, display, and input device is used to run the previously described menu-driven computer program, thereby allowing the designer to interact with the program during the design, simulation, end/or synthesis processes. The microcomputer further includes i storage device and network interface to allow for the storage, retrieval, and sharing of information between two or more microcomputers configured with the aforemantioned computer program.<br>
In a fourth aspect of the invention, an integrated circuit design depicted in a hardware description language and synthesized using the aforementioned method of the invention is disclosed.<br>
In a fifth aspect of the invention, an integrated circuit fabricated using the aforementioned synthesized design is disclosed. In one exemplary embodiment, the integrated circuit comprises a reduced instruction set CPU (RISC) processor.<br>
In a sixth aspect of the invention, s data storage device adapted for use with a computer system and comprising in part the aforementioned computer program is disclosed.<br>
-3-<br><br>
Brief Description Accompanying Drawings<br>
figure 1 b a flow diagram illustrating a typtcal prior art integrated circuit design and synthesis method.<br>
Figure 2 is a flow diagram iustrating the general integrated circuit design and synthest* method of the invention.<br>
Figure 2a is a flow diagram illustrating one specific embodiment of the generalized method of Figure 2.<br>
Figures 3a-3e collectively comprise a logical flow diagram illustrating one exemplary embodiment of the architecture module of the invention.<br>
Figure 4na logical flow diagram illustrating one exemplary embodiment of the method of determining the memory and register configuration of the system under design as shown generally in figure 3c herein.<br>
Figures 5a-5h collectively comprise a logical flow diagram illustrating one exemplary embodiment of the method of configuring file extensions as shown generally in figure 3c herein.<br>
Figure 6 is a logical flow diagram illustrating one exemplary embodiment of the method of setting up the cache structure as shown generally in Figures 5b, 5c, and 5d herein.<br>
Figure 7 is a logical flow diagram illustrating one exemplary embodiment of the method of setting up the load/store interface structure as shown generally in figure 5d herein.<br>
Figure 8 is a logical flow diagram filustrating one exemplary embodiment of the method of setting up the register transfer language (RTU link structure as shown generally in figure 3d herein.<br>
Figure 9 is a logical flow diagram illustrating one exemplary embodiment of the method of generating a new script according to the invention.<br>
Figure 10 is a logical flow diagram of one exemplary embodiment'of the method of building a libraries list as shown generally in Figure 9.<br>
Figure 11 is a logical flow diagram of one exemplary embodiment of the method of adding the libraries list to the' system "mtlcefifa" as shown generally in Figure 9.<br>
Figure 12 is a logical flow diagram of one exemplary embodiment of tha method of adding datafile dependency rules to tha system "makefile" as shown generally in Figure 9.<br>
figure 13 is a topical flowchart illustrating one exemplary embodiment of the method of hierarchy file generation according to tha invention.<br>
Figure 14 is 8 logical flowchart iustrating one exemplary embodiment of the method of reading input files in accordance with the hierarchy file generation method of Figure 13.<br>
Figure 15 is a logical flowchart illustrating one exemplary embodiment of the method of reading hierarchy files as shown generally in  Figure 14.<br>
Figure 16 is a logical flowchart Bustrating on ixempJary embodiment of the method of reading top level entity data   files as shown generally in Figure 14.<br>
figure 17 b a logical flowchart illustrating one exemplary embodiment of the method of reading primary block data files as shown genenlv in Figure 14.<br>
4-<br><br>
Figure 18 is a logical flowchart lustraong one exemplary embodiment of the method of identifying and integrating now signals into the block data files as shown generally in Figure 17.<br>
figure 19 is a logical flowchart illustrating one exemplary ombodimant of the method of verifying data integrity as shown generally n Rgura 13.<br>
Figure 20 is a logical flowchart illustrating one exemplary embodiment of tha method of adjusting signal types relative to the block data files as shown generally in Figure 13.<br>
Figure 21 is a logical flowchart illustrating one exemplary embodiment of the method of checking for in or "out" signals as shown generally in figure 20.<br>
Figure 22 is a logical flowchart illustrating one exemplary embodiment of the method of generating The merged hardware description language (HDL} file according to the invention.<br>
Figure 23 is a logical flowchart illustrating one exemplary embodiment of the method of reading the HDL control file as shown generally m Figure 22.<br>
Figure 24 is a logical flowchart illustrating one exemplary embodiment of the method of reading tha HDL top level entity data file as shown generally in figure 22.<br>
Figure 25 is a logical flowchart illusstrating one exemplary embodiment of the method of reading the HDL dependency data file as shown generally in Figure 22.<br>
Figure 26 is a logical flowchart illustrating one exemplary embodiment of the method of processing the signal record as shown generally in Figure 25.<br>
Figure 27 is a logical flowchart illustrating one exemplary embodiment of the method of processing the signal list into groups as shown generally in Figure 22.<br>
Figure 28 is a logical flowchart illustrating, one exemplary embodiment of the method of verifying data integrity as shown generally in Figure 2Z<br>
Figure 29 is a logical flowchart illustrating one exemplary embodiment of the method of reading tha library file as shown generally in Figure 22.<br>
Figure 30 is a logical flowchart illustrating one exemplary embodiment of the method of writing the HDL file as shown generally in Figure 22.<br>
Figure 31 is a perspective view of sne exemplary embodiment of an integrated circuit design apparatus according<br>
to the invention.<br>
Figure 32 is a top plan view Ilustrating the layout of one exemplary embodiment of a processor-based integrated<br>
circuit designed using the method of the invention.<br>
Detailed Description of the Invention<br>
Reference is now made to the drawings wherein like numerals refer to like parts throughout.<br>
As used herein, the turn "computer program.' "routine," "subroutine," and "algorithm" are essentially synonymous, with "computer program" being used typically (but not exclusively) to describe collections or groups of<br>
5<br><br>
the latter three elements. In general, however, all of the aforementioned terms as used herein are meant to encompass any series of logical steps performed in a sequence to accomplish a given purpose.<br>
Also, white the following description relates explicitly to the VHDL environment, it can be appreciated that the genera) principles and functionality of the present invention may be embodied in other description language environments including, for example, Verilog®. Background of "ARC ""<br>
In the following discussion, the term "ARC"" (ARC RISC Care) refers to a microprocessor-like central processing unit (CPU) architecture. While the method of present invention can be applied to other types of integrated circuits including, for example, application specific integrated circuits (ASICs ) and field-programmable gate arrays (FPGAs), the microprocessor-like CPU design is chosen to more clearly illustrate the operation and capability of the invention.<br>
As discussed in greater detail below, the present invention takes in one embodiment the form of a computer program having a synthasizable and customizable (i.e., "soft") macro with a complementary suite of software tools for configuration and hardware-software co-design. This computer program employs the concept of a "system builder" to accomplish much of the desired functionality. In the present context, the ARC system builder refers to that portion or module of the computer program whereby the designer controls the generation of the subject CPU design. In one particular embodiment, the system builder directs the assembly of a series of predefined VHDL based designs along - with design elements created by the user (also in VHDL, or whatever other description language is chosen] to produce a raw, custom CPU specific to the user's specifications and needs. Hence, the system builder controls the creation and testing of HDL-based synthesizable CPUs. This approach further provides users with a great deal of flexibility in configuring the specific attributes of the resulting CPU.<br>
The ARC System builder is embodied in a series of "scripts' that allows users to build customiied ARC systems along with support files for both design simulation and synthesis. A script is more specifically a computer program, often written in a special computer programming language designed for tha purpose. Such script languages include for example tha "pert" and language commonly employed in UNIX based computer systems as a "scripting language." There are other languages available to write scripts compatible with the present invention. It is noted that for the purposes of the present discussion, the term "scripts* refers to any series of logical instructions or actions of a computer program which are executed in a predefined order.<br>
When executed, the ARC system builder script produces a series of questions, answered primarily through menus (as illustrated in greater detail below in the exemplary menu structure of Appendix I), the answers to which are used to build the VHDL simulator and synthesis files. An installation script allows several different ARC features to be selected, such as processor cacha size and cache line length, size of external memory space to be cached, and clock period/skew. The script creates a working directory for the user, and further generates various VHDL files necessary to support further customized VHOL development<br>
-6-<br><br>
The term "makefile" as used herein refers to the commonly used UNIX makefile function or similar function of a computer system well known to those of skill in the computer programming arts. The makefile function causes other programs or algorithms resident in the computer system to be executed in the specified order. In addition, it further specifies the names or locations of data files and other information necessary to the successful operation of the specified programs. It is noted, however, that the invention disclosed herein may utilize file structures other than the 'makelife" type to produce the desired functionality.<br>
Central to the method of the invention is the concept that one computer program may write another program, which is subsequently executed by the computer system. For example, am script may write a second script that is tailored by user input to perform a specific task. The task is then performed when the second script is executed. This "dynamic scripting" is employed in various aspects of the invention, as further described herein. Detailed Description of Method<br>
Referring now to Figure 2, one embodiment of the generalized method of the invention is described. While this description is presented in terms of an algorithm or computer program running on a microcomputer or other similar processing device, it can be appreciated that other hardware environments (including minicomputers, workstations, networked computers, "supercomputers", and mainframes) may be used to practice the method 100. Additionally, one or more portions of the computer program may be embodied in hardware or firmware as opposed to software if desired, such alternate embodiments being well within the skill of the computer artisan.<br>
Initially, the hierarchy file specific to the processor design under consideration is edited in the first step 102. Specificaliy, desired modules or functions for the design are selected by the user, and instructions relating to the design are added, subtracted, or generated as necessary. For example, in signal processing applications, it is often advantageous for CPUs to include a single 'multiply and accumulate" (MAC) instruction. This instruction commonly improves system performance and reduces the amount of computer code required to perform signal processing tasks; two desirable characteristics in such systems. Conversely, applications that are essentially logical control oriented in nature have little or no need for such an instruction. Eliminating the instruction from a purpose-built CPU reduces the CPU die size and gate count, also a generally preferred advantage. In still another case, an instruction that is only of value to one specific application may be defined and implemented by designers. In all of these examples, the present invention permits designers a greater degree of control over the CPU design and more flexibility in making design tradeoffs and optimizations.<br>
It should also be recognized that when using the system builder of the present embodiment in its most common mode, the hierarchy of design is determined by the script, and a "hierarchy builder" is called by the script builder.<br>
In step 104 of the method of Figure 2, the technology library location for each VHDL file is defined by the user. The technology library files in the present invention ston all of the information related to cells necessary for the synthesis process, including for example logical function, nputfoutput timing, and any associated constraints. In the present invention, each user can define his/her own library name and location(s), thereby adding further flexibility.<br>
-7-<br><br>
A makefile is then generated tn the third step 106 using the hierarchy file information, library information previously described, as well as additional user input information relating to the desired configuration and attributes of the device. For example, in the ARC system builder, the user is asked to input the type of "build" (e.g., overall device or system configuration), width of the external memory system data bus, different types of extensions, cache type/sue, etc., as described in additional detail below with respect to figures 3a-3e. It will be recognized that such user input may be in the form of an interactive software prompt, or alternatively may occur using command line parameters, by accessing a pre-buirt configuration file, or a concurrently running application or other computer program resident on the designer's system or another system linked thereto. Many other methods of input are also possible, ail of which are considered to be Within the scope of the invention.<br>
Next, the makefile generated in the third step 106 is run in a fourth step 108 to create a customized VHDL model. As part of this step, the user is presented with a variety of optional response menus and prompts to further define the VHDL model based on his/her desired attributes.<br>
At this point in the program, a decision is made whether to synthesize or simulate the design (step 110). If simulation is chosen, a separate script ("MTI make' in the present embodiment) is run in step 112 to generate a separate simulation makefile for use in the simulation. Simulation scripts and makefiles are generally well known to those of ordinary skill in the art, and accordingly will not be discussed further herein. Alternatively, if synthesis is chosen, the synthesis scriptls) (e.(j., "synopsys_make") are run m step 114 to generate corresponding synthesis makefiles. After completion of the synthesis/simulation scripts, the adequacy of the design is evaluated in step 116. For example, a synthesis engine may create a specific physical layout of the design that meets the performance criteria of the overall design process yet does not meet the die size requirements. In this case, the designer will make changes to the control fPes, libraries, or other dements that can affect the die size. The resulting set of design information is then used to re-ran the synthesis script<br>
Note that there are marry different criteria that may be used to determine whether or not a design is acceptable. In general, each design will have a different set of criteria used to determine the acceptability of the final design. Die size, sower consumption, clock speed, and numerous other factors may constitute alone or collectively design constraints or targets. This great variability in acceptance criteria is one factor that demands the flexibility of the present invention.<br>
If tha generated design is acceptable, the design process is completed. If the design is not acceptable, the process steps beginning with step 102 are re-performed until an acceptable design is achieved. In this fashion, the method 100 is iterative. Note that if the simulation path 112 is chosen in order to simulate the operation of the generated design, the user may subsequently run the synthesis scripts per step 114 (dotted line in Figure 2) if desired to synthesize the logical design into a physical structure.<br>
Appendix I tttustrates the operation of an algorithm utilizing the method of Figure 2. In Appendix I, several explicit examples illustrating various menu structures, design considerations, and user input options are presented.<br>
-8<br><br>
Note that thus examples are merely illustrative of the general process performed by the user in practicing the method of the present invention using the VHDL software embodiment set forth herein.<br>
Appendix II is a list of the VHDL script files used in conjunction with the VHDL embodiment of the algorithm of the present invention.<br>
It is noted that while the source code for the embodiment of the computer program set forth herein is written using AWK, a programming language commonly found on UNIX workstations, but also available on other personal computers, the program may be embodied using any of a number of different programming languages such as, for example, C*\ The source code directed to the exemplary AWK embodiment of the invention described herein is set forth in Applicant's aforementioned Provisional U.S. Patent Application number 60/104,271, which is incorporated herein by reference in its entirety.<br>
Referring now to Figure 2a, one specific embodiment of the general method of Figure 2 is described. In this embodiment, certain steps of the method depicted in Figure 2 are separated into constituent parts for illustration purposes. For example, step 102 of Figure 2 is separated into an interactive ("Wizard™") component and a hierarchy generator ("hiergen") component (not shown) The interactive component of step 102 provides substantially all of the direct user interaction control Through a series of questions answered by the user, the program selects the relevant design elements necessary to realize the user's design. Portions of this information are used by the hierarchy generator to create a makefile script that is executed to build the HDL hierarchy.<br>
Similarly, the step 104 of defining the library location for each VHDL file in Figure 2 corresponds to the steps of (i) creating a working directory 204, (ft copying files from a master database 205, and merging the selected extension VHDL modules into placeholder files 208. The remainder of method 100 depicted in Figure 2a generally parallels that of Figure 2.<br>
It will be appreciated by one skilled in the relevant art that there are a large number of alternative partitionings or structures of the flowchart of Figure 2, each of which results in the same or similar sets of scripts, makefiles, and other design data for a given set of input data. Further, it may be advantageous for additional data or partitiomngs to be selected in order to utilize commonly available tools for executing portions of the method 100. Also, the order of performance of several of the individual steps present in the method of Figure 2 (and Figure 2a) may be permuted without departing from the invention as disclosed herein.<br>
Referring now to Figures 3a-3e. one embodiment of the architecture functionality of the invention ("ARChitact™"} b described in detail, The archrtectun module essentially gathers information about the designer's system, including for example, specifications from the designer's fibraries, and assembles this information for later use by other modules within the program. The output of the ARChitect ™ process is an HDL synthesizable model of the IC under design.<br>
As shown in Figure 3a, the process 300 specifically employed by the ARChitect™ module comprises a series of steps, the first of which is initializing the program and setting default values 301 Next, a destination directory is created m step 304 for the HDL (in this case VHDL) files to be generated in subsequent steps. In step 36, the technology/feature<br>
-9-<br><br>
size is obtained from the user (or another source, es previously described). Far example, the user may desure a 0 18 micron process for their design.<br>
In step 308, the system clock, memory configuration, and cache default values are set based on the technology chosen in step 306 above. If the technology chosen by the user allows a chotca of dock speed, the user is prompted (or the selection otherwise obtained) in steps 310 and 312. The clock period is then sst per step 314.<br>
Referring now to Figure 3b, the process 300 continues with steps 316 and 318, wherein the dock skew is selected (or otherwise defaulted). The extensions logic library nameJIocatum is than obtained from the user in step 320. As used herein, the term "extensions" refers to a sat of predetermined logical functions. For example, extensions within the ARC system may include rotate, arithmetic and logical shifts within the barrel shifter, small multi-cycle multiply, MAC function, swap function (for swapping upper and lower bytes), timer interrupt, and the like. Lastly, in steps 322-32B, the need or user desire for a memory subsystem such as a scratchpad RAM is analyzed (based on the user's technology choice), and the memory subsystem values are set accordingly.<br>
Referring now to Figure 3c, the method 300 continues with step 330, wherein the user's manufacturer code (specific to each user entity) and version are obtained from the user. In step 332, the memory bus and register file configuration required for the design are determined; see the discussion of Figure 4 herein for further details of this process. Once the memory/register configuration is determined, the user is prompted in step 334 to determine if the use of fast load returns is desired. As used herein, the term 'fast load returns" refers to the condition in which the processor initiates'a load operation but continues other execution before the load has been confirmed as being * completed: 'Steps 336-338 allow the user to enable/disable this functionality, respectively, as desired.<br>
Next, in step 340, the system configures the extensions used with the design as specified in step 320 described above. Figures 5a-5h depicts this process in greater detail, as discussed further below. The user's choice of technology (step 306) is then examined in step 342 to determine if dock gating is allowed; if so, the user is prompted for a clock gating flag in step 344.<br>
Referring now to Figure 3d, the user is next prompted for a series of inputs including the desred reset action (Le, "halt" or "run") per step 346, simulator choice (step 348), and pipeline display options (step 350). In step 352, the setup parameters for the register transfer link (RTL) and SeeCode Application Link ("RASCAL™") are defined, as discussed in greater detail below with reference to Figure 8. RASCAL" is a utility module avatable from ARC Cores, Ltd. that connects the debugger module to the MTI simulator. This connection allows the debugger to control the simulation of code on the IC system model in the MTI simulator far hardware/software co-verification. The output directories for the files are then created in step 354.<br>
Referring now to Figure 3e, the configuration is compiled, the core configuration registers and configuration register test code are set up per step 356. Next, in step 358. the functional HDL files are generated by (i) copying prototype files; (ii) substituting chosen and calculated values where required; and (iii) merging tn the HDL where required. NotB that in the illustrated embodiment only the prototype fries actually required for the selected configuration are copied.<br>
-10-<br><br>
In step' 360, the structural HDL files are generated, along with the synthesis scripts and simulation makefile!. Lastly, the test code required by the chosen extensions is compiled m step 362.<br>
Refernng now to Figure 4, one exemplary embodiment of the method of determining, the memory and register configuration of the system under design as shown generally in step 332 of Figure 3c is described. The method 400 comprises an initial determination in step 402 of whether the bus parameters are dictated by the technology previously chosen tn step 306 (Figure 3a), if the chosen technology requires specific bus values, these values are set in step 404. If not (or alternatively, after setting the bus values m step 404), it is next determined whether core verification was requested by the user (steps 406,407). If not, and the technology selected does not dictate the bus values, then the user is prompted to provide tha desired bus widths in step 408. The memory values appropriate to the selected bus width are then set in step 410, and the user prompted far the desired register file configuration in step 412.<br>
If core verification was requested by the user in steps 406 or 407, the memory values required for such verification are set in step 414, and the register values required by the selected technology and the core verification are set in step 416.<br>
In the case that the technology selected does dictate the bus values, and core verification is not selected, then the register values are set per step 416 previously described.<br>
Referring now to Figures 5a-5h, one exemplary embodiment of the method of configuring f3e extensions as shown generally in step 340 of Figure 3c herein is described. As illustrated in Figure 5a, the method 500 comprises first choosing one or more extensions library files in step 502 based on the technology initially selected and the memory subsystem configuration previously discussed. In step 504, the chosen extensions library files) are read. A list of available extensions compatible with the selected technology, memory subsystem configuration, and core verification choices is then built in step 506. Next, the user is prompted for specific core extension choices and associated parameters in step 508. Specifically, extensions include core registers, ALL extensions that provide more operations, auxiliary registers, condition codes, FIFO (first in-first out memory), increasing the number of pending load/stores that may be issued, and interrupts. After the user input has been received in step 508, each of the user core extension choices is analyzed to determine if it is compatible with the other choices made by the user (step 510): If so, the values required by those user selected core extensions are set in step 512. Note that the selection of some extensions wilt require the selection of other extensions which are needed for support functions. If not, the extension algorithm 500 is aborted in step 514, and restarted. It will be recognized that step 510 herein may tie accomplished interactively, such that when the user is making selections in step 508, they will be immediately apprised of the compatibility of the extensions chosen. Alternatively, the method 500 may be structured such that the system will not allow incompatible choices, either by prompting the user to make another selection, or only presenting the user with compatible choices to choose from, (such as on a display menu). Many other approaches are possible as wet<br>
Referring now to Figure 5b, the method 500 continues with step 516, wherein the user's choice of technology is examined to determine whether it permits the choice of memory extensions (versus care extensions, es previously<br>
-11-<br><br>
described). If no choice of memory extensions is allowed, the required memory extension values are set per step 518, the cache values set up per step 520, and the load/store interface configuration set up per step 522.<br>
If a choice of memory extensions is allowed per step 516, the method of figure 5c B utilized. As shown therein, the existence of a memory subsystem is next determined in step 524. If no memory subsystem exists, values consistent with no memory interface are set in step 526. Next, the user is queried if an instruction cache is desired in step 52S; if no, the values for a core build only (i.e, no memory interface) are set in step 530. If yes, a cache random access memory (RAM) and direct mapped cache controller (DMCC) are added (step 532), "instruction fetch" extension is added to list of selected extensions (step 534), and the cache " set up (step 536), as further described with reference to Figure 6 herein.<br>
If a memory subsystem does exist in step 524, the desired memory extensions are obtained from the user in step 538.<br>
Referring now to Figure 5d, the method 500 continues by setting up the load/store interface in step 540. The method of step 540 is described in greater detail wrth respect to figure 1 herein. Upon completion of step 540, the algorithm determines it step 542 whether an instruction fetch was selected by the user. If so, the algorithm again determines whether a memory subsystem exists (step 544); if so, the user is queried in step 546 as to the type' of instruction fatch system desired. If the type of instruction fetch system is a "cache", tha algorithm then adds a cache RAM and DMCC to the configuration per step 548, and sets up the cache in step 550 as in step 536 previously described. If the type of instruction fetch selected in step 546 is a "dummy", then tha algorithm proceeds to step 552 of figure 5e. Note that if no instruction fetch was selected in step 542, or no memory subsystem exists in step 544, the algorithm proceeds to step 552 as well.<br>
Referring now to Figure 5e, the method 500 continues with step 552 in which the initial choice of technology by the user (step 306) is examined to determine whether the choice of a memory arbiter is allowed. If yes, the existence of a memory subsystem is then determined in step 554. If no choice of memory arbiter is allowed, or if there a no memory subsystem, the algorithm then determines whether the choice of RAM sequencer is allowed for the chosen technology in step 556. Note that in step 544, if a memory subsystem is allowed, then the algorithm queries the user to specify the memory arbiter and channels desired.<br>
Returning to step 556, if a RAM sequencer choice is permitted, then the algorithm determines in step 558 whether a synchronous RAM (SRAM) was chosen by the user. If so, the user u prompted in step 560 for the number of RAM sequencer wait states associated with the SRAM. Upon obtaining that information, the algorithm proceeds to step 562 of Figure 5f. Similarly, if no choice of RAM sequencer is permitted by the technology in step 556, the algorithm proceeds to step 561<br>
Referring now to Figure 5f, tha extensions selection algorithm continues at step 562, wherein again the existence of a memory subsystem is determine! If a memory subsystem does exist the existence of a memory arbiter is queried in step 564. If a memory arbiter exists, then the existence of a memory sequencer is determined in step 566. If a memory sequencer exists, tha existence of an instruction fetch is determined in step 568. After step 568, the algorithm executes a branch return back to step 342 of Figure 3c. If no memory subsystem exists per step 562, a branch return to<br>
-12-<br><br>
step 336 of Figure 3c is also executed. If no sequencer exists per step 566, the algorithm proceeds to step 574 of Figure 5g. If no instruction fetch exists per step 569, then the algorithm proceeds to step 576 oi Figure 5g.<br>
If no memory arbiter exists per step 564, then the existence of a sequencer u again determined per step 570. If a sequencer exists, the aforementioned return is execute! If no sequencer exists, the existence of an instruction fetch is determined in step 572. If an instruction fetch exists per step 572, the algorithm proceeds to step 580 of Figure 5h. If not, then step 582 of Figure 5h is selected.<br>
Referring now to Figure 5g, step 574 comprises adding a dummy SRAM sequencer. After the dummy sequencer has been added, the algorithm determines whether an nstruction fetch exists in step 578. If yes, a branch return is executed. If no, a dummy instruction fetch interface is added per step 579. If no instruction fetch exists per step 572 of Figure 5f, an instruction fetch channel is added to the arbiter per step 576 of Figure 5g, and a dummy instruction fetch interface added per step 579.<br>
Referring now to Figure 5h, step 560 comprises adding an miu(l) (external memory instruction fetch) interface for addressing external memory during instruction fetch. Alternatively, in step 582, an miu(4) interface and cache default values are added. Upon completion of step 580 or step 582. the algorithm determines in step 584 whether slide pointers or a scratch RAM was chosen by the user. If either was chosen, a scratchpad RAM is added per step 586, and slide pointers added to the build (as appropriate per steps 568 and 590.<br>
Referring now to Figure 6, one exemplary embodiment of the method 6D0 of setting up the cache as previously discussed with respect to Figures 5b, 5c, and 5d herein is described. In a first step 602. the type of instruction cache to be used is obtained from the user. In the illustrated embodiment, the user may specify cache size, memory width, line size, and operation mode (such as debug and bypass), although other choices are possible. Next, in step 604, the values for the chosen cache type are read and stored as appropriate for later use.<br>
Pefemng now to Figure 7, one embodiment of the method 700 of setting up the load/store interface per Figure 5d herein " describd First, the load/store memory controller size is obtained from the user per step 702; the values associated with tin selected controller size are then obtained from the appropriate file and stored in step 704.<br>
Referring now to Figure 8, one exemplary imbodiment of the method 800 of setting up the register transfer language structure (e.g., RTL and SeeCode Link, or RASCAL™) as shown generally n Figure 3d herein is described. The method 800 first determines in step 802 whether a core verification was selected by the user; if a core verification was selected, a branch return to step 354 (Figure 3d) is executed. If no core verification was selected, the method BOO then determines what simulator choice has been made by the user in step 804. If no choice has been made, the system "testbench" function (a simulation environment with test vectors) is set to "standalone" mode, and the RTL and SeeCode Link disabled per step 806. If some choice (other than "none") has been made, the user is prompted in step 808 to determne whether the aforementioned RTL Enk is desired; if not the testbench function a set per step 808. If the RTL Ink is desired the existence of a memory subsystem is again determined per step 810, and the values for either a generic build with the RTL ink (step 812) or the core btrld with RTl link (step 814) set as appropriate. Upon completion of the RTL setup method 600. a branch return to step 354 is executed.<br>
-13-<br><br>
Figure 9 Ihistrates one eiempiary embedment of the method 900 of generating a new script according to the invention. First the hierarchy (Be representative of the physical hierarchy of the design is read per step 902. Next the applicable fibrary file is read m step 904. In step 906. a 1st of the libraries used in conjunction with the design is budt, as described in greater data! with reference to Figure 10 herein. After the bbranes list is built an output makefile is created in step 908, and the constant headers written to the created makefile. In step 910, the aforementioned libraries Est is added to the makefile as described in detal with reference to Figure 11 harem. Neit the "top-lever rule is added to the makefile in step 912. As used herein, the top level rule relates to those rules specified by the hardware description language (such as VHDL or Venlog), although it wiD be appreciated that others rule bases may be used.<br>
Alter the top-level rules havB been added, the datatla dependency rules are added to the makeffc m step 914 This step 914 is described in greater detail with reference to Figure 12 herein. Lastly, the physical hierarchy generation control file rule is added to the makefile to complete the latter.<br>
Referring now to Figure 10, one exemplary embodiment of the method 1000 of building a libraries list as shown generaDy in step 90S of Figure 9 is described. In a first step 1002, each block present in the design is analyzed; if the read block's library is presently within the libraries list (step 1004), the next block is read and similarly checked. Note that as used herein, the term "block" refers to a logical entity having a particular function, such as an adder or multiplier. If the required block library is not m the list that Kbrary is added per step 1006. This process 1000 is repeated until all blocks have been analyzed and the presence of their required libraries verified in the libraries list<br>
Referring now to Figure 11, one exemplary embodiment of the method 1100 of adding the libraries Est to the system "malcefBe" as shown generally in step 910 of Figure 9. Specifically, the method 1100 comprises reading each library per step 1102. and writing the library name and path to the aforementioned makefile per step 1104. The algorithm returns to step 912 of Figure 9 when aH of the required library information has been added to the makefile.<br>
Figure 12 ilustrates one embodiment of the method of adding datafle dependency rules to the system "makefile" as shown generally in step 914 of Figure 9. Specifically, each block is read in step 1202, and the dependency rules are written to a foe m step 1204 to extract that block from its library. When aH dependency rules have been written, the algorithm returns to step 916 of Figure 9. This completes the script generation process 900.<br>
Referring now to Figure 13, one exemplary embodiment of the method 1300 of hierarchy file generation according to the invention is described. In step 1302, the library foe name and top level block name are obtained. Next, in step 1304, the input files are read as described in detaP with respect to Figure 14 herein. Next, the integrity of tha data read b verified in step 1306; see Figure 19 for additional detal. Then, for each intermediate block, a subsumption map is buit {step 1308). In step 1310, an 1/0 lit is built for each mtermediati block as further described with reference to Figure 20 herwru bi step 1312. the In", "out", and "incut" signals art written to a new data file for each block; the block ID and architecture type an ilso written thereto. Next the HDL (e.g., "VHOLgen") control file for each block is written in step 1314. The foregoing thru steps 1310, 1312, 1314 art subsequently performed for each intermediate block untl all blocks have been processed; at this point the HDL control file for the top level is written in step 1316.<br>
-14-<br><br>
Naxt, for each intermediate block, the HOL is generated in ltep 1318, and when all intermediate blocks have been generated, the HDL for the top IBVSJ generated in step 1320. This completes the hierarchy file generation method 1300.<br>
Figure 14 illustrates one embodiment of the method 1400 of reading input files (step 1304) in accordance with the hierarchy ftla generation method of Figure 13. First the hierarchy file is read in step 1401 Next the data file for the top level entity is read per step 1404. Then, for each primary block, the data ffla is read per step 1406. Figures 15,16, and 17 illustrate these steps 1402,1404,1406 in detail<br>
Figure 15 illustrates one exemplary embodiment of the method 1500 of reading hierarchy ties as shown generally in step 1402 of Figure 14. For each fine in the hierarchy files, the associated block and list of dependent blacks is read in step 1502 and each added to the block list in step 1503. When all such lines have been read, the block fist is then split into a separate (i) primary block fist and (a) intermediate block list in step 1504.<br>
Referring now to figure 16, one exemplary embodiment of the method 1600 of reading top level entity data files as shown generally in step 1404 of Figure 14 is describe! Fust each fine of the top level data file is analyzed in step 1602 to determine whether it describes a signal tf so, then the signal data is extracted from each Bne per step 1604. In the illustrated embodiment signal data includes, without limitation. Id," "upper bound," "lower bound," "type," and "direction" information. Next in step 1606, the direction of tha signal in each fins determined to have a signal present is analyzed; if the signal is outbound, the top level of the hierarchy is added as tha destination of the signal, and the signal source set to "unknown' per step 1608. tf the signal is not outbound, the signal's destination Dst is cleared, and the source of the signal set to the top level per step 1610. This process 1600 is repeated for each line m the top level data file until all lines have been analyzed.<br>
Figure 17 illustrates one exemplary embodiment of the method 1700 of reading primary block data files as shown generally in step 1406 of Figure 14. Initially, for each primary block, each line of the associated top level data file is analyzed in step 1701<br>
If the line under analysis is classified as a "signal" line, then the signal data is extracted from that line in step 1704 as previously described with reference to Figure 16. If the signal has been read before by the algorithm, and the values associated with the signal match those previously read, the signal is connected to the prmary block per step 1710. If the signal has not been previously read, it is added to the signal fist per step 1708, and then connected to the primary block. Note also that if the signal has been read before but the current values do not match those previously read, then the algorithm aborts per step 1716.<br>
If tha line under analysis is an 'architecture" line, thi architecture of the primary block is set to "data" per step 1718, and the next fine analyzed.<br>
If the hne under analysis is nerthar an "architecture" or "signal" line, no action is taken, and the next line "the top level data file is real<br>
Referring now to Figure 18, ont embodiment of the method 1800 of identifying and integrating new signals into the block data files as shown generally in Figure 17 is described. Initially, the signal type is determined in step 1601<br>
¦15-<br><br>
Signal types m the present embodiment include In', -out", and 'mom*. If the signal is an "m" signal thB signal's source is set to "unknown" m step 1804; the block is then added as the destination of the signal per step 1805. If an "out" signal, the signal a examined to determine if a source already nuts (step 18061; if yes, the algorithm 1800 a aborted. If no. the signal's destination fast is cleared and the signal's source set to "block" per step 1808. If the signal's type is "inout", then the block a set as the destination in step 1805.<br>
Referring now to Figure 19, one exemplary embodiment of the method 1900 of verifying signal data integrity as shown generally in Figure 13 is described. Fret in step 1902, each signal a examined to determine if it has an associated destination. If so, the existence of an associated source is then checked in step 1904. If both source and destination exist for all signals, the routine is terminated. If no destination is present for one or more signals in step 1902, a list of signals without destinations is printed per step .1906. If ad signals have destinations but one or more signals do not have a source, a Ust of signals without sources is printed per step 1908.<br>
Referring now to Figure 20, one exemplary embodiment of the method 2000 of building an I/O tut relative to the block data files as shown generally in Figure 13 is described. For a given block, the lists of "in", "out", and Inout" signals are first cleared per step 2002. Each signal is then checked to determine if it ts an "Snout" signal relative to the block in step 2004, as described in greater detail with reference to Figure 21 harem. For each signal with a source inside the subsumption, the signal is checked m stsp 2006 to determine if it has a destination outside the subsumption. If so, the signal is added to the "out" list per step 2008, and the next signal analyzed. If the signal under analysis has no source inside thp block, or all of its destinations are inside the subsumption, then the signal is checked to determine if it has an source outside of the subsumption in step 2010. If so, and it has at least one destination inside the subsumption (step 2012), then the signal is added to the "in" list per step 2014, and the next signal subsequently analyzed.<br>
Figure 21 is a logical flowchart illustrating one embodiment of the method 2100 of checking for "in" or "out" signals as shown generally in figure 20. For a given block and signal, the signal type is checked in step 2102 to determine whether the signal is an "inout" type'; if the signal is not an "inout" type, the algorithm returns to Figure 20. If it is an "inout type, the signal's source is checked in step 2104 to determine if it is outside of the block, then whether it has destinations inside the block (step 2106). If both conditions are met. the signal is added to the inout list per step 2108. If either one of the conditions is not met the signal's source is checked in step 2110 to determine if it is inside of the block; if so, then the destination is checked in step 2112 to determine if it is outside of the block.<br>
Referring now to Figure 22. one exemplary embodiment of the method 2200 of generating the merged hardware description language (HDL) foe actQrdmg to the invention is described.<br>
It is again noted that white the following discussion is cast in terms of VHSIC Hardware description Language (VHDU, other languages may be used to practice the method of the invention with equal success VHDL is chosen for the illustrated examples .simply for its comparatively wide-spread recognition and ease of use.<br>
As used herein, the term "vrxflgen" refers to VHDL generation, a process within the invention by which the individual VHDL foes relating to various aspects or components of the design are merged together to form a common VHDL ffle descriptive of the overal design.<br>
-16-<br><br>
As shown m figure 22, ihe vhdJgen melhod 22D0 comprises first reading a control file (step 2202L followed by reading the top level data file (step 2204}. These steps 2202. 2204 are described "i greater detail with reference to figures 23 and 24, respectively. After the top level data file is read, each dependency present is analyzed by reading the dependency data file (step 2206), as further illustrated in figure 25. After each dependency data fiie has been read, the signal fist is processed in step 2208 into a plurality of groups (Figure 27), the data ntegntY verified m step 2210 (Figure 281, the associated library fila read in step 2212 (Figure 291, and the 'merged" VHDL file written in step 2214 (figure 301.<br>
Referring now to Figure 23, one exemplary embodiment of the method 2300 of reading the HDL control file as shown generally in step 2202 of Figure 22 u described. Initially, the library file name is read from the control file in step 2302. Next, the top level entity name is read from the control file in step 2304 The control ffc is then examined in step 2306 to determine if it is at end of file (eof); if so, the routine ts terminated and returns to step 2204 of figure 22. If not. the first dependency entity name is read from the control file in step 230S and added to the fist of dependent blocks m step 2309. If additional dependencies exist, they are subsequently read and added to the list of dependent blacks untfl the eof condition is met at which point the routine returns to step 2204 of Figure 21<br>
Figure 24 ilustrates one exemplary embodiment of the method 2400 of reading the HDL top level entity data file as shown generally in step 2204 of Figure 22. Specifically, each record in the top level data file is examined in step 2402 to determine if it is a "signal' record; if so, the signaf's upper bound, lower bound, direction, and type are set from the input record in step 2404. The signal's destination Bst is also cleared. Next each signal's direction (i e., 'in*, "out", or "inout") is determined in step 2406; if the direction of a given signal ts "out", then the signal's source is set to "unknown", and "PORT" is added to the signal's destination fist in step 2410. If the signal is "in" or "inout", then the signal's source ts set to "PORT" in step 2411 Lastly, m step 2414, the signal is added to the signal list, and the next record in the top level data file subsequently read.<br>
Figure 25 flustrates one exemplary embodiment of ttw method 2500 of reading the HDL dependency data file as shown generally in Figure 22. For a given entity, each record in tha data file ts read and the type of record determined tn step 2502. If the record is a "signal", data from the signal record is then processed in step 2504 (see Figure 26 for additional detal on this stepl After the data has been processed, tha signal is added to the entity's signal fist in step 2506, and the neit record real Conversely, if the record read is an "architecture" record, then the architecture of the dependency for that record ts set per step 2510, and then a subsequent record read. When all records have been read, the routine is terminated in favor of step 2206 of Figure 25.<br>
Figure 26 illustrates one embodiment of the method 2600 of processing signal record as previously discussed with respect to Figure 25. For the chosen entity, the algorithm 2600 first determines in step 2602 whether the signal being examined has been read before; rf so, the signal's type and bounds ere next examined to determine whether they match the previous occurrence of the signal (step 2604). If so, the signal's direction is next analyzed n step 2606 to determine its type. If die signal b tn "out" signal the source of the signal ts then analyzed m step 2608 if s source exists, the routine is aborted per step 2610. If not the signal's source is set to "entity" per step 2612. Conversely, if the signal is an "out" or "inout* signal, then the entity ts added to the signal's destination fist per step 2616.<br>
o17<br><br>
In the case where the signal under examination has not been previously read, the signal's upper and lower bounds, direction, and type are set in step 2620 using information from the input one. The signal's destination fist is also cleared. If the signal's direction is inout", then the signal's source  is set to "entity" in step 2622. and the signal added to the signal list in step 2624. If not, the signal is added to the signal list directly. After the addition of the signal to the signal list in step 2624, the routine proceeds to step 2606 for analysis of the signal's direction as previously described.<br>
Figure 27 illustrates one exemplary embodiment of the method 2700 of processing the signal Est into groups as shown generaBy in Figure 22. Specifically, for each signal, the signal's source is first determined in step 2702; if the signal source is "PORT", then no further analysis of that signal is required, and the next signal is analyzed. If the signal's source is "unknown", then the signal is added to the list of signals with no source in step 2704, and the next signal analyzed. If the signal source is "other", the signal b then analyzed in step 2706 to determine if any destinations are specified. If there are no destinations specified, the signal is added to the list of signals without destinations per step2710. If the signal does have one or more destinations, these destinations are then examined in step 2712 to determine if any are destinations other than "PORT". If so, then the signal is added to the ust of intermediate signals per step 2716. Next, in step 2718, the destinations of the signal are again examined to determine if any of these destinations are "PORT"; if yes, the signal is further added to the list of signals requiring output drives in step 272D.<br>
Referring now to Figure 28, ona exemplary embodiment of the method 2800 of verifying signal data integrity as shown generally in figure 22 is described. First, in step 2802, each signal is examined to determine if it has an associated destination. If so, the existence of an associated source ts then checked tn step 2804. If both source and destination exist for all signals, the routine is terminated. If no destination is present for one or more signals in step 2802, a list of signals without destinations is printed per step 2806. If all signals, have destinations but one or more signals do not have a source, a list of signals without sources is printed per step 2808.<br>
Figure 29 illustrates one embodiment of the method 2900 of reading the library file as shown generally in Figure 22 herein. For each record present in the given library file, a determination is first made in step 2902 as to what type of record is under analysis; if the record is a "library id", then the status of setting the "worklib" flag is determined in step 2904. If the flag has not been set, it is set from the present record per step 2906. If it has been set then the next subsequent record is read from tha library. If the record is an "entity" record, the "entity id" and "library id" are extracted from the record m step 2908, end the entity's library name is set to library" in step 2910.<br>
Lastly, if the record ts classified as "other" in step 2902. then no action is taken and the next subsequent record is read.<br>
After each record has been read from the selected library and analyzed as to type, each entity is examined to determine whether it has an associated entity library per step 2914. If a given entity does have a lbrary, that library is next analyzed in step 2916 to determine if that library has been read before. If so, the next sequential entity is analyzed. If not the library is added to the library Gst in step 2918, and then the next subsequent entity analyzed. If the entity has no associated library in step 2914, then the program is aborted per step 2920.<br>
¦18-<br><br>
Referring now to figure 30, one exemplary embodiment of the method 3000 of writing one or more HDL fQes as shown generally in figure 22 is described. The VHDL file is written in a sequence of steps that conform to the specification for VHDL format. It is noted that other HDL languages may employ differing formats that result in some information becoming unnecessary, or required in a different order. The first itep 3002 of tha illustrated method 3000 comprises writing the VHDL file header to a VHDL file. Next the fist of libraries and packages used is written to the VHDL fila in step 3004. Next the entity declarations are written to the VHDL file in step 3006. Subsequently the architecture information is written to the VHDL file in step 3008. In the next step 3010, VHDL component declarations are written to the VHDL file. The list of intermediate signals is then written to the VHDL file in step 3012. and VHDL configuration statements are written to the VHDL file in step 3014. Then, in step 3016, all component instantiations are written to the VHDL file. Finally, output drives are written to the VHDL file in step 3018. This completes the hardware description language file generation process.<br>
It is noted that while the foregoing description of Figures 2-30 refers to specific embodiments of the various aspects of the method of the invention, various substitutions, alterations, permutations, additions, and deletions may be made to the disclosed method. For example, certain routines disclosed herein may be selectively employed, or the order in which they are employed with respect to other routines varied. Similarly, individual steps within each of the routines may be modified as required by the particular application. Description of the IC Design Apparatus.<br>
Referring now to Figure 31, an exemplary apparatus capable of implementing the method of Figures 2 -32 is described. A stand-alone microcomputer system 3100 of the type well know in the computer arts, having a processor 3102, internal or external storage device 3104, display device 3106, internal memory 3108, and input device 3110, is used. The algorithm 100 of Figure 2, embodied in the form of a computer program reduced to machine readable object code as is also well known in the art (not shown), is loaded into the storage device 3104 and memory 3108 of the system 3100 and run on the processor 3102 based on inputs provided by the user via the input device 3110. Alternatively, the computer program may reside on a removable storage device (not shown) such as a floppy disk or magnetic data cartridge of the type well known in the art. The display device 3106, which may comprise for example a cathode ray tube (CRT), liquid crystal display (LCD), thin film transistor (TFT), or plasma display, provides the user with a variety of visual information including representations of the program's menu structure, and the status and output of various routines or modules running within the program. See Appendix I for one exemplary embodiment of the menu structure used in conjunction with the aforementioned computer program. While the illustrated embodiment is a microcomputer, it will be recognized that other computer types and architectures may be used with equal success. For example, a networked minicomputer system or client/server arrangement wherein data or libraries relating to the design are not resident on the local system 3100 may be employed, or alternatively, a plurality of different computers may be used to run parts of the computer program in parallel. Many varying architectures and equipment/software configurations may be substituted, consistent with the general aims of providing an automated, interactive design process.<br>
-19-<br><br>
Description of the Integra tad Circuit<br>
Referring now to Figure 32, an exemplary integrated circuit developed using the above-described method of the present invention is disclosed. As shown in Figure 34, the integrated circuit 3200 is an ARC microprocessor-bice CPU device having, inter alia, a processor core 3202. on-chip memory 3204, and an external interface 3206. The device is fabricated using the customized VHDL design obtained using the present invention (step 108 of Figure 2) which is subsequently synthesized into a logic level representation, and then reduced to a physical device using compilation, layout and fabrication techniques well known in the semiconductor arts. As previously noted, the designs for a wide variety of other types of integrated circuits (including, for example, ASICs and FPGAs) can be synthesized using the method and apparatus set forth herein. Hence, the CPU-based device of Figure 32 is merely exemplary of such devices.<br>
It will be appreciated by one skilled in the art that the Integrated Circuit of Figure 32 may contain any commonly available microcontroller peripheral such as serial communications devices, parallel ports, timers, counters, high current drivers, analog to digital (A/D) converters, digital to analog converters (D/A), interrupt processors, LCD drivers, memories and other related peripherals. Further, the Integrated Circuit may also include custom or application specific circuitry that is specifically developed to solve a specific applications problem or meet the needs of a single application. The present invention is not limited to the type, number or complexity of peripherals and other circuitry that may be combined using the method and apparatus. Rather, any limitations are imposed by the physical capacity of the extant semiconductor processes which improve over time. Therefore it is anticipated that the complexity and degree of integration possible employing the present invention will further increase as semiconductor processes improve.<br>
It is noted that power consumption of devices such as that shown in Figure 34 is significantly reduced due in part to a lower gate count resulting from batter block and signal integration. Furthermore, the above-described method provides the user with the option to optimize for low power (or use a low power silicon process such as Xemics for example). The system may also be run at a lower clock speed, thereby further reducing power consumption; the use of one or more custom instructions and/or interfaces allows performance targets to be met at lower clock speeds.<br>
It is also noted that many IC designs currently use a microprocessor care and a DSP core. The DSP however, might only be required for s limited number of DSP functions, or for the IC's fast DMA architecture. The invention disclosed herein can support many DSP instruction functions, and its fast local RAM system gives immediate access to data. Appreciable cost savings may be realized by using the methods disclosed herein for both the CPU &amp; DSP functions of the IC.<br>
Additionally, it will be noted that the computer program as previously described herein can readily be adapted to newer manufacturing technologies, such as 0.18 or 0.1 micron processes, with a comparatively simple re-synthesis instead of tht lengthy and expensive process typically required to adapt such technologies using "hard" macro prior §rt systems.<br>
-20-<br><br>
While tha above detailed description and Appendices have shown, described, and pointed out novel features of tha invention as applied to various embodiments, it will be understood that various omissions, substitutions, and changes in the form and details of the device or procass illustrated may be nude by those skilled n tha art without departing from the spirit of the invention. The foregoing description is of the best mode presently contemplated of carrying out the invention. This description is in no way meant to be limiting, but rather should be taken as illustrative of the generaf principles of the invention. The scope of the invention should be determined with reference to tha dams.<br>
o21-<br><br>
APPENDIX I<br>
The following describes snd  illustrates the operation of the ARC System Budder Program:<br>
Installation Script<br>
Installation script allowing the following ARC features to ba selected:<br>
o	?Extensions required<br>
o	 ?Cacha size<br>
o	 ?Cache line length<br>
o	?Size of external memory space that is to be cached.<br>
o	?Ctock period<br>
o	?Clock skew<br>
o	?Synthesized d-latches or 3-port RAM for register file<br>
o	?Type of technology being used.<br>
o	?Manufacturer code and version number information<br>
o<br>
The script creates a working directory for the user, and in it creates the following:<br>
o	VHDL for the extensions selected<br>
o	VHDL for a direct mapped I cache configured to user's specification<br>
o	VHDL test-bench for testing basecase operation and external interfaces<br>
o	VHDL structure to link together all required modules<br>
o	Configuration files for Synopsys Design Compiler<br>
o	Manory image file containing basecase test code<br>
o	Synthesis script for Synopsys Design Compiler v3.4b or above<br>
o	Makefile o set up for the Model Technologies VSystem/VHDL simulator, but can be altered for use with<br>
other simulation environments.<br>
The user can select from 4 different types of build:<br>
o	Core Build<br>
o	Generic System Build<br>
o	Altera Build (for ARCAnuel™ development board)<br>
¦    Core Verification System<br>
AftBr setting up his ARC area, before the user can use the ARC system buildar, several environment variables need to be set.<br>
-22-<br><br>
In .cshrc.<br>
Set ARCHOME environment variable, base of the arc install tree. Add bin directories to path. Set other<br>
environment variable* such as ARC_MANC00E and ARC MANVER and ARCASIC. (If these variables are<br>
not set the build script will ask for them at run time.)<br>
e.g.<br>
setenv ARCHOME lapps/ARC Cores<br>
sotenv ARCMANCODE <br>
setenv ARC MANVER <br>
set path - (SARCHOMEarec/bin path}<br>
ARC MIANCODE is the unique manufacturer code that ARC Cores gives to each ARC licensee, and the ARC MANVER is that manufacturers additional identity number. Both numbers go on to be stored as part of the identity register.<br>
After setting up the environment the ARC system builder can be run just by typing systemjiuilder, which is an executable script. A log file (sys_bld.log), which keeps s record of the build selections the user make, is created in the directory that the user specify for the user working directory.<br>
The ARC System builder script when run produces a series of text menus/questions.<br>
Example MENU 1<br>
1.	Continue.<br>
2.	Valid selection.<br>
3.	* Mutually exclusive.<br>
4.	Mutually inclusive.<br>
- * Permanently selected. N/A Invalid selection. 7. * Valid selection Please select:<br>
The above menu shows an example menu. The'"' next to a menu entry indicates that it is selected.<br>
-23-<br><br>
Continue<br>
On all the menus that allow multiple selections 1 is always continue.<br>
Valid selections<br>
In this example menu entry 2 is a valid selection which is currently unselected. Menu entry 7 is also a valid selection,<br>
which is selected. Valid selections can be selected and deselected fay entering their corresponding menu number. (When<br>
menus are initially displayed some valid selections may be preselected; these are fust recommended<br>
selections for this build.)<br>
Mutually exclusive selections (On the same menu)<br>
Selections are mutually exclusive, for example two types of the same extension cannot be selected at the same time. If<br>
one menu entry, of a mutually exclusive set, is already selected and the user then selects the another, the first is<br>
deselected.<br>
Mutually inclusive selections (Between menus)<br>
Mutually inclusive relationships can exists between menu entries on two separate menus. If this is so, the entry on the<br>
second menu is either permanently selected or invalid depending on the state of the first entry.<br>
Permanent selections<br>
In certain circumstances menu entries usually valid select/deselect are permanently selected, e.g. Example menu entry 5. This usually because on a previous menu the user selected a menu entry to which this one is mutually inclusive. Permanent selections can also be active due to the build type.<br>
Invalid selections<br>
As with permanent selections, invalid selections are normal valid select/deselect menu entries, however in this case these options are not available. This is usually due to either mutually inclusive selections on previous menus that were not selected, or this selection is not available on this type of build. Menu entry 6 is an example of an invalid selection.<br>
Example MENU 2<br>
1.	Selection 1.<br>
2.	Selection 2.<br>
3.	Selection 3.<br>
4.	Selection 4.<br>
Please select(3):<br>
-24-<br><br>
Menu Default<br>
Some menus in the ARC system builder have default selections. On such menus entering nothing, i.e just pressing enter, will select tha default. The default menu entry number is specified next to the requestor. Menu defaults can be more than just numbers, on some questions they can be file paths, yln etc.<br>
The following describes examples for each of tha four types of build available, Base case. Generic, ARC Angel and Core<br>
verification.<br>
The first menu the user will encounter for all installations is tha one below:<br>
ARC System Build Tool o ARC System install.<br>
|c) 1998 ARC Cores Technologies Ltd.<br>
Generic install<br>
This program is capable of creating a basecase ARC or a complete ASIC for<br>
simulation, using MT1 and synthesis using Synopsys Design Compiler/Design<br>
Expert<br>
We're going to make:<br>
1. The directory structure<br>
1 Tfi3 structural VHDL levels<br>
3.	A personalized version of the cache config package<br>
4.	An optional external memory interface<br>
5.	Synopsys RAM models for the cacha RAMs<br>
6.	Synthesis scripts<br>
7.	A simulation makefile<br>
But first, you must answer some questions:<br>
Please select the type of system you wish to build.<br>
1. Core build with selected extensions<br>
1 Generic System Build with selected core/memory extensions<br>
3.	Alters Build for ARCAngel Development Board<br>
4.	Core Verification System.<br>
Please select (1):<br>
This menu allows the user to select from four types of build Core (Base case) build. Generic, ARCAngel and Core Verification. We will now example an install of all four types, showing the menus the user will encounter and 'typical' responses.<br>
-25-<br><br>
1.	Base Case<br>
From the full menu we select 1, which it also the default. The ARC system builder wifl then prompt the user for details about the Core build, i.e. Standard extensions (not including any scratchpad extensions). Direct mapped instruction cache, Load/ST interface to external memory, Host interface and model of external memory.<br>
-...-.-.-.-.-- Instruction/Data byte Address selections	Instruction<br>
Fetch memory system byte address bus width 1.22 bit (4Mb)<br>
2.	23 bit (8Mb)<br>
124 bit (16Mb)<br>
4.	25 bit (32Mb)<br>
5.	26 bit (64Mb)<br>
Please select (3):<br>
This menu asks for the number of bits for the instruction fetch address. For the purpose of this example we will select the default of 24 bit (16Mb), by pressing ENTER.<br>
The external memory system data bus width is 32 bits wide<br>
The external data bus an the ARC is 32-bits wide.<br>
External memory system address bus width (22 
The external memory system data bus width can range from 22 to 32 bits, 4Mb to 4Gb address range, the default on this menu is set to the value of the l-fetch address bus width. We are going to select 29 bits, an address range of 512 Mb. NOTE: Even though the bus width is set to an arbitrary value the memory model for a core build simulation is 128Kbytes.<br>
-.-.-.-.-.---.-.- Core Register File Selection	<br>
Tha 32 x 32 register file can be implemented using a synthesized array of d-latches, or by using a three-port (2 read, 1 write) synchronous RAM cell. Usi a synchronous 2r1w RAM for the register file? (y):<br>
-26-<br><br>
For the 32 general purpose registers rO r31 the user can either use: Synchronous 3 port (2r1w) RAM, {3 fast writs<br>
through is not required).<br>
Synthesized arrays of d-latches that require a write pulse to be generated<br>
Standard synthesis script assumes a 90°-delayed clock signal, for the synthesized array of d-latches.<br>
We will use a synchronous 3-port RAM and so we select y.<br>
"..........._.............__. Fast Load Returns-----¦-------.-------.-.<br>
Enable Fast load returns? (n):<br>
Fast Load returns, if the current instruction does not use register write back then the pipeline is not stalled.<br>
...........	............. Extensions Builder --	........<br>
Select the extensions to be added to the ARC<br>
1. Continue<br>
2.32x32 Barrel shifter o rotate, arithmetic and logical shifts -1 cycle<br>
3.	32x32 Barrel shifter - rotate, arithmetic and logical shifts - Multi-cycle<br>
4.	Small multi-cycle 32x32 Multiply<br>
* 5. Faster 
6.16x16 Multiply/Multiply Accumulate function with 36 bit accumulator ¦ Fast 7.16x16 Multiply/Multiply Accumulate function with 36 bit accumulator o Slow<br>
8.	Swap function - swaps upper and lower 16 bits of 32 bit word<br>
9.	MIN/MAX function o 32 bit precision<br>
10.	Normalize function - finds first fait set in 32 bit ward<br>
11.24-bit Timer which counts to limit and then generates an interrupt<br>
N/A A Scratchpad RAM<br>
N/A A Scratchpad RAM with Sliding Pointers<br>
Please select:<br>
The above menu shows all the standard extensions, the user can select different combinations depending on his needs.<br>
We will select the single cycle barrel shifter and the 32x32 multiply. Entering 2 and then entering 4 does this. If we wanted to disable the multiply  we could do this by entering 4 again.<br>
27<br><br>
Note the user cannot select both types of band shifters, in an Install, selecting one automatically deselects the other. This also applies to both instances of the 32 x32 multiplier, the MAC and both instances of the Scratchpad RAM. We will now enter 1 to continue.<br>
............................. Technology Selection ---.--.-.-.---------<br>
Feature sue (drawn) of technology in use<br>
1.	0..35um<br>
2.	0.5um<br>
3.	0.65um<br>
4. 0.8um<br>
5: 1.0(um)<br>
Please select (5):<br>
The feature size provides timings for DATA / TAG ram and the core registers. Our chosen technology is 1.0?m so we press ENTER to continue.<br>
The default synthesis script is set-up for the 1.0?m [S] 10K library supplied with the Synopsys synthesis tool.<br>
These values are only used to set the timings for the synthesis of RAM models. Jf an unsupported feature size required the user can select an arbrtrary value and following the build change the dock period for the simulation of the VHDL and synthesis scripts to support tha raw feature size, timings of RAM etc.<br>
Target clock speed m MHz (20)<br>
We will use the default of 20MHz as we have specified 1.0 ?m technology. Clock speed has a minimum of 1 MHz and a Maiimum of 150 MHz.<br>
Clock skew for synthesis (+1-1.5ns):<br>
Tha default of 1.5ns will be used for this example. Clock Skew has a minimum of 0 and a maximum less than the clock period.<br>
Library for extensions logic? (user):<br>
-28-<br><br>
Here the user can specify a name for his user's library. This name will he used as the VHDL library names and also during the install when creating directories and copying subsequent files to these directories (The directories created are in upper ease) The name entered a arbitrary so we will enter 'Alex'.<br>
_._._.-.-.---.-.-.-.-.-.-.- Memory Extensions --.-----.-.----.---.-Do you wish to include a Direct-Mapped Instruction Cache? (y):<br>
If the user enters "no" here the user wll build an ARC with no cache, if the user enters "Yes" he will be prompted to for further information about the cache he wants. We will enter "Yes" the default.<br>
_.._._._.-.-._--.-.-.-.-.-.- lfetch Modes --------.---.-.-.-.-.--Select the instruction Cache Modes.<br>
1.	Continue<br>
2.	Standard Cache with debug and cache bypass capability.<br>
3.	Virtual Cache<br>
4.	Mixed Code RAM / Icache space &amp; Cache Erne lock<br>
The .first thing the script needs to know is what kind of cache do the user want. It's possibie to have a:<br>
1.	Standard Cache<br>
2.	Virtual cache allows a user to dynamically resize the cache in software.<br>
3.	Mixed Code RAM f Icache space with Line locking<br>
NOTE: Standard Cache and Virtual Cache are mutually exclusive, and Mixed Code RAM is a superset of Standard Cache. We want to try a range of cache sizes to see what cache size best suits our application, therefore we are selecting Virtual Cache<br>
Please select the max size of the Direct Mapped Instruction Cache.<br>
1.0.5k bytes, 128 words<br>
2. 1K bytes, 256 words<br>
3.2k bytes, 512 words<br>
4.4kbytes, 1024 words<br>
5.8k bytes, 2048 words<br>
6.16k bytes, 4096 words<br>
7. Other stze<br>
Please select (3):<br>
29<br><br>
The Direct Mapped Instruction cache is user definable, using the script the user can select sizes from 4 bytes (1 word), up to 512k bytes (128k words). There are shortcuts for 512 bytes to 16K bytes, but other sues (larger or smaller) can be entered manually using option 7. For our test 4K bytes {selection 4) is sufficient.<br>
Please select the min size of the Direct Mapped Instruction Cache.<br>
1.0.5k bytes, 128 words<br>
2. Ik bytes. 256 words<br>
3.2k bytes, 512 words<br>
4.4k bytes, 1024 words<br>
 8k bytes, 2048 words<br>
16k bytes, 4095 words<br>
7. Other sue<br>
Please select (3):<br>
Virtual Cache requires a range of possible caches and line lengths so a minimum cache size is required. We will enter 2 512 bytes.<br>
Select a max Cache line length 1.2 instruction words 2.4 instruction words 3.8 instruction words 4.16 instruction words 5.32 instruction words 6. Other Please select (3):<br>
The cache line length is the number of words fetched when a cache miss occurs. The script has options for 2,4, 8,16, or 32 word lines, tha default being 8 wants. Selecting 4, will give a cache line length of 16 words, suitable for our test<br>
Select a max Cache line length 1.2 instruction words 2. 4 instruction words 3.8 instruction words<br>
4.16 instruction words<br>
-30-<br><br>
o 32 instruction wards<br>
6. Other<br>
Please select (3):<br>
Virtual Cache require! a range of possible caches and line lengths so a minimum cache line length is required. Entering 1, selects two instruction words. Cache size, line length and external address all determine the size of the tag RAM. Larger cache means more tag words and fewer tag bits. Longer line length means fewer tag words and more tag bits.<br>
.._._._._.___._.- Simulation ----.--------.-.-.-.-Selection of the state of the ARC on reset is important since it is preferable to have the system build start on reset while the core build should halt on reset since the hast effectively clears the halt bit during simulation. Do you wish to halt the ARC at address location 0 on reset (y):<br>
We have entered Y here, that means the ARC is halted immediately on reset Had we selected V the ARC starts<br>
running the code at address 0 on reset.<br>
The default for this is Y on core build and N on generic and ARCAngel builds.<br>
Note you will have to set the status register to the appropriate start address and clear the halt bit through the host interface before running the simulation." You can manually edit "arc_start" in xaux_regs.vhdl so that the ARC is running following a reset<br>
Having selected 'y' the above information message is displayed. Is your VHDL simulator Model Technologies VSystem? (y):<br>
At ARC Cores we enter 'Y' as we use MTI VSystem to simulate our VHDL If the user use a different simulator, select no. The user may set his environment up for his simulator by editing the makefile and other support files, after the install has completed.<br>
Do you wish to use the R.T.L And SeeCode Application link (RASCAL)? (n):<br>
RTL And See-Code Application Link, otherwise known as RASCALTM, is an extra utility that connects the Met aware debugger to connect to the Modeltech simulator. This allows the debugger to control the simulation of code on the<br>
-31-<br><br>
ARC system model in the MTI simulator for hardware/software co-verification. The default is no which is what we want for this build.<br>
_-o._._.-.-.-.-._._._._.-._._ install Directory -----o--------Full path to ARC user working directory (home/someone/basearc):<br>
At this prompt the user have to specify a destination directory name (with full path).<br>
The path must not include /tmpjnnt/ etc.<br>
We will select the default, a directory named "basearc" created where we launched the ARC system builder.<br>
What we hve built:<br>
l-fetch address bus width 24-bit<br>
external address bus width 29-btt<br>
register file 3-port RAM<br>
Fast Load returns 'no'<br>
Extensions Single Cycle Barrel shifter<br>
Small multi-cycle 32x32 multiply<br>
Clock speed 20 MHz<br>
Clock skew 1.5 ns<br>
Technology size 1.0 ?m<br>
Users library name 'alex'<br>
Direct mapped instruction Virtual<br>
Max/ Mm instruction cache size 4K bytes 512 bytes<br>
Max/ Min Cache line length 16 instruction words 2 instruction words<br>
Halt ARC on Reset? 'yes'<br>
Destination directory fhome/user/basearc<br>
Simulator - MTI? 'yes'<br>
RASCAL 'no1<br>
2.         Generic<br>
The second selection from the first menu is the generic btnid. This is similar to the base case build however it allows the selection of memory extensions. As described in the generic build certain selections determine which menus the user will see, we are going to make selections in  this example that will give access to all menus.<br>
-32-<br><br>
.................. Instruction/Data byte Address selections ---	-.-.-.- Instruction<br>
Fetch memory system byte address bus width<br>
1.22	bit (4Mb)<br>
2.22	bit (8Mb)<br>
3.22	bit (16Mb)<br><br>
4.	25 bit (32Mb)<br>
5.	26 bit (64Mb)<br>
NOTE: If you intend to use the PC parallel communications host port do not exceed 24-bits Please select (31:<br>
This menu asks for the number of bits for the instruction fetch address. For the purpose of this example we will salect 22 bit (4Mb), by entering 1.<br>
NOTE: Later in the build the user will be asked to select a host port for communications with the ARC. The SUN/PC parallel communications host port has maximum of 24-bits, if the user select a value greater than 24-bits in this menu the PC host port will no longer be available.<br>
.The external memory system data bus width is 32 bits wide<br>
The external data bus on the ARC is set to 32 bits wide.<br>
External memory system byte address bus width (22 
The external memory system data bus width can range from 22 to 32 bits, 4Mb to 4Gb address range, the default on this menu is set to the value of the l -tetch address bus width. We are going to select 24 bits, 16Mb address range, which is the maximum valid selection that can be used with the PCJSUN host port NOTE: Even though the bus width is set to an arbitrary value the memory model for a generic build simulation is 512Kbytes.<br>
....................... Core Register File Selection -------o-.-.-.<br>
The 32x32 register file can be implemented using a synthesized array of d-latches, or by using i three-port (2 read, 1 write) synchronous RAM celL Use a synchronous 2r1w RAM for the register file? (y):<br>
For the 32 general purpose registers rO-r31 the user can either use: Synchronous 3 port (2r1w) RAM, where a fast write-through not required, or Synthesized arrays of d-latches that require a write pulse to be generated<br>
-33-<br><br>
Standard synthesis script assumes a 90°-delayed clock signal. We desire a synchronous 3 port RAM and so we select y<br>
		Fast Load Returns	<br>
Enable Fast load returns? (n):<br>
Fast Load returns, if the current instruction does not use register write back then the pipeline is not stalled. Our design allows us to take advantage of fast return loads and therefore we enter 'yes'.<br>
......-...-.-.--.-.-...-.... Extensions Builder --.---	-...-.-<br><br>
Select the extensions to be added to the ARC<br>
1. Continue<br>
2.32x32 Barrel shifter o rotate, arithmetic and logical shifts -1 cycle<br>
3.32x32 Barrel shifter - rotate, arithmetic and logical shifts o Multi-cycle<br>
4.	Small multi-cycle 32x32 Multiply<br>
5.	Faster (&amp; larger) 32x32 Multiply<br>
6.16x16 Multiply/Multiply Accumulate function with 36 bit accumulator - Fast 7.16x16 Multiply/Multiply Accumulate function with 36 bit accumulator Slow<br>
8.	Swap function - swaps upper and lower 16 bits of 32 bit word<br>
9.	MINfMAX function o 32 bit precision<br>
10.	Normalize function - finds first bit set m 32 bit word<br>
11.24-bit Timer which counts to limit and then generates an interrupt<br>
12.	A Scratchpad RAM<br>
13.	A Scratchpad RAM with Sliding Pointers<br>
Please select:<br>
The above menu shows all the standard extensions, the user can select lots of different combinations depending on his needs.<br>
Wa will select mutti-cycle barret shifter. Fast Mul/MAC. scratchpad RAM with sliding pointers and swap. Entering 3,7,12 and 8 does this. We really wanted a Normalize extension rather than Swap. We disable Swap by entering 8 again and then enter 10 to select normalize.<br>
34-<br><br>
Note that the usar cannot select bath types of barrel shifters, in an install, selecting one automatically deselects the other. This also applies to bath instances of the 32x32 multiplier, the MAC and both instances of the Scratchpad RAM.<br>
We will now enter 1 to continue.<br>
-._.-,_-_.-.-.-._.-,._.-.-,..._ Technology Selection ---.---------.--.-<br>
Feature sue (drawn) of technology in use<br>
1.	0.35um<br>
2.	0.5um<br>
3.	0.65urn<br>
4,0.8um<br>
5.1.0um<br>
Please select (5):<br>
The feature size provides timings for DATA / TAG ram simulation &amp; synthesis models and the core registers. Our chosen technology is 0.35?m so press 1 to continue. If vendor models are to bB used the timings these settings produce are not used.<br>
These values are only used to set the timings for the synthesis of RAM medals. If an unsupported feature size required the user can select an arbitrary value and following the build change the clock period for the simulation of the VHOL and synthesis scripts to support the new feature size, timings of RAM etc.<br>
Targat clock speed in MHz (100)<br>
We will use the default of 100Mbz as we have specified 0.35 ?m technology.<br>
Clock skew for synthesis (+/-0.4ns): The default of 0.4ns will be used for this example. Library for extensions logic? (user):<br>
Here tha user can specify a name for his user library. This name will be used as the VHDL library names and during the install when creating directories and copying subsequent files to these directories. The name entered ts arbitrary so we will enter sam.<br>
-35-<br><br>
-.-...-.-........		Memory Extensions	--<br>
Select the memory extensions to be added to the ARC interface<br>
1. Continue<br>
- * load/Store memory controller<br>
3.	* Instruction fetch memory controller<br>
4.	* Host interface for communications with ARC<br>
5.	* Arbitration unit for memory accesses<br>
6.	* RAM Sequencer<br>
Please select:<br>
Here the memory extensions for off chip memory are selected. The (O/ST memory controller is not optional, and is thereforce permanently selected. To show the full use of the build script we are selecting all memory extensions. To do this there must a   next to each number, if not type that number (and pressing enter), finally enter 1 to continue.<br>
The queue depth for the Load/Store Memory Controller is fixed, i.e. 4 deep with a max of 2 stores.<br>
Having continued the above information message is displayed.<br>
----.--.-._.---.,. .Ld/St Memory Controller	- - - --Select<br>
RAM for local load/store operations. 1. No Local RAM 2. 512 x 32 bit of Local RAM 3. 1024x32 bit of Local RAM 4. 2048x32 bit of Local RAM 5.4096x32 bit of Local RAM Please select (3) :<br>
The size of RAM to be used for local memory can be specified. We want 8 KbytBS of 32 bit local ram and so enter 4. Tha local RAM is situated at the top of memory by default (determined by the external address width) and therefore hat a base address of {Maximum RAM size o local RAM size).<br>
.--------.--- (l-fetch Memory Controller	 -Select<br>
type of Instruction Fetch memory system 1. Dummy Metch unit for User Definition<br>
o36-<br><br>
A Direct Mapped Cache Please select (2):<br>
There are several different ways in which the instruction fetch memory system can be defined.<br>
1.	Dummy (-fetch, creates a template VHDL file for the user to edit<br>
2.	Direct mapped cache.<br>
We are using the default, 2, Direct Mapped Cache.<br>
......-.-.-.-.-.-.-.---.-- lifetch Modes -----.-.1 -._._..-.-.-..-.-.-<br>
Select the instruction Cache Modes<br>
1.	Continue<br>
2.	Standard Cache with debug and cache bypass capability.<br>
3.	Virtual Cache<br>
4.	Mixed Code RAM / lcache space &amp; Cache line lock<br>
Please select:<br>
The first thing the script needs to know is what kind of cache do the user want. It's possible to have a:<br>
1. Standard Cache<br>
Z Virtual cache allows a user to dynamically resize the cache in software<br>
3. Mixed Code RAM / Icache space with Line locking<br>
We have previously looked at using Virtual Cache to experiment with a range of cache configurations. Using this<br>
method we have found a standard cache configuration that gives the required performance to cost ratio for our<br>
application. We are therefore selacting Standard Cache.<br>
Please select thB max size of the Direct Mapped Instruction Cache.<br>
1. 0.5k bytes, 128 words<br>
2. 1Ik bytes. 256 words<br>
3. 2k bytes, 512 words<br>
4. 4k bytes, 1024 words<br>
5. 8k bytes, 2048 words<br>
6. 16k bytes, 4096 words<br>
7. Other size<br>
Please select (6):<br>
37-<br><br>
The Direct Mapped Instruction cache is user definable, using the script the user can input select sized from 512 bytes (128 words), up to 16k bytes (4k words). Other sizes (larger or smaller) can be manually input using option 7. For our test 6K bytes (selection 5) is sufficient.<br>
Please select the mm sue of the Direct Mapped Instruction Cache. 1.0.5k bytes, 128 words 2. Ik bytes, 256 words 3.2k bytes, 512 words<br>
4.	4k bytes, 1024 words<br>
5.	8k bytes, 2048 words<br>
-- 16k bytes, 4096 words<br>
7. Other sue<br>
Please select (1):<br>
As we are using a virtual cache, it is necessary to specify a lower limit for the cache size. When using a virtual cache it is possible to artificially set the cache to any size between the maximum and minimum using software. For this test we want to test a large range of cache sizes down to the very small, therefore we select 7.<br>
Please enter the min size of the Direct Mapped Instruction Cache in bytes. NOTE: Size must be a power of two also 4 
As we are testing a large range of caches we have decided to choose 128 bytes as our minimum cache size. Entering 128 and pressing enter sets this constant At this menu we can use abbreviations, 16k for example is the same as entering 16384.<br>
Select a max Cache one length 1.2 instruction words 2.4 instruction words 3.8 instruction words 4.18 instruction words 5.32 instruction words<br>
6.	Other size<br>
Please select (3):<br>
-38-<br><br>
The cache line length is the number of words tetched when a cache miss occurs. The script has options for 2. 4, 8, 16, or 32 word lines, the default being 8 words. Typing ENTER here, like all other menus, selects the default. 3, giving a cache line length of 8 words.<br>
Select a mm Cache line length 1.2 instruction words 2.4 instruction words 3.8 instruction words<br>
-	16 instruction words<br>
-	32 instruction words<br>
6. Other size<br>
Please select (3):<br>
When using a virtual cache, as with the cache size, the user must also specify a minimum cache line length. 1 wilt give a minimum line length of 2 instruction words, which is the choice we have made.<br>
Cache size, line length and external address, afl go to determine the size of the tag RAM. Larger cache means more tag words and f Bwer tag bits. Longer line length means fewer tag words and more tag bits.<br>
.................. Host Interface Communications --------------- --Select<br>
from available host communications ports.<br>
1.	Dummy Host Communications Port<br>
2.	Standard PC/SUN Parallel Communications Port<br>
3.	JTAG Communications Port<br>
Please select 12] :<br>
Host port for 1(0 communications can be either a dummy VHDL file, which the user can edit to create a user defined communications port, standard PC/SUN or JTAG communications ports. We are selecting 2, PC/SUN, as we are not using our ARC with custom hardware.<br>
.......................... Memory Arbitrator<br>
.......................... -Select<br>
the channels that you would like the memory arbitrator to service.<br>
1. Continue<br>
o Load/Store channel for external memory accesses.<br>
o * Host Interface channel for debugging and data downloading.<br>
-39-<br><br>
' Instruction fetch channel for I cache.<br>
" Local Scratch-pad RAM channel for burst readi/wntes. 6. Additional Channels Please select:<br>
How this menu looks is very dependent on the selections that have been made before, as most options are mutually inclusive with other selections. For test purposes we are adding some additional channels 6.<br>
How many additional channels do you want? (1-10):<br>
The user can select from between 1 and 10 extra channels. Enter 5 to give 5 additional channels.<br>
1. Continue<br>
o	* Load/Store channel for external memory accesses.<br>
o	* Host Interface channel for debugging and data downloading.<br>
-" Instruction fetch channel for l-cache.<br>
o	* Local Scratch-pad HAM channel for burst reads/writes.<br>
6. * Additional Channels(5)<br>
Please select:<br>
The number of additional channels is now displayed next to the option. We enter 1 to continue to the next menu.<br>
....................... RAM Sequencer	 - -	 - -Select<br>
the number of watt states for the RAM Sequencer. The script does not allow the user to enter a value greater than 31. If you wish use more than 31 wait states then you will have to edit the appropriate files manually. How many watt states? (31):<br>
Choou from 0-31 RAM sequencer wait states. The default and the value we are using is 31. This is a good default, as it wiH product an ARC that will run with almost any spaed memory. For simulation purposes, or if the user know that the ARC the user are building will always use a certain speed RAM, it may be useful to set the default value for the wait states to a smaller number than the maximum 31.<br>
40-<br><br>
.............	Simulation -	<br>
Selection of the state of the ARC on reset is important since it is preferable to have the system build start on reset while the core build should halt on reset since the host effectively clears the halt bit during simulation. Do you wish to halt the ARC at address location 0 on reset (n):<br>
We have entered 'n' here, that means the ARC starts running the code at address 0 on reset. Had we selected "y" the<br>
ARC is halted immediately on reset.<br>
The default for this Y on core build and N on generic and ARC Angel builds.<br>
Is your VHDL simulator Model Technologies VSystem? fy):<br>
ARC Cores Technologies we enter y' as we use MTI VSystem to simulate our VHDL If the user use 8 different simulator, select no. The user may set his environment up for his simulator by editing tha makefile and other support files, after the install has completed.<br>
Do you wish to use the R.T.L And SeeCode Application Link (RASCAL)? (n):<br>
RTL And See-Code Application Link, otherwise known as RASCAL", is extra utility that connects the Metaware debugger to connect to the Modeltech simulator. This allows the debugger to control the simulation of code on the ARC system model in the MTI simulator for Hardware/Software Co-Verification. To include RASCAL we enter y and press enter.<br>
	........_..._......._._._ install Directory -.----	.............<br>
Full path to ARC user working directory (/homelsomeonefsystemarc):<br>
At this prompt the user have to specify a destination directory name (with full path).<br>
The path must not include /tmp_mnt/ etc.<br>
Wo will select the default, a directory named "systemarc" created where we launched the ARC system builder.<br>
What we have built l-fetch address bus width 22-bit External address bus width 24-bit Register file 3-port RAM Fast load returns 'yes'<br>
41-<br><br>
Extensions Multi-cycle barrel shifter.<br>
Fast Mul/MAC.<br>
Scratchpad RAM with sliding pointers.<br>
Technology size 0.35 ?m<br>
Clock speed 100 MHz<br>
Clock skew 0.4 ns<br>
Users library name 'sam'<br>
Memory Extension Load/Store memory controller<br>
Instruction fetch memory controller<br>
Host interface for communications with ARC<br>
Arbitration unit for memory accesses<br>
RAM Sequencer<br>
Ld/St memory size 8 Kbytes.<br>
Type of I-Cache Direct Mapped Cache<br>
1 Cache made Virtual Cache<br>
1-cache sue. Max / Min 8K bytes 128 bytes<br>
Cache line length Max / Min 8 instruction words 2 instruction words<br>
Host communication port Standard Sun/PC<br>
Arbitration Channels Load/Store channel for external memory accesses<br>
Host l/f channel for debugging and data downloading<br>
Instruction fetch channel for l-cache<br>
Local Scratch-pad RAM channel for burst<br>
roads/writes<br>
Additional Channels (51<br>
Ram Sequencer Wait states 31<br>
Halt ARC on Resat? 'no'<br>
Destination directory /home/user/systemarc<br>
Simulator - MTI? 'yes'<br>
RASCAL? 'yes'<br>
3.         ARCAngel<br>
The final build is ths ARCAngeL A large number of the selections on the ARCAngel build are chosen automatically due to the nature of ths ARCAngel development board.   The ARC Angel development board is described in detail in<br>
42-<br><br>
		, which is incorporated herein by reference in us<br>
entirety.<br>
_._._._._._._._........_._.. Fast Load Returns -- -.-----.------------<br>
Enable Fast load returns? (n):<br>
Fast Load returns, if the current instruction does not use register write back then the pipeline is not stalled. ARCAngel development allows the use of fast return loads and so will our final design, therefore we enter 'yes'.<br>
............-.-.-.-.-.....-.- Extensions Builder -.-.--.-.-----.-.---.-.-<br>
Select the extensions to be added to the ARC<br>
1. Continue<br>
2. 32×32 Barrel shifter o rotate, arithmetic and logical shifts -1 cycle<br>
3. 32x32 Barrel shifter o rotate, arithmetic and logical shifts o Multi-cycle<br>
4. Small multi-cyela 32x32 Multiply<br>
N/A Faster (&amp; Larger) 32x32 Multiply<br>
N/A 16x16 Multiply/Multiply Accumulate function with 36 bit accumulator - Fast<br>
7. 16x16 Multiply/Multiply Accumulate function with 36 bit accumulator - Slow<br>
8.	Swap function o swaps upper "and lower 16 bits of 32 bit word<br>
9.	MIN/MAX function - 32 bit precision<br>
10.	Normalize function - finds first fait set in 32 bit word<br>
11." 24-bit Timer which counts to limit and then generates sn interrupt N/A A Scratchpad RAM NfA A Scratchpad RAM with Sliding Pointers<br>
, Note the multi-cycle barrel shifter has been selected along with the 24-bit timer. These have been selected as part of the standard Altera configuration, however, the system will still function correctly without them. Please select:<br>
The above menu shows ill the standard extensions, the user can select different combinations depending on his needs.<br>
Note: The scratchpad RAM and the single cycle barrel shifter are too large to fit on the current ARCAngel FPGA, as are the fast 32x32 multiplier end the fast MUL/MAC. Also a build with all extensions selected will not fit on the current FPGA.<br>
43-<br><br>
The 24-bit Timer is automatically selected, as it is a common selection on an ARC Angel build. We are using this extension however the user can deselect it by entering the corresponding number. We will also select the Multi-Cycle Barrel shifter and the Small 32x32 multiply. Entering 3 then 4 does this.<br>
Note the user cannot select the fast type of Mul/MAC, in an install, if the user attempt to select it the ARC system builder prompts the user for another response.<br>
We will now enter 1 to continue.<br>
_._.....-.-.......-.......... lfetch Modes	----------<br>
Select the instruction Cache Modes.<br>
1.	Continue<br>
2.	"Standard Cache with debug and cache bypass capability.<br>
3.	Virtual Cache<br>
4.	Mixed Code RAM / lcache space &amp; Cache line lock<br>
Please select:<br>
The first thing the script needs to know is what kind of cache do the user want. It is possible to have a:<br>
1.	Standard Cache<br>
2.	Virtual cache allows a user to dynamically resize the cache in software.<br>
3.	Mixed Code RAM / lcache space with Line locking<br>
Selecting 3 allows standard Cache with the extra features of Code RAM and Line locking.<br>
Please select the norm size of the Direct Mapped Instruction Cache.<br>
1. 0.5k bytes, 128 words<br>
2. 1k bytes, 256 words<br>
3. 2k bytes. 512 words<br>
4. 4k bytes, 1024 words<br>
5. 8k bytes, 2048 words<br>
6. 16k bytes, 4096 words<br>
Please select (3):<br>
44-<br><br>
The Direct Mapped Instruction cache is user definable, using the script the user can input select sized from 512 bytes (128 words), up to 16K bytes (4k words). Other sizes (larger or smaller) can be manually instantiated but for our lest 4K bytes (selection 4) is sufficient<br>
The ARCAngel has onboard tag-RAM but uses external memory for the cache data-RAMS, so selecting larger cache sizes does not drastically affect the amount of RAM resources available on the Altera device.<br>
Cache line length 1.2 instruction words 2.4 instruction words 3.8 instruction words 4.16 instruction words 5.32 instruction wards Please select (3):<br>
The cache line length is the number of words fetched when a cache miss occurs. The script has options for 2,4, 8,16, or 32 word lines, the default being 8 words. Entering 2 will give a cache line length of 4 words, suitable for our test.<br>
..........--. Host Interface Communications --------------- -Select<br>
from available host communications ports.<br>
1.	Standard PC /SUN Parallel Communications Port<br>
Z JTAG Communications Port<br>
Please select (1):<br>
Host port for I/O communications can be either a standard PC/SUN or a JTAG communications port. We are selecting<br>
2,	JTAG, as we wish to have art ARCAngel that can communicate to a range of host machines via the industry<br>
standard JTAG.<br>
................-.......... Simulation ---.-.-.--.-.-.----<br>
Selection of the state of the ARC on reset is important since it is preferable to have the system build start on reset while the core build should halt on reset since the host effectively clears the halt bit during simulation. Do you wish to hah the ARC at address location 0 on reset (n):<br>
We have entered 'n* here, that means the ARC starts running the code at address 0 on reset. Had we selected 'y' the ARC is halted immediately on reset.<br>
45-<br><br>
The default for this Y on core build and N on generic and ARCAngel builds. Is your VHDL simulator Model Technologies VSystem? (y):<br>
At ARC Cores we enter 'y' as we use MT1 VSystem to simulate our VHDL ff the user use a different simulator, select no. The user may set his environment up for his simulator by editing the makefile and other support files, after the install has completed.<br>
Do you wish to use the R.T.L And SeaCode Application Link (RASCAL)? (nl :<br>
RTL And See-Code Application Link, otherwise known as RASCALTM, is extra utility that connects the Metaware debugger to connect to the Modeltech simulator. This allows the debugger to control the simulation of code on the ARC system model in the MTI simulator for Hardware/Software Co-Verification. The default of n is selected by simply pressing enter.<br>
...-.-.......-.-.-.-.--.. Install Directory -	--	-<br>
Full path to ARC user working directory( /home/someone/arcangel):<br>
At this prompt the user have to specify a destination directory name (with full path).<br>
The path must not include /tmp_mnt/ etc<br>
We will select tha default: a directory named "arcangel" created where we launched the ARC build script.<br>
NOTE: Even though tha bus width is set to 26-bits, the memory model for a ARCAngel build simulation is 512Kbytes.<br>
What we have built<br>
Fast Load returns? 'yes'<br>
Extensions Multicycle barrel shifter.<br>
24-bit timer.<br>
Small 32x32 multiplier<br>
Oirect mapped instruction cache size 4K bytes<br>
Cache line length 4 instruction words<br>
Host interface controller JTAG<br>
Ram Sequencer SRAM 0 Wait itates<br>
Halt ARC on Reset? 'no'<br>
Destination directory /home/user/systemarc<br>
46-<br><br>
Simulator - MTI? "yes" RASCAL? 'no'<br>
4.	Core Verification system<br>
The Cora verification is a build which creates an ARC system and appropriate test files to verify that the ARC VHDL<br>
behaves as described in the ARC Programmers Reference manual.<br>
	-..-.-.-.-.-.-.-.- Core Register File Selection --	-.-.-.--.<br>
The 32x32 register file can be implemented using a synthesized array of d-latches, or by using a three-port (2 read, 1 write) synchronous RAM call. Use a synchronous 2r1w RAM for the register file? |y):<br>
For the 32 general purpose registers rO-r31 the user can either use : Synchronous 3-port (2r1w) RAM, where a fast write-through not required, or Synthesized arrays of d-latches that require a write pulse to be generated. Standard synthesis script assumes a 90°-delayed dock signal. We selected a synchronous 3-port RAM and so we select y.<br>
-.-.-.-.-.-.-..-.-.-._._._._ Technology Selection -----.---.-.-.-.---¦-.-.--<br>
Feature size (drawn) of technology in use<br>
1. 0.3 5 urn<br>
2. 0.5um<br>
3. 0.65um<br>
4. 0.8um<br>
5.1.Oum<br>
Please select (5):<br>
The feature size provides timings for DATA / TAG ram simulation &amp; synthesis models and the core registers. Our chosen technology is 0.657m so press 3 to continue.<br>
Target dock speed in MHz (50)<br>
We will use the default of 50Mhz is we have specified 0.65 ?m technology.<br>
Clock skew for synthesis (+/-0.4ns):<br>
47-<br><br>
The default of +/- 0.7m will be used for this example Library for extensions logic? (user):<br>
Here the user can specify a name for his user's library. This name will be used during the install when creating two directories and copying subsequent files to these directories. The string entered is arbitrary so we will enter 'tom'.<br>
..-...-.--.-.-.-..---.- Simulation -.-----.-.--.-.----¦----<br>
Selection of the state of the ARC on reset is important since it is preferable to have the system build start on reset while the core build should halt on reset since the host effectively clears the halt bit during simulation. Do you wish to hart the ARC at address location 0 on reset (y):<br>
Wo have entered Y here, that means the ARC is halted immediately on reset. Had we selected V the ARC starts running the code at address 0 on reset.<br>
The defaults are T for a core build and 'N' for generic and ARC Angel builds.<br>
Note you will have to set the status register to the appropriate start address and clear the halt bit through the host interface before running the simulation. You can manually edit "are_start" in xaux_regs.vhdi so that the ARC is running following a reset<br>
Having selected 'Y' the above information message is displayed. Is your VHDL simulator Model Technologies VSystem? (y):<br>
At ARC Coras we enter 'Y'as we use MTI VSystem to simulate our VHDL If the user use a different simulator, select no. The user may set his environment up for his simulator by editing the makefile and other support files, after the install has completed.<br>
............................. tnstall Directory --	-<br>
Full path to ARC user working directory (/home/someone/verifyarc):<br>
At this prompt the user have to specify a destination directory name (with full path).<br>
48-<br><br>
The path must not include /tmpmnt/ etc<br>
We will select the default, a directory named "venfyarc" created where we launched the ARC system builder.<br>
What we have built:<br>
Technology<br>
Feature Size 0.6 5 um<br>
Clock Speed in MHz 50 MHz<br>
Clock Skew in ns +/ 0.7 ns<br>
Halt ARC on Reset' 'yes'<br>
Destination directory /home/user/venfyarc<br>
Simulator - MTI? 'yes1<br>
Once the script has completed the install, the base case / ARCAngel build generates files for simulation and synthesis. The Generic builder can generate files for simulation provided all the required memory extensions are selected. For all types of build the VHDL that the user can modify has been included in the directory :./vhdl<br>
As default the test code is linked to the tests: -Core/<br>
Generic &amp; ARCAngel builds: mem.hex<br>
Core Verification build : testscript.hcs*<br>
Type of Tests Hex Directories<br>
ALU and<br>
interrupts<br>
Core_b<br>
Extension Core<br>
Interfaces<br>
Core_x<br>
Extension<br>
interfaces<br>
Ext_x<br>
Host interface hm<br>
Auxiliary logic Aux_x<br>
Base Case<br>
For simulation a makefile is auto-generated to compile all the selected VHDL for the MTI VSystem simulator. Type 'make' to build database, see makefile header for information on using the makefile with other simulators. To simulate,<br>
--49-<br><br>
simply type 'coretest'. This runs the Model Technologies simulator from the command line. The behavior of the ARC core ts displayed in the form of a pipeline diagram (SEE FIGURE 3) that shows the state of the processor as it processes each instruction. The user is made aware when host interface accesses are taking place, in addition to Load/Store from external memory. NOTE: The code will be executed twice for the default set-up since it is run in normal mode and also in single step mode where each instruction is single stepped through the pipeline The single step feature is only executed upon successful conclusion of the test code in normal operational mode. Upon conclusion the user is made aware whether the test being simulated passed or failed.<br>
To synthesize, type 'synarc', which runs the synthesis scripts for Synopsys Design Compiler. Simulation Display Example of Pipeline diagram.<br>
# 1 2975ns: Z 000001AO 7FFFFFFF	<br>
# 13025ns: Z 000001A0 7FFFFFFF	<br>
# 13075ns: Z 000001A0 601F7C00 mov	<br>
# 13125ns: Z 000001A4 80000000 80000000 mov -	<br>
# 13175ns: Z 000001A8 48000100 rlc.f	- mov -<br>
# 13225ns. Z 000001AC 601FFE00 mov rlc.f	wb. r0 
# 13275ns: Z 000001B0 48000100 rlcf mov rlc f -# 13325ns: Z CV 000001B4 57E07A01 sub.f rlc f mov wb: rO <. z cv nop sub.f rlcf wb: ro wb : o></.>
#13475ns: Z 000001 C0  FFFFFFFF	nop nop -<br>
# 13525ns: Z 000001C0 FFFFFFFF	- nop -<br>
Empty slots Long Immediate<br>
Stage 4 -Writeback<br>
to<br>
core register<br>
Condition<br>
Code<br>
Rags<br>
Data Word<br>
-50-<br><br>
Program<br>
Counter<br>
Opcodes in pipeline stages!   3 Simulation<br>
Time Stage 4<br>
Generic build &amp; ARCAngel builds<br>
The ARCAngel build allows the designer to simulate and synthesize an ARC to the FPGA on the ARCAngel development board so that extensions and other features that have been added can be debugged. The generic build is similar however memory extensions can be added in addition to the core extensions. This build allows the designer to simulate most variations although certain combinations provide "Dummy' blocks for the designer to add their own functionality The generic system can be synthesized from auto-generated scripts for the Synopsys Design Compile). To simulate, simply type 'asictest'.<br>
To run code in the Generic or ARCAngel builds<br>
First . we need to have produced a Mentor-quicksim format HEX file from the Metaware tools - This has already been done for basecase and extensions test code, since the basecase memory models read these fues. The system builds are also capable of reading hex files, however, the user must be aware that test code generated must Upon conclusion (when the ARC has been halted) the user is made aware whether the test being simulated passed or failed. This is accomplished by reading the contents of the Status register via the host port to check whether the Zero flag has been set.<br>
Core Verification system build<br>
The Core verification system defaults to settings that allow the user to simulate, synthesize and verify the ARC core. For more information see the ARC core verification overview document<br>
4.2 Running Extensions test code<br>
When an installation has been completed, the simulation is sei up to run the basecase test code. The VHDL reads a file 'init_mem.hex' from the working directory that contains a memory image of the test program. Compiling the extensions test source code (testxalu-s) with the script mw.bat created these files.<br>
Memory image Tests<br>
x_bshift.hex 32 bit barrel shift/rotate block<br>
x_mmmax.hex MIN and MAX instructions<br>
x_mul64.hex 32 x 32 Scoreboard multiplier with 64-bit result<br>
5f<br><br>
x_mulmac.hex 16-bit Multiply/Multiply-accumulate function with 36 bit<br>
accumulator<br>
x_norm.hex Normalize (find-first-bit) instruction<br>
x_swap.hex SWAP instruction<br>
x ldstram.hex Local LD/ST RAM<br>
x_timer.hex 24-btt timer counter<br>
xscratch.hex Scratch Pad RAM.<br>
x_slide.hex Scratch Pad RAM with sliding pointers.<br>
x_all.hex All extensions together.<br>
For example, to test an ARC configured with the barrel shifter block, do the following from the working directory: rm imt_mem.hex In -s sARCHOME/exts|src/metaware/x_bshift.hex mit_mem.hex Now run the VKDL simulation. To replace the link to the basecase lest cade: rm imt_mem.hex In s SARCHOME/arc/src/coretest.hex int _mem hex<br>
Single step tests (For Core build)<br>
The standard testbench runs the code provided in mit_mem.hex, and then runs it again, single stepping each of the instructions. Editing the file vhdl/memcon2.vhdl can disable this. Altering the signal assignment of no_step_test to supply the value '1' does this.<br>
Tests (For Generic/ARCAngel build)<br>
The standard testbench runs code provided in imt_mem.hex. Modifying the variable do_pc_test to T in glue.vhdl can also set the PC test, provided that the hex file sARCHOMEJexts/src/metawarelaa.hex is used. Note that single step instruction mode for test code can be enabled by modifying the variable no_step_test to '0' in glue.vhdl. The single stepping feature is executed only when the test code has been successfully run in normal operation mode.<br>
To create further additions to the test the user can use the METAWARE HighC compiler. The core build can read the output from the METAWARE tool set directly, i.e. HEX format files. The ARCAngeligenenc builds also read the HEX format files output by HighC.<br>
o52-<br><br>
Cache test code<br>
Test coda has been provided to allow the cache logic to be tested. It must be edited by the user to set the cache sue which is in use. Make a subdirectory under his working area, and copy the appropriate files into tt:<br>
llama &gt; mkdirsrc<br>
liama&gt; cdsrc<br>
llama &gt; cp $ARCHQME/exts/src/metaware/cathe.".<br>
llama &gt; cp $ARCHQME/exts/src/metaware/macros.s.<br>
llama&gt; chmod +w caches<br>
Now edit the test code file caches to set the CACHES1ZE variable to the appropriate value, and recompile the code This will require a certain amount of copying files between PC and Sun systems if the Metaware tools are not available on the Sun system.<br>
llama &gt; cache.bat<br>
The user may now either link cache.hex to imtjnem.hex for his specific build, i.e. core or system. The designer can edit the files in the VHOL directory to modify or add features to the extension core logic:<br>
-xalu. vhdl Extension aiu functions.<br>
xdefs.vhdl Extension instruction opcodes, auxiliary registers and other<br>
constants.<br>
xrctLvhdl Extension control logic for pipeline flow.<br>
xaugs _regs.vhdl Auxiliary registers.<br>
xcorej-egs.vhdl Core registers.<br>
There are memory extension files that can be edited. Depending on the user's selection, files that can be edited are as<br>
follow:<br>
¦sram_seq.vhdi RAM sequencer.<br>
mc_sys.vhdl Memory arbitration unit.<br>
mc_arc.vhdl LdJst memory controller.<br>
dmccvhdl Direct mapped cacha controller.<br>
t_fetch.vhdl Dummy instruction fetch.<br>
mm.vhdl External memory iff unit.<br>
The synthesis scripts and support files can also be edited: o<br>
¦53-<br><br>
synopsys dcsetup Technology-specific setup usBr_synopsys dcsetup ARC-specrfic setup. Included by above scripts/elaborate.dc Elaboration of VHDL scnptsianalyse.de Analysis of VHDL scripts/do alhdc Complete synthesis of design.<br>
Hierarchy Generation<br>
If additional files ate added to the hierarchy then the makefile must be modified to reflect this.<br>
Command line parameters:<br>
NAME<br>
system Jjuilder - builds ARC VHDL files for simulation &amp; synthesis.<br>
SYNOPSYS<br>
systemJiuilder ARCgui [-parameters)<br>
DESCRIPTION<br>
The system builder<br>
REQUIRED PARAMETERS<br>
build^type [value] core, generic, altera, core verification<br>
-ifetch_addri value] 19-26<br>
-ext addr [value] 19-32<br>
otech [value] Feature sue. e.g. 0,35um<br>
ck_speed [value] Clock speed in MHz e.g. 100<br>
¦ck_skew [value] Clock Skew +1- value in (is<br>
extJib [value] Name to be used for ext. library.<br>
-local_ram [value] Amount of Local loadlst RAM<br>
¦ifetch_system {value) dummy. Direct Mapped Cache<br>
cachasize [value] Cache size<br>
¦cachejmajength [value] Cache Line length<br>
-add_chan [valuel Additional channels<br>
-wait^states [value] Ram sequencer wart states<br>
¦54<br><br>
-install_dir [path) Where destination dir is to be created install name [dir name] Name of the destination directory<br>
OPTIONAL PARAMETERS<br>
-registeMile Use synchronous RAM cell register file, ocache Cache enabled -Idst_cont load/store controller ohostif cont host interface controller -host port [value] PC.dummy oifetchcont l-fetch memory controller -arbitrator Memory Arbitrator .-ramseq Ram sequencer<br>
sramchan Ram Sequencer Memory Arbitrator channel halt Halt the ARC on reset mi\ Compile for use with MTI Vsystem.<br>
¦55<br><br><br>
-56-<br><br>
WE  CLAIM   :<br>
I.         An apparatus-adapted to generate integrated circuit designs,<br>
comprising:<br>
a processor capable of running a computer program; a storage device operatively coupled to said processor, said storage device being capable of storing at least a portion of a computer program;<br>
an input device, operatively coupled to said processor capable of receiving input from a user and transmitting said input to said processor; and<br>
a computer program resident at least in part on said storage device, said computer program adapted to perform the following acts:<br>
receiving one or more inputs from a user for at least one customized parameter of the integrated circuit:<br>
receiving an identification of a location of one or more library Files that provide at least one prototype description and at least one extension logic description for the integiated circuit for which a model is being generated; and<br>
generating a customized description language model based on at least one customized parameter, the at least one piototypc description, and the at least one extension logic description including the acts of reading at least one prototype description and modifying the ai least one prototype description by substituting values in ihe at least one prototype description or merging additional descriptions based on the at least one customized parameter<br>
2	The apparatus of claim I, wherein said description language model is a<br>
hardwaie descupnon language (HDL)<br>
-   57   -<br><br>
3.        The apparatus of claim 1, wherein said computer program is further adapted to perform the acts comprising:<br>
generating a file based on said description language model for use with a<br>
simulation; and<br>
simulating said design using said file.<br>
4.	The apparatus of claim 3, wherein said computer program is further<br>
adapted to perform the act comprising running synthesis scripts based on said<br>
description language model in order to synthesize said integrated circuit design.<br>
5.	The apparatus of claim l, wherein said processor comprises a digital<br>
microprocessor, and said storage .device comprises magnetic media.<br>
6.	A method of generating the design of an integrated circuit rendered in<br>
a hardware description language, said method being performed at a high level of<br>
abstraction and comprising the acts of:<br>
selecting a process technology;<br>
receiving one or more inputs'from a user for at least one customized parameter of the integrated circuit, including at least one parameter selected from the group comprising:<br>
(i) processor instrations, (ii) cache configuration; (iii) memory interface configuration, and (iv) system architecture configmation,<br>
receiving an identification of a location of at least one libary file that provides at least one prototype description and at least one extension logic description for the integrated circuit for which a model is being generated, and<br><br>
generating through an automated process a customized description language model based on at least one customized parameter, the at least one prototype description, and the at least one extension logic description, the automated process including the acts of reading at least one prototype description-and modifying the at least one prototype description by substituting values in the atJeast one prototype description or merging additional descriptions based on the at least one customized parameter.<br>
7.         A method of designing a configurable processor, the method comprising:<br>
receiving an identification of one Or more pre-defined instructions described in a hardware description language for the configurable processor and at least one user-defined extension description, described in user-supplied hardware description language;<br>
generating, at a high level of abstraction, a processor specification based on one or more of the pre-defined instructions described in a hardware description language and including a user-definable portion based on the at least one user-defined extension description, the user-definable portion of said specification including at least one user-defined instruction having a function associated therewith; and<br>
based on said processor specification, generating a description of a hardwaie implementation of said configurable processor<br>
8	The method of claim 7, wherein said act of generating a description<br>
comprises generating a description including control logic nccessaiy for the execution of said at least one user-defined instruction<br>
9	The method of claim 8, wherein said act of generating a description of<br>
a hardware implementation comprises describing at least an instruction execution<br><br>
pipeline having a plurality of stages, said control logic including portions associated with said stages.<br>
10.       The method of claim 7, wherein said act of generating a description comprises generating a description having at least one element selected from the group consisting of:<br>
(i) registers; (ii) condition code choices; and (iii) scratchpad RAM. 11.     * The. method of claim 7, wherein said act of generating a description comprises generating a description having at least one library of multimedia extensions.<br>
 12.       The method of claim 7, further comprising simulating said configurable processor using at least said description.<br>
13.       The method of claim 12, wherein said act of simulating comprises: running at least one script to generate simulation data; running at least one simulation using at least said simulation data; and determining the adequacy of said configurable processor based at least in part on said act of running<br>
14         The method of claim 7, further comprising synthesizing said configurable processor using ai least said description.<br>
15	The method of claim 14, wherein said act of synthesizing comprises.<br>
i mining at least one synthesis senpt lo generate synthesis data. and evaluating llie adequacy of said synthesis data based at least in part on at least one design criterion<br>
16        The method of claim 1 5, wherein said at least one design criterion comprises<br>
at least one specific processor performance criterion; and<br>
-60-<br><br>
at least one processor die size criterion.<br>
17.       The method of claim 15, further comprising;<br>
revising at least one design element when said act of evaluating indicates that said synthesis data is not adequate;<br>
re-running said at least one synthesis script using said at least one revised design element to generate revised synthesis data;<br>
and re-evaluating the adequacy of.said revised synthesis data based at least in part on said at least one design criterion.<br>
18.	The method of claim 17, wherein said at least one design criterion<br>
comprises at least one processor die si2e criterion, and said act of revising comprises<br>
revising at least one library.<br>
19.	The method of claim 18, wherein said at least one design criterion<br>
comprises at least one processor die size criterion, and said act of revising further<br>
comprises revising at least one control file.<br>
20.	The method of claim 17, wherein said at least one .design criterion<br>
comprises processor clock speed, and said act of revising comprises revising at least<br>
one library<br>
21.	The mclhod of claim 17, wherein said al least one design collection<br>
comprises piocessoi power consumption, and said acl of revising comprises revising<br>
at least one netlist (net load)<br>
22.	A computer-implemented method of generating the design of an<br>
integrated circuit at a high level of abslraclion using a description language,<br>
comprising the acts of:<br>
providing an existing processor core configuration,<br><br>
receiving one or more inputs from a user for at least one customized parameter of the existing processor core configuration for the integrated circuit device, the input being selected from a constrained set of input parameters associated with said configuration, said parameters comprising:<br>
(i) at least one custom instruction; (ii) a cache configuration; and (iii) a memory interface configuration;<br>
receiving an identification of a location of one or more library files that provide at least one prototype description and at least one extension logic description for the integrated circuit device for which a model is being generated; and<br>
generating through an automated process a customized description language model based on at least one customized parameter, the at least one prototype description, and the at least one extension logic description, the automated process including the acts of reading at least one prototype description and modifying the at least one prototype description by substituting values in the at least one prototype description oi merging additional descriptions based on the at least one customized pafameter<br>
2-i         A method of generating an extended processoi design at a high level of abstraction, comprising<br>
providing the user with a basccase processor core configuration having a base instruction set,<br>
providing a user with a plurality of optional instructions adaptable for use with said base-case core,<br>
receiving the selection of at least one of said plurality of optional instructions; receiving the selection of at least one cache configuration;<br>
-  62 -<br><br>
receiving an identification of a'location of one or more library files that provide at least one basecase description and at least one extension logic description for the integrated circuit device for which a model is being generated;<br>
generating through an automated process a customized description language model based on at least one optional instruction, the at least one basecase description, and the at least one extensfon logic description, the automated process including the acts of reading at least one basecase description and modifying the at least one basecase description by substituting values in the at least one basecase description or merging additional descriptions based on the at least one customized parameter, and<br>
wherein said plurality of optional instructions and cache configurations are constrained so as to ensure the functionality of said processor design irrespective of the user's selections.<br>
25.       A computer-implemented method of generating a customized description language model of an integrated circuit design including at least one of a microprocessor or microprocessor peripheral device comprising the following acts performed by a computer process:<br>
receiving one or more inputs from a user for at least one customized paiametcr of the micropiocessor or microprocessor peripheral,<br>
receiving an identification of a location of one or more library files that provide at least one prototype description and at least one extension logic description for the microprocessor or microprocessor peripheral for which a model is being generated, and<br>
generating through an automated process a customized description language model based on the least one customized parameter, the at least one prototype description, and the at least one extension logic description, the automated process<br><br>
including the acts of reading at least one of the prototype descriptions and modifying the at least one prototype description by substituting .values in the at least one<br>
prototype description or merging additional descriptions based on the at least one<br>
customized parameter.<br>
26.	The method of claim 25 .where the inputs are received through an<br>
interactive process.<br>
27.	The method of claim 25 wherein the inputs are received in a non<br>
description language format.<br>
28.	The method of claim 25 wherein the customized description language<br>
model includes both functional and structural description language descriptions for<br>
the microprocessor or microprocessor peripheral.<br>
29.	The method of claim 25 wherein the generating act comprises copying<br>
one or more prototype files, substituting chosen and calculated values in those<br>
prototype files and merging in additional hardware language description language to<br>
the prototype file.<br>
30.	The method of claim 25 wherein the description language is written in<br>
steps<br>
31.         A computer-implemented method of generating a customized descnption language model and associated test code of a integrated circuit design including at least one of a microprocessor or microprocessor peripheral device comprising the following acts performed by a computer process'<br>
receiving one or more inputs from a user for at least one customized parameter of the microprocessor or microprocessor peripheral;<br>
generating through an automated process a customized description language mode! based on the least one customized parameter, the automated process including<br>
- 64  -<br><br>
the act of modifying at least one prototype description by substituting values in the at least one prototype description or merging additional descriptions based on the at least one customized parameter;<br>
generating through an automated process test code associated with the . customized description language model based on the at least one customized parameter.<br>
32.	The method of claim 31, wherein the customized description language<br>
model includes both functional and structural description language descriptions for<br>
the microprocessor or microprocessor peripheral.<br>
33.	The method of claim 31, wherein said one or more inputs received<br>
from the user are received via a graphical user interface (GUI).<br>
34.	The method of claim 31, wherein the method further comprises<br>
conducting a hardware/software co-verification<br>
35.	The method of claim 34, wherein the act of conducting a<br>
hardware/software co-verification further comprises using a debugger to run software<br>
using at least a portion of the description language model<br>
36        The method of claim 11, wherein the method further comprises conducting a core verification as part of the act of generating a customized description language model<br><br>
- 65 -<br><br>
A method of managing the configuration, design parameters and functionality of an Integrated circuit (IC) design using a hardware description language (HDL). Instructions can be added, subtracted, or generated by the designer Interactively during the design process, and customized HDL descriptions of the IC design are generated through the use of scripts based on the user-edited instruction set and Inputs. The customized HDL description can then be used as the basis for generating " make-files" for purposes of simulation and/or logic level synthesis. The method further affords the ability to generate an HDL model of a complete device, such as a microprocessor or DSP. A computer program implementing the aforementioned method and a hardware system for running the computer program are also disclosed.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
		<br>
		<div class="pull-left">
			<a href="206702-light-beam-display.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="206704-a-method-for-the-synthesis-of-methanol-and-a-system-thereof.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>206703</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2001/00420/KOL</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>19/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>11-May-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>10-May-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>12-Apr-2001</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>ARC CORES LTD</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>369 BURNT OAK BROADWAY EDGWARE, MIDDLESEX HA8 5XZ</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>HAKEWELL, JAMES</td>
											<td>35 ALDENHAM AVENUE, RADLETT, HERTS, HERTS WD7 8HZ</td>
										</tr>
										<tr>
											<td>2</td>
											<td>KHAN MOHAMMED</td>
											<td>6 CURIE GARDENS, PASTEUR CLOSE, COLINDALE NW9 5JP</td>
										</tr>
										<tr>
											<td>3</td>
											<td>PLOWMAN, EDWARD</td>
											<td>VICTORIA HOUSE, 2 WARESLEY ROAD, GAMLINGAY CAMBRIDGESHIRE SG19 3NZ,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06 F 17/50</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/IB99/02030</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>1999-10-14</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/104,271</td>
									<td>1998-10-14</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/206703-method-and-apparatus-for-managing-the-configuration-and-functionality-of-a-semiconductor-design by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:53:56 GMT -->
</html>
