<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/221182-each-iteration-array-selective-loop-data-prefetch-in-multiple-data-width-prefetch-system-using-rotaing-register-and-parameterization-to-avoid-redundant-prefetch by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:55:30 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 221182:EACH ITERATION ARRAY SELECTIVE LOOP DATA PREFETCH IN MULTIPLE DATA WIDTH PREFETCH SYSTEM USING ROTAING REGISTER AND PARAMETERIZATION TO AVOID REDUNDANT PREFETCH</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">EACH ITERATION ARRAY SELECTIVE LOOP DATA PREFETCH IN MULTIPLE DATA WIDTH PREFETCH SYSTEM USING ROTAING REGISTER AND PARAMETERIZATION TO AVOID REDUNDANT PREFETCH</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method being implemented in a computer system (200), providing support for register rotation for prefetching array data (274,278) from within a loop (210), on each iteration, parameterized by the rotating register (214,216,218), embedded therein comprising: rotating register (214,216,218), embedded in the system being initialized to activate selected loop iterations (210) indicating prefetch (274,278) to a first array initiating the said prefetch operation to the first array; storing data (270) for one or more arrays (220,230), including the first array; and executing a rotation register, embedded in the said system processor to indicate a prefetch operation to a new array.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT 1970<br>
[39 OF 1970]<br>
COMPLETE SPECIFICATION<br>
[See Section 10]<br><br>
EACH  TIERATION ARRAY SELECTIVE LOOP DATA<br>
PREFETCH IN MULTIPLIE DATA WIDTH PREFETCH<br>
SYSTEM USING ROTATING REGISTER AND <br>
INTEL  CORPORATION,   a  Delaware   Corporation,   2200   Mission  College Boulevard, Santa Clara, California 95052, United States of America<br>
PARAMETERIZATION TO AVOID REDUNDANT PREFETCH       <br>
The   following   specification   particularly   describes   the   nature   of   the invention and the manner in which it is to be performed :-<br>
GRANTED<br>
26-4-2005<br>
ORIGINAL<br>
IN/PCT/2001/01455/MUMNP<br>
21/11/2001<br><br>
MECHANISM TO REDUCE THE OVERHEAD OF SOFTWARE DATA<br>
PREFETCHES Background of the Invention<br>
Technical Field The present invention relates to methods for prefetching data, and in particular, to methods for performing prefetches within a loop.<br>
Background Art. Currently available processors run at clock speeds that are significantly faster than the clock speeds at which their associated memories operate. It is the function of the memory system to mask this discrepancy between memory and processor speeds, and to keep the processor's execution resources supplied with data. For this reason, memory systems typically include a hierarchy of caches, e.g. LO, LI, L2 . . , in addition to a main memory. The caches are<br>
maintained with data that the processor is likely to request by taking advantage of the spatial and temporal locality exhibited by most program code. For example, data is loaded into the cache in blocks called "cache lines" since programs tend to access data in adjacent memory locations (spatial locality). Similarly, data that has not been used recently is preferentially evicted from the cache, since data is more likely to be accessed when it has recently been accessed (temporal locality).<br>
The advantages of storing data in caches arise from their relatively small size and their attendant greater access speed. They are fast memory structures that can provide data to the processor quickly. The storage capacities of caches generally increase from LO to L2, et seq., as does the time required by succeeding caches in the hierarchy to return data to the processor.  A data request propagates through the cache hierarchy, beginning with the smallest, fastest structure, until the data is located or the caches are exhausted. In the latter case, the requested data is returned from main memory.<br>
Despite advances in the design of memory systems, certain types of programming structures can still place significant strains on their ability to provide the processor with data. For example, code segments that access large amounts of data from loops can rapidly generate mulitple cache misses. Each cache miss requires a long latency access to retrieve the target data from a higher level cache or main memory. These accesses can significantly reduce the computer system's performance.<br>
Prefetching is a well known technique for masking the latency associated with moving data from main memory to the lower level caches (those closest to the<br><br><br>
processor's execution resources). A prefetch instruction is issued well ahead of the time the targeted data is required.  This overlaps the access with other operations, hiding the access latency behind these operations.  However, prefetch instructions bring with them their own potential performance costs.  Prefetch requests add traffic to the processor memory channel, which may increase the latency of loads. These problems are exacerbated for loops that load data from multiple arrays on successive loop iterations. Such loops can issue periodic prefetch requests to ensure that the array data is available in the low level caches when the corresponding loads are executed. As discussed below, simply issuing requests on each loop iteration generates unnecessary, i.e. redundant, memory traffic and bunches the prefetches in relatively short intervals.<br>
A prefetch returns a line of data that includes the requested address to one or more caches. Each cache line typically includes sufficient data to provide array elements for multiple loop iterations. As a result, pefetches do not need to issue on every iteration of the loop. Further, generating too many prefetch requests in a short interval can degrade system performance. Each prefetch request consumes bandwidth in the processor-memory communication channel, increasing the latency for demand fetches and other operations that use this channel. In addition, where multiple arrays are manipulated inside a loop, prefetch operations are provided for each array. Cache misses for these prefetches tend to occur at the same time, further burdening the memory subsystem with bursts of activity. One method for dealing with some of these issues is loop unrolling.<br>
A portion of an exemplary loop (I) is shown below. The loop loads and<br>
manipulates data from five arrays A, B, C, D, and E on each loop iteration.<br>
(I)	Orig_Loop:<br>
load A(I)<br>
load B(I)<br>
loadC(I)<br>
load D(I)<br>
load E(I)<br>
branch Orig_Loop<br><br>
Fig. 1 represents loop (I) following its modification to incorporate prefetching. Here, it is assumed that each array element is 8 bytes and each cache line returns 64 bytes, in which case a prefetch need only be issued for an array on every eighth iteration of the loop. This is accomplished in Fig. 1 by unrolling loop (I) 8 times, and issuing a prefetch request for each array with the instruction groups for successive array elements. Unrolling the loop in this manner adjusts the amount of data that is consumed on each iteration of the loop to equal the amount of data that is provided by each prefetch, eliminating redundant prefetches. On the other hand, loop unrolling can significantly expand a program's footprint (size) in memory, and it fails to address the bursts of prefetch activity that can overwhelm the memory channel.<br>
An alternative approach to eliminating redundant prefetches is to predicate the prefetches, calculate the predicate values on successive iterations to gate the appropriate prefetch(es) on or off. The instruction necessary to implement the predicate calculations expand the code size and, depending on the conditions to be determined, can slow down the loop.<br>
The present invention addresses these and other issues related to implementing prefetches from loops.<br>
Summary of the Invention The present invention reduces the instruction overhead and improves scheduling for software data prefetches. Register rotation is used to distribute prefetches over selected loop iterations, reducing the number of prefetches issued in any given iteration. It is particularly useful for programs that access large amounts of data from within loops.<br>
In accordance with the present invention, data is prefetched within a loop by a prefetch operation that is parameterized by a value in a register. Data targeted by the prefetch operation is adjusted by rotating a new value into the register.<br>
For one embodiment of the invention, the register that parameterizes the prefetch operation is a rotating register that indicates the address to be prefetched.  Rotating a new value into the register alters the prefetch target for a subsequent iteration of the loop. For another embodiment of the invention, the register is a rotating predicate register that activates or deactivates the prefetch operation according to the current value of the predicate it stores.  Rotating a new value into the register activates or deactivates the prefetch operation for the next iteration of the loop.<br><br><br>
Brief Description of the Drawings<br>
The present invention may be understood with reference to the following drawings, in which like elements are indicated by like numbers. These drawings are provided to illustrate selected embodiments of the present invention and are not intended to limit the scope of the invention.<br>
Figs. 1 represents a loop that has been unrolled according to conventional methods to implement prefetching from within the loop.<br>
Fig. 2 is a block diagram of one embodiment of a system in which the present invention may be implemented.<br>
Fig. 3 is a flowchart representing a method in accordance with the present invention for processing prefetches from within a loop.<br>
Detailed Description of the Invention<br>
The following discussion sets forth numerous specific details to provide a thorough understanding of the invention. However, those of ordinary skill in the art, having the benefit of this disclosure, will appreciate that the invention may be practiced without these specific details. In addition, various well-known methods, procedures, components, and circuits have not been described in detail in order to focus attention on the features of the present invention.<br>
The present invention supports efficient prefetching by reducing the instruction overhead and improving the scheduling of software data prefetches. It is particularly useful where data prefetching is implemented during loop operations. Methods in accordance with the present invention allow prefetches to be issued within loops at intervals determined by the cache line size and the data size being requested rather than by the loop iteration interval. They do so without expanding the code size or adding costly calculations (instruction overhead) within the loop. Rather, a prefetch operation within the loop is parameterized by a value stored in a selected register from a set of rotating registers. Pefetching is adjusted by rotating a new value into the selected register on each iteration of the loop.<br>
For one embodiment, the register value indicates an address to be targeted by the prefetch operation.  Where the loop includes loads to multiple arrays, a prefetch instruction is targeted to prefetch data for a different array on each iteration of the loop. The size of the rotating register set is determined by the number of arrays in the loop for<br><br><br>
which data is to be prefetched. Depending on the number of arrays to be prefetched, the size of their data elements (stride) and the cache line size, it may be preferable to employ more than one prefetch instruction per loop iteration.  In addition to controlling the frequency of prefetches for each array, reuse of the prefetch instruction for multiple arrays reduces the footprint of the program code in memory.<br>
For an alternative embodiment, the register is a predicate register and a prefetch instruction is gated on or off according to the value it holds. If the loop includes a single array from which data is loaded, the prefetch instruction can be activated for selected loop iterations by initializing the rotating predicate registers appropriately. This eliminates redundant prefetch requests that may be generated when the cache line returns sufficient data for multiple loop iterations. If the loop includes multiple arrays, multiple prefetch instructions may be parameterized by associated predicate registers. Register rotation determines which prefetch insrruction(s) is activated for which array on each loop iteration.<br>
Persons skilled in the art and having the benefit of this disclosure will recognize that the exemplary embodiments may be modified and combined to accommodate the resources available in a particular computer system and the nature of the program code. The present invention may be implemented in a system that provides support for register rotation. For the purpose of this discussion, register rotation refers to a method for implementing register renaming. In register rotation, the values stored in a specified set of registers are shifted cyclically among the registers. Rotation is typically done under control of an instruction, such as a loop branch instruction. For example, a value stored in register, r(n), on a current iteration of a loop, is shifted to register r(n+l) when the loop branch instruction triggers the next iteration of the loop. Register rotation is described, for example, in IA-64 Application Instruction Set Architecture Guide, published by Intel® Corporation of Santa Clara, California.   A more detailed description may be found in Rau, B.R., Lee, M., Tirumalai, P., and Schlansker, M.S. Register Allocation For Software Pipelined Loops, Proceeding s of the SIGNPLAN '92 Conference on Programming Language Design and Implementation, (San Francisco, 1992).<br>
The number and type of registers available for rotation may vary with the register type.  For example, Intel's IA-64 instruction set architecture (ISA) provides 64 rotating<br><br><br>
predicate register, ninety-six rotating floating point registers, and a variable number of rotating general purpose registers.  In the IA-64 ISA, up to ninety-six of the 128 general purpose registers may be defined to rotate. Rotating general purpose registers are defined in multiples of 8.<br>
Fig. 2 is a block diagram of one embodiment of a system 200 in which the present invention may be implemented. System 200 mcludes a processor 202 and a main memory 270 that are coupled to system logic 290 through a system bus 280 and a memory bus 284. System 200 typically also includes a graphics system and peripheral device(s) (not shown) which also communicate through system logic 290.<br>
The disclosed embodiment of processor 202 includes execution resources 210, a first cache (L0) 220, a second cache (LI) 230, a third cache (L2), a cache controller 250, and a bus controller 260. Processor 202 typically also includes other logic elements (not shown) to retrieve and process instructions and to update its architectural state as instructions are retired. Bus controller 260 manages the flow of data between processor 202 and main memory 270. L2 cache 240 may be on a different chip than processor 202, in which case bus controller 260 may also manage the flow of data between L2 cache 240 and processor 202. The present invention does not depend on the detailed structure of the memory system or the processor.<br>
L0 cache 220, LI cache 230, L2 cache 240, and main memory 270 form a memory hierarchy that provides data and instructions to execution resources 210. The instructions operate on data (operands) that are provided from register files 214 or bypassed to execution resources 210 from various components of the memory hierarchy. A predicate register file 218 may be used to conditionally execute selected instructions in a program. Operand data is transferred to and from register file 214 through load and store operations, respectively. A load operation searches the memory hierarchy for data at a specified memory address, and returns the data to register file 214 from the first level of the hierarchy in which the requested data is found. A store writes data from a register in file 214 to one or more levels of the memory hierarchy.<br>
For the present invention, portions of register files 214, 218 may be rotated by a register renaming unit 216. When execution resources 210 implement a loop in which prefetches are managed in accordance with the present invention, the prefetch operations are directed to different location in a data In region 274 of memon 270 by rotation of the<br><br><br>
registers. These prefetch operations move array data to one or more low level caches 220, 230, where they can be accessed quickly by load instructions in the loop when the corresponding loop iterations are reached. The instructions that implement prefetching, loading, and manipulating the data are typically stored in an instruction region 278 of memory 270 during execution. They may be supplied to main memory from a non¬volatile memory structure (hard disk, floppy disk, CD, etc.).<br>
Embodiments of the present invention are illustrated by specific code segments with the understanding that persons skilled in the art and having the benefit of this disclosures will recognize numerous variations of these code segments that fall within the spirit of the present invention.<br>
One embodiment of the present invention is illustrated by the following code<br>
segment:<br>
(II)	r41 -address ofE(l+X)<br>
r42 = address of D(l+X)<br>
r43 = address of C(l+X)<br>
r44 = address of B(l+X)<br>
r45 = address of A(l+X) (IIa)     Loop:<br>
Prefetch [r45]<br>
r40 = r45 + INCR<br>
load A(J) load B(J) load C(J) load D(J) load E(J)<br>
J = J+ 1<br>
branch	Loop<br>
A, B, C, D, and E represent arrays, the elements of which are accessed from within the loop portion of code segment (II) by the corresponding load instructions. When prefetching is synchronized properly, the data elements targeted by these loads are<br><br>
available in a low level cache, and can be supplied to the processor's execution resources with low access latency, e.g. a one or two cycles.  In code segment (II), this is accomplished by selecting appropriate values for address offset, X, and address increment, INCR.<br>
In the disclosed loop, when the current loop iteration is operating on element (J) of the arrays, the prefetch targets element (J+X) of the array. Here, X represents the number of array elements by which the targeted element follows the current element.  In effect, X represents the lead time necessary to ensure sure that element J+X is in the cache when the load targeting J+X executes. The value of X depends on the number of cycles required to implement each iteration of code segment (II), and the latency for returning data from the main memory. For example, if code segment (II) completes an iteration in 10 clock cycles and it takes 100 clock cycles to return a cache line from memory, the prefetch in the current iteration of the loop should target an element that is at least 10 elements ahead of that in the current iteration of the loop.<br>
For each iteration of code segment (II), the prefetch instruction targets an address specified in r45. Here, r45 is a virtual register identifier that points to a value in a physical register. The correspondence between the physical register and the virtual register identifier is provided by the register renaming algorithm, which in this case is register rotation. For code segment (II), r4 I - r45 are initialized to addresses of elements in arrays E - A, respectively. The values in these registers are rotated on each iteration of the loop, when the loop branch instruction is executed. Register rotation adjusts the array to which the prefetch instruction applies on each iteration of code segment (II). This eliminates the need for separate prefetch instructions for each array and the bandwidth problems associated with bunched prefetches. It also allows the frequency with which prefetches are issued for a particular array to be adjusted to reflect the size of the cache line returned by prefetches and the array stride.<br>
The assignment instruction, r40 = r45 + INCR increments the target address of the array for its next prefetch and returns it to a starting register in the set of rotating registers. In code segment (II), the prefetch targets an element of a given array every 5 iterations - the number of loop iterations necessary to move the incremented array address from r40 back to r45. As a result, a prefetch targets elements in arrays A, B, C,<br><br>
D, and E on 5 successive iterations, then repeats the cycle, beginning with array A on the 6" iteration.<br>
The increment value in the assignment instruction depends on the following parameters: the size of the cache line returned on each prefetch (L); the number of iterations between line fetches, i.e. the number of arrays that require prefetches (N); and the size (stride) of the array elements (M). The cache line size divided by the stride is the number of iterations for which a single line fetch provides data. For example, where a cache line is 64 bytes (L = 64), data is required for 5 arrays (N = 5), and each array element is 8 bytes (M = 8):<br>
INCR = N*L/M For the above example, INCR = 5*64/8 = 40.<br>
Certain ISAs, e.g. the IA-64 ISA, provide prefetch instructions that automatically increment the address to be prefetched by a specified value, e.g. prefetch [target address], address increment. For these ISAs, the prefetch and assignment instructions can be replaced by a an auto-increment prefetch instruction and a MOV instruction. For example, the first two instructions in loop (Ila) may be replaced by prefetch [r45], 40 and mov r40 = r45.<br>
Table 1 shows the iterations of Loop (II) for which elements of array A are prefetched, the current element of A when the prefetch is launched, the address of the element to be prefetched, and the elements of the array returned by the prefetch. Table entries are suitable for the case in which X = 20.<br><br>
J	CURRENT ELEMENT	PREFETCH ADDRESS	CACHE LINE CONTENTS<br>
0	A(0)	A(20)	A(16)-A(23)<br>
5	A(5)	A(25)	A(24)-A(3I)<br>
10	A(10)	A(30)	A(24)-A(31)<br>
15	A(15)	A(35)	A(32)-A(39)<br>
20	A(20)	A(40)	A(40}-A(47)<br>
25	A(25)	A(45)	A(40)-A(47)<br>
30	A(30)	A(50)	A(48)-A(55)<br>
35	A(35)	A(55)	A(48)-A(55)<br>
40	A(40)	A(60)	A(56)-A(63)<br>
45	A(45)	A(65)	A(64)- A(71)<br>
C A	<br><br>
	    A(7I)<br><br><br>
The method embodied in code segment (II) does generate some redundant    prefetches. For example, those launched on the 10lh 25  , 35th and 50'   iterations target the same cache lines as those launched on the 5th, 20th , 30th  and 45th   iterations. Redundant prefetches are generated when the number of array elements returned in a cache line is incommensurate with the number of iterations between prefetches. The level of redundancy is, however, significantly less than that obtained when prefetches are launched on every iteration.  In addition, the processor may include logic to identify and eliminate redundant prefetches.<br>
Another embodiment of the present invention is illustrated by the following code<br>
segment:<br>
(III)	p41=true<br>
p42 = false<br>
p43 - false<br>
p44 = false<br>
p45 = false<br>
p46 = false<br>
p47 = false<br>
p48 = false<br>
r4 = address of A(l+X)<br>
r5 = address of B(l+X)<br>
r6 = address of C(l+X)<br>
r7 = address of D(l+X)<br>
r8 = address of E(l+X) (IIIa)    Loop:<br>
(p41)    prefetch [r4], 64<br>
(p42)   prefetch [r5], 64<br>
(p43)   prefetch [r6], 64<br>
(p44)    prefetch [r7], 64<br>
(p45)    prefetch [r8], 64<br>
p40 = p48<br>
load A(J)<br><br><br>
load B(J) load C(J) load D(J) load E(J)<br>
J=J+ 1<br>
branch	Loop<br>
Prior to entering the loop (Ilia), a set of rotating predicate registers, p41-p48 are initialized so that at least one predicate represents a logic true value. In addition, each register/in a set of non-rotating registers, r4 - r8, is initialized to a prefetch address for one of the arrays, A - E. Here, X represents an offset from the first address of the array. As in the previous embodiment, it is selected to provide enough time for prefetched data to be returned to a cache before the load targeting it is executed.<br>
The loop (IlIa) includes a predicated prefetch instruction for each array. The true predicate value moves to successive predicate registers as the predicate registers rotate on successive loop iterations. On each iteration, the prefetch instruction gated by the predicate register that currently holds the true value is activated. The other prefetch instructions are deactivated (predicated off). Of the 8 predicate registers in the set, only 5 gate prefetch instructions. The last three are dummies that allow the prefetch frequency for an array to be synchronized with the cache line size and the array stride. For the disclosed embodiment, a prefetch is activated once every eight iterations by rotating the true predicate value through a set of 8 rotating predicate registers. This makes the number of iterations between prefetches (8) equal to the number of array elements returned by a cache line (8), eliminating redundant prefetches.<br>
For the disclosed embodiment, the activated prefetch instruction automatically increments the address in the corresponding register by 64 bytes, e.g. 8 array elements. For other embodiments, the same operations may be accomplished by a simple prefetch instruction (one without an auto-increment capability), and an assignment instruction (r4 = r4 + 64) as in code segment (II).<br>
Following the predicated prefetches, the assignment instruction, p40 = p48 rotates the value in the last predicate register of the set back to a position from which it can begin to cycle through the set of predicate registers again.  An embodiment of code<br><br><br>
segment (111) based on the IA-64 ISA may implement the assignment using the following compare instruction:<br>
(p48) comp.eq.unc p40, pO = rO,rO. The IA-64 ISA also allows the predicate initialization to be implemented by a single instruction, pr.rot = 0x20000000000, which initializes P41 to true and all other predicate registers to false.<br>
Fig. 3 is a flowchart representing a method 300 in accordance with the present invention for executing software prefetches from within a loop. Before entering the loop portion of method 300, a set of rotating registers is initialized 310. For example, rotating general registers may be initialized with the first prefetch addresses of the arrays, as illustrated by code segment (II). Alternatively, rotating predicate registers may be initialized to logical true or false values, to activate selected prefetch instructions, as illustrated in code segment (III). In this case, non-rotating general registers are initialized to the first prefetch addresses of arrays.<br>
Following initialization 310, the loop portion of method 300 begins. A cache line is prefetched 320 for an array designated through the rotating register set. For disclosed embodiments, this is accomplished through prefetch instruction(s) that are parameterized by one or more of the rotating registers. For code segment (II), the target address is the parameter and the general register specifying the target address parameterizes the prefetch.  For code segment (III), the predicates associated with the prefetch instructions are the parameters, and the predicate registers that hold these values parameterize their associated prefetches.  In each case, altering the value in the designated register changes the array targeted by the prefetch operation. Following the prefetch 320, the address of the array(s) for which the prefetch is performed is adjusted 330 to point to the cache line containing the next element to be prefetched for the array(s).<br>
Any instructions in the loop body, such as the load instructions and any instructions that operate on loaded values, are executed 340 on each iteration of the loop. While these are shown to follow prefetching 320 and adjusting 330 in Fig. 3, their relative order in method 300 is not important. The remaining instructions may be executed before, after, or concurrently with prefetching and adjusting the current array address.  On each loop iteration, a termination condition 350 is checked and the loop is terminated 370 if the condition is met.  If additional iterations remain, registers are<br><br>
rotated 360 to update the prefetch instruction for the next iteration, and the loop is repeated.  Depending on the computer system employed, registers may be rotated even when the loop termination condition is met.<br>
The present invention thus supports efficient prefetching from within a loop, by reducing redundant prefetches and distributing prefetch activity across multiple loop iterations. This is accomplished without expanding the code size of the loop or increasing the instruction overhead. A set of rotating registers is initialized, and one or more prefetch instructions within the loop are parameterized by one or more rotating registers. Operation of the prefetch instruction(s), e.g. the target address, active/NOP status, is adjusted as the registers are rotated on successive iterations of the loop. The present invention may be employed advantageously in any code that implements prefetching from within a loop.<br>
The disclosed embodiments have been provided to illustrate the general features of the present invention.  Persons skilled in the art of computer software, having the benefit of this disclosure, will recognize modifications and variations of these embodiments that fall within the spirit of the present invention. The scope of the invention is limited only by the appended claims.<br><br><br>
WE CLAIM:<br>
1. A method being implemented in a computer system (200), providing support for register rotation for prefetching array data (274,278) from within a loop (210), on each iteration, parameterized by the rotating register (214,216,218), embedded therein comprising:<br>
rotating register (214,216,218), embedded in the system being initialized to activate selected loop iterations (210) indicating prefetch (274,278) to a first array initiating the said prefetch operation to the first array;<br>
storing data (270) for one or more arrays (220,230), including the first array; and executing a rotation register, embedded in the said system processor to indicate a prefetch operation to a new array.<br>
2.	The method as claimed in claim 1, wherein the rotating register embedded in the said system stores an array address (220,230) and initializing that rotating register comprises  initializing  the  rotating • register to an address of the_first array.<br>
3.	The method as claimed in claim 2, wherein executing a said register rotation, embedded therein comprises: incrementing the address (278) in the rotating register to point to a new element of the first array; and rotating an address associated with a new array into the rotating register.<br><br>
4.	The method as claimed in claim 1, wherein, the rotating register is a designated register of a set of said rotating registers, and initializing the rotating register comprises initializing the designated register (214,216,218) to point to the first array and initializing other rotating registers of the set to point to  other arrays.<br>
5.	The method as claimed in claim 1, wherein initializing a rotating register to activate selected loop iterations (210) indicating a prefetch (274) to a first array comprises initializing the rotating register to activate a said prefetch operation that targets the first array.<br>
6.	The method as claimed in claim 5, wherein the rotating register (214,216,218) is a predicate register (214,216,218) and the said prefetch operation is activated by writing a specified logic value to the said predicate register.<br>
7.	The method as claimed in claim 6, wherein executing a register rotation comprises rotating the specified logic value (220,230) into a said predicate register that activates a prefetch operation to the new array.<br>
8.	The method as claimed in claim 1, comprising: issuing a prefetch (274) for an element of an array that is specified through a prefetch parameter (278); loading data from each of the one or more<br><br>
arrays (278); and adjusting the prefetch parameter (278), responsive to a loop branch.<br>
9.	The method as claimed in claim 8, wherein the prefetch parameter is stored in a rotating predicate register (214,216,218) that gates a prefetch associated with the array, and issuing the prefetch comprises is the prefetch when the predicate register holds a specified logic value.<br>
10.	The method as claimed in claim 9, wherein adjusting the said prefetch parameter comprises moving a new logic value into the said predicate register (214,216,218) by register rotation.<br>
11.	The method as claimed in claim 8, wherein the said prefetch parameter is an array address stored in a said rotating register, and issuing the prefetch comprises issuing the prefetch to an element of the array indicated by the address.<br>
12.	The method as claimed in claim 11, wherein adjusting the said prefetch parameter comprises rotating an address (220,230) associated with another array into the designated rotating register.<br><br><br>
13.	A method as claimed in claim 1, comprising: issuing a prefetch (274) that is parameterized by a said rotating register; adjusting an address targeted by the prefetch; and rotating a new value into the rotating register to indicate a next prefetch.<br>
14.	The method as claimed in claim 13, wherein issuing a prefetch (274) that is parameterized by a rotating register comprises issuing a<br>
prefetch having a target address specified by a value in the rotating<br>
register.<br>
15.	The method as claimed in claim 14, wherein rotating a new value into the said rotating register comprises rotating a new- target address (220,230) into the rotating register.<br>
16.	The method as claimed in claim 13, wherein the said rotating register is a rotating predicate register (214,216,218) and issuing a prefetch comprises issuing a prefetch that is gated by a predicate stored in the rotating predicate register.<br>
17.	The method as claimed in claim 16, comprising initializing a set of rotating predicate registers (214,216,218) with logic values at least one of which represents a logic true value.<br><br>
18.	The method as claimed in claim 17, wherein rotating a new value into the said rotating register comprises rotating the logic values among the set of rotating predicate registers (214,216,218).<br>
19.	The method as claimed in claim 17, wherein the number of said predicate registers initialized is determined by a frequency (220,230) with which the issued prefetch is to be gated on by the predicate register.<br>
20.	The method as claimed in claim 13, wherein the said rotating register is a predicate register (218) that activates the prefetch if a stored predicate value is true and nullifies the prefetch if the stored predicate value is false (220,230).<br>
21.	The method as claimed in claim 13, wherein the said rotating<br>
register specifies a target address of one of a plurality of arrays<br>
arid (220,230) rotating a new value into the rotating register<br>
comprises rotating a target address for one of the arrays into the<br>
rotating register.<br>
Dated	this    the 21st day	of        November,   2001<br>
JAYANTA PAL]<br>
Of Remfry &amp; Sagar<br>
ATTORNEY FOR THE APPLICANT[S]<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWNhbmNlbGxlZCBwYWdlKDI2LTQtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-cancelled page(26-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWNhbmNlbGxlZCBwYWdlcygyOC00LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-cancelled pages(28-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWNsYWltKGdyYW50ZWQpLSgyNi00LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-claim(granted)-(26-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWNsYWltcygyMS0xMS0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-claims(21-11-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWNsYWltcyhhbWFuZGVkKS0oMjYtNC0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-claims(amanded)-(26-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWNsYWltcyhncmFudGVkKS0oMjYtNC0yMDA1KS5kb2M=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-claims(granted)-(26-4-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWNvcnJlc3BvbmRlbmNlKDI2LTQtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-correspondence(26-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDE0NTUtTVVNLUNPUlJFU1BPTkRFTkNFKDI4LTgtMjAwOSkucGRm" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01455-MUM-CORRESPONDENCE(28-8-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDE0NTUtTVVNLUNPUlJFU1BPTkRFTkNFKDQtMi0yMDA5KS5wZGY=" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01455-MUM-CORRESPONDENCE(4-2-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWNvcnJlc3BvbmRlbmNlKGlwbyktKDI4LTQtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-correspondence(ipo)-(28-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWNvcnJlc3BvbmRlbmNlKGlwbyktKDQtOC0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-correspondence(ipo)-(4-8-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWRlc2NyaXB0aW9uKGNvbXBsZXRlKS0oMjEtMTEtMjAwMSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-description(complete)-(21-11-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWRyYXdpbmcoMjEtMTEtMjAwMSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-drawing(21-11-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWRyYXdpbmcoMjYtNC0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-drawing(26-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWZvcm0gMSgyMS0xMS0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-form 1(21-11-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDE0NTUtTVVNLUZPUk0gMTUoMjgtOC0yMDA5KS5wZGY=" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01455-MUM-FORM 15(28-8-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWZvcm0gMTkoMjYtMy0yMDA0KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-form 19(26-3-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWZvcm0gMWEoMjYtNC0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-form 1a(26-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWZvcm0gMigyMS0xMS0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-form 2(21-11-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWZvcm0gMihncmFudGVkKS0oMjYtNC0yMDA1KS5kb2M=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-form 2(granted)-(26-4-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWZvcm0gMihncmFudGVkKS0oMjYtNC0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-form 2(granted)-(26-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWZvcm0gMih0aXRsZSBwYWdlKS0oMjEtMTEtMjAwMSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-form 2(title page)-(21-11-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDE0NTUtTVVNLUZPUk0gMjYoMjgtOC0yMDA5KS5wZGY=" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01455-MUM-FORM 26(28-8-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDE0NTUtTVVNLUZPUk0gMjYoNC0yLTIwMDkpLnBkZg==" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01455-MUM-FORM 26(4-2-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWZvcm0gMygyMS0xMS0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-form 3(21-11-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWZvcm0gMygyNC00LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-form 3(24-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWZvcm0gMygyNi00LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-form 3(26-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWZvcm0gNSgyNi00LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-form 5(26-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWZvcm0tcGN0LWlwZWEtNDA5KDI2LTQtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-form-pct-ipea-409(26-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLWZvcm0tcGN0LWlzYS0yMTAoMjYtNC0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-form-pct-isa-210(26-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDE0NTUtTVVNLU9USEVSIERPQ1VNRU5UKDI4LTgtMjAwOSkucGRm" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01455-MUM-OTHER DOCUMENT(28-8-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLXBldGl0aW9uIHVuZGVyIHJ1bGUgMTM3KDI2LTQtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-petition under rule 137(26-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLXBldGl0aW9uIHVuZGVyIHJ1bGUgMTM4KDI2LTQtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-petition under rule 138(26-4-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLXBvd2VyIG9mIGF1dGhvcml0eSgyLTUtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-power of authority(2-5-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLXBvd2VyIG9mIGF1dGhvcml0eSgyMS0xMS0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-power of authority(21-11-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDE0NTUtbXVtLXBvd2VyIG9mIGF1dGhvcml0eSgyNi00LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-01455-mum-power of authority(26-4-2005).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="221181-novel-functional-peptide-nucleic-acid-and-process-for-producing-the-same.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="221183-dry-powder-inhaler-for-administering-medicaments-in-solid-finely-divided-form.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>221182</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2001/01455/MUM</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>42/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>17-Oct-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>18-Jun-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>21-Nov-2001</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTEL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2200 MISSION COLLEGE BOULEVARD, SANTA CLARA, CALIFORNIA 95052,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>GUATAM B DOSHI</td>
											<td>442 MADERA AVENUE NO. 10, SUNNYVALE, CALIFORNIA 94086-7414,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>KALYAN MUTHUKUMAR</td>
											<td>20219 CAMARDA COURT, CUPERTINO, CALIFORNIA 95014,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F9/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US00/13165</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2000-05-12</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09/322, 196</td>
									<td>1999-05-28</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/221182-each-iteration-array-selective-loop-data-prefetch-in-multiple-data-width-prefetch-system-using-rotaing-register-and-parameterization-to-avoid-redundant-prefetch by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:55:31 GMT -->
</html>
