<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/204467-apparatus-and-method-implementing-hierarchical-state-charts by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 07:01:21 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 204467:APPARATUS AND METHOD IMPLEMENTING HIERARCHICAL STATE CHARTS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          <div class="alert fade in alert-error"><button class="close" data-dismiss="alert">&times;</button>That patent was not found in our database</div>
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">APPARATUS AND METHOD IMPLEMENTING HIERARCHICAL STATE CHARTS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>1. Appararus Imp1emennng merarcmcal slale cnans ana comprIsIng: a slale macnme engine (SME) operative to carry out repertoires of behaviors of a system; a state chart encoder operative to replicate, in computer code form, a user-defined hierarchical state chart describing a repertoire of behaviors of said system, said encoder being operative to preserve said state chart&#x27;s hierarchical structure intact in a first data structure; an event list generator operative to generate, for each individual event from among a plurality of events within the repertoire, a list of at least one transition between states of said state chart which are associated with said individual event, said event list generator being operative to preserve said list in a second data structure; and a behavior implementer operative to activate said system to carry out each of the behaviors in its repertoire, wherein the state machine engine is operative to carry out repertoires by dynamically computing at least one new state in response to an event, without generating a static representation of all possible states and transitions in the user-defined hierarchical state chart.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
FIELD OF THE INVENTION<br>
The present invention relates to computer code and to apparatus and methods for computer code generation.<br>
BACKGROUND OF THE INVENTION<br>
Hierarchical state charts are described in "Statecharts, a visual approach to complex systems", David Harel, Science of Computer Programming, 1987.<br>
The disclosures of all publications mentioned in the specification and of the publications cited therein are hereby incorporated by reference.<br><br>
SUMMARY OF THE INVENTION<br>
The present invention seeks to provide improved computer code and improved apparatus and methods for computer code generation.<br>
There is thus provided in accordance with a preferred embodiment of the present invention apparatus implementing hierarchical state charts and including a state machine engine (SME) operative to carry out repertoires of behaviors of a system, a state chart encoder operative to replicate, in computer code form, a user-defined hierarchical state chart describing a repertoire of behaviors of the system, the encoder being operative to preserve the state chart's hierarchical structure intact in a first data structure, an event list generator operative to generate, for each individual event from among a plurality of events within the repertoire, a list of at least one transition between states of the state chart which are associated with the individual event, the event list generator being operative to preserve the list in a second data structure, and a behavior implementer operative to activate the system to carry out each of the behaviors in its repertoire.<br>
Further in accordance with a preferred embodiment of the present invention the system includes at least one of hardware and software.<br>
Still further in accordance with a preferred embodiment of the present invention the first data structure's size increases linearly in direct proportion to the number of branches in the hierarchical structure.<br>
Additionally in accordance with a preferred embodiment of the present invention the second data structure's size increases linearly in direct proportion to the number of transitions in the list of at least one transition.<br>
Moreover in accordance with a preferred embodiment of the present invention the order of the at least one transition of each of the lists corresponds to the order of evaluation of the transitions as defined by the hierarchical state chart.<br>
Further in accordance with a preferred embodiment of the present invention the plurality of events for which the event list generator generates lists includes at least one external input event.<br>
Still further in accordance with a preferred embodiment of the present invention the plurality of events for which the event list generator generates lists includes at least one internal data value change event, the apparatus also including a data value change event notifier operative to generate a notification to th6 state machine engine of each data value change event.<br>
There is additionally provided in accordance with a preferred embodiment of the present invention a method implementing hierarchical state charts, the method including providing a state<br><br>
machine engine (SME) operative to cany out repertoires of behaviors of a system   replicating, in i<br>
computer code form, a user-defined hierarchical state chart describing a repertoire of behaviors of the system, the replicating step being operative to preserve the state chart's hierarchical structure intact, generating, for each individual event from among a plurality of events within the repertoire, a list of at least one transition between states of the state chart which are associated with the individual event, and activating the system to carry out each of the behaviors in its repertoire.<br>
There is additionally provided in accordance with a preferred embodiment of the present invention an automatic code generation method including automatically generating code which forms, in memory, a replica of a hierarchical state chart which preserves the chart's hierarchical structure, automatically generating code which forms, for each of a first plurality of input events, a list of transitions affected by that input event, automatically generating code which forms, for each of a second plurality of internal data variables, a list of transitions affected by changes in that internal data variable, automatically generating code which notifies the state machine engine of changes in internal data variables, and automatically generating code which evaluates conditions and implements actions and activities.<br>
Further in accordance with a preferred embodiment of the present invention the method includes the step of providing a state machine engine operative, upon receipt of notification regarding occurrence of an event, to evaluate a list of transitions affected by the event so as to select transitions to be performed, and to perform the transitions.<br>
There is additionally provided in accordance with a preferred embodiment of the present invention a method for computing a state for a hierarchical state machine, the method including providing a state machine engine operative to receive notification regarding occurrence of at least one event, providing a hierarchical state chart describing a repertoire of behaviors of a system, providing a list of at least one transition between states of the state chart for each of the events with which the at least one transition is associated, evaluating the list of at least one transition so as to select a transition to be performed in response to the at least one event, and evaluating the hierarchical state chart to compute the state that corresponds to the selected transition.<br><br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
The present invention will be understood and appreciated from the following detailed description, taken in conjunction with the drawings in which:<br>
Fig. 1 is a simplified block diagram of a software system constructed and operative in accordance with a preferred embodiment of the present invention which includes automatically generated code which interfaces with a state machine engine (SME);<br>
Fig. 2 is a simplified flowchart illustration of a preferred method of operation for the state machine engine of Fig. 1;<br>
Fig. 3 is a simplified flowchart illustration of a preferred method for generating high level computer code from hierarchical state charts;<br>
Fig. 4 is a pictorial illustration of a computer screen generated in the course of automatically generating computer code from hierarchical state charts in a particular example;<br>
Fig. 5 is a pictorial illustration of a computer screen, generated in the course of processing the example of Fig. 4, which shows all modes making up the state chart of the example;<br>
Fig. 6 is a pictorial illustration of a computer screen, generated in the course of processing the example of Fig. 4, which shows an alternative presentation of the state chart of Fig. 5; and<br>
Fig. 7 is a simplified flowchart illustration of an automatic code generation technique operative in accordance with a preferred embodiment of the present invention.<br><br>
DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS<br>
Reference is now made to Fig. 1 which is a simplified block diagram of a software system constructed and operative in accordance with a preferred embodiment of the present invention which includes automatically generated code 10 which interfaces with a state machine engine (SME) 20. An optional interface 30 to underlying hardware (not shown) is also provided.<br>
The state machine engine 20 is a pre-built object code module that is linked, either dynamically or statically, to the automatically generated code and the interface library.<br>
The state machine engine implements the behavior of the software system preferably as defined solely by the automatically generated code that is linked with it. That being the case, the state machine engine code is typically provided only once in object code form, and does not need to be changed per software system.<br>
The state machine implements this behavior by converting input events and changes of data values into transitions within the hierarchical state chart, and then implementing these transitions. It does this by computing the new state associated with this transition, deactivates the relevant parts of the old state and finally activates the relevant parts of the new state.<br>
A preferred method of operation for the state machine engine (SME) 20 is described by the flow chart of Fig. 2.<br>
The SME begins operation by building initial data structures based on data provided by the automatically generated code 30. These data structures typically include:<br>
•	a data structure that is a one to one representation of the hierarchical state chart,<br>
•	a data structure that couples together any input events with the transitions that are triggered by these input events,<br>
•	a data structure that couples together any data variables in the application with transitions that are triggered by changes in the value or state of these data variables, and with any expressions that must be evaluated when these data variables change, and<br>
•	a pointer to all logic and activity functions within the automatically generated code.<br>
The SME then enters its normal operating state, which is to wait for any input events or any changes in data values. It is appreciated that input events may originate from a hardware device, such as a lamp as described in greater detail hereinbelow with reference to Fig. 4, or from a software process, such as an interprocess message.<br>
When an input event notification arrives or a data change notification arrives from the automatically generated code, SME 20 checks if the event or data structure that triggered the notification has a list of transitions or logic expressions associated with it. If not it discards the<br><br>
notification and returns to its normal operating state.<br>
If the source of the notification does have such a list associated with it, the SME then checks each entry in the list and selects those entries that belong to a state that is currently active. All<br>
other entries are icnored.<br>
*&gt;&gt;<br>
The SME then iterates over the selected list and checks each entry.<br>
If an entry is a transition, and the source state of that transition is still active, the SME performs the transition by computing the new state associated with the transition, deactivating those parts of the current state that will no longer be active in. the new state, and then activating all those elements in the new state that were not active in the current state. The new state then becomes the current state.<br>
If the entry is a logic expression, rather than a transition, the SME evaluates this expression by calling the corresponding functions in the generated code.<br>
Once the SME has processed all entries in the list, it returns to its normal operating mode to await the next notification.<br>
Referring back to Fig. 1, the'automatically generated code 10 is a translation of a hierarchical state chart description of a system, in addition to all data elements in the system, which, when compiled and run together with the SME and the interface library, implements the behavior of the original system.<br>
The automatically generated code 10 typically comprises some or all of the following components:<br>
•	code to generate in memory, on a one to one basis, a replica of the original state chart, including the transitions and activities as defined,<br>
•	code to generate the lists that link sources of input events with the transitions to be evaluated when notification of these events are received by the SME,<br>
•	code to generate the lists that link data variables with the transitions and the logical expressions to be evaluated when notification of changes to these data variables are received by the SME,<br>
•	code to generate the notifications to the SME whenever a data variable changes,<br>
•	code to evaluate the conditions and to implement actions and activities that describe the behavior of the system described by the original state chart, including code to activate elements of hardware or software as specified by the state chart,<br>
•	code to deliver to the SME any of the above as is needed by it.<br>
The object code; interface library 30 to the underlying hardware is optional pre-built object code that allows one or both of the state machine and the automatically generated code to interact with the hardware on which these elements operate.<br><br>
This obiect code interface library is specific to the hardware on which the system is to oe run.<br>
Conventional technology for generating high level code from state charts has entailed generating a static representation of all the possible transitions and states as described by the state chart, as well as generating code for the state machine that activates these various states. In general, the state and the state machine are inseparable in such generated code.<br>
The two main techniques available for accomplishing this have been: state machines built of nested branch statements and state machines built around state transition tables.<br>
In the first technique, code generation using branch statements, the state chart formalism is converted into a large number of typically deeply nested branch statements, where each branch statement represents one of the possible transitions. The depth of nesting is at least as deep as the deepest hierarchy in the state chart and increases non-linearly as a function of the depth of all branches in the state chart, the width of the branches and the number of possible input events. Branch statements are statements of the type "if-else" or "switch-case". For simple programs this may be adequate, but in general, because of the large amount of code needed to code the nested branch statements, this technique produces overly large programs.<br>
Every possible input event is typically represented by some sort of flag. When an input event occurs, the corresponding flag is set to indicate this. The state machine mechanism involves continuously cycling through all the branch statements in the search for any branches that involve flags which may have been set before the current cycle as well as any condition statements that may have become true due to a variable changing value. This has the inevitable result that such code is very slow, especially since every cycle has to go through the deeply nested branch points that make up the code. This makes this type of code big and too slow for any application that requires a fast response time or modest memory requirements.<br>
In the second technique, code generation using state transition tables, a procedure or function is generated for every possible transition and state, together with a state transition table that is used by the generated state machine for choosing which procedure to call for every possible external input. This state transition table is, in effect, a two-dimensional array whose indices are "input event" and "current state" and whose value is the new state.<br>
The state here is not a hierarchical state, but rather a state in a normal linear state diagram, which is derived from the state chart by "flattening out" the original state chart.<br>
When an input event arrives at the state machine, the state machine uses it, together with the current state to look up the next state. This use of tables results in much better response times than the nested branch statements to input. On the other hand, condition statements must still be<br><br>
evaluated by .cycling through all such statements in search of any that evaluates to "true." This, of course, is still very slow.<br>
In addition, because of the need to "flatten out" or linearize the original state chart, the size of the table explodes exponentially as a function of the number of possible input events, of depth of the state chart and the width of each branch. Hence, programs generated this way are normally so large as to make the generated code impractical for commercial products.<br>
In contrast, the code generation technique of the present invention preferably has some or all of the following features:<br>
•	It does not try to reproduce the hierarchical state machine in the generated code, but rather generates code that, after compilation and linkage, is run by a pre-built, optimized state machine engine.<br>
•	It does not generate a static representation of all possible states and the transitions in the state chart, but rather generates code that reproduces the actual hierarchical state structure of the original state chart. The pre-built state machine engine then dynamically computes the required new state in response to every input event, or change in conditions.<br>
•	It is completely event driven, even in the case of conditions. Every source of events and every variable can have a list of logic associated with it. This list points to any statement that must be evaluated if and when that event is triggered or that variable changes value. In general, the statements in the list represent transitions, and the order of the statements expresses the order of evaluation of these transitions. As soon as an input event arrives, or a variable changes value, the transition dependent upon it is immediately identified and evaluated.<br>
•	The size of the generated code is linear in the number of branches and the number of transitions between the branches. The size is independent of the width of the branches and the number of possible input events.<br>
The code generation technique of the present invention and the code structure of the present invention preferably has some or all of the following advantages:<br>
•	The resultant generated code, together with the pre-built state machine engine, is very small, and has memory requirements which are comparable to equivalent code developed manually by programmers.<br>
•	Whereas response time of the generated code to input events is as good as conventional automatically generated code, the response time to changes in variables is better than that for automatically generated code, and in fact, is similar to that for input events.<br>
•	The code generated is guaranteed to reflect the state chart from which it was derived, rather than being a transformed version of it. As a result, the generated code behaves as described by<br><br>
. the original state chart. In addition, because of the clarity of the state chart formalism itself, the generated code is more likely to behave as required, compared to the equivalent manually developed code.<br>
EXAMPLE: Fig. 3 illustrates incorporation of a system for generating me code snow and described herein into the Rapid S/W tool, commercially available from Emultek Ltd., Misgav 20179, Israel.<br>
The steps of Fig. 3 are now described:<br>
Build Interface Library: The interface library is used by the automatically generated code to interact with the hardware on which the system to be developed runs. For example, the library code may be used to request memory allocation from the operating system, or, if the hardware controls a device such as a lamp, the library might contain the code to switch the lamp on and off, e.g., by accessing certain addresses on the hardware. The library can be written in any convenient language and is preferably pre-tested before development with Rapid begins.<br>
Map Components to Simulation Objects: In Rapid, applications are built by assembling simulations of the hardware and/or software components on the screen and building logical expressions from functions supplied with the object simulations. These supplied functions animate the behavior of the object simulations. For example in the case of a Lamp object, the function "switchOn" would cause the simulated lamp on the screen to change to the "on" color. In order for the logical expressions be able to interact with the actual components, a mapping between the supplied functions and interface library is provided. This mapping may be hard coded into the simulated objects code. Alternatively, an external textual mapping file may be used.<br>
Open a New Rapid Application:     This is the first step in building Rapid applications,<br>
» providing a "clean slate" on which to build the application.<br>
Build Simulation of the System: The simulation is built by dragging objects from a tool palette in the Layout Editor and positioning them as required on the graphic representation of the device being simulated. Each object can be graphically customized and, to some extent, functionally customized.<br>
Rapid State Charts: The logic in a Rapid application is described by a state chart. State charts in Rapid are built from units called "modes". A mode is a functional state of the system and any mode can be hierarchically nested within any other mode. Therefore, the modes describe a hierarchical tree. Modes come in two "flavors": exclusive and concurrent. For exclusive modes, only one sibling can be in the active state at any given time, while for concurrent modes all siblings must be active together. When a particular mode is active, this implies that all its ancestors are active. If the mode's children are exclusive modes, this also implies that at least one of its children are active,<br><br>
while if.the mode's children are concurrent modes, this implies that all of the children are active.  A state in a state chart is the list of all currently active modes.  A mode can have lists of activities and transitions.  Activities describe what the system does when it is a particular state. Activities can be entry activities, exit activities or mode activities.   Entry activities are activities that are performed when the mode that contains them becomes activate.  Exit activities are activities that are performed when the mode that contains them becomes inactive.    Mode actixities are activities that are performed when the mode becomes active and that, as long as the mode is still active, are automatically re-evaluated whenever data variables that describe them change value.   Transitions define how the system evolves from one state to another. Transitions typically have a destination mode. Transitions must also have a list of input events, or a condition expression or both. Transitions may also have a list of actions.   If notification of one of the input events held by a transition is received, and that transition belongs to a currently active mode, and the condition expression, if any evaluates to true, then the mode belonging to the transition is deactivated (together with its children and any relevant ancestors) and the destination mode of the transition is activated (together with its children etc.). Between the deactivation of the original mode and the activation of the destination mode, any actions in the transition are performed.<br>
Build the State Chart: The simulation is typically built using two tools in Rapid: the Mode Tree Editor and the Logic Editor. The Mode Tree Editor allows the user to define and add modes to the hierarchical tree of modes by selecting the parent of the new mode, specifying the type of the new mode, and giving a name to the new mode. During this process, the transitions and activities can be added and edited using the Logic Editor. As each logic expression is added to the state chart it is compiled into byte codes for a virtual machine that is used to run a simulation of the system.<br>
Run Simulation: At any time during the development process, the simulation of the system under development can preferably be run. This allows incremental development of the system and verification that the system behaves as desired.<br>
Generate Code: Once the developer is satisfied with the system, Rapid automatically generates C++ code for that system having the characteristics described above. It is appreciated that programming languages other than C++ may be used for the automatically generated code.<br>
Compile the Generated Code: The automatically generated code can be compiled to produce object code.<br>
Link with State Machine and Interface Library: The object code produced by compiling the automatically generated code is then linked with the SME object code and the interface library to produce executable code for the target system.<br><br>
This executable code can oe downloaded and run on the target system. Sample Application:<br>
The following is a sample application in Rapid and the code automatically generated for it:<br>
Fig. 4 is a screen capture of the application in the Layout Editor, showing the object layout. As can be seen the application contains five lamps, and five push buttons:<br>
Objects<br>
RAPED   APPLICATION:    TRANSITN    12/12/96   16:09:08 OBJECT DATA REPORT<br>
Parameters: Scope: Subtree. Order: Hierarchy. Content: Active objects, Nongraphic objects, Object parameters, Object properties.<br>
1.	OBJECT: transitn<br>
Parent: none    Type: Root Object<br>
Parameters:<br>
Position (pxl): '0 @ 0' Size (pxl): '393 @ 403' Dynamic: 'false' Drag fn Drop: 'false'<br>
2.	OBJECT: LampH<br>
Parent: transitn    Type: Round Lamp<br>
Parameters:<br>
Center (pxl): '300 @ 139' Radius (pxl): '15 @ 15' Dynamic: 'false' Drag 'n Drop: 'false'<br>
Properties:<br>
2.1.  Name: blinkPeriod   Type: Data<br><br>
Parameters:<br>
Value: 500<br>
3.	OBJECT: LampG<br>
Parent: transitn    Type: Round Lamp<br>
Parameters:<br>
Center (pxl): '243 @ 139' Radius (pxl): *15 @ 15' Dynamic: 'false' Drag 'n Drop: 'false'<br>
Properties:<br>
3.1.  Name: blinkPeriod   Type: Data Parameters: Value: 500<br>
4.	OBJECT: LampA<br>
Parent: transitn    Type: Round Lamp<br>
Parameters:<br>
Center (pxl): 72 @ 140' Radius (pxl): !15 @ 15* Dynamic: 'false' Drag'n Drop:'false1<br>
Properties;<br>
4,1.   Name; blinkPeriod   Type: Data Parameters: Value: 500<br>
5.	OBJECT: LampE<br>
Parent; transitn   :Type: Round Lamp<br>
Parameters:<br><br>
renter (pxl): '129 @ 139' Radius (pxl): '15 @ 15' Dynamic: 'false Drag 'n Drop: 'false1<br>
Properties:<br>
5.1.   Name: blinkPeriod   Type: Data Parameters: Value: 500<br>
6. OBJECT: LampF<br>
Parent: transitn    Type: Round Lamp<br>
Parameters:<br>
Center (pxl): '186 @ 139' Radius (pxl): '15 @ 15' Dynamic: 'false' Drag'n Drop: 'false*<br>
Properties:<br>
6.1.  Name: blinkPeriod   Type: Data Parameters: Value: 500<br>
7.	OBJECT: BToA<br>
Parent: transitn    Type: Flat Pushbutton<br>
Parameters:<br>
Position (pxl): '57 @ 199' Size (pxl): '40 @ 40' Dynamic: false1 Drag 'n Drop: 'false* Momentary: 'true' Autorepeat: 'false' Autorepeat period: 500<br>
8.	OBJECT: Default<br>
Parent: transitn '. Type: Flat Pushbutton<br><br>
'    Posrtion (pxl): '131 @ 199* Size (pxl): '40 @ 40' Dynamic: 'false' Drag !n Drop: Talse' Momentary: rtrue' Autorepeat: 'false1 Autorepeat period: 500<br>
9.	OBJECT: History<br>
Parent: transitn    Type: Flat Pushbutton<br>
Parameters:<br>
Position (pxl): '206 @ 199' Size (pxl): '40 @ 40' Dynamic: 'false' Drag 'n Drop: 'false' Momentary: 'true' Autorepeat: 'false' Autorepeat period: 500<br>
10.	OBJECT: DeepHistory<br>
Parent: transitn    Type: Flat Pushbutton<br>
Parameters:<br>
Position (pxl): '276 @ 199' Size (pxl): '40 @ 40' Dynamic: 'false' Drag 'n Drop: 'false' Momentary: true' Autorepeat: 'false1 Autorepeat period: 500<br>
11.	OBJECT: History<br>
Parent: transitn    Type: Label<br>
Parameters:<br>
Position (pxl): '198 @ 244' Size (pxl): '58 @ 15' Dynamic: 'false' Drag 'n Drop: 'false1 Text: ^History' Orientation: 'Horizontal' Font: 'Fixedsys' Line width: 1<br>
12.	OBJECT: Next<br>
Parent: transitn    Type: Flat Pushbutton<br>
Parameters:<br>
Position (pxl):'167 @ 282' Size (pxl):'40 @ 40' Dynamic:'false' Drag 'n Drop: 'false' Momentary: 'true' Autorepeat: 'false'<br><br>
Autorepeat period: 500<br>
Fig. 5 is a screen capture of the Mode Tree Editor showing all the modes that make up the state chart of this sample application. As can be seen there are nine modes in this application.<br>
An alternative view of the state chart can be seen in the screen capture of the Logic Chart tool shown in Fig. 6. Fig. 6 shows each mode as a rectangle and each transition as an arc. Tiie hierarchical nature of the state is clearly seen.<br>
Reference is now made to Fig. 7 which is a simplified flowchart illustration of a automatic code generation technique operative in accordance with a preferred embodiment of the present invention. The resulting code is useful in conjunction with a state machine engine which performs the following functions, inter alia:<br>
a.	Upon receipt of notification that an input event has occurred, the SME accesses the list<br>
formed for that input event and evaluates each transition on that list to determine, depending on the<br>
current state, which transitions are to be performed.<br>
b.	Upon receipt of notification that an internal data variable has been changed, the SME<br>
accesses the list formed for that internal data variable and evaluates each transition on that list to<br>
determine, depending on the current state, which transitions are to be performed.<br>
To perform a transition, the SME computes the new state associated with the transition by going to the destination of the transition and looking up and activating all ancestors. All children are also looked up and activated as appropriate, e.g. in accordance with predefined defaults. Those portions of the current state that are no longer active in the new state are deactivated. Elements in the new state that were not active in the current state are activated. The new state then becomes the current state and is stored in the SME.<br>
Alternatively, one or both of the above lists may not be provided. For example, the system may poll periodically for internal events rather than being driven thereby. Alternatively or in addition, the system may poll periodically for external events rather than being driven thereby.<br>
Logic in State Chart<br>
RAPID   APPLICATION:    TRANSITN    12/12/96   16:07:32 MODE DATA REPORT<br>
Parameters:<br>
Scope: Subtree.<br><br>
Order: Hierarchy.<br>
Includes: User Functions, Activities, Transitions, Triggers, Actions.<br>
USER FUNCTIONS<br>
1.	MODE: transitn Parent: none   Type: root Note:<br>
2.	MODE: A<br>
Parent: transitn   Type: exclusive<br>
Entry Activities: a. LampA on<br>
Exit Activities: a. LampA off<br>
Transitions:<br>
a.	Destination: B    Entry type: Default<br>
al. Trigger: Default in &amp;<br>
b.	Destination: B    Entry type: History<br>
bl. Trigger: History in &amp;<br>
c.	Destination: B    Entry type: Deep history<br>
cl. Trigger: DeepHistory in &amp;<br>
3. MODE:B<br>
Parent: transitn   Type: exclusive<br>
Transitions: a. Destination: A    Entry type: Default al. Triscer: BToA in &amp;<br>
4. MODE: C<br><br>
, Parent: B   Type; exclusive<br>
5. MODE E<br>
Parent: C   Type: exclusive<br>
Entry Activities: a. LampE on<br>
Exit Activities: a. LampE off<br>
Transitions: a. Destination: F    Entry type: Default<br>
al. Trigger: Next in &amp;<br>
6. MODE:F<br>
Parent: C   Type: exclusive<br>
Entry Activities: a. LampF on<br>
Exit Activities: a. LampF off<br>
Transitions: a. Destination: G    Entry type: Default al. Trigger: Next in &amp;<br>
7.	MODE:D<br>
Parent: B   Type: exclusive<br>
8.	MODE: G<br>
Parent: D   Type: exclusive<br><br>
Entrv Activities: a. LampG on<br>
Exit Activities: a. LampG off<br>
Transitions: a. Destination: H    Entry type: Default al. Trigger: Next in &amp;<br>
9. MODE: H<br>
Parent: D    Type: exclusive<br>
Entry Activities: a. LampH on<br>
Exit Activities: a. LampH off<br>
Transitions:<br>
a. Destination: E    Entry type: Default al. Trigger: Next in &amp;<br>
Generated Code<br>
Header File<br>
#ifhdef	include_transitn<br>
#define	include_transitn<br>
#include "applic.h" #include "task.h" #include "object.h" #include "mode.h"<br><br>
class Application; class myApplication;<br>
typedef bool (myApplication:: *MyApplicationMethod)();<br>
#define cNumberDependencies     8<br>
#define cNumberDependencylndices 6<br>
#define cNumberChildren	18<br>
#define cNumberObjects	20<br>
#define cNumberTriggers	5<br>
#define cNumberTransitions       8<br>
#d'efine cNumberModes	9<br>
#define cNumberActivities        10<br>
class myApplication: public Application<br>
{<br>
private: // Objects enum objectID<br>
{<br>
cOB_RootObject = 0, //PushButtons<br>
cOBJDefault,	III<br>
cOB_History,	111<br>
cOB_DeepHistory, 1/3<br>
cOB_BToA,	HA<br>
cOB_Next,	IIS<br>
//Lamps<br>
cOB_LampA,	1/6<br>
cOB_LampE,	111<br>
cOB_LampF,	//8<br>
cOB_LampG,	119<br>
cOB_LampH,	//10<br>
//Modes<br><br><br><br><br><br><br><br>
// Each object has a list of dependency records, sorted<br>
*<br>
// by property and event, and referencing pairs of<br>
// (modes, activity/condition, index), or a transition index<br>
static DependencyRecord dependencies[cNumberDependencies];<br>
// For each object/property pair, there is a dependency index record<br>
// that includes the first &amp; last dependency record pertaining to the<br>
// object/property pair.<br>
static DependencylndexRecord dependencyIndicies[cNumberDependencyIndices];<br>
// Each transition has an index and an associated record that includes // the indices of the source and destination, type, condition, and action static TransitionRecord transitionRecords[cNumberTransitions];<br>
// Each transition has an index and an associated record that includes // the indices of the source and destination, type, condition, and action static TriggerRecord triggerRecords[cNumberTriggers];<br>
// Activity methods are indexed through the following array<br>
// subroutine methods are NOT indexed here.<br>
static MyApplicationMethod activityRecords[cNumber Activities];<br>
// Each mode record includes entry and exit activities, if any, // and the start index and length of the mode activities. Can the mode activities // be merged? Also, the number of transitions, to facilitate flag allocation, static ModeRecord modeRecords[cNumberModes];<br>
// Each object record includes<br>
static ObjectRecord objectRecords[cNumberObjects];<br>
// Array to hold all of the children for the objects static int children Array [cNumberChildren];<br><br>
static A^plicationRecord applicationRecord;<br>
};<br>
class myTask: public RapidTask<br>
{<br>
public: myTaskQ; -myTaskQ<br>
{<br>
removeContext(&amp;_mainApp);<br>
};<br>
private: my Application jnainApp;<br>
};<br>
#endif<br>
Body File<br>
/*<br>
Rapid Application:<br>
Objects: Transitn<br>
|-&gt;BToA (Square Pushbutton) |-&gt;Default (Square Pushbutton) |-&gt;History (Square Pushbutton) |-*&gt;DeepHistory (Square Pushbutton) |--&gt;Next (Square Pushbutton) J—&gt;LampA (Round Lamp) |—&gt;LampE (Round Lamp) |--&gt;LampF (Round Lamp) |—&gt;LampG (Round Lamp) |—&gt;LampH (Round Lamp)<br><br><br><br>
cl. Trigger: DeepHistory in &amp;<br>
3.	MODE: B<br>
Parent: Transitn   Type: exclusive<br>
Transitions: a. Destination: A    Entry type: Default al. Trigger: BToA in &amp;<br>
4.	MODE: C<br>
Parent: B   Type: exclusive<br>
5.	MODE: D<br>
Parent: B   Type: exclusive<br>
6.	MODE: E<br>
Parent: C   Type: exclusive<br>
Entry Activities: a. LampE on<br>
Exit Activities: a. LampE off<br>
Transitions: a. Destination: F    Entry type: Default al. Trigger: Next in &amp;<br>
6. MODE: F<br>
Parent: C   Type: exclusive<br>
Entry Activities: a. LampF on<br><br>
Exit Activities: a. LampF off<br>
Transitions: a. Destination: G    Entry type: Default al. Trigger: Next in &amp;<br>
6. MODE: G<br>
Parent: D   Type: exclusive<br>
Entry Activities: a. LampG on<br>
Exit Activities: a. LampG off<br>
Transitions: a. Destination: H    Entry type: Default al. Trigger: Next in &amp;<br>
6. MODE: H<br>
Parent: D   Type: exclusive<br>
Entry Activities: a. LampH on<br>
Exit Activities: a. LampH off<br>
Transitions: a. Destination: E    Entry type: Default<br>
al. Trigger: Next in &amp;<br><br>
Generated Code:<br>
^include "transitn.h" ^include "emtrace.h" ^include "ekemel.h"<br>
struct DependencyRecord<br>
{<br>
DependencyClass dependencyClass; // event, condition, mode activity<br>
int mode;	// Frame Table index<br>
int eventID;	// eventID, if any -<br>
int index;	// Index of transition or mode Activity<br>
}; */<br>
DependencyRecord my Application: :dependencies[cNumberDependencies] =<br>
{<br>
{cEvent,	cOB_ModeA, cPushButtonIn, 0}, // 0 A-&gt;B on Default in<br>
{cEvent,	cOB_ModeA, cPushButtonIn, 1}, // 1 A-&gt;B on History in<br>
{cEvent,	cOB_ModeA, cPushButtonIn, 2}, // 2 A-&gt;B on DeepHistory in<br>
{cEvent,	cOB_ModeB, cPushButtonIn, 0}, // 3 B-&gt;A on BToA in<br>
{cEvent,	cOB_ModeE, cPusliButtonln, 0}, // 4 E-&gt;F on Next in<br>
{cEvent,	cOB_ModeF, cPushButtonIn, 0}, // 5 F-&gt;G on Next in<br>
{cEvent,	cOB_ModeG, cPushButtonIn, 0}, // 6 G-&gt;H on Next in<br>
{cEvent,	cOB_ModeH, cPushButtonIn, 0}, // 7 H-&gt;E on Next in<br>
};<br>
/*<br>
struct DependencyIndexRecord{ PropertyEntry _propertyId;<br><br><br><br><br><br><br><br>
{<br>
*<br>
■<br>
int objectlD; int propertylD; int eventID;<br>
}; */<br>
//NOTE: Could get sophisticated, and reuse trigger records... TriggerRecord my Application: :triggerRecords[cNumberTriggers] =<br>
{<br>
{cOB_Default, cSelf, cPushButtonln},     // 0 {cOB_History, cSelf, cPushButtonln},      //1 {cOBJDeepKstoiy, cSelf, cPushButtonln}, 111 {cOB_BToA, cSelf, cPushButtonln},        // 3 {cOB_Next, cSelf, cPushButtonln},        IIA<br>
};<br>
I*<br>
struct TransitionRecord<br>
{<br>
int triggers tart;    // index of first trigger record<br>
int triggerLength;   // number of trigger records<br>
int sourceMode;      // object index of source mode<br>
int destinationMode; // object index of destination mode<br>
int condition;       // index of condition method<br>
int action;	// index of action method<br>
unsigned inttype:3;<br>
unsigned int IsConditionOnly:l;<br>
unsigned int toAncestonl;<br>
unsigned int toDescendant:l;<br>
unsigned int sourceEqualsDestination:l;<br>
}; */<br><br><br><br><br><br><br><br>
We claim:<br>
1.	Apparatus implementing hierarchical state charts and comprising: a state machine engine (SME) operative to carry out repertoires of behaviors of a system; a state chart encoder operative to replicate, in computer code form, a user-defined hierarchical state chart describing a repertoire of behaviors of said system, said encoder being operative to preserve said state chart's hierarchical structure intact in a first data structure; an event list generator operative to generate, for each individual event from among a plurality of events within the repertoire, a list of at least one transition between states of said state chart which are associated with said individual event, said event list generator being operative to preserve said list in a second data structure; and a behavior implementer operative to activate said system to carry out each of the behaviors in its repertoire, wherein the state machine engine is operative to carry out repertoires by dynamically computing at least one new state in response to an event, without generating a static representation of all possible states and transitions in the user-defined hierarchical state chart.<br>
2.	Apparatus according to claim 1 wherein said system comprises at least one of hardware and software.<br>
3.	Apparatus according to claim 1 wherein said first data structure's size increases linearly in direct proportion to the number of branches in said hierarchical structure.<br><br>
4.	Apparatus according to claim 1 wherein said second data structure's size increases linearly in direct proportion to the number of transitions in said list of at least one transition.<br>
5.	Apparatus according to claim 1 wherein the order of said at least one transition of each of said lists corresponds to the order of evaluation of said transitions as defined by said hierarchical state chart.<br>
6.	Apparatus according to claim 1 wherein said plurality of events for which said event  list  generator  generates   lists  comprises  at  least  one   external   input  event.<br>
7.	Apparatus according to claim 1 wherein said plurality of events for which said event list generator generates lists comprises at least one internal data value change event, the apparatus also comprising a data value change event notifier operative to generate a notification to the state machine engine of each data value change event.<br>
8.	A method implementing hierarchical state charts, the method comprising: providing a state machine engine (SME) operative to carry out repertoires of behaviors of a system; replicating, in computer code form, a user-defined hierarchical state chart describing a repertoire of behaviors of said system, said replicating step being operative to preserve said state chart's hierarchical structure intact; generating, for each individual<br><br>
event from among a plurality of events within the repertoire, a list of at least one transition between states of said state chart which are associated with said individual event; and activating said system to carry out each of the behaviors in its repertoire, wherein the state machine engine is operative to carry out repertoires by dynamically computing at least one new state in response to an event without generating a static representation of all possible states and transitions in the user-defined hierarchical state chart.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTc0Ny1tYXMtMTk5Ny0gYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">1747-mas-1997- abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTc0Ny1tYXMtMTk5Ny0gY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">1747-mas-1997- claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTc0Ny1tYXMtMTk5Ny0gY29ycmVzcG9uZGVuY2Ugb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">1747-mas-1997- correspondence others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTc0Ny1tYXMtMTk5Ny0gY29ycmVzcG9uZGVuY2UgcG8ucGRm" target="_blank" style="word-wrap:break-word;">1747-mas-1997- correspondence po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTc0Ny1tYXMtMTk5Ny0gZGVzY3JpcGl0b24gY29tcGxldGUgIGR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">1747-mas-1997- descripiton complete  duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTc0Ny1tYXMtMTk5Ny0gZGVzY3JpcGl0b24gY29tcGxldGUgIG9yaWdpbmFsLnBkZg==" target="_blank" style="word-wrap:break-word;">1747-mas-1997- descripiton complete  original.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTc0Ny1tYXMtMTk5Ny0gZm9ybSAxLnBkZg==" target="_blank" style="word-wrap:break-word;">1747-mas-1997- form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTc0Ny1tYXMtMTk5Ny0gZm9ybSAyNi5wZGY=" target="_blank" style="word-wrap:break-word;">1747-mas-1997- form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTc0Ny1tYXMtMTk5Ny0gZm9ybSAzLnBkZg==" target="_blank" style="word-wrap:break-word;">1747-mas-1997- form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTc0Ny1tYXMtMTk5Ny0gZm9ybSA0LnBkZg==" target="_blank" style="word-wrap:break-word;">1747-mas-1997- form 4.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="204466-a-method-for-accessing-a-location-in-a-network-by-activating-a-link-in-a-file.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="204468-a-radio-set-for-a-mobile-radio.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>204467</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1747/MAS/1997</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>26/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>29-Jun-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>22-Feb-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>05-Aug-1997</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>EMULTEK LTD</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>BEIT RABIN, TERADION INDUSTRIAL PARK, MISGAV 20179</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>FREDERICK C ROTBART</td>
											<td>142 YUVALIM ST MISGAV 20142</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G05B19/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>119914</td>
									<td>1996-12-25</td>
								    <td>Germany</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/204467-apparatus-and-method-implementing-hierarchical-state-charts by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 07:01:22 GMT -->
</html>
