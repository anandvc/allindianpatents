<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/254399-method-of-protecting-a-server-from-denial-of-service-attack by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 11:43:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 254399:METHOD OF PROTECTING A SERVER FROM DENIAL OF SERVICE ATTACK</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD OF PROTECTING A SERVER FROM DENIAL OF SERVICE ATTACK</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The invention proposes a challenge-response mechanism to defend systems against Denial of service (DOS)/ Distributed Denial of Service (DDOS), especially resource consumption attack. The system which wants to defend itself from DOS/DDOS attack (server), before committing its resources to system connecting to it (client), throws challenge to client, verifies result generated by client and commits resources only if verification is successful. When client mounts attack against server throwing multiple requests, server will throw multiple challenges to client and client will get loaded in resolving challenges thrown by server. Thus server&#x27;s resources are free for legitimate users connecting to it. This is based on the fact that the system, which wants to defend itself from resource consumption attack, shall be able to Control cost of challenge and verify response generated for challenge, investing minimal resources.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FIELD OF THE INVENTION<br>
This invention relates, in general, to security and communication in networks and in particular to a method for designing Denial of Service (DOS) and Distributed Denial of Service (DDOS) resilient systems. This invention is about a challenge-response mechanism for DOS/DDOS mitigation, which can be applied in design of protocols [such as security, networking, communication protocols, design of software system and applications (like e-commerce, m-commerce, B2B (Business to Business), B2C (Business to Consumer) applications, etc.] to make them DOS resilient.<br>
DESCRIPTION OF RELATED ART<br>
Denial of Service commonly known as DOS are the attacks, which aim at denying or degrading legitimate user's access to a service or network resource, or at bringing down servers offering such services. The system under threat may be a server connected to network, a proxy server or any such resource, which is vulnerable to DOS/DDOS attack. The present invention is directed towards a kind of DOS attack called resource consumption attack. The following paragraphs explain about the existing techniques for DDOS (Distributed Denial of Service) mitigation in brief.<br>
Listed below are patents related to DOS, granted by USPTO and are included herein by reference.<br><br><br><br>
Anti-clogging cookies:<br>
Anti-clogging  cookies  are  generally  used  in   IKE   (Internet   Key   Exchange<br>
protocol) to protect responders from DDOS and the operations performed comprises of the following.<br>
1.	Initiator sends cookie (Cookie-I) to server.<br>
2.	Responder concatenates Cookie-I with the secret it owns, to generate Cookie-R using a hash function. Responder does not commit its resources to initiator at this point.<br>
3.	Responder sends Cookie-I, Cookie-R to client.<br>
4.	Initiator in next request sends Cookie-I and Cookie-R to responder along with other information.<br>
5.	Responder uses Cookie-I and repeats operation in step 2 to get a result and if the result matches with Cookie-R sent by initiator than responder its commits resources for initiator.<br>
More description of the above is available for reference at http://www.faqs.org/rfcs/rfc2401.html, http://www.faqs.org/rfcs/rfc2408.html, and http://www.faqs.org/rfcs/rfc2409.html<br>
Hash Cash, Client puzzles, etc. are other methods to defend servers from DDOS.<br>
Client puzzles:<br>
Client puzzles, which employ hash algorithms, follows the following steps,<br>
1.  Server generates a random value 'random*, applies it to hash function to generate hash output randomjiash.<br><br>
2.	Server sends random value with last few bits masked and random_hash to client.<br>
3.	Client should find the bits, which are missing, in random value sent by server such that hash of random value along with identified bits results in randomhash value. Client uses brute force or linear search methods to identify missing bits.<br>
Some references pertaining to this activity is available at the following addresses,<br>
viz.	http://www.rsasecuritv.com/rsalabs/node.asp?id=2050	and<br>
http://www.dataman.ro/phd/conti2004-3.pdf.<br>
DOS resistant authentication with client puzzles:<br>
DOS resistant authentication with client puzzles, while the client receives random<br>
value Ns and k (number of bits to be guessed) from server and the Client tries to<br>
find X, is governed by H(C,Ns,Nc,X) = O00..000(upto k bits) Y (rest of hash), in<br>
which<br>
X is solution to puzzle<br>
H represents hash algorithm<br>
C represents client identity<br>
Ns represents server's nonce<br>
Nc represents client's nonce<br>
K represents puzzle difficulty level<br>
000...000 represents first k bits of hash, which mush be zero.<br><br>
Y represents rest of hash value, which can be anything. (http://research.microsoft.com/users/tuomaura/Publications/aura-nikander-leiwo--pr otocols00.pdf for more reference)<br>
Hash cash:<br>
Hash cash is another method to defend servers from DDOS, and involves the<br>
following main operations.<br>
Step 1: Server generates PUBLIC and PRIVATE values<br>
PUBLIC:        n=pq, where p and q are primes and n is public. PRIVATE:      q&gt; (n) = (p-1) (q-1)<br>
Step 2 : Server generates challenge<br>
(CHAL is generated by server in interactive mode). C 
choose C in range (0,n-1)<br>
return (s.c.w).<br>
Step 3: Client finds solution for challenge. Client spends considerable CPU resources to find solution.<br>
T 
Compute y 
Return (s,c,w,y)<br><br>
Step 4: Verification of result in server<br>
V 
Compute z 
If x٨z = y (mod n) return w Else return 0.<br>
Even though the above methods are well established and widely acclaimed, they hold many demerits. One major drawback of 'Anti-clogging cookies' is that in this case all it takes for client to go ahead with attack is to store Cookie-I and matching Cookie-R from server (a light-weight session in initiator which is not costly for attacker). Since initiator stores Cookie-I and Cookie-R, it can send further payloads with certificates and fake signatures, which would make responder to verify certificate chains and signature leading to resource intensive operations, causing denial of service to legitimate users.<br>
The problems with client puzzles are listed below.<br>
1.	Complexity of solving puzzle increases exponentially with increase in number of bits to be identified.<br>
2.	Cost or complexity of solving puzzle cannot be adjusted precisely.<br>
i. If client tries to find answer for puzzle using brute force, it may so happen that client ends up not being able to find appropriate bits, which needs to be found, especially when number of bits to be guessed are more.<br><br>
ii. If linear search is used in finding solution (ie, client starts from 0x00000 and goes up to 2٨k-1 where k is number of bits to be found) and if server wants client to spend considerable time in finding solution to puzzle, it basically means reducing challenge to some fixed range. This can be exploited to attack server. 3.  Solving this puzzle can be parallelized.<br>
There are problems existing with DOS resistant authentication with client puzzles also as listed below.<br>
1.	Complexity of solving puzzle increases exponentially with increase in number of bits to be identified.<br>
2.	In practical scenario, adopting brute force approach may take indefinitely long to find results when number of bits to be identified is more.<br>
3.	Solving puzzle can be parallelized.<br>
Similarly there are problems associated with hash cash also. The major problem is that the verification in server requires two exponentiation operations, which are very costly and this may be used to as weakness to attack server. For example, when a challenge is received by client, it does not perform exponentiation operation. Client throws some random output to server and server has to perform two exponentiation operations to verify the result and conclude that it is wrong.<br>
1.  Proposed challenge-response method<br><br>
In the light of the foregoing, the invention proposes a challenge-response mechanism to defend systems against DOS/DDOS. The system which wants to defend itself from DOS/DDOS attack (server), before committing its resources to system connecting to it (client), throws challenge to client, verifies result generated by client and commits resources only if verification is successful. When client mounts attack against server throwing multiple requests, server will throw multiple challenges to client and client will get loaded in resolving challenges thrown by server. Thus server's resources are free for legitimate users connecting to it.<br>
This is based on the fact that the system, which wants to defend itself from resource consumption attack, shall be able to<br>
•	Control cost of challenge and<br>
•	Verify response generated for challenge, investing minimal resources.<br>
SUMMARY OF THE INVENTION<br>
The primary object of the invention is, therefore, to provide a method for protecting a system from the kind of DOS attack called resource consumption attack, wherein the server throws challenge to client connecting to it, before committing its resources and verifies result generated by client and commits resources only if verification is successful.<br>
Another object of the invention is to provide a challenge response mechanism, in which when the client mounts attack against server throwing multiple requests,<br><br>
server will throw multiple challenges to client and client will get loaded in resolving challenges thrown by server thereby making the server resources free for legitimate users connecting to it.<br>
It is also an object of the invention to provide a system capable of defending itself from resource consumption attack, control cost of challenge and verify response generated for challenge, investing minimal resources.<br>
Accordingly, the invention provides a method for protecting servers from DOS attack with the avoidance of immediate commitment to client, the method comprising the steps of:<br>
a)	checking the commitment of client in going ahead with protocol, by throwing a challenge to it, forcing client to spend considerable resources in solving the challenge, whose cost is controllable by server;<br>
b)	verifying the results or responses sent by the client, spending relatively very small effort;<br>
c)	committing the resources for the serving client only if the above said result or response is valid; and<br>
d)	controlling the cost of the modular exponentiation operation in client<br><br>
These and other objects, features and advantages of the present invention will become more readily apparent from a reading of the following detailed description taken in conjunction with the drawings.<br>
BRIEF DESCRIPTION OF THE ACCOMPANYING DRAWINGS<br>
Figure 1<br>
Describes message flow in challenge response method where client and server communicate without intermediate system. For detailed description please refer Deployment Scenarios (section 2) subsection l-A.<br>
Figure 2<br>
Describes message flow in challenge response method where client and server communicate with intermediate system(s) between them. For detailed description please refer Deployment Scenarios (section 2) subsection l-B.<br>
Figure 3<br>
Describes message flow in challenge response method with minimal change of application in server, where client and server communicate without intermediate system. For detailed description please refer Deployment (section 2) Scenarios subsection I l-A. Figure 4<br>
Describes message flow in challenge response method with minimal change of application in server where client and server communicate with intermediate<br><br>
system(s)  between  them.   For detailed  description  please  refer  Deployment Scenarios (section 2) subsection ll-B. Figure 5<br>
Describes message flow in challenge response method with out any change in application on server and client, where client and server communicate without intermediate system. For detailed description please refer Deployment Scenarios (section 2) subsection lll-A. Figure 6<br>
Describes message flow in challenge response method with out any change in application on server and client, where client and server communicate with intermediate system(s) between them. For detailed description please refer Deployment Scenarios (section 2) subsection I ll-B.<br><br>
Figure 7 is a High Level Block Diagram with Operations in the present invention.<br>
Brief description of operations:<br>
Above block diagram has two parts, namely, Server and Client.<br>
"Challenge Parameter Generator" in server generates challenge parameters and<br>
stores in data store. "Challenge Parameter Generator" in server is responsible for<br>
generation of challenge parameters with varied difficulty levels.<br>
Any operation initiated by client, which would involve considerable computing<br>
power and resources in server to serve,  results in generation of trigger to<br>
"Challenge Generator".<br>
When Trigger (1) is received by "Challenge Generator" in server, generates<br>
challenge set and sends the same to client ((2) Send Challenge) through<br>
communication link.<br>
Client upon receiving challenge ((3) Receive challenge) resolves the challenge<br>
using "Challenge Resolver" and sends back the result to server ((4) Result to<br>
server) through communication link.<br>
Server upon receiving the result ((5) Receive result) verifies using "Challenge<br>
Verifier" module.<br>
If results are verified successfully, server commits resources to serve the client.<br>
DETAILED DESCRIPTION OF THE INVENTION<br>
The preferred embodiments of the present invention will now be explained with reference to the accompanying drawings. It should be understood that the disclosed embodiments are merely exemplary of the invention, which may be<br><br>
embodied in various forms. While specific steps, configurations and arrangements are discussed for illustrative purpose only. A person skilled in the art will recognize that other steps, configurations and arrangements can be used without departing from the spirit and scope of the present invention. Therefore the details disclosed herein are not to be interpreted as limiting but merely as the basis for the claims and as a basis for teaching one skilled in the art how to make or use the invention.<br>
The term challenge refers to set of parameters determined by server, using which client has to perform modular exponentiation operation.<br>
Cost of operation is defined as effort in terms of CPU cycles and memory that has to be spent by client to resolve the challenge from server.<br>
This invention proposes a method for protecting a system from the kind of DOS/DDOS attack called resource consumption attack, which can be mounted against system on network (victim), where in multiple requests from one or more machines are directed to victim simultaneously, resulting in increased load on system under attack, blocking its resources like CPU, memory, disk space thus making victim to deny service to legitimate users. The system may be a server connected to network, a proxy server or any thing, which is vulnerable to DOS/DDOS attack.<br>
For the purposes of this specification, any system that is vulnerable to resource consumption attack and needs to be shielded from attack is referred as server, and<br><br>
the system that is capable for mounting resource consumption attack over a targeted system is referred to as client. The term challenge refers to set of parameters determined by server, using which client has to perform modular exponentiation operation. Also the cost of operation is defined as effort in terms of CPU cycles and memory that has to be spent by client to resolve the challenge from server.<br>
In security protocols like SSL (Secure Socket Layer), TLS (Transport Layer Security), IKE etc during handshake process, server performs CPU intensive operations like certificate verification and signature verification. A malicious attacker can misuse this feature to attack server wherein server's resources are virtually locked thus denying services to legitimate users. As more and more computers, devices etc get connected to network with higher capabilities (processing power, memory) and increased bandwidth, resource consumption attacks based on vulnerabilities in protocols or software design are very important issues to be addressed. It is because these attacks have the potential to stop or terribly slow down business critical services indefinitely.<br>
According to the invention, the system that wants to shield itself from attack (server)<br>
•	Do not commit resources immediately to client.<br>
•	Checks the commitment of client in going ahead with protocol, by throwing a challenge to it. (Client should spend considerable resources in solving the challenge, whose cost is controllable by server)<br><br>
•	Once correct results are identified by the client, it sends the results to server.<br>
•	Server verifies result sent by client, spending relatively very small effort and if it result is valid, it commits its resources for serving the client.<br>
•	Cost of the modular exponentiation operation in client is controllable by server.<br>
•	Challenge is thrown by the system, which wants to defend itself from attack, or the system, which wants to defend itself from attack, shall designate other system to throw the challenge and validate it.<br>
I.    Parameters pre-computed and stored in server<br>
The following parameters are pre-computed and stored in server as part of the<br>
operation of the invention.<br>
1.	Generate prime numbers of various sizes.<br>
2.	Calculate m such that, m is product of two or more primes. For example if p, q are primes, m = p.q.<br>
3.	Calculate φ  (m) using Euler's Totient Function. For example, m=p.q<br>
where p and q are primes, φ  (m) = (p-1)(q-1).<br>
(Euler's Totient Function denoted by lower case Phi <p. euler totient function returns the number of integers less than m including that></p.>
are relatively prime to m)<br>
4.	Calculate exponent, e1 such that e1= x* φ  (m) + c, where x and c are<br>
natural numbers of arbitrary size (say 128 bits and above).<br>
5.	Generate e2 such that e2 mod( φ  (m)) is not zero. Techniques for<br>
generation of e2 are described below in sub sections A,B and C. The<br><br>
value of e2 adds to complexity of challenge. Server shall use this parameter to control the cost of resolving challenge.<br>
6.	Letr = e2 mod(φ  (m)).<br>
7.	Let margin be a small value (say varying from 1 to 30).Calculate d=c*r-margin.<br>
8.	Generate random number a such that gcd(a,m)=1.<br>
9.	Server generates result = a٨ margin mod(m).<br>
The operations specified in steps 1-9 shall be performed in any order subject to the condition that all required parameters are available to perform the operations in a specified step. Either the steps from 1-9 shall be performed offline, and stored in server or the lightweight operations shall be performed when required (for example steps 4, 7-9 may be performed when required).<br>
In step (4) values of x and c are chosen to be as bigger as possible. Bigger the values of x and c, harder it is to factorize e1 and thus difficult to find <p from e1.></p>
(Value of m shall be refreshed periodically for additional security) Following methods explain various approaches to generate e2.<br>
A.	Exponentiation<br>
e2 = rtexp<br>
Where n &gt; 0,exp&gt;0 and nexp mod (<p is not zero.></p>
B.	Factorial method<br><br>
e2 = num!, where num is a natural number such that, e2 (mod (φ(m)) is not<br>
zero.<br>
C. Hash method<br>
1.	Generate a random value of arbitrary size (for example 10 bytes).<br>
2.	Identify size depending on cost of challenge.<br>
3.	Calculate output = hash(random)||hash(h(1))||hash(h(2)).... ||hash(h(r)). where hash is hashing algorithm,<br>
h(i)= hash(h(i-1)) for i ranging from 2 to r, h(1) = hash(random), || indicates concatenation.<br>
Generate output using hash algorithm and concatenate the hash values generated.<br>
4.	e2= most significant 'size' bytes of 'output'<br>
where e2 (mod( q&gt; (m)) is not zero,<br>
e2 shall be calculated using various methods (as specified in A-C above) offline and stored.<br>
All the pre-computations shall be performed using one or more systems and it may or may not be the server, which wants to defend itself from attack. Throwing challenge to client and verifying the response may be performed by server or by the system designated by server.<br>
II.   Challenge generation in server<br><br>
If challenge is generated using exponentiation method (as above) for generation of e2, the set (a,e1,n,exp,d,m) with operation type exponentiation constitute the challenge.<br>
If challenge is generated using factorial method (as above) for generation of e2, the set (a,e1,num,d,m) with operation type factorial constitute the challenge.<br>
If challenge is generated using hash method (as above) for generation of e2, the set (a,e1,random,size,d,m) with operation type hash and name of hash algorithm to be used, constitute the challenge. If hash algorithm to be used is fixed in client and server it need not the exchanged.<br>
The set formed along with operation type and algorithm (if required) is sent to client. If operation type to be supported is fixed in client and server, operation type need not be exchanged.<br>
III.  Challenge resolution in client<br>
If operation type is exponentiation, client resolves challenge as described below.<br><br>
If operation type is factorial, client resolves challenge as described below.<br><br><br>
If operation type is hash, client resolves challenge as described below.<br>
1.	out = hash(random)||hash(h(1))....||hash(h(r)) where size of out is<br>
greater than are equal to size.<br>
where hash is hashing algorithm,<br>
h(i)= hash(h(i-1)) for i ranging from 2 to r, h(1) = hash(random), || indicates concatenation. Generate output using hash algorithm and concatenate the hash values generated.<br>
2.	Leading 'size' bytes from out constitute e2.<br>
3.	res = a{c{*c2-l\mod(m))<br>
Calculated result, res is sent to server. In order reduce number of bytes sent to server, client depending on agreement with server shall use one of methods explained above to send result.<br>
IV. Challenge response verification in server<br>
For all operation types discussed above if server and client have not agreed on reducing size of response from client (as explained in section V, below) and if result (generated in step (9) of section I) is equal to value of res received from client, challenge is considered to be resolved successfully. Other wise server concludes that client fails to resolve challenge.<br><br>
If client and server have agreed upon reducing size of response from client (as explained in section V, below), procedure explained in section V is applied to verify result from client.<br>
V.   Reducing size of response from client<br>
In order to enable efficient utilization of network bandwidth, client shall send only the fingerprint of challenge to server, instead of sending complete value of result generated for challenge.<br>
Fingerprint will be generated by client and server using following methods:<br>
A. Hash mechanism<br>
1.	Client and server agree on hash algorithm.<br>
2.	The result generated for challenge is applied to hash function to generate hashed output.<br>
Here Client sends hashed output to server, and server generates the hashed output using result in step (9) of section I above and compares with the hashed output received from client. If the hashed output generated by server matches with the value sent bye client, server concludes that client has resolved challenge successfully.<br><br>
Alternately in the above-mentioned method, client and server shall agree to exchange only part of hashed output (for example say leading 10 bytes of hashed output) to further reduce number of bytes sent by client.<br>
B. Repeated XOR<br>
1.	Client and server agree on a block size.<br>
2.	If number of bytes in result generated for challenge is not multiple of block size agreed upon, the result value is appended with minimal number of zero bytes (0x00) at the end, so that result generated for challenge along with padding is multiple of block size. If block size is s, number of 0x00 bytes appended at end of result will range from 0 to (s-1).<br>
3.	The result generated for challenge is divided into block size agreed. Let res be the result generated for challenge with padding, then<br>
res = block(0)|| block(1)...||block(n), || indicates concatenation.<br>
4.	Perform XOR operation over blocks to generate output. Final<br>
output is calculated as out = block(0)٨block(1)	٨block(n). (٨<br>
indicates XOR operation).<br>
Client sends output generated in step (4) to server, server follows "Repeated XOR" method explained above and generates output using result in step (9) of section I above and compares with value received from client. If the values match, server concludes that client has resolved challenge successfully.<br><br><br><br><br>
Since a(eX*el-d) is congruent to amaig'" under modulo m, reducing a(tlV2"(/)and anm*"7 by modulo m would yield same values.<br>
3.    Easy way to generate n in section (A) of (I) such that nexp mod(<p is not></p>
zero. To prove:<br>
If n is a prime and n is not perfect divisor of <p than nexp="rem"></p>
where rem is non zero positive value.<br>
Proof:<br><br>
This can be proven by contraction.<br><br>
According to (3) n is a factor of <p which contradicts with property that n is not perfect divisor of></p>
So, equation (2) is invalid and there is some non-zero remainder. If nex?
«exp can not be equal to φp (m) because, it contradicts with properly that n is not perfect divisor of φ (m).<br>
Thus, n٨exp mod(^ (m)) is always non-zero when n is prime , exp&gt;=0 and n is not perfect divisor of φ (m).<br>
VII. Complexity of breaking the method<br>
1.    Finding q&gt; (m)<br><br>
cp (m) shall be found either by factorizing m or by deriving equation e1=x*φ (m)+c<br>
from el Both of them require factorizing big numbers and in practice factorizing big numbers are extremely difficult.<br>
2.   Finding order of a<br>
If there is some simple algorithm to find order of 'a', costly exponentiation operation can circumvented in client side. But finding order of a number is very costly operation.<br>
The challenge-response mechanism explained above shall be turned on when attack is anticipated and in normal conditions it shall be turned off or the cost of challenge-response operation shall be kept as minimal as possible.<br>
2.  Deployment Scenarios<br>
Applying challenge-response mechanism described in above needs resolving issues related to<br>
•	Overall operation considering all entities/systems involved<br>
•	Enabling defense functionality in legacy systems without change in existing protocol/design<br>
•	Design of protocol/system with defense mechanism<br>
•	Deployment of challenge-response with effective bandwidth utilization<br>
Following sections in document describes about approaches that shall be applied in<br><br>
different scenarios.<br>
Intermediate system is a system, which resides in between client and server, performing operations delegated to it. There may be zero or more intermediate systems between client and server. Intermediate system does not invest its resources in resolving challenge and it has enough information to route challenge-response related messages.<br>
For example, if web browser is considered as client and HTTP server providing content is considered as server, HTTP proxy residing in between browser and HTTP server is considered as intermediate system.<br>
Challenge manager service resides with server or other system and is responsible for managing challenge-response operation carried out.<br>
Challenge resolver service in client resolves challenges directed to it, ensuring that system is not over-burdened in resolving challenges. It alerts user if the number of challenges arriving at it reaches or exceeds beyond threshold limit. Threshold limit may be determined by configuration parameters, resources available and other relevant parameters. Challenge resolver service has to be installed in client in order to resolve challenges arriving at it. For example in an environment where there can be larger number of mobile nodes, Challenge resolver service can be installed by service provider or trusted authority using OMA (Open Mobile Alliance) Device management protocol, without causing any burden to user.<br><br>
Sniffer is an application, which resides with server or other system and monitors the traffic of interest and initiates challenge-response operation with the help of "Challenge manager service" and takes appropriate corrective actions when deviation is identified.<br>
I.        Applying challenge response method to protocol or design<br>
A.	Client and Server without intermediate system<br>
The method explained below describes how challenge-response method shall co-exist with protocol/ design of client and server. In this method client communicates with server without any intermediate system. Server before committing its resources for client, throws a challenge (sequence 2 in Figure 1) to client, verifies response (sequence 3 in Figure 1) and upon successful<br>
*<br>
verification server commits its resources to client.<br>
B.	Client connecting to server through intermediate systems<br>
In some cases as shown in figure 2, client may not directly connect to server, but through intermediate system (for example proxy/gateway). When client connects to server through intermediate system (sequences 1, 2 in Fig. 2), server throws challenge to client (sequence 3 of Fig. 2). Challenge received by intermediate system (sequence 3 fig. 2) is routed to client (sequence 4 of fig. 2) and response from client (sequence 5 in fig. 2) is routed to server (sequence 6 of<br><br>
fig 2). Upon finding response to be valid, server commits resources to serve the client.<br>
For messages related to challenge-response operation, intermediate system acts as router and does not commit its resources in resolving challenge.<br>
II.       Applying challenge  response method  with  minimal  change of application in server and services added in client and server<br>
The following methods describe about employing challenge-response mechanism with minimal change in application on server and there is no change in application residing on client. Server runs Challenge manager service, which throws challenges and verifies the responses. Client runs Challenge resolver service, which responds to challenges arriving at it. This method enables server to make client perform challenges in proportion to the extent to which client loads server. Since Challenge resolver service in client runs as separate service, it is may be vulnerable to attack which shall be avoided by client warning user if number and complexity of challenges arriving at it exceeds threshold limit. Threshold limit shall be configured by user or trusted authority depending on expected load on client, resources available in client and application relevant parameters.<br>
A. Client connecting to Server without intermediate systems<br><br>
In this method client communicates with server without any intermediate system. Server before committing its resources for client, requests Challenge manager service to perform challenge response operation (sequence 2 in Fig. 3). Challenge manager service in server throws challenge to client (sequence 3 in Fig. 3), receives response (sequence 4 in Fig. 3), verifies status of response and returns status of operation (sequence 5 in Fig. 3) to application in server. When challenge response operation is successful, server commits its resources to client to perform further operations (sequence 6 in Fig. 3).<br>
B. Client connecting to server through intermediate systems<br>
In some cases as shown in figure 4, client may not directly connect to server, but through intermediate system (for example proxy/gateway). In this method server, before committing its resources to serve client, requests Challenge manager service to perform challenge-response operation (sequence 3 in Fig. 4). Challenge manager service in server, throws challenge (sequence 4 of Fig. 4) to client. The intermediate system, which receives the challenge, forwards it to client (sequence 5 in Fig. 4).<br>
Challenge resolver service in client resolves the challenge and sends the response to intermediate system (sequence 6 of Fig. 4), and intermediate system forward the response to server (sequence 7 of Fig. 4). Challenge manager service in server verifies the response from client and passes the status of operation to application (sequence 8 in Fig. 4). If challenge is resolved successfully, server commits its<br><br>
resources to service client and responds to client's request (sequence 9, 10 in Fig 4). In case if there are multiple intermediate systems, they perform the operations delegated to them by protocol/design and when a challenge is received by an intermediate system, it shall act as channel to route the challenge and response to appropriate entities and do not invest its resources in resolving challenge.<br>
III.      Applying challenge response method legacy systems with out change in existing application in server and client<br>
In some cases it is quite possible that applications in server and client cannot be changed. In such cases, challenge-response operation should be deployed without any change in application in server and client. The methods described below make use of sniffer to achieve the purpose. Sniffer keeps monitoring the traffic that arrives at Application in server. Upon detecting a request, which would cause server to perform resource intensive operation, sniffer initiates challenge-response operation with the help of Challenge manager service. If the response for challenge is not correct, it shall take appropriate corrective actions like generating system alerts to prompt administrators or configure firewall to drop packets originating from a specific mal-performing client.<br>
Since sniffer is independent of application on server, before sniffer detects and completes challenge-response operation, application might have invested its resources to serve client. In order to better utilize server resources, sniffer shall stand a step ahead of server (for example in firewall), where in it is be able to<br><br>
receive the packets before it reaches server, queue it for some time, perform challenge-response operation and when response for challenge is successful, shall forward the appropriate packet in queue to server.<br>
A.	Client connecting to Server without intermediate systems<br>
Upon sniffer detecting a request, which would cause resource intensive operation in server (sequence 1 of Fig. 5), initiates Challenge manager service in server to perform challenge-response operation (sequence 2 of Fig. 5). Challenge manager service throws challenge to client (sequence 3 of Fig. 5), receives response from client (sequence 4 in Fig. 5), verifies if result is valid and returns status to sniffer (sequence 5 in Fig. 5). Sniffer upon finding results to be invalid shall take appropriate corrective actions like alerting system administrators or blocking traffic from client. Application in server after receiving request (seq. 1 in Fig. 5) performs appropriate operations to generate response (seq.6 in Fig. 5).<br>
B.	Client connecting to server with intermediate systems<br>
For messages related to challenge-response operation, intermediate system acts as router and does not commit its resources in resolving challenge. In some cases as shown in figure 6, client may not directly connect to server, but through intermediate system (for example proxy/gateway). Request raised by client reaches server through intermediate system (sequence 1, 2 of Fig. 6). Sniffer upon detecting the request, which could cause resource intensive operation in server, initiates<br><br>
challenge-response operation (sequence 3 in Fig. 6). Challenge manager service in server, throws challenge to client and it passes through intermediate system as shown in sequences 4, 5 of Fig. 6. Challenge resolver service in client, resolves challenge and sends response to server which passes through intermediate system as shown in sequences 6, 7 in Fig. 6.<br>
Challenge manager service in server verifies the response from client and passes the status of operation to sniffer (sequence 8 in Fig. 4). Sniffer upon finding results to be invalid, shall take appropriate corrective actions like alerting system administrators or blocking traffic from client. After receiving request application in server (seq. 2 in Fig. 6), perform appropriate operations to generate response (seq. 7 in Fig. 5).<br>
In case if there are multiple intermediate systems, they perform the operations delegated to them by protocol/design and they shall act as channel to route the challenge and response to appropriate entities and do not invest their resources in resolving challenge.<br>
IV.      Applying challenge-response mechanism with effective bandwidth utilization<br>
Since challenge-response messages would be exchanged very often before server performing resource intensive operation, it is very important that number of bytes exchanged is kept as minimal as possible. The challenge parameters sent by<br><br>
server contains few parameters that will not be refreshed quite often. Further there are other parameters like algorithm to be used for a particular operation, which will not change quite often. Effective exchange the parameters which do not change quite often will enable efficient network bandwidth utilization.<br>
The challenge parameter set is divided into two sub-sets. One set is called fixed challenge parameters and other set is called variable challenge parameters. Fixed challenge parameters are the ones that do not change very often and have considerable lifetime. Variable challenge parameters are the ones that change for almost for every challenge-response operation.<br>
Following sections explain about exchange of fixed and variable challenge parameters, mapping between them, validity duration of fixed parameters and how challenge-response operation is performed using fixed and variable set challenge parameters.<br>
A.    Control parameters<br>
Control parameters are the parameters, which enable mapping between fixed challenge parameters and variable challenge parameters unambiguously along with validity parameter, which holds duration for which fixed challenge parameters are valid.<br>
System identifier is a control parameter, which uniquely identifies a system that<br><br>
wants to defend itself from attack. System identifier can be Fully Qualified Domain Name, IP address which does not change for longer duration. A system may have one or more system identifiers.<br>
Challenge identifier is a parameter, which uniquely identifies fixed challenge parameters thrown by a system. System identifier and challenge identifier uniquely identify a fixed challenge parameter set. Challenge identifier is a unique identifier and does not repeat.<br>
Validity is the time duration for which fixed challenge parameters are valid. This enable hosts to flush out out-dated fixed challenge parameters.<br>
B.    Selection of fixed challenge parameters<br>
Following parameters are considered as fixed challenge parameters. These parameters are selected from sub-section I of "Proposed challenge-response method" (section 1). Following parameters shall constitute fixed challenge parameters<br>
i.     Value m is a part of fixed challenge parameters. Please refer step 2 of<br>
section I in Proposed challenge-response method section, ii.     If exponentiation method is used, values n, exp (section 1, sub-section I) along with operation type 'exponentiation' is a part of fixed challenge parameters, iii.     If factorial method is used (section 1-1), parameters num along with operation type 'factorial' constitute part of fixed challenge parameters.<br><br>
iv. If hash method is used (section 1-1), parameters random, size, hash algorithm and operation type 'hash' constitute part of fixed challenge parameters.<br>
v. If reducing size of response from client (section 1-V) is employed with Hash mechanism (section 1-V-A) than a parameter to indicate usage<br>
of reducing size of response from client, identifier to indicate hash method, hash algorithm to be used and portion of hashed output to be exchanged (if only part of hashed output is exchanged) constitute part of fixed challenge parameters, vi.     If reducing size of response from client (section 1-V) is employed with<br>
Repeated XOR mechanism (section 1-V-B) than a parameter to indicate usage of reducing size of response from client, identifier to indicate XOR method, block size constitute part of fixed challenge parameters.<br>
Thus server forms fixed cost parameters. Other challenge parameters in section 1-1, apart from above mentioned constitute variable challenge parameter set.<br>
C.	Communication  of fixed  challenge  parameters  along  with  control<br>
parameters<br>
The set constituting fixed cost parameters along with control parameters are communicated to clients. The mode of transport is explained section H below.<br>
D.	Management of fixed challenge parameters and control values in client<br><br>
Clients after having received fixed challenge parameters along with control parameters shall store them till the validity period. Clients shall also be configured to accept fixed challenge parameters along with control parameters only from specific systems identified by System identifier. This enables client to ignore fixed challenge parameters arriving from unknown systems, which may not be of interest to client.<br>
E.	Challenge message exchange with variable challenge parameters,<br>
control parameters and challenge resolving process in client<br>
When server wants to perform challenge-response operation, shall send only variable portion of challenge (with some exceptions as explained above) along with system identifier (if required) and challenge identifier to client. Client upon receiving challenge with variable parameters and required control parameters shall map to fixed challenge parameter which is already received, using system identifier and challenge identifier to construct complete challenge parameter set. Once complete set of challenge parameters are identified in client, it shall perform modular exponentiation operation as explained in section 1 —III. Resolved challenge is sent to server for verification.<br>
F.	Methods to get fixed challenge parameters when required<br>
It may so happen, that at the time when variable challenge parameters along with<br><br>
control parameters are received, client may not have appropriate mapping to fixed-challenge parameters. This scenario may arise when client fails to receive fixed challenge parameters from server.<br>
Following methods can be used to exchange fixed-challenge parameters at run<br>
time:<br>
i. Before getting variable challenge parameters, client sends the list of challenge-identifiers possessed by it to server. Server upon detecting appropriate fixed-challenge parameters not present in client shall send the fixed-challenge parameters along with control parameters and variable challenge parameters along with required control parameters to client. Client shall store the fixed challenge parameters in device (so that it need not request again). Once fixed and variable parameters are received client shall follow procedure explained above to resolve the challenge.<br>
Server may also send list of all fixed-challenge parameters which are supposed to be known to client along with the ones which are required for on-going challenge-response operation. Client shall store fixed-challenge response in it, so that it need not request for the same in later challenge-response operations.<br>
ii.     If server can keep track of fixed-challenge parameters sent to client and client's identitv before oerformina challenae-resnonse oneration server<br><br>
shall send fixed-challenge parameters and control variables to client if required( if it is not communicated to client earlier). Server also sends variable challenge parameters along with required control parameters. Using fixed and variable challenge parameters along with required control parameters, client shall follow procedure explained in section 2-IV-E to resolve the challenge. Client shall store the fixed-challenge parameters and its control parameters for future reference.<br>
G.    Control messages<br>
Control messages shall be sent to clients to control change in validity of fixed challenge parameters.<br>
Control messages shall be sent to<br>
i.     Invalidate already sent fixed-challenge parameters along with control parameters<br>
If server or relevant authority want to invalidate already sent fixed-challenge parameters, shall send a control message containing operation type which identifies invalidation of particular fixed-challenge parameters along with control parameters, system identifier and challenge identifier of fixed-challenge parameters. Client upon receiving this control message shall delete appropriate fixed challenge parameters and its control parameters identified by system identifier and challenge identifier.<br><br>
ii.     Extend the life-time of already sent fixed-challenge parameters along with control parameters<br>
If server or relevant authority wants to extend validity period of already transmitted fixed-challenge parameters along with challenge parameters, shall send control message containing operation type which identifies extension of life-time for fixed challenge parameter set, new time till which fixed-challenge parameters are valid, system identifier and challenge identifier of fixed challenge parameters on which change has to be applied.<br>
H.    Communication of asynchronous messages<br>
Server or relevant authority would like to send messages like fixed-challenge parameters along with control parameters (section 2-IV-C) or control message<br>
(section 2-IV-G) from time to time.<br>
Such asynchronous messages shall be communicated to client over reliable and/or un-reliable transport medium.<br>
When asynchronous messages are communicated over reliable transport medium, server shall be able to keep track of its client who has received its asynchronous messages. For example, reliable transport medium can be i.     Reliable push over WAP or HTTP.<br><br>
ii. Client shall run a service at a port and server upon knowing that it can reach client, shall send fixed-challenge parameters to it over reliable transport mediums like TCP, HTTP etc.<br>
When asynchronous messages are communicated over un-reliable transport layers like for example, IP broadcast, IP multicast, UDP or any connectionless transport means, in order for client to receive message,<br>
i.       Server may keep sending the messages periodically or<br>
ii.       Client shall use either of methods explained in section 2-IV-F to get<br>
fixed-challenge parameters.<br>
Alternatives/other embodiments of the invention<br>
1.     Reducing size of d above to save bandwidth:<br>
In step (7) of section 1-1, d = cVmargin. If c*r is greater than φ(m), d and<br>
margin shall be calculated as described below.<br>
Let margin be a small value (say varying from 1 to 30). If c*r mod {<p></p>
does not reveal (not close to p(m)), then d=(c*r mod (<p margin.></p>
Reduced size of 'd' enables saving few bytes at the cost of performing a modular multiplication operation. Proof in section 1-VI, shall be logically extended for this change. Step (9) in section 1-1 holds good for verification operation in server.<br><br>
2.	When sign in some equations are changed in section I and/or III of section 1, would result in server performing result = a٨(-margin) mod(m) to calculate result for verification. a٨(-margin) mod (m) can be calculated using Extended Euclidean Algorithm. [The extended Euclidean algorithm is a version of the Euclidean algorithm; its input are two integers a and b and the algorithm computes their greatest common divisor (gcd) as well as integers x and y such that ax + by = gcd(a, b). The equation ax + by = gcd(a, b) is particularly useful when a and b are co-prime, x is then the multiplicative inverse of a modulo b]<br>
3.	Even when sign in some equations are changed in section I, III of section 1, would result in server performing result=aAmargin mod(m) to calculate result for verification.<br>
4.	In section 1-1, step (4) is e1= x*φ (m)+c. If x is set to 1 and c = +/- margin<br>
where margin is small value, e1 becomes e1 = φ (m)+/-margin. If values of e2<br>
and d are fixed as e2 = 1  and d = 0, main operation becomes a٨( φ<br>
(m)+/-margin) mod (m) in client and in server it becomes, a٨margin mod(m) or a٨(-margin) mod(m)[this can be calculated using extended Eucledian algorithm]. This would make server to refresh value of m almost for every transaction, since in the above equation margin is small value, ^(m) can be<br>
easily identified from el<br>
5.	In the methods described above, server shall delegate separate system to<br>
perform challenge response operation, i.e. Challenge manager service shall<br><br>
reside in some other machine and carry out the operation. When application in server decides to perform challenge-response operation, shall request client to contact system delegated by it to perform challenge-response operation. Once client performs challenge response operation, server commits its resources to serve client after verifying if client has successfully performed challenge-response operation with the system delegated by it.<br>
6.	In section 2-IV, fixed challenge parameters along with control parameters and control messages may be optionally signed in-order to assert authenticity of messages.<br>
7.	In section 2-IV, fixed challenge parameters along with control parameters when updated as a part of DNS resource record can reach clients easily.<br>
Advantage(s) of the Invention<br>
Challenge-response method proposed above defends system from resource consumption attacks has following advantages.<br>
1.	Cost of resolving the challenge shall be controlled by server:<br>
Complexity of modular exponentiation operation in client is directly dependent on parameters e1 and e2,.Since values of e1 and e2 are determined by server, it has full control over determining cost of operation in client.<br>
2.	Verification is very light weight operation in server, thus saving server's<br>
resources for critical operations:<br><br>
Despite cost incurred by client in resolving challenge, server has to perform a٨ margin mod(^ (m)) to verify challenge. Since margin is controlled by server and<br>
is very small value, complexity of modular exponentiation operation is always low.<br>
3.	Usage of pre-calculated values:<br>
All the operations specified in steps (1)-(9) in section 1-1 and operations specified in section 1-V can be pre-calculated. This enables server spending very minimal resources while performing challenge-response operation at run time.<br>
4.	Comparison of proposed method with methods described in prior art section:<br>
A.	Comparison with Anti-clogging cookies<br>
Anti-clogging cookies do not make client to go for a resource intensive operation. The method proposed employs challenge-response mechanism in which cost of operation performed in client is controllable by server.<br>
B.	Comparison with client puzzles<br>
Complexity of resolving challenge increases exponentially with increase in a bit. Further even if brute force or linear search mechanism is employed to resolve challenge, controlling cost of operation in client is difficult. In the proposed method, cost of operation in client can be controlled in better way by changing values of e1 and/or e2.<br>
C.	Comparison with DOS resistant authentication with client puzzles<br><br>
Complexity of resolving challenge increases exponentially with increase in a bit. Cost of operations can be controlled in better way in proposed method by changing values of e1 and/or e2.<br>
If number of bits to be guessed is larger, client may end up with not being able to resolve challenge. In the method proposed results are guaranteed upon client performing modular exponentiation to resolve challenge.<br>
D.    Comparison with hash cash<br>
In hash cash method, server performs two modular exponentiation operations in order to verify the result. In the method proposed, server always performs aAmargin mod (m) to verify challenge (step 9 above). Since margin is chosen by server and always it is kept low, verification is simple in server despite cost incurred by client in resolving challenge.<br>
The present invention shall ordinarily be used in design of protocols, software/hardware systems for defending system against DOS attack. Further the method shall be applied to protect software or hardware resources, which are connected to network from DOS attack. Apart from DOS/DDOS mitigation, this method can be applied in an environment, where a system wants other system to resolve challenge in-order to proceed with further operations. For example, password cracking has become a common problem and the rate at which password is cracked shall be slowed down by employing challenge-response mechanism i.e., a system (say server) before validating password sent by other system (say client)<br><br>
snaii request client to resoive cnaiienge DeTore going Tor passwora verification operation. When client tries to crack password by throwing multiple requests would get loaded in trying to resolve the challenge thus slowing down the rate at which password is cracked.<br>
In the description herein, numerous specific details are provided, such as examples of components and/or methods, to provide a thorough understanding of embodiments of the present invention. One skilled in the relevant art will recognize, however, that an embodiment of the invention can be practiced without one or more of the specific details, or with other apparatus, systems, assemblies, methods, components, materials, parts, and/or the like. In other instances, well-known structures, materials, or operations are not specifically shown or described in detail to avoid obscuring aspects of embodiments of the present invention.<br>
While it is apparent that the invention herein disclosed is well calculated to fulfill the objects above stated, it will be appreciated that numerous modifications and embodiments may be devised by those skilled in the art, and it is intended that the appended claims cover all such modifications and embodiments as fall within the true spirit and scope of the present invention.<br><br><br>
WE CLAIM<br>
1.	A method for protecting servers from DOS attack with the avoidance of<br>
immediate commitment of server's resources to client, the method comprising<br>
the steps of<br>
a)	checking the commitment of client in going ahead with protocol, by throwing a challenge to it forcing to spend considerable resources in solving the challenge, whose cost is controllable by server;<br>
b)	verifying the results or responses sent by the client, spending relatively very small effort;<br>
c)	committing the resources for the serving client only if the above said result or response is valid; and<br>
d)	controlling the cost of the modular exponentiation operation in client.<br><br>
2.	The method as claimed in claim 1 wherein, the challenge is thrown by the system, which wants to defend itself from attack, or another system that is designated by it throw the challenge and validate it.<br>
3.	The method as claimed in claim 1, wherein the challenge and response mechanism comprises Pre-computation of parameters, Challenge generation in server, Challenge resolution in client, Challenge response verification in server and Reducing size of response from client<br>
4.	The method as claimed in claim 2, wherein the intermediate system if employed<br><br>
does not commit any resources, but acts only as router to route traffic related to challenge-response messages.<br>
5.	The method as claimed in claim 3, wherein the challenge-response mechanism can be deployed with or without minor changes on application in server and without any change in application on client.<br>
6.	The method as claimed in claim 1, wherein distribution of challenge parameters to utilize bandwidth efficiently, comprises a method for exchange of fixed challenge parameters along with control parameters, method for exchange of variable challenge parameters along with control parameters, mapping between fixed and variable challenge parameters, management of challenge parameters in client, control messages and communication Channel.<br>
7. A method for protecting servers from DOS attack with the avoidance of immediate commitment to client, substantially as herein above described and illustrated with reference to the accompanying drawings</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1DSEUtMjAwNSAgICBBTUVOREVEICBQQUdFUyBPRiBTUEVDSUZJQ0FUSU9OICAgMjgtMDgtMjAxMi5wZGY=" target="_blank" style="word-wrap:break-word;">1954-CHE-2005    AMENDED  PAGES OF SPECIFICATION   28-08-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1DSEUtMjAwNSAgICBBTUVOREVEIENMQUlNUyAgIDI4LTA4LTIwMTIucGRm" target="_blank" style="word-wrap:break-word;">1954-CHE-2005    AMENDED CLAIMS   28-08-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1DSEUtMjAwNSAgICBGT1JNLTEgICAyOC0wOC0yMDEyLnBkZg==" target="_blank" style="word-wrap:break-word;">1954-CHE-2005    FORM-1   28-08-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1DSEUtMjAwNSAgICBGT1JNLTEzICAgMjgtMDgtMjAxMi5wZGY=" target="_blank" style="word-wrap:break-word;">1954-CHE-2005    FORM-13   28-08-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1DSEUtMjAwNSAgICBGT1JNLTMgICAyOC0wOC0yMDEyLnBkZg==" target="_blank" style="word-wrap:break-word;">1954-CHE-2005    FORM-3   28-08-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1DSEUtMjAwNSAgICBGT1JNLTUgICAyOC0wOC0yMDEyLnBkZg==" target="_blank" style="word-wrap:break-word;">1954-CHE-2005    FORM-5   28-08-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1DSEUtMjAwNSAgICBQT1dFUiBPRiBBVFRPUk5FWSAgMjgtMDgtMjAxMi5wZGY=" target="_blank" style="word-wrap:break-word;">1954-CHE-2005    POWER OF ATTORNEY  28-08-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1DSEUtMjAwNSAgIEFNRU5ERUQgQ0xBSU1TICAwMy0xMC0yMDEyLnBkZg==" target="_blank" style="word-wrap:break-word;">1954-CHE-2005   AMENDED CLAIMS  03-10-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1DSEUtMjAwNSAgIEFNRU5ERUQgUEFHRURTIE9GIFNQRUNJRklDQVRJT04gIDAzLTEwLTIwMTIucGRm" target="_blank" style="word-wrap:break-word;">1954-CHE-2005   AMENDED PAGEDS OF SPECIFICATION  03-10-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1DSEUtMjAwNSAgIEVYQU1JTkFUSU9OIFJFUE9SVCBSRVBMWSBSRUNFSVZFRCAgIDI4LTA4LTIwMTIucGRm" target="_blank" style="word-wrap:break-word;">1954-CHE-2005   EXAMINATION REPORT REPLY RECEIVED   28-08-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1DSEUtMjAwNSAgIEVYQU1JTkFUSU9OIFJFUE9SVCBSRVBMWSBSRUNFSVZFRCAgMDMtMTAtMjAxMi5wZGY=" target="_blank" style="word-wrap:break-word;">1954-CHE-2005   EXAMINATION REPORT REPLY RECEIVED  03-10-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1DSEUtMjAwNSAgIEZPUk0tMTMgICAyOC0wOC0yMDEyLnBkZg==" target="_blank" style="word-wrap:break-word;">1954-CHE-2005   FORM-13   28-08-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1DSEUtMjAwNSAgIE9USEVSIFBBVEVOVCBET0NVTUVOVCAgMDMtMTAtMjAxMi5wZGY=" target="_blank" style="word-wrap:break-word;">1954-CHE-2005   OTHER PATENT DOCUMENT  03-10-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1DSEUtMjAwNSAgIE9USEVSIFBBVEVOVCBET0NVTUVOVCAgMjgtMDgtMjAxMi5wZGY=" target="_blank" style="word-wrap:break-word;">1954-CHE-2005   OTHER PATENT DOCUMENT  28-08-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1DSEUtMjAwNSAgIFBPV0VSIE9GIEFUVE9STkVZICAwMy0xMC0yMDEyLnBkZg==" target="_blank" style="word-wrap:break-word;">1954-CHE-2005   POWER OF ATTORNEY  03-10-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1jaGUtMjAwNS1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">1954-che-2005-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1jaGUtMjAwNS1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">1954-che-2005-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1jaGUtMjAwNS1jb3JyZXNwb25kbmVjZS1vdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">1954-che-2005-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1jaGUtMjAwNS1kZXNjcmlwdGlvbihjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">1954-che-2005-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1jaGUtMjAwNS1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">1954-che-2005-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1jaGUtMjAwNS1mb3JtIDEucGRm" target="_blank" style="word-wrap:break-word;">1954-che-2005-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1jaGUtMjAwNS1mb3JtIDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">1954-che-2005-form 13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk1NC1jaGUtMjAwNS1mb3JtIDI2LnBkZg==" target="_blank" style="word-wrap:break-word;">1954-che-2005-form 26.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="254398-system-and-method-for-using-natural-gas-to-generate-electricity-offshore.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="254400-articles-including-a-release-coating-containing-a-thermoplastic-silicon-containing-polymer.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>254399</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1954/CHE/2005</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>44/2012</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>02-Nov-2012</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>31-Oct-2012</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>29-Dec-2005</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>SAMSUNG INDIA SOFTWARE OPERATIONS PRIVATE LIMITED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>BAGMANE LAKEVIEW,BLOCK B NO.66/1 BAGMANE TECH PARK,C.V.RAMAN NAGAR,BYRASANDRA BANGALORE 560 093</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>PERUMAL RAJ S</td>
											<td>EMPLOYED AT SAMSUNG ELECTRONICS CO.LTD.,INDIA SOFTWARE OPERATIONS(SISO), HAVING ITS OFFICE AT, J.P TECHNO PARK, 3/1, MILLERS ROAD, BANGALORE 560 052</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F9/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td></td>
									<td></td>
								    <td>NA</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/254399-method-of-protecting-a-server-from-denial-of-service-attack by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 11:43:26 GMT -->
</html>
