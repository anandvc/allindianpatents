<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/208021-a-system-and-method-for-decoding-a-sequence-of-signals by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:11:12 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 208021:A SYSTEM AND METHOD FOR DECODING A SEQUENCE OF SIGNALS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A SYSTEM AND METHOD FOR DECODING A SEQUENCE OF SIGNALS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A soft decision output decoder and decoding method. The decoder decodes a sequence of signals output by an encoder and transmitted over a channel. The soft decision output decoder includes a first &quot;generalized&quot; Viterbi decoder for decoding the ;sequence of signals received over the channel during a forward iteration through a trellis representing the encoder output having a block length T. The first &quot;generalized&quot; Viterbi decoder begins at an initial state to and provides a plurality of forward iteration state metrics a for each state at each time interval over a window of length 2L, where k is on the order of a few constraint lengths and 2L is less than a block length T. A second &quot;generalized&quot; Viterbi decoder decodes the sequence of signals received over the channel during a backward iteration through the trellis. The second decoder starts at a second time t2L and provides a plurality of backward iteration state metrics B for each state at each time interval. A processor then performs a dual maxima computation at each state using the forward state metric, the backward state metric and the branch metric for same to provide a measure of the likelihood that a particular sequence of data was transmitted by the encoder. In the illustrative embodiment, the processor computes a log of the likelihood ratio using the forward and backward state metrics and the branch metrics for a selected state. This is achieved by first computing a max function as an approximation of the measure of the likelihood that a particular sequence of data was transmitted by the encoder. Then, a correction factor is computed for the approximation to provide a more exact measure of the likelihood that a particular sequence of data was transJT\itted by the encoder. In a specific embodiment, the correction factor includes an exponential function of the forward state metric and the backward state metric and the branch metric for a selected state. By performing forward and backward Viterbi decoding with dual maxima computations at each node within a winTw moved over the trellis, the inventive decoder provides the performance benefits associated with a LOG-MAP decoder while avoiding the excessive memory requirements of same.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
The present invention relates to communications systems. More specifically, the present invention relates to systems for encoding and decoding data in digital communication systems.<br>
IL-Dcacription ol the Related Art<br>
Communication systems facilitate transmission and reception of information from a source to a physically separate receiver. Mobile communications systems are typified by the movement of a receiver relative to a transmitter or vice versa. The communications link between transmitters and receivers in a mobile communications systems is characterised as a fading channel. Mobile satellite communications systems, having a transmitter on a spacecraft and a receiver on a ground based vehicle, cellular telephone systems and terrestrial microwave systems are examples of fading communications systems. A fading channel is a channel which is severely degraded. The degradation is due to numerous effects including multipath fading, severe attenuation due to the receipt via multiple paths of reflections of the transmitted signal off objects and Structures in the atmosphere and on the surface. Other effects contributing to the impairment of the faded channel include Dopplcr shift due to the movement of the receiver relative to the transmitter and additive noise.<br>
While both analog and digital communication methods have been used, digital methods afford several advantages including: improved immunity to channel noise and interference, increased capacity, and improved security of communication through the use of encryption.<br>
Typically, an information signal is first converted into a form suitable for efficient transmission over the channel. Conversion or modulation of the information signal involves varying a parameter of a carrier wave on the basis of the information signal in such a way that the spectrum of the resulting modulated carrier is confined within the channel bandwidth. At a user location, the original message signal is replicated from a version of the modulated carrier received subsequent to propagation over the channel.<br><br>
Such replication is generally achieved by using an inverse of the modulation process employed by the source transmitter.<br>
The field of data communications is particularly concerned with optimizing data throughput of a transmission system with a limited signal to noise ratio (SNJR), The use of error correcting circuitry, such as encoders and decoders, allows system tradeoffs to be made with smaller SNRs or higher data rates to be used with the same bit error rate (BER).<br>
One class of encoders is known as a convolutional encoder. As is well known in the art, a convolutional encoder converts a sequence of input data bits to a codeword based on a convolution of the input sequence with itself or with another signal. Coding rate and generating polynomials are used to define a convolutional code. Convolutional encoding of data combined with a Viterbi decoder is a well known technique for providing error correction coding and decoding of data.<br>
Coding rate and constraint length are used to define a Viterbi decoder. A coding rate (k/n) corresponds to the number of coding symbols produced (n) for a given number of input bits (k). The coding rate of 1/2 has become one of the most popular rates, although other code rates are also generally used. A constraint length (K) is defined as the length of a shift register used in a convolutional encoding of data. A constraint length of seven (K = 7) is typical in convolutional coding schemes. The convolutional encoder can be thought of as a Finite Impulse Response filter with binary coefficients and length K -1. This filter produces a symbol stream with 2 " possible states.<br>
The basic principle of the Viterbi algorithm is to take a convolutionally encoded data stream that has been transmitted over a noisy channel and use a finite state machine to efficiently determine the most likely sequence that was transmitted. The fundamental concept of a K = 7 Viterbi decoder is that it is a machine that hypothesizes each of the possible 64 states that the encoder could have been in and determines the probability that the encoder transitioned from each of those states to the next set of 64 possible encoder states, given what was received. The probabilities are represented by quantities called metrics, which are proportional to the negative of the logarithm of the probability. Adding of the metrics is therefore the equivalent to the reciprocal of the product of the probabilities. Thus, smaller metrics correspond to higher probability events.<br>
There are two types of metrics: state metrics, sometimes called path metrics; and branch metrics. The state metric represents the probability that the received set of symbols leads to the state with which it is associated. The<br><br>
branch metric represents the conditional probability that the transition from one state to another occurred assuming that the starting state was actually the correct state and given the symbol that was actually received.<br>
There are two possible states leading to any other state, each corresponding to the occurrence of a zero or a one in the rightmost bit of the convolutional encoder shift register. The decoder decides which is the more likely state by an add-compare-select (ACS) operation. Add refers to adding each state metric at the preceding level to the two branch metrics of the branches for the allowable transitions. Compare refers to comparing the pair of such metric sums for paths entering a state (node) at the given level. Select refers to selecting the greater of the two and discarding the other. Thus, only the winning branch is preserved at each node, along with the pode state metric. If the two quantities being compared are equal, either branch may be selected, for the probability of erroneous selection will be the same in either case.<br>
The Viterbi algorithm is a computationally efficient method of updating the conditional probabilities of the best state and the most probable bit sequence transmitted from the possible 2 K-l states. In order to compute the probability, all<br>
2K-1 states for each bit must be computed. The resulting decision from each of fliese computations is stored as a single bit in a path memory.<br>
A chain-back operation, an inverse of the encoding operation, is performed in which the C decision bits are used to select an output bit, where C is the chainback distance. After many branches the most probable path will be selected with a high degree of certainty. The path memory depth must be sufficiently long to be governed by the signal-to-noise ratio and not the length of the chain-back memory.<br>
Though it is not necessary for analyzing either the code characteristics or the performance of the optimal decoder, it is useful in understanding both to exhibit the code on a trellis diagram. The term "trellis" is a term which describes a tree in which a branch not only bifurcates into two or more branches but also in which two or more branches can merge into one. A trellis diagram is an infinite replication of the state diagram for an encoder. The nodes (states) at one level in the trellis are reached from the node states of the previous level by the transition through one, branch, corresponding to one input bit, as determined by the state diagram. Any codeword of a convolutional code corresponds to the symbols along a path (consisting of successive branches) in the trellis diagram.<br><br>
Convolutional codes with Viterbi decoders have been used extensively to achieve reliable communication over power limited channels such as satellite communication systems and interference limited channels such as CDMA wireless communication systems. In a paper by G. Ungerboeck entitled "Channel Coding with Multilevel/Phase Signals", IEEE Transactions of Information Theory, Vol IT-28, No, 1, January 1982, pp. 55-67, Ungerboeck used convolutional codes matched to two-dimensional signal constellations, to achieve coding gains of up to 6 dB (with respect to uncoded systems) over band limited channels. This technique is known as trellis coded modulation, and is widely used in data communication over voice-band telephone modems, digital transmission over coaxial cables, etc. G.D. Forney, Jr., in his treatise Concatenated Codes, Massachusetts Institute of Technology, 1966, developed a multilevel coding structure (consisting of a convolutional code and a block code) known as a concatenated code, which has been employed in deep space, resulting in very high coding gains.<br>
The achievements mentioned above represent significant milestones in the continuing effort at reducing the gap between the performance of practical communication systems and the fundamental limits imposed by the Shannon Theorem. The Shannon limit refers to the minimum signal-* to-noise ratio needed to communicate reliably over a given communication medium at a given spectral (bandwidth) efficiency. Recently, researchers have developed new classes of error correcting codes such as Turbo Codes and Serial Concatenated Interleaved Codes (SCIC), which provide further increases in performance over classical concatenated codes. These codes have been shown to achieve reliable communication at less than 1 dB above the Shannon limit The use of Turbo Codes is described in a paper by C Berrou entitled "Near Shannon Limit Error-Correcting Coding and Decoding: Turbo Codes/' Proceedings of ICC93, Geneva, Switzerland, pp. 1Q64-1070, May 1993. Serial Concatenated Codes are described in S-Benedetto's paper "Serial Concatenation of Interleaved Codes: Performance Analysis, Design, and Iterative Decoding," TDA Progress Report 42-126.<br>
The Turbo Codes as(swell as Serial Concatenated Codes employ-iterative decoding schemes, in which each iteration uses one or more soft-decision output trellis decoders. The overwhelming success of these codes has refocused attention on soft decision trellis decoders. J. Hagenauer describes a soft output Viterbi algorithm (SOVA) using soft output metric decoders in his paper "Iterative (Turbo) Decoding of Systematic Concatenated Codes with MAP and SOVA Algorithms," Proceedings of the<br><br>
ITG Conference on Source and Channel Coding, Frankfurt Germany, pp. 1-9, October 1994. In addition, J Hagenauer describes a soft output Viterbi algorithm in his paper "Concatenated Viterbi Decoding", Proceedings of the Fourth Joint Swedish-Soviet Int. Workshop on. Information Theory, Gotland Sweden, pp- 29-33, August 1989.<br>
\Vhile MAP decoders offer significant performance gains over SOVA decoders, it is generally felt that SOVA decoders are simpler and faster. A particular' limitation of the MAP approach is that it tends to be memory intenside, Hence, a need remains in the art for a soft output decision decoder which provides the superior performance of the MAP decoder while addressing the shortcomings and limitations of same.<br>
SUMMARY OF THE INVENTION<br>
The need in the art is addressed by the soft decision output decoder and decoding method of the present invention. The inventive decoder decodes a sequence of signals output by an encoder and transmitted over a channel. The inventive decoder includes two "generalized" Viterbi decoders (one for forward decoding and one for backward decoding) and a generalized dual maxima processor. The implementation of a dual maxima processor is described in detail in U.S. Patent No. 5,442,627, entitled "NONCOHERENT RECEIVER EMPLOYING A DUAL-MAXIMA METRIC GENERATION PROCESS", assigned to the assignee of the present invention and incorporated by reference herein.<br>
The first 'generalized" Viterbi decoder decodes the sequence of signals received over the channel during a forward iteration through a trellis representing the encoder output having a block length T. The first "generalized" Viterbi decoder begins at an initial state t0 and provides a plurality of forward iteration state metrics a for each state at each time interval over a window of length L, where L is less than a block length T but otherwise independent of T. In the illustrative embodiment, the first decoder sums products of the forward state metrics a,_1(s') for each previous state s' by a branch metric Yt(s',s) between each previous state s' and the selected state s to provide the forward state metric at(s) for the selected state<br>
s-<br>
A second "generalized" Viterbi decoder decodes the sequence of signals received over the channel during a backward iteration throttgh the trellis. The second decoder starts at a second time t2L and provides a plurality of backward iteration state metrics p for each state at each time<br><br>
terval. In the illustrative embodiment, the second decoder sums products of the backward state metrics 3t+i(s') for each subsequent state s' by a branch tetric Y1e)(S') between each subsequent state s' and each selected state sto<br>
rovide ;the branch metric p,(s) for the selected state s..<br>
i<br>
Al processor then performs a generalized dual maxima computation<br>
t each lime using the forward state metric of one state, the backward state<br>
' i letric of another state and the branch metric of the branch connecting the<br>
,vo states for same to provide a measure of the likelihood that a particular*<br>
equence of data was transmitted by the encoder. In the illustrative<br>
mbodimen the processor computes a log of the likelihood ratio using the<br>
Drward and backward state metrics and the branch metrics for a selected<br>
tate.     This  is achieved by first computing  a  max  function as an,<br>
pproximation of the measure of the likelihood that a particular sequence of<br>
iata was transmitted by the encoder. Then, a correction factor is computed<br>
or the approximation to provide a more exact measure of the likelihood<br>
hat a particular sequence of data was transmitted by the encoder. In a<br>
pecific embodiment, correction factor includes an exponential function of<br>
he forward state metric and the backward state metric and the branch metric<br>
or a selected state.  A similar technique applies to the operation of the two<br>
generalized Viterbi decoders.<br>
In an alternative embodiment, a third Viterbi decoder is provided for performing a second backward iteration through the trellis. The third lecoder provides a second plurality of backward iteration state metrics p for each state at each time interval starting at a third time t3L<br>
By performing forward and backward Viterbi decoding with dual maxima computations at each node within a window moved over the grellis, the invention provides the performance benefits associated with a L.OG-MAP decoder while avoiding the excessive memory requirements of same.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
The features, objects, and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings in which like reference characters identify correspondingly throughout and whereih:<br>
FIG. 1 is a block diagram of a transmitter and receiver operating over a channel using a conventional MAP decoder.<br><br>
FIG- 2 is a trellis diagram of a blocked (or tailed off) convolutional code which starts and terminates in a zero state.<br>
FIG. 3 is a block diagram of a transmitter and receiver operating over a channe and using a simplified LOG-MAP decoder .in accordance with the teachings of the present invention.<br>
FIG. 4 is a block diagram of an illustrative implementation of the soft output decision decoder of the present invention.<br>
FIG. 5 is a trellis diagram of a blocked (or tailed off) convolutional code which starts and terminates in a zero state.<br>
FIG.vr6 shows the timing for the forward and backward Viterbi decoders in accordance with a first illustrative implementation of the reduced memory simplified LOG-MAP method of the present invention.<br>
FIG. 7 is a flow diagram of the first illustrative implementation of the reduced memory simplified LOG-MAP method of the present invention.<br>
FIG. 8 shows the timing for the forward and backward Viterbi decoders in accordance with a second illustrative implementation qf the reduced memory simplified LOG-MAP method of the present invention.<br>
FIG. 9 is a flow diagram of the second illustrative implementation of the reduced memory simplified LOG-MAP method of the present invention.<br>
DETAILED DESCRIPTION OF THE PREFERRED<br>
EMBODIMENTS<br>
Illustrative embodiments and exemplary applications will now be described with reference to the accompanying drawings lo disclose the advantageous teachings of the present invention.<br>
While the present invention is described herein with reference to illustrative embodiments for particular applications, it should be understood that the invention is not limited thereto. Those having ordinary skill in the art and access to the teachings provided herein will recognize additional modifications, applications, and embodiments within the scope thereof and additional fields in which the present invention would he of significant utility.<br>
The present invention is best illustrated with a preliminary review of  the MAP algorithm as is known in the art.<br><br>
The MAP Approach;<br>
i 1<br>
FIG. 1 is a block diagram of a transmitter and receiver operating over a chahnel using a conventional MAP decoder. The system 10' includes a 1/N convolutional encoder 12' which receives an input sequence ut and outputs a signal stream xt to a modulator 14'. The modulator 14' modulates and spreads the signal in a conventional manner and provides it to the transmitter 16'. The transmitter 16' includes power amplifiers and antennas necessary to transmit the signal over an additive white Gaussian noise (AWGN) diannel 17'. The signal received over the channel yt is despread and demodulated by a conventional demodulator 19" and forwarded to a MAP decoder 20'. The MAP decoder 20' outputs an estimate of the input sequence w-:<br>
The operation of the conventional MAP decoder 20' is described below with reference to FIG. 2.<br>
PIG. 2 is a trellis diagram of a blocked (or tailed off) convolutional code which starts and terminates in a zero state. Focusing on the kth branch of the trellis 30' the following definitions are useful:<br>
uk - bits associated with the kth branch;<br>
s = generic state for the kth node (after kth branch);<br>
s' = generic state for (k-l)th node (before kth branch);<br>
yk = vector or received symbols for kth branch;<br>
yj<k- vector of received symbols for all branches before kth branch></k->
yj&gt;k = vector of received symbols for all branches after kth branch; and   .<br>
y = yj<k>k = vector of all received symbols over entire trellis.<br>
Then using the independence of symbols y on successive received branches and the Markov property of the trellis, (state s and branch yk depend only on state s')/ we have<br><br><br><br>
where the summations of numerator and denominator are over those pairs of states for which Uk+1 and uk = -1, respectively and the conditional probabilities of the first ratio are replaced by joint probabilities according to Bayes rule and cancellation of the common term p(y) in numerator and denominator. The likelihood ratio of eq. (7) provides a measure of the probability that a +1 was transmitted versus a -1 at time t When the likelihood ratio is computed for each time period, the code has been decoded. With hard decision output decoders, if a '1' is more likely than a '0', it is decoded as a T, otherwise, it is decoded as a '0'. But with turbo codes, a hard decision is not actually made. Instead, the likelihood ratios are retained as a level of confidence. Accordingly, the function of the decoder is to provide an indication of what has been transmitted and the level of confidence for same as determined by the likelihood ratio (i.e., eq. (7)).<br>
The MAP algorithm, then, consists of the operation eq. (7) coupled with the recursions of eqs. (5) and (6) which employ the branch likelihood eq. (4). Note that because equation (7) is a ratio, the a and p state metrics can be normalized at any node, which keeps all of them from overflowing.<br>
The conventional MAP approach as described above has been known in the art for over twenty years and generally ignored because:<br><br>
a)	with hard decision outputs, performance is almost the same as for<br>
the Viterbi algorithm and<br>
b)	complexity is much greater because of the multiplication operation<br>
required and the additional backward recursion. That is, the entire trellis 30'<br>
must be stored. The memory required is on the order of the length of the<br>
trellis times the number of states times the storage required for each state.<br>
With the incentive provided by turbo codes and SCIC and their improved performance employing MAP, interest was rekindled and it was recognized that simplification can be effected without compromising performance, as described below.<br><br>
Note that for a binary tree, the summations in equations (5') and (6') are over just two terms, while in equation (7'), each is over half the connected state-pairs of which there are in all 2m in each subset where m is the number of memory elements of the convolutional encoder 12', Note also that since the a and (5 metrics could be normalized by a common factor at each node, the a and b metrics can be reduced by a common amount at each node.<br><br>
with the approximation improving as the values X1 diverge.   Then equations (5') and (6') become the Viterbi algorithm recursions forward and backward,<br><br>
respectively, where the latter begins with the final node. Similarly, equation (7') becomes the dual-maxima procedure. Hence, we arrive at a forward and backward Viterbi algorithm, coupled together at each node by a dual-maxima computation. Accordingly, the soft output decision decoder of the present invention includes a forward Viterbi decoder, a backward Viterbi decoder and a dual maxima processor.<br>
FIG. 3 is a block diagram of a transmitter and receiver operating over a channel and using a simplified LOG-MAP decoder in accordance with the teachings of the present invention. The system 10 includes a convolutional encoder 1% which receives an input sequence ut and outputs a signal stream xt to a modulator 14. The modulator 14 modulates the signal in a conventional manner and provides it to the transmitter 16. The transmitter 16 includes power amplifiers and antennas necessary to transmit the signal over the channel 17- The signal received over the channel yt is demodulated by a conventional demodulator 19 and forwarded to the simplified LOG-MAP decoder 20 designed in accordance with the present teachings The decoder 20 is a soft decision output decoder which outputs an estimate of the input sequence ur.<br>
FIG, 4 is a block diagram of an illustrative implementation of the soft output decision decoder 20 of the present invention. In the illustrative implementation, the decoder 20 includes a buffer memory 22 which receives the demodulated received signal from the demodulator 19. The buffer memory delays the inputs to a forward Viterbi decoder 24 until enough signals samples are received for a backward Viterbi decoder 26 to initiate a backward recursion through the trellis. The outputs of the forward Viterbi decoder 24 and the backward Viterbi decoder 26 are input to a dual maxima processor 28- The dual maxima processor provides an estimate of the sequence ut under control of a timing circuit 27 and using a correction factor supplied by a read-only memory (ROM) 29 as described more fully below. The dual maxima processor 28 may be implemented with an application specific integrated circuit (ASIC), a digital signal processor (DSP) or a microprocessor by one of ordinary skill in the art.<br>
The operation of the decoder 20 is described below with reference to<br>
FIG. 5,<br>
FIG. 5 is a trellis diagram of a blocked (or tailed off) convolutional code which starts and terminates in a zero state. The trellis 30 is the same as that 30' of FIG. 2 with the exception that the forward and backward<br><br>
recursions are joined together at each node by the dual maxima computation of eq. (7).  <br>
Unfortunately, the approximation of equation (8) necessarily produces some degradation. This can be avoided by using the second revelation, the identity<br><br>
The secorded term is a correction factor which is implemented using a look: up table stored in ROM 29. The ROM 29 is driven by |x-y| while sign (x-y) is required to determine Max(x,y).<br>
i To obtain a precise form of equation (8) when there are more than . two terms in the sum, we nest the operations g() to obtain<br>
i<br>
i [ <br>
which is required for eq (7')/ as well as for eqs. (5') and (6') when the trellis structure is nonbinary.<br>
But the conclusion is the same with the correction (second term of eq. (9)) providing for the exact form. Hence, in accordance with one aspect of the present teachings, the LOG-MAP approach is implemented as two generalized Viterbi decoders coupled by a generalized dual-maxima procedure where the generalization involves adding the correction term to the max (x,y) function of eq. (8) to obtain the function g(s,y) of eq. (9).<br>
Implementation for Memory Reduction<br>
The remaining drawback of the LOG-MAP approach set forth above is that it is memory intensive. The entire state metric history must be stored, out to the end of the trellis, at which point the backward algorithm begins and decisions can be output starting with the last branch, without need to store any but the last set of state metrics computed backward. This storage requirement is obviously excessive. For a 16-state code, assuming 6-bit state metrics, it would require 96 bits of storage per branch, for a total of 96,000 bits for a 1,000 bit block, judged to be minimal for turbo code performance by those skilled in the art.<br>
This problem is addressed by the present invention. Although the teachings   of   the   invention   may   be   implemented   in   a   number   of<br><br>
embodiments, two illustrative embodiments are described herein: one involving a single backward iteration and one involving two backward iterations. The basis for both approaches is the fact that the Viterbi decoder can start cold in any state at any time. Initially the.state metrics are of little value, but after a few constraint lengths, the set of state metrics are as reliable as if the process had been started at the initial (or final) node. Let this "learning" period consist of L branches. (For a 16 state code, L=32 should be more than sufficient, amounting to over 6 constraint lengths of the convolutional code.) This applies equally to the backward as well as the forward algorithm and assumes that all state metrics are normalized by subtracting at every node an equal amount from each Both methods reduce the memory requirement for a 16-state code to just a few thousand bits, independent of the block length T.<br>
MEMORY REDUCTION USING A SINGLE BACKWARD ITERATION<br>
In this implementation, we let the received branch symbols be delayed by 2L branch times where L is the length of a window on the trellis -30. Then we set an initial condition of T in a linear implementation (or '0' in a log implementation) for the initial node and zero for all other nodes at the initial time to. Next, the forward Viterbi decoder 24 of FIG, 4 starts computing forward state metrics at the initial node at time t0 for each node every branch time in accordance with equation (5 or 5'). These state metrics are stored in a memory in the processor 28. This process is depicted in the diagram of FIG. 6.<br>
FIG. 6 shows the timing for the forward and backward Viterbi decoders in accordance with the first illustrative embodiment of the present invention. From time t-0 to time t=L, the generalized forward Viterbi algorithm-computes the forward state metric is shown by segment 42. At time t=L, the forward iteration is suspended and a backward iteration is initiated by the backward Viterbi decoder 26 of FIG. 4. The backward iteration is initiated not from the end of the trellis as with the conventional approach, but from time 2L as though it were the end of a frame of length 21. The nodes or states of the trellis 30 are all set at the initial value of T in a linear implementation or '0' in a log implementation. At first, the metrics are again unreliable as shown by the dashed line 44 in FIG. 6. These metrics become reliable after L as shown by 46. Hence, at time L, we have reliable forward and backward metrics. At this point, the generalized dual-maxima process may be performed according to equation (T) and soft decisions<br><br>
corresponding to the first L branches are output. We can now discard the forward metrics from time t = 0 to time t - L. Backward metrics are discarded upon computation of the next set of backward metrics.<br>
Next, the forward Viterbi decoder 24 moves forward from time t = L and forward metrics for each node are computed as above until time 2L. This is shown again by the line segment 42 in FIG. 6. At 2L the forward decoding is suspended and the backward Viterbi decoder 26 begins to generate metrics from time 3L. Again, these metrics are unreliable until time 2L as shown by the dashed line 48. However, from L to 2L, we now have reliable forward and backward metrics. Hence, we may compute th§ likelihood ratio during this time interval, using the generalized dual maxima computations.<br>
The method of this first illustrative implementation is depicted in the flow diagram of FIG. 7. As depicted in FIG. 7, the above described process is repeated over the entire trellis 30.<br>
Those skilled in the art will appreciate that the memory required is on the order of L times the number of states instead of T times the number of states where T is the trellis frame length and L « T. Those skilled in the art will also be able to choose an optimal frame length. In the illustrative embodiment, a frame length of L in the range of 5 to 7 constraint lengths was found to be sufficient.<br>
Alternative Implementation<br>
For the alternative illustrative implementation, reference is made to FIG-8 which shows the bit processing times for one forward processor and two backward processors operating in synchronism with the received branch symbols, i.e., computing one set of state metrics during each received branch time (bit time for a binary trellis). Once again we let the received branch symbols be delayed by 2L branch times. The forward decoder 24 of FIG. 4 starts again at the initial node at branch time 2L, computing all state metrics for each node every branch time and storing these in memory. For this implementation, the first and second backward Viterbi decoders are shown generally as '26' in FIG. 4. The first backward decoder starts at the same time as the forward decoder 24 but processes backward from the 2Lth node, setting every initial state metric to the same value,' not storing anything until branch time 3L, at which point it has built up reliable state metrics and it encounters the last of the first set of L forward computed metrics. At this point, the generalized dual-maxima process is performed according to<br><br>
equation (7'), the Lth branch soft decisions are output, and the backward processor proceeds until it reaches the initial node at time 4L- Meanwhile, starting at time 3L, the second backward decoder begins processing with equal metrics at node 3L, discarding all metrics- until time 4L, when it encounters the forward algorithm having computed the state metrics for the 2Ith node-   The generalized dual-maxima process is then turned on until<br>
; time 5L, at. which point all soft decision outputs from the 2Lth to the Lth<br>
 node Will have been output.  The two backward processors hop forward 4L<br>
branches every time they have generated backward 2L sets of state metrics<br>
 and the time-share the output processor, since one generates useless metrics while the other generates the useful metrics which are combined with those of the forward algorithm.<br>
The method of this alternative implementation is illustrated in the flow diagram of FIG. 9. Note that nothing needs to be stored for the backward algorithms except for the metric set of the last node and these only when reliable metrics are being generated. The forward algorithm only needs to store 2L sets of state metrics since after its first 2L computations (performed by time 4L), its first set of metrics will be discarded and the emptied storage cart then be filled starting with the forward-computed metrics for the (2L+l)th node (at branch time 4L+1). Thus the storage requirements for a 16-state code using 6-bit state metrics is just 192L bits in all, which for L=32 amounts to approximately 6,000 bits. (Note further that a conventional K = 7 Viterbi decoder with 64 states and a 32-bit path memory requires about 2,000 bits of memory, while a K=9 decoder requires at least a<br>
 40-bit path memory resulting in over 10,000 bits of storage). Hence, the LOG-MAP storage requirements are no greater than those of a conventional Viterbi algorithm.<br>
As for processing requirements, it would appear that the Viterbi algorithm load is thus tripled; furthermore, the complexity of the generalized dual-maxima process is no greater than that of the forward or backward Viterbi algorithm processor, so that overall the complexity is not more than quadrupled.  Also, the chain-back procedure is avoided. Further,<br>
 since the code is shorter, the number of states is reduced by a factor of 4 or 16 for the K=7 and 9 examples given. Since the MAP decoder (with short constraint length) is only justified for turbo codes, we must also account for the required number of iterations, which are of the order of 4 to 8. thus a 16-state serial turbo decoder performing 8 iterations imposes double the processing load of a K=9 Viterbi decoder and 8 times that of a K-7 decoder.<br><br>
Minimum decoding delay is set by the length of the block or its corresponding interleaver. If the processors described above operate at just the speed of the received branches, it may be necessary to pipeline the successive iterations and hence multiply the minimum delay by the pumber of iterations. If, on the other hand, the processors can operate at a much higher speed;, then additional delay can be much reduced.<br>
'The previous description of the preferred embodiments is provided to enaple any person skilled in the art to make or use the present invention. The various modifications to these embodiments will be readily apparent to those skijfjed in the art, and the generic principles defined herein may be applied to other embodiments without the use of the inventive faculty. Thus, the present invention is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein.<br>
WE CLAIM:<br><br><br><br>
We claims:<br><br>
1. A system for decoding a sequence of signals output by an encoder and transmitted over a channel, said encoder output represented by a trellis having a block length T, said system comprising:<br>
first means for Viterbi decoding said sequence of signals received over said channel during a forward iteration through said trellis, said first means providing a plurality of forward iteration state metrics a for each state at each time interval over a window of length 2L, where L is a number of constrainflengths and 2L is less than a block length T, wherein said forward iteration begins at an initial state to;<br>
second means for Viterbi decoding said sequence of signals received over said channel during a backward iteration through said trellis, said second means providing a plurality of backward iteration state metrics p for each state at each time interval starting at a second time; and<br>
third means for performing a dual maxima computation at each state using the forward state metric, the backward state metric and the branch metric for same to provide a measure of the likelihood that a particular sequence of data was transmitted by said encoder.<br>
2. The invention of Claim 1 wherein said first means includes means for multiplying a forward state metric aNl(s') for a previous state s' by a branch metric yt(s',s) to provide said forward state metric at(s) for a selected states.<br>
3- The invention of Claim 2 wherein said first means includes means for summing products of the forward state metrics <xt-i each previous state s by a branch metric yt between and the selected to provide said forward for></xt-i>
state s.<br>
4.	The invention of Claim 1 wherein said second means includes means for multiplying a backward state metric p*+i(s') for a subsequent state s' by a branch metric yt(s,s') to provide said branch metric j3t(s) for a ^elected state s.<br>
5.	The invention of Claim 4 wherein said second means includes means for summing products of the backward state metrics pt+t(s') for each<br><br>
subsequent state s' by a branch metric yt(s,s') between each subsequent state s' 4    and each selected state s to provide said branch metric pt(s) for the selected state s.<br><br>
6..       The invention of Claim 1 wherein said means for performing a<br>
2    dual maxima computation includes means for computing a likelihood ratio.<br>
7.	The invention of Claim 6 wherein said means for computing a<br>
2    likelihood ratio includes means for computing the log of the likelihood<br>
ratio.        <br>
8.	The invention of Claim 1 wherein said third means includes<br>
2    means for computing a max function as an approximation of the measure of<br>
the likelihood that a particular sequence of data was transmitted by said     encoder.<br>
9.	The invention of Claim 8 wherein said third means includes<br>
    means for providing a correction factor for said approximation to provide a<br>
more exact measure of the likelihood that a particular sequence of data was     transmitted by said encoder.<br>
10.	The  invention  of Claim  9  wherein said  correction factor<br>
   includes an exponential function of the forward state metric and the<br>
backward state metric and the branch metric for a selected state.<br>
11.	The invention of Claim 1 wherein said second means includes<br>
:   means for providing a second backward iteration through said trellis, said<br>
second means providing a second plurality of backward iteration state metrics p for each state at each time interval starting at a third time t3L-<br>
12.     A soft decision output decoder comprising:<br>
means for receiving a sequence of transmitted codewords; means for providing a trellis for decoding of said sequence of codewords, said trellis having a block length T;   ,<br>
first means for decoding said sequence of signals received over said channel during a forward iteration through said trellis, said first means providing a plurality of forward iteration state metrics a for each state at each time interval over a window of length 2L, where L is a number of<br><br>
I	!	i<br>
constraint lengths and 21 is less than a block length T, wherein said forward iteration begins at an initial state t0, said first means including means for summirig products of forward state metrics at.i(s')for each previous state s' by a branch metric Yt(s',s) between each previous state s' and a selected state s to provide a forward state metric at(s) for the selected state s;<br>
second means for decoding said sequence of signals received over said channel during a backward iteration through said trellis, said second means including:<br>
means for summing products of the backward state metrics pt+1(s') for Jach subsequent state s' by a branch metric Yt(s/S') between each subsequent state s' and each selected state sto provide a first plurality of backward iteration state metrics (3t(s) for each selected state s at each time interval starting at a second time t2L and<br>
means for summing products of the backward state metrics |3t+1(s') for each subsequent state s' by a branch metric Yt(s,s') between each subsequent state s' and each selected state s to provide a second plurality of backward iteration state metrics pt(s) for each selected state s at each time interval starting at a third time t3L: and<br>
third means for performing a dual maxima computation at each state using the forward state metrics, the backward state metrics and the branch metrics for same to provide a measure of the likelihood that a particular sequence of data was transmitted by said encoder.<br>
13.	The invention of Claim 12 wherein said means for performing a dual maxima computation includes means for computing a likelihood ratio.<br>
14.	The invention of Claim 13 wherein said means for computing a likelihood ratio includes means for computing the log of the likelihood ratio.<br>
15.	The invention of Claim 12 wherein said third means includes means for computing a max function as an approximation of the measure of the likelihood that a particular sequence of data was transmitted by said encoder.<br>
16.	The invention of Claim 15 wherein said third means includes means for providing a correction factor for said approximation to provide a<br><br><br>
more exact measure of the likelihood that a particular sequence of data was    transmitted by said encoder.<br>
17.	The invention of Claim 16 wherein said correction factor includes an exponential function of the forward state metric and the backward state metrics and the branch metric for a selected state.<br>
18.	A method for decoding a convolutionally encoded codeword including the steps of:<br><br>
a)	providing a trellis representative of an output of an encoder used to encode said codeword, said trellis having a block length T;<br>
b)	assigning an initial condition to each starting node of the trellis for a forward iteration through the trellis;<br>
c)	assigning an initial condition to each starting node for a backward iteration through the trellis;<br>
d)	computing a forward metric for each node in a window of length L on the trellis during a forward iteration, where the window length L is less than the block length T;<br>
e)	computing, during a backward iteration, a backward metric for each node in a window of length L on the trellis starting at a time 2L from a point at which the forward iteration is initiated;<br>
f)	computing a dual maxima for each node using the forward metric and the backward metric to decode said codeword; and<br>
g)	repeat steps d) - f) over entire block.<br>
19.	The invention of Claim 18 wherein the step f) includes the step<br>
of log mapping.<br>
*<br>
20.	The invention of Claim 18 wherein the step e) includes a step of initiating a second backward iteration starting at time 3L from a point at which the forward iteration is initiated.<br>
21.	A method for decoding a convolutionally encoded codeword including the steps of;<br>
a) providing a trellis representative of an output of an encoder used to encode said codeword, said trellis having a block length T;<br>
b) assigning an initial condition to each starting node of the trellis for<br>
a forward iteration through the trellis;<br>
"I<br><br>
       c) assigning an initial condition to each starting node for a backward 8    iteration through the trellis;	<br><br>
d) using a Viterbi algorithm to compute a forward metric for each 10   node in a window of length L on the trellis during a forward iteration,<br>
where the window length L is less than the block length T;<br>
12	e) using a Viterbi algorithm to compute, during a backward iteration,<br>
a backward metric for each node in a window of length L on the trellis 14    starting at a time 2L from a point at which the forward iteration is initiated;<br>
f)	computing a dual maxima for each node using the forward metric 16    and the backward metric to decode said codeword; and<br>
g)	repeat steps d) - f) over entire block.<br><br>
22.	the invention of Claim 21 wherein the step f) includes the step 2    of log mapping.<br>
23.	The invention of Claim 21 wherein the step e) includes a step 2    of initiating a second backward iteration starting at time 3L from a point at<br>
which the forward iteration is initiated.<br>
24.      A system for decoding a sequence of signals output by an pncoder  and  transmitted  over a channel,  said  encoder  output represented by a trellis having a block length T substantially as hereinbefore  described with  reference  to  the   accompanying drawings.<br>
251       A  3oft  decision  output  decoder  substant ially  as here inb^foj^e   described  with  reference  to  the   accompanying<br>
drawings.<br>
26.        A method  for  decoding  a  convolutionally   encoded<br>
i<br>
(iddeword  substantially as hereinbefore described with  reference<br><br>
to the accompaning drawings.<br><br></k></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzMy1tYXMtMTk5Ny0gYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">2533-mas-1997- abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzMy1tYXMtMTk5Ny0gYXNzaWdubWVudC5wZGY=" target="_blank" style="word-wrap:break-word;">2533-mas-1997- assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzMy1tYXMtMTk5Ny0gY2xhaW1zIGR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">2533-mas-1997- claims duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzMy1tYXMtMTk5Ny0gY2xhaW1zIG9yaWdpbmFsLnBkZg==" target="_blank" style="word-wrap:break-word;">2533-mas-1997- claims original.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzMy1tYXMtMTk5Ny0gY29ycmVzcG9uZGVuY2Ugb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">2533-mas-1997- correspondence others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzMy1tYXMtMTk5Ny0gY29ycmVzcG9uZGVuY2UgcG8ucGRm" target="_blank" style="word-wrap:break-word;">2533-mas-1997- correspondence po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzMy1tYXMtMTk5Ny0gZGVzY3JpcHRpb24gY29tcGxldGUgZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">2533-mas-1997- description complete duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzMy1tYXMtMTk5Ny0gZGVzY3JpcHRpb24gY29tcGxldGUgb3JpZ2luYWwucGRm" target="_blank" style="word-wrap:break-word;">2533-mas-1997- description complete original.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzMy1tYXMtMTk5Ny0gZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">2533-mas-1997- drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzMy1tYXMtMTk5Ny0gZm9ybSAxLnBkZg==" target="_blank" style="word-wrap:break-word;">2533-mas-1997- form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzMy1tYXMtMTk5Ny0gZm9ybSAyNi5wZGY=" target="_blank" style="word-wrap:break-word;">2533-mas-1997- form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzMy1tYXMtMTk5Ny0gZm9ybSAzLnBkZg==" target="_blank" style="word-wrap:break-word;">2533-mas-1997- form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzMy1tYXMtMTk5Ny0gZm9ybSA0LnBkZg==" target="_blank" style="word-wrap:break-word;">2533-mas-1997- form 4.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="208020-hydrostatic-transmission.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="208022-cable-splice-closure.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>208021</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>2533/MAS/1997</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>27/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>06-Jul-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>06-Jul-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>06-Nov-1997</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>6455 LUSK BOULEVARD, SAN DIEGO, CALIFORNIA 92121.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>SINDHUSHAYANA NAGABHUSHANA T</td>
											<td>10635 DABNEY DRIVE, #63, SAN DIEGO, CALIFORNIA 92126.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>VITTERBI ANDREW J</td>
											<td>2712 GLENWICK PLACE, LA JOLLA, CALIFORNIA 92037.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H03D001/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>08/743,688</td>
									<td>1996-11-06</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/208021-a-system-and-method-for-decoding-a-sequence-of-signals by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:11:13 GMT -->
</html>
