<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/268379-methods-and-apparatus-for-managing-the-storage-of-content-in-a-file-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 07:09:02 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 268379:METHODS AND APPARATUS FOR MANAGING THE STORAGE OF CONTENT IN A FILE SYSTEM</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHODS AND APPARATUS FOR MANAGING THE STORAGE OF CONTENT IN A FILE SYSTEM</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>One embodiment of the invention is directed to the containerization of content units that are accessed using an identifier. Applicants have appreciated that file systems sometimes impose limits on the number of files that may be stored therein that are too restrictive. Thus, in one embodiment, multiple content units may be stored in a single file, called a container file, in a file system. Each content unit may have an identifier associated with it. When an accessing entity requests access to a previously-stored content unit and provides the identifier for the content unit, the identifier may be used to locate the container file in which the content unit is stored.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>WO 2007/001596	PCT/US2006/014180<br>
-1-<br>
METHOPS AND APPARATUS FOR MANAGING THE STORAGE OF<br>
CONTENT IN A FILE SYSTEM<br>
Field of the Invention<br>
	The present invention relates to managing the storage of content.<br>
Description of the Related Art<br>
	A file system is a logical data structure that may be used to organize data. A file<br>
system generally has a plurality of logical partitions;, often referred to as directories or<br>
folders, that may be arranged in a hierarchy. In many file systems, there is a single<br>
directory at the top of the hierarchy, referred to as the root directory. Data may be<br>
arranged into logical units of storage, called files, which are stored in the file system's<br>
directories.<br>
	Typically, the file system is installed on a computer system having one or more<br>
underlying storage devices (e.g., a disk or a tape) on which the data is physically stored.<br>
The logical arrangement of files and directories in the file system may have little or<br>
nothing to do with the way the data is physically stored on the physical storage device.<br>
Thus, a map typically is used to map logical storage locations in the file system to the<br>
actual physical storage locations (e.g., blocks) on the storage device(s).<br>
	Many file systems impose limits on the number of files that may be stored in each<br>
directory and the total number of files that may be stored in the file system. These limits<br>
may be imposed by the file system for any number of reasons. For example, the<br>
performance of the file system may significantly, decrease as the number of files<br>
increases. Further, the limit may be imposed, for example, to guarantee disaster recovery<br>
in a certain amount of time, if, for example, the file system data structure is lost and<br>
needs to be restored from a backup copy.<br>
Summary of the Invention<br>
	One embodiment of the invention is directed to a method of managing content<br>
units in a file system, the method comprising acts of: receiving a first request to store a<br>
first content unit, the first content unit having a first content address that is computed<br>
based, at least in part, on the content of the first content unit; in response to the first<br><br>
WO 2007/001596	PCTAJS2006/014180<br>
-2-<br>
request, storing the first content unit in a file in the file system; receiving a second<br>
request to store the second content unit, the second content unit having a second address<br>
that is computed based, at least in part, on the content of the second content unit; and in<br>
response to the second request, storing the second content unit in the file. Another<br>
embodiment is directed to at least one computer readable medium encoded with<br>
instructions that, when executed on a computer system, perform the above-described<br>
method.<br>
	A further embodiment is directed to a computer that manages content units in a<br>
file system comprising: at least one input; and at least one controller coupled to the at<br>
least one input that: receives, via the input, a first request to store a first content unit, the<br>
first content unit having a first content address that is computed based, at least in part, on<br>
the content of the first content unit; in response to the first request, stores the first content<br>
unit in a file in the file system; receives, via Hie input, a second request to store the<br>
second content unit, the second content unit having a second address that is computed<br>
based, at least in part, on the content of the second content unit; and in response to the<br>
second request, stores the second content unit in the file.<br>
	Another embodiment is directed to a method of accessing a content unit having <br>
acontent address that is based, at least in part, on the content of the content unit, wherein<br>
the content unit is stored in a file in a file system, the method comprising acts of:<br>
receiving a request to access the content unit, wherein the request identifies the content<br>
unit using an identifier, and wherein the file in which the content unit is stored stores at<br>
least one additional content unit, the at least one additional content unit having a content<br>
address that is based, at least in part, on the content of the content unit; locating the file<br>
in which the content unit is stored using the identifier; and locating the content unit in the<br>
file in which the content unit is stored. A further embodiment is directed to at least one<br>
computer readable medium encoded with instructions that, when executed on a computer<br>
system, perform the above-described method.<br>
	Another embodiment is directed to a computer that accesses a content unit having<br>
a content address that is based, at least in part, on the content of the content unit, wherein<br>
the content unit is stored in a file in a file system, the computer comprising: an input; and<br>
at least one controller, coupled to the input, that: receives, via the input, a request to<br>
access the content unit, wherein the request identifies the content unit using an identifier,<br><br>
WO 2007/001596	 PCT/US2006/014180<br>
-3-<br>
and wherein the file in which the content unit is stored stores at least one additional<br>
content unit, the at least one additional content unit having a content address that is<br>
based, at least in part, on the content of the content unit; locates the file in which the<br>
content unit is stored using the identifier; and locates the content unit in the file in which<br>
the content unit is stored.<br>
	A further embodiment is directed to a method of storing content units in a<br>
hierarchical file system having a plurality of directories arranged in a hierarchical tree<br>
that has a plurality of levels, each of the plurality of levels corresponding to a unit of<br>
time, the hierarchical tree comprising at least one root directory and a plurality of non-<br>
root directories that each has a parent directory, wherein at least one of the plurality of<br>
directories in the tree correspond to a period of time subsumed by a period of time<br>
corresponding to its respective parent directory, the method comprising acts of:<br>
determining a rate at which content units are received for storage; and dynamically<br>
determining one of the plurality of levels at which to store content units based on the rate<br>
at which content units are received for storage. Another embodiment is directed to at<br>
least one computer readable medium encoded with instructions that, when executed on a<br>
computer system, perform the above-described method.<br>
	A further embodiment is directed to a computer that stores content units in a<br>
hierarchical file system having a plurality of directories arranged in a hierarchical tree<br>
that has a plurality of levels, each of the plurality of levels corresponding to a unit of<br>
time, the hierarchical tree comprising at least one root directory and a plurality of non-<br>
root directories that each has a parent directory, wherein at least one of the plurality of<br>
directories in the tree correspond to a period of time subsumed by a period of time<br>
corresponding to its respective parent directory, the computer comprising: an input; and<br>
at least one controller that: determines a rate at which content units are received through<br>
the input for storage; and dynamically determines one of the plurality of levels at which<br>
to store content units based on the rate at which content units are received for storage.<br>
Brief Description of the Drawings<br>
	Figure 1A is a block diagram of a system for containerizing content units, in<br>
accordance with one embodiment of the invention;<br><br>
WO 2007/001596						'PCT/US2006/014180<br>
-4-<br>
	Figure IB is a block diagram of system for containerizing content units that<br>
employs hierarchical storage management techniques, in accordance with one<br>
embodiment;<br>
	Figure 2 is a diagram of an example of a time-based directory structure which<br>
may be employed in embodiments of the invention;<br>
	Figure 3 is a block diagram of a system in which replicated content units may be<br>
containerized, in accordance with one embodiment;<br>
	Figure 4 is a block diagram illustrating the relationship between a container index<br>
file and a container file, in accordance with one embodiment;<br>
	Figure 5 is a block diagram of an example of a deletion data structure, in<br>
accordance with one embodiment;<br>
	Figure 6 is a block diagram of an example of a container file, in accordance with<br>
one embodiment;<br>
	Figure 7 is a diagram of an example of a storetime container file, in accordance<br>
with one embodiment; and<br>
	Figure 8 is a diagram of an example of a deletion container file, in accordance<br>
with one embodiment.<br>
Detailed Description<br>
	Applicants have appreciated that, in some situations, a file system-imposed limit<br>
on the number of files may be too restrictive to store all the desired data and* it may thus<br>
be desired to store the data in the file system in a manner that does not violate the limit.<br>
	Thus, one embodiment of the invention is directed to containerization of logically<br>
distinct content units, so that multiple distinct content units can be stored in the same file.<br>
Content units that are logically distinct typically are stored in separate files in a file<br>
system. For example, each document that is created by a word processing application<br>
usually is stored in a separate file because these documents are logically separate from<br>
each other: However, in one embodiment of the invention content units that are logically<br>
separate may be containerized. That is, two or more content units that are logically<br>
separate may be stored in a single file, called a container file, in the file system. In one<br>
embodiment, each content unit that is stored in the container may have its own identifier<br>
(e.g., a file name or other identifier) so that an entity accessing the content (e.g., a human<br><br>
WO 2007/001596			PCWS2006/014180<br>
-5-<br>
user, an application program, or a host computer) can use this identifier to access the<br>
content unit.<br>
	In one embodiment, the use of containers is transparent to entities storing and<br>
retrieving content units on the system, so that these users can store and retrieve content<br>
units without knowledge that the content units have been stored in container files with<br>
other content units, and may access the content units as if they were each stored in<br>
separate files.<br>
	The use of containers can decrease the number of files managed by the file<br>
system, and can allow a greater amount of data (grouped in container files) to be stored<br>
in the file system before reaching the limit on the maximum number of flies permitted to<br>
be stored thereby.<br>
	Using container files to store multiple content units may be done in any suitable<br>
way, as the invention is not limited to any particular implementation technique. For<br>
example, as shown in Figure 1 A, a host computer 109 may include an accessing entity<br>
101 (e.g., an application program), processing software 103, and afile system 105. The<br>
accessing entity 101 may communicate with processing software 103 which stores and<br>
retrieves data from file system 105. The data that is logically stored in file system 105<br>
may be physically stored on a storage device 107. When storing a content unit,<br>
accessing entity 101 may send the content unit to processing software 103 for storage.<br>
An identifier that has previously been associated with the content unit and of which<br>
accessing entity 101 is aware may be used by accessing entity 101 to later retrieve the<br>
content unit. Alternatively, the identifier may be assigned at the time of storage of the<br>
content unit in file system 105 by processing software 103 and returned to accessing<br>
entity 101 as acknowledgement of receipt of the request to store the content unit.<br>
Processing software 103 may receive the content unit from accessing entity 101 and may<br>
store the content unit in file system 105 in a container file that may also store other<br>
content units. If a container file that is suitable for storing the content unit does not exist,<br>
such a container file may be created and the content unit may be stored therein.<br>
	In the example of Figure 1 A, accessing entity 101, processing software 103, and<br>
file system 105 execute on host computer 109. However, the invention is not limited in<br>
this respect, as each of these layers may execute on a different computer or on any<br>
suitable combination of computers. For example, accessing entity 101 may execute on a<br><br><br>
WO 2007/001596	PCT/US2006/014180<br>
-6-<br>
storage system that replicates content units to host computer 109. Further, storage device<br>
107 may be any suitable type of storage device and may be an internal storage device of<br>
host computer 109 or storage device external to host computer 109, as the invention is<br>
not limited in this respect.<br>
	Accessing entity 101 may be any type of entity that accesses content, as the<br>
invention is not limited in this respect. For example, accessing entity 101 may be, for<br>
example, an application program, a human user, another computer, or any other suitable<br>
entity. In one embodiment, accessing entity may be a storage system (not shown) that<br>
communicates with processing software 103 to replicate content units stored on the<br>
storage system to storage device 107.<br>
	The identifier that is associated with the content unit may be any suitable<br>
identifier, as the invention is not limited in this respect. The identifier may be, for<br>
example, a human-readable name, or any other suitable type of identifier. In one<br>
embodiment, the identifier is a content address that is computed based, at least in part, on<br>
the content of the content unit. For example, the content unit may be hashed (using any<br>
suitable hashing algorithm) and the hash value may be used as all or part of the content<br>
address. While in one embodiment the content address may include only the hash value<br>
with no additional information, the invention is not limited in this respect as the content<br>
address may include any other suitable information in addition to the hash value. For<br>
example, the content address may also include a timestamp that indicates a time at which<br>
the content unit was created or initially stored in the file system or on another storage<br>
system. The content address may also include, for example, a guaranteed unique<br>
identifier (GUBD), which is a series of bits that are guaranteed to be unique and may be<br>
used to ensure that no two content addresses are identical. The content address may also<br>
include other information such as a flag that indicates what type of data is included in the<br>
content of the content unit. Examples of content addresses and the situations in which<br>
content addresses may be used are described in the applications listed in Table 1, each of<br>
which is incorporated by reference herein.<br>
	Storage device 107 may be any suitable type of storage device, as the invention is<br>
not limited in this respect. For example, storage device 107 may be a magnetic disk<br>
storage device, an optical disc storage device, a tape storage device, and/or any other<br>
suitable type of storage device. Similarly, any suitable file system software may be used<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-7-<br>
to implement the file system 105, as the invention is not limited in this respect In one<br>
embodiment, file system 105 is the StorNext™ file system sold by Advance Digital<br>
Information Corporation, having a place of business at 11431 Willows Road NE,<br>
Redmond, Washington, but the invention is not limited to this or any other particular file<br>
system.<br>
	In one embodiment, hierarchical storage management (HSM) may be employed.<br>
HSM is a technique by which data is automatically moved between more expensive, but<br>
faster storage devices (e.g., magnetic disk drives) and less expensive, but slower storage<br>
devices (e.g., optical disc drives and/or magnetic tape drives). Thus, in situations where<br>
it is prohibitively expensive to provide enough storage capacity on the faster storage<br>
devices, data may be stored on the slower storage devices and the faster storage device<br>
may be treated as a cache for the slower storage devices.<br>
	An example of system mat employs HSM techniques is shown in Figure IB. In<br>
Figure IB, logically stored in file system 105 may be stored on storage device 113 and a<br>
portion of this data may be cached on storage device 111. Thus, storage device 111 may<br>
be a more expensive, but faster storage devices, whereas storage device 113 is a less<br>
expensive, but slower storage devices. If processing software 103 requests a content unit<br>
stored logically in file system 103, if the content of that content unit is already cached on<br>
storage device 111, they the content may be retrieved from storage device 111.<br>
However, if the content is not already cached on storage device 111, then the content<br>
may be moved from storage device 113 into the cache (i.e., storage device 111) and may<br>
be returned to processing software 103.<br>
	In one embodiment, file system 105 is responsible for performing the HSM<br>
functions, although the invention is not limited in this respect For example, file system<br>
105 may allow a user to configure policies for certain directories and/or files that specify<br>
when and for how long the data stored in those directories and/or files should be kept in<br>
the cache (i.e., stored on storage device 111) and/or when that data should be moved to<br>
the storage device 113. File system 105 then moves the data between storage device 111<br>
and storage device 113 in accordance with this policy.<br>
	As discussed above, processing software 103 may either store a new content unit<br>
in an existing container file or create a new container file in which to store the content<br>
unit. The decision as to whether to store the content unit in an existing container file or a<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-8-<br>
new container file may be made in any suitable way, as the invention is not limited in<br>
this respect. Examples of techniques for making this decision are discussed below in<br>
greater detail. Processing software 103 may select any suitable container file in which to<br>
store a content unit and may select any suitable directory in file system 105 in which to<br>
store a container file, as the invention is not limited in this respect. Examples of<br>
techniques for selecting a directory in which to store a container file are discussed below<br>
in greater detail.<br>
	When accessing entity 101 desires to retrieve a previously-stored content unit,<br>
accessing entity 101 may provide the identifier associated with the content unit to<br>
processing software 103. Processing software 103 may determine in which container file<br>
the content unit is stored, access the container file, locate the requested content unit in<br>
the container file, and return the content unit to the accessing entity 101. Processing<br>
software 103 may locate the appropriate container file in any suitable way, as the<br>
invention is not limited in this respect. Similarly, processing software 103 may locate<br>
the requested content unit within a particular container file in any suitable way, as tihe<br>
invention is not limited in this respect. Examples of techniques for locating the container<br>
file in which a particular content unit is stored and for locating a content unit within a<br>
container file are discussed below in greater detail.<br>
	The accessing entity 101 may perform any of numerous types of access requests<br>
to a content unit stored in file system 105 using the identifier associated with the content<br>
unit, including reads, writes, and query requests. A query request is a request to identify<br>
and/or return content units that satisfy one or more criteria specified in the request. An<br>
example of one type of query request that may be issued by accessing entity 101 is a<br>
time-based query request. A time-based query request is a request to identify and/or<br>
return content units that were stored during a particular time range. In accordance with<br>
one embodiment, in response to a time based query request, processing software may<br>
locate container files that include content units stored during the time range specified in<br>
the request and return the identifiers of such content units and/or the content units<br>
themselves. This may be done in any suitable way, as the invention is not limited in this<br>
respect. Examples of techniques for processing and responding to query requests are<br>
discussed below in greater detail.<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-9-<br>
	In one embodiment, the file system 105 may have a time based directory structure<br>
that may be used to logically store container files. A time based directory structure is<br>
one in which directories and files are organized based, at least in part, on the time at<br>
which the content units were stored and/or created by the source (e.g., an application<br>
program). Any suitable time based directory structure may be used, as the invention is<br>
not limited in this respect. In one embodiment, the time-based directory structure may be<br>
organized as a plurality of hierarchical directories, where each directory represents a<br>
period of time and each subdirectory represents a period of time that is subsumed by the<br>
period of time of its parent directory. Files may be stored in the bottom-level or "leaf'<br>
directories (i.e., directories that represent lie smallest units of time) and the leaf directory<br>
in which a particular file is stored may be selected based on a time of storage or a time of<br>
creation of the file.<br>
	An example of such a time based directory structure is shown in Figure 2. Figure<br>
2 shows a directory structure 200 having six levels (labeled L1-L6), wherein directories<br>
at level LI designate the year in which the file was stored, directories at level L2<br>
designate the month, directories at level L3 designate the day, directories at level L4<br>
designate the hour, directories at level L5 designate the minute, and directories at level<br>
L6 designate the second. It should be appreciated that the entire hierarchy of directories<br>
in directory structure 200 is, for the sake of clarity, not expanded and that each non-leaf<br>
directory shown in Figure 2 may have one or more subdirectories that are not shown in<br>
Figure 2.<br>
	As discussed above, files may be stored in the leaf directory that corresponds to<br>
the time at which they were stored and/or created. Thus, for example, a file stored on<br>
January 1,2005 at 11:00 PM may be stored in the L6 directory 201, which has a path of<br>
/2005/January/01/23/00/00, wherein "2005" is the LI directory corresponding to the year<br>
2005, "January" is a subdirectory of the 2005 directory corresponding to the month of<br>
January 2005, the subdirectory "01" of the "January" directory is the L3 directory<br>
corresponding to the 1st day of January 2005, the subdirectory "23" of the "01" directory<br>
is the L4 directory corresponding to the 24th hour of the 1st day of January 2005, the<br>
subdirectory "00" of the "23" directory is the L5 directory corresponding to the 1st<br>
minute of the 24th hour of the 1st day of January 2005, and the subdirectory "00" of the<br><br>
WO 2007/001596.		PCTAJS2006/014180<br>
-10-<br>
"00" L5 directory is the L6 directory corresponding to the 1st second of the 1st minute of<br>
the 24th hour of the 1st day of January 2005.<br>
	It should be appreciated that the embodiments of the present invention described<br>
below that employ time in specifying a directory structure for storing content units are<br>
not limited to use with directory structures having the arrangement of the particular<br>
example shown in Figure 2, as the embodiments of the present invention can be<br>
implemented in any of numerous ways, including with directory structures using<br>
different units of time (or different granularities) as establishing boundaries for the<br>
subdirectory levels.<br>
	In the example of Figure 2, the hierarchical directory structure has six levels and<br>
the smallest unit of time granularity (i.e., the lowest level in the hierarchy) corresponds<br>
to the second in which a content unit was stored. However, as mentioned above,<br>
embodiments of the invention described .herein are not limited in this respect, as they can<br>
be used with directory structures having any suitable number of levels, with each level<br>
corresponding to any suitable unit of time. For example, the directory structure may<br>
include only four levels, with the smallest unit of time granularity being hours. In this<br>
respect, the total number of directories may be reduced (as compared to a directory<br>
structure with six levels) and the number of content units stored in each "leaf directory<br>
may increase. Alternatively the number of levels hi the hierarchy may be increased to,<br>
for example, seven levels with the lowest level of granularity corresponding to<br>
milliseconds or some other sub-second unit of time. As a result, the number of "leaf<br>
directories may be increased and there may be fewer content units stored in each "leaf "<br>
directory.<br>
	Applicants have appreciated that the number of content units stored in each leaf<br>
directory may affect the performance of the system. As discussed above, the file system<br>
may map locations in the file system directory structure to physical storage locations<br>
(e.g., blocks). The mapping information that the file system uses to do this may be large,<br>
such that it may not be possible and/or feasible to store the entire map in tie memory of<br>
the computer on which the file system is-executing. Thus, only parts of the map may be<br>
cached hi memory at any particular point in time, while the rest remains stored on non-<br>
volatile storage (e.g. disk) used by the computer on which the file system executes. If<br>
there are a large number of directories and only a small number of content units stored in<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-11-<br>
each directory, then it is less likely that the file system location of a content unit to be<br>
retrieved will be in the portion of the map that is cached. As a result, the file system may<br>
have to frequently retrieve the relevant portions of the map from disk, resulting in a<br>
decrease in performance. However, if the number of directories in the directory structure<br>
is small and there are a large number of content units in each directory, the time spent<br>
locating the desired content unit within the appropriate directory may be increased,<br>
resulting in a decrease in performance.<br>
	It may be desirable to select a directory structure that balances these two<br>
competing factors. The optimum number of levels in the hierarchical structure may<br>
depend, for example, on the number of content units stored in the directory structure, the<br>
distribution of content units across the directory structure, and the frequency at which<br>
content units are stored in the directory structure. Thus, in one embodiment, the number<br>
of levels in the directory hierarchy is configurable and is alterable during operation of the<br>
system. This may be accomplished in any suitable way. For example, increasing the<br>
number of levels can be accomplished by creating additional subdirectories for each leaf<br>
directory and moving content units down into the appropriate additional subdirectories<br>
and decreasing the number of levels can be accomplished by moving content units up<br>
into a parent directory of the subdirectory in which they are stored and removing the<br>
subdirectory from the hierarchy.<br>
	In one embodiment, a time based directory structure that employs the<br>
containerization aspects of the present invention may serve as a replication target for a<br>
storage system. It is often desirable to create copies of content units stored on a storage<br>
system on a storage device that is external to the storage system so that, in case of<br>
unrecoverable failure of the storage system (or components thereof), a backup copy of<br>
the data exists. As used here in, replication of a content unit refers to creating a copy of<br>
the content unit on a storage device external to the storage system. An exemplary<br>
replication system is shown in Figure 3, wherein a storage system 301 replicates content<br>
units to replication target 303. In accordance with one embodiment of the invention,<br>
replication target 303 includes processing software 305 which processes access requests<br>
from storage system 301 (for example, as described above in connection with Figure 1A)<br>
and stores content units in and retrieves content units from container files in file system<br><br>
WO 2007/001596		PCT/US2006/014180<br>
-12-<br>
307. Files logically stored in file system 307 may be physically stored on underlying<br>
storage device 309.<br>
	It should be appreciated that although in Figure 3, replication target 303 using<br>
only a single storage device 309, the invention is not limited in this respect. Indeed,<br>
replication target 303 may use multiple storage devices, and these storage devices may<br>
be arranged in a hierarchical fashion, such that the HSM techniques described above in<br>
connection with Figure IB may be employed.<br>
	In one embodiment, the frequency at which content units are replicated from<br>
storage system 301 to replication target 303 may be used to determine the number of<br>
levels in the hierarchy and the granularity of the leaf levels in the file system 307. For<br>
example, if it is determined that, on average, thirty content units per second are<br>
replicated to replication target 303 and it is desired to store approximately ten content<br>
units hi each container file, then if the file system 307 were using the time-based<br>
directory structure shown in Figure 2, there may be, on average, three container files in<br>
each leaf directory. If it is desired to increase the number of files in each leaf directory,<br>
then the granularity of the L6 directories maybe increased such that each directory<br>
represents a period of time greater than one second. For example, each leaf directory<br>
may represent a period of five seconds, such that each L5 directory has twelve<br>
subdirectories, rather than sixty subdirectories. As a result, each leaf directory may<br>
store, on average, fifteen content units rather than three content units. Alternatively, the<br>
number of levels in the hierarchy of directory structure 200 may be reduced. For<br>
example, the files stored in each L6 directory may be moved to its parent L5 directory<br>
and the L6 directory may be removed. Thus, each L5 leaf directory will, on average,<br>
store one hundred eighty files, rather than the three files previously stored by each L6<br>
leaf directory.<br>
	In the example described above, the time-based directory structure was altered<br>
based on the rate at which content units were replicated to the replication target.<br>
However, the invention is not limited in this respect as the time-based directory structure<br>
may be altered to manage the number of files in each directory and the number of<br>
container files in each directory for any reason. For example, the time-based directory<br>
structure may be altered based on the frequency at which write requests for initial storage<br>
of content units (as opposed to write requests for replication of content units) are<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-13-<br>
received. It should be appreciated that techniques for altering the time-based directory<br>
structure are not limited to use with container files, as the time-based directory structure<br>
may be also be used with files that include only a single content unit. In this respect, the<br>
number of files in directories may be managed by altering the time-based directory<br>
structure and/or storing files in non-leaf directories in the time-based directory structure.<br>
	The time-based directory structure may be managed to control the number of files<br>
stored in directories either manually or automatically, as the invention is not limited in<br>
this respect. When managed manually, a user may specify what time granularity the leaf<br>
directories in the directory structure should have and the system may alter the time-based<br>
directory structure based on this specification. In one embodiment, when a user changes<br>
the time granularity, the. time granularity may be altered for directories that correspond to<br>
future times. That is, the portion of the directory structure that has already been created<br>
and/or already store files may not be altered based on the new granularity specification.<br>
However, the invention is not limited in this respect, as in one embodiment, both future<br>
time and past time directories may be altered to have the newly specified granularity.<br>
	When managed automatically, the system may automatically select the time<br>
granularity of the leaf directories based on the frequency at which content units are<br>
written to the system. This may be done in any suitable way, as the invention is not<br>
limited in this respect. In one embodiment, the system may select a granularity of the<br>
leaf directories at which to store content units based on the current frequency at which<br>
content units are being received for storage. If the frequency increases, the granularity of<br>
the leaf directories may be changed, for example, by creating subdirectories of the<br>
current leaf directories, but that have a smaller time granularity. For example, the system<br>
may determine that content units are being received with a frequency of sixty per hour<br>
and may thus elect to limit the directory structure for future directories to four levels with<br>
the leaf directory having a time granularity of hours. Thus, if write requests continue to<br>
be received at this rate, then sixty content units may be stored in each leaf directory. It<br>
should be appreciated that if content units are containerized, then multiple content units<br>
may be stored in a single container file, such that there may be less than sixty files in the<br>
directory (depending on how many content units are stored in each container file).<br>
However, this aspect of the invention is not limited to use with container files, as each<br>
content unit may be stored in a separate file.<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-14-<br>
	If the number of content units received for storage subsequently increases, the<br>
directory structure may be expanded. That is, for example, if the leaf directory currently<br>
has a granularity of hours and the frequency of requests increases from, for example,<br>
sixty per hour to six hundred per hour, then subdirectories of the current hours directory<br>
may be created, wherein each of these subdirectories corresponds to a minute within the<br>
hour represented by its parent directory. In this way, the time granularity may be<br>
decreased to minutes and subsequently received content units may be stored in the<br>
minutes directory. The time-based directory structure may continue to be created with<br>
leaf directories representing minutes. If the frequency at which write requests are<br>
received later decreases, minutes directories may no longer be created and content units<br>
may again be stored in the hours directories.<br>
	In the example above, because the time-based directory structure is expanded as<br>
time progresses (i.e., additional directories are created to represent the new times), the<br>
number of the levels in directory structure and the granularity of the leaf levels may be<br>
dynamically altered. Thus, a first portion of the directory structure that correspond to a<br>
first period of time may have a different number of levels than a second portion of the<br>
directory structure that corresponds to a second period of time. Further, because the<br>
decision to expand or contract the directory structure may be made at any time, a<br>
directory may not have a complete set of leaf directories. For example, if content units<br>
are being stored in the leaf hour directory that corresponds to the time period from 1:00<br>
PM -1:59 PM on a certain day, and a decision is made to decrease the granularity to<br>
minutes starting at 1:30 PM, there will only be thirty leaf subdirectories of the hours<br>
directory (i.e., one subdirectory for each minute from 1:30 PM -1:59 PM). That is,<br>
content units stored from 1:00 PM -1:29 PM may be stored in the parent hours directory,<br>
while content units stored from 1:30 PM -1:59 PM may be stored m one of the minutes<br>
subdirectories of the hour directory representing the time period from 1:00 PM -1:59 PM.<br>
Thus, the hours directory may have only thirty subdirectories, each having a time<br>
granularity of one minute, instead of sixty subdirectories (i.e., one subdirectory for each<br>
minute in the hour).<br>
	It should be appreciated that, in the example above, content units may be stored<br>
in leaf directories of the directory structure and/or non-leaf directories. Thus, in one<br>
embodiment, when requests to read content units stored in the time-based directory<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-15-<br>
structure are subsequently received, non-leaf directories may also be searched to locate<br>
content units identified by the requests.<br>
	In one embodiment a go-deeper file that indicates that a directory has<br>
subdirectories which contains content units may be employed to aid in locating content<br>
units on subsequent read requests. This may be done in any suitable way, as the<br>
invention is not limited in this respect. For example, as discussed above, when content<br>
units are being stored in a directory having a first time granularity, it may be decided that<br>
the time granularity of directories should be decreased by creating a new level of<br>
subdirectories that have smaller time granularities and storing content units in these<br>
subdirectories. A go-deeper file may be created and stored in the parent directory of<br>
these subdirectories. In one embodiment, when a read request that identifies a content<br>
unit is received, the content unit may be located, for example, by determining the period<br>
of time at which the content unit was stored and locating the highest level directory in the<br>
time-based directory structure that corresponds to the storage time and that stores content<br>
units. If the content unit is not found in the highest level directory corresponding to the<br>
storage time that has content units stored therein, it may be determined whether there is a<br>
go-deeper file in the directory. If there is a go-deeper file, then the subdirectory of the<br>
highest level directory that corresponds to the period of time may be searched to locate<br>
the content unit. This subdirectory might also contain a go-deeper file.<br>
	In one embodiment, the go-deeper file may indicate the time at which a decision<br>
to expand the directory structure (e.g., by adding an additional level into the hierarchy)<br>
was made. Thus, on a read request for a content unit having a content address that<br>
includes a timestamp that indicates a time later than the time specified in the go-deeper<br>
file, processing software 305 may proceed to the appropriate subdirectory at the lower<br>
level, without having to examine content units in the directory of the go-deeper file.<br>
	In the example described above, the granularity of the directory structure is<br>
altered based on the frequency at which content units are received for storage. However,<br>
the invention is not limited to this respect, as the granularity may be determined based on<br>
any suitable criterion or criteria.<br>
	It should be appreciated that the scenarios provided above are merely examples of<br>
ways in which a time based directory structure may be configured to impact the number<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-16-<br>
of files that are stored in each directory. The invention is not limited to these particular<br>
examples, as any suitable directory structure may be used.<br>
	In the. examples above, an average of thirty contentunits per second were<br>
replicated to the replication target 303 and container files were expected to store ten<br>
content units each. It should be appreciated that the replication rate and the expected<br>
number of content units in each container file were provided only as examples, and any •<br>
suitable replication rate and/or number of content units may be used. For example, it .<br>
may be expected that a container file store fifty, seventy-five, one hundred, or any other<br>
suitable number of content units.<br>
	In the examples above, the directory structure 200 was altered to increase the<br>
number of files stored in each directory. It should be appreciated that directory structure<br>
200 may also be altered to decrease the number of files stored in each directory. This<br>
may be done in any suitable way. For example, the time period represented by each leaf<br>
directory may be increased or an additional level of directories may be added to the<br>
hierarchy with a smaller granularity time period.<br>
	In Figure 3, replication target 303 serves as the replication target for one storage<br>
system (i.e., storage system 301). However, it should be appreciated that the invention is<br>
not limited in this respect, as replication target 303 may serve as the replication target for<br>
any suitable number of storage systems. Replication target 303 may be a storage system,<br>
a host computer, an appliance, or any other suitable entity. In this respect, the storage<br>
device 309 may be an internal storage device of replication target 303, such as, for<br>
example, a disk drive, or may be an external storage device, such as an external tape<br>
storage device, attached to the replication target 303.<br>
	In one of the examples described above, container files were referred to as having<br>
a limit on the content units stored therein. The recognition that a container file should<br>
not store additional content units and that a new container file should be created may be<br>
made in any suitable way, as the invention is not limited in this respect. For example,<br>
processing software 305 may impose a limit on the number of content units stored in a<br>
particular container file. Alternatively, in one embodiment, a new container file may be<br>
created after a certain amount of time has elapsed. The time interval at which to create<br>
new container files may be based on, for example, the desired average number of content<br>
units stored in each container file. That is, for example, if it is known or determined that<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-17-<br>
replication target 303 receives, on average, thirty content units per second for replication<br>
and it is desired to have approximately one hundred fifty content units in each container<br>
file, then a new container file may be created, for example, every five seconds.<br>
	In one embodiment, a container file may include information in addition to the<br>
content units themselves. Any suitable information may be included, as the invention is<br>
not limited in this respect. For example, in addition to the content units, a container file<br>
may include the content addresses of content units stored therein and a size of each<br>
content unit. An example of container file 600 is shown in Figure 6. In the example of<br>
Figure 6, container file 600 stores three content units and thus has three entries 601a,<br>
601b, and 601c (i.e., one entry for each content unit). Each entry in container file 600<br>
includes three piece of information: the content address of the corresponding content<br>
unit; the size of the content of the content unit; and the content of the content unit.<br>
	The serial organization of entries in container file 600 is only one example of a<br>
way in which entries in a container file may be organized. It should be appreciated that<br>
container files may be organized in any suitable way, as the invention is not limited in<br>
this respect.<br>
	Processing software 305 (Figure 3) may select a directory in which to store a<br>
container file in any suitable way. For example, in embodiments where file system 307<br>
includes a time based directory structure, a container file may be stored in the time based<br>
directory in the leaf directory that corresponds to the time at which the container file was<br>
created. In this respect, in embodiments where a new container file is created after a<br>
certain time interval, the time period of the leaf directory in which the container file is<br>
stored may be greater than the time interval at which new container files are created.<br>
Thus, content units that are stored in the container file are also stored in the leaf directory<br>
that corresponds to the time of storage of the content units. For example, if a leaf<br>
directory corresponds to a time period of thirty seconds (e.g., March 20,2005 at<br>
1 l:30:00-March 20,2005 at 11:30:29) and a new container file is created every five<br>
seconds, there may be six container files in the leaf directory and any content units<br>
received by replication target 303 during the thirty second time period that the leaf<br>
directory represents may be stored in one of the six container files in the leaf directory;<br>
By contrast, if a leaf directory corresponds to a time period of one second, but the time<br>
interval at which new container files are created is five seconds, then only one out of<br><br>
WO 2007/001596	PCTYUS2006/014180<br>
-18-<br>
every five leaf directories may store a container file. Consequently, content units that<br>
were received by replication target 303 during a time period that is represented by a leaf<br>
directory which does not store a container file may be stored in a leaf directory that does<br>
not correspond to the period of time during which the content unit was received by<br>
replication target 303.<br>
	While the invention is not limited to storing a content unit in a container file that<br>
is stored in a directory that corresponds to the time period during which the content unit<br>
was received, doing so may aid in locating a particular content unit in the container file<br>
in which it is stored, as is described below in greater detail.<br>
	A container file may have any suitable filename, as the invention is not limited in<br>
this respect. In one embodiment, the filename of a container file may be a timestamp<br>
that indicates a time at which the container file was created. However, any other suitable<br>
filename may be used.<br>
	In embodiments of the invention where content units are replicated to a<br>
replication target (e.g., as shown in Figure 3), there may be two storage times associated<br>
with a content unit. First, the content unit may have a storage time that reflects the time<br>
at which the content unit was initially stored on storage system 301. Second, the content<br>
unit may have a storage time that reflects the time at which the content unit was stored<br>
on replication target 303. Thus, in embodiments of the invention which use as the<br>
identifier for a content unit a content address that includes timestamp information,<br>
because the content unit was initially stored on storage system 301 (i.e., when the content<br>
address was initially assigned), timestamp information included in the content address<br>
may reflect the initial time of storage on storage system 301 and not the time of storage<br>
on replication target 303. However, the container file in which the content unit is stored<br>
and, consequently, the time-based directory in which the content unit is stored on the<br>
replication target 303 is based on the time of storage of the content unit on replication<br>
target 303, and not the time indicated by the timestamp in the content address.<br>
	The timestamp in the content address of content unit stored on the replication<br>
target may not, by itself, indicate in which time based directory a content ■unit is stored,<br>
as the time-based directory is selected based on a storage time on the replication target,<br>
whereas the timestamp reflects the storage time on the replication source (i.e., the storage<br>
system). Thus, in one embodiment, in addition to employing container files to store<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-19-<br>
content units, one or more container index files may be created and stored in the<br>
directory structure of the replication target. The directory in which a container index file<br>
is stored may be based on the timestamps of the content addresses of content units<br>
referenced by the container index file (i.e., the time of storage on storage system 301).<br>
For example, when a request is received by replication target 303 to store a content unit,<br>
processing software 305 may store the content unit in a container file located in one of<br>
the time based directories in 307, that corresponds to the period of time during which the<br>
content unit was received for storage by replication target 303. Additionally, an entry<br>
may be made in a container index file that identifies the content unit by its content<br>
address and indicates in which container file the content unit is stored. The container<br>
index file may be stored in a time based directory that corresponds to the time at which<br>
the content unit was initially stored on storage system 301.<br>
	In one embodiment, the content address of a content unit may not include a<br>
timestamp. Thus, the initial time of storage of the content unit on storage system 301<br>
may not be known. Thus, creating an index entry in a time-based file system for the<br>
content unit may present challenges. In one embodiment, a hash function that takes as<br>
input a content address or a portion of a content address and outputs a time value is used.<br>
The content address or a portion of the content address may be input to the hash function<br>
and the time based directory corresponding to the time value output by the hash function<br>
may be selected. The container index file may be stored in the selected time-based<br>
directory. Thus, the container index file is not necessarily stored in the directory selected<br>
based upon the time at which the content unit was initially stored on storage system 301,<br>
but rather a directory selected upon the time value generated by the hash function. Thus,<br>
an entry in a container index file stored in a directory in a time-based directory structure<br>
may be made for a content unit even where there is no timestamp information in the<br>
content address and the initial time of storage on the storage system may not be known.<br>
While subsequent examples may refer to the container index file and associated files<br>
being stored in a directory that corresponds to the time at which a content unit was<br>
initially stored on storage system 301, it should be appreciated that the container index<br>
file and associated files may be stored in a directory corresponding to the time value<br>
generated by the hash function.<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-20-<br>
	When a request to access the content unit is later received and identifies the<br>
content unit by its content address, processing software 305 may locate the container<br>
index file that references the content unit using the timestamp information in the content<br>
address or, if the content address does not include a timestamp, using the hash function<br>
to generate a time value from the content address and may locate an entry in the<br>
container index file that corresponds to the content unit. This entry may identify the<br>
container file in which the content unit is stored and/or provide a pointer to this container<br>
file. Thus, rather than searching all container files for the content unit that has the<br>
content address specified in the request, a pointer to the appropriate container file may be<br>
located using the timestamp information in the content address and an exhaustive search<br>
for the container file need not be performed.<br>
	The use of container index files may be particularly beneficial in systems which<br>
employ HSM techniques. For example, if container files are stored on the slower storage<br>
device and it were necessary to search all container files to locate a particular content<br>
unit, then many container files (which are typically much larger than container index<br>
files, as they contain content units) may have to be transferred between the slower<br>
storage device into the cache (i.e., the faster storage device). The use of container index<br>
files allows processing software 305 to determine in which container file a requested<br>
content unit is stored, and thus it is not necessary to move many large container files<br>
from the slow storage device (e.g., a tape system) to the faster storage device (e.g., a<br>
magnetic disk drive). Rather, only the container file that includes the content may be<br>
moved from the slow storage device to the faster storage device, if it is not already stored<br>
on the faster storage device.<br>
	Figure 4 shows one example of a relationship between a container index file 401<br>
and container files 405 and 407. Container index file 401 includes a plurality of entries,<br>
403 a, 403b, and 403 c, each of which identifies a content unit by its content address and<br>
also includes information that may be used to locate the content unit. In one<br>
embodiment, this information includes a pointer .that specifies the location of the<br>
container file in which the content unit is stored and an offset within the container file at<br>
which the content unit begins. Thus, for example, entry 403 a may include a pointer to<br>
container file 405 and may indicate that the corresponding content unit begins a certain<br>
number of bytes into the container file. In addition, an entry in a container index file<br><br>
WO 2007/001596 PCT/US2006/014180<br>
-21-<br>
may also include information that indicates the next index with the same hash as the<br>
current entry. It should be appreciated that some of this information need not be<br>
included in the container index file and any other suitable information may be included<br>
in the index file, as the invention is not limited in this respect<br>
	In one embodiment, the container index file may have any suitable number of<br>
entries, wherein each entry identifies a content unit and the container file in which it is<br>
stored. However, the invention is not limited to this situation, as the container index file<br>
may have any suitable form. In one embodiment, each container index file may<br>
correspond to a particular time period. Thus, a container index file may include entries<br>
for content units whose content addresses include timestamps that fall within the time<br>
period of the container index file. The time period that corresponds to a container index<br>
file may be of any suitable duration, as the invention is not limited in this respect.<br>
However, in one embodiment, the duration of the time period of a container index file is<br>
less than or equal to the duration of the time period represented by the leaf directory in<br>
which the container index file is stored. For example, if a container index file is stored in<br>
a leaf directory in a time based directory structure wherein the lowest level leaf<br>
directories correspond to a time period of thirty seconds, then the container index file<br>
may correspond to the same time period or a shorter time period. Thus, when an entry<br>
for a content unit is made in the container index file that corresponds to a time period<br>
encompassing the time indicated by the timestamp in the content unit's content address,<br>
the container index file will be stored in a leaf directory that also encompasses the time<br>
indicated by the timestamp in the content unit's content address.<br>
	A container index file may also have any suitable filename, as the invention is not<br>
limited in this respect. In one embodiment, a container index file may have a filename<br>
that indicates the period of time to which the container index file corresponds. It should<br>
be appreciated that this is only one example of a filename that may be used and the<br>
invention is not limited to this particular example.<br>
	In embodiments of the invention where the container index file corresponds to a<br>
time period shorter in duration than the duration of the time period represented by the<br>
leaf directory in which it is stored, there may be multiple container index files in a leaf<br>
directory. For example, if a leaf directory represents a thirty second time period (e.g.,<br>
March 20,2005 at 11:30:00-March 20,2005 at 11:30:29) and each container index file<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-22-<br>
corresponds to a fifteen second time period, then there may be two container index files<br>
in the leaf directory: one that corresponds to the March20,2005 at 11:30:00- March 20,<br>
2005 at 11:30:14 time period and another that corresponds to the March 20,2005 at<br>
11:30:15 - March 20,2005 at 11:30:29 time period.<br>
	The duration of the time period'of a container index file may be selected in any<br>
suitable way, as the invention is not limited in this respect. For example, in one<br>
embodiment the duration may be selected to correspond to the interval at which new<br>
container files are created. Thus, for example, if a new container file is created every<br>
five seconds, then the duration of the time period of a container index file may also be<br>
five seconds. Alternatively, the duration may be selected based on the maximum number<br>
of desired container index files in a leaf directory. That is, for example, if the duration of<br>
the time period represented by the leaf directory is thirty seconds, and it is desired to<br>
have a maximum of five container index files in the leaf directory, then the duration of<br>
the time period of each container index file in the leaf directory may be six seconds.<br>
These are just examples of ways in which the duration of the time period of a container<br>
index file may be selected and any other suitable way may be used. For example, all<br>
container index files need not be of the same duration.<br>
	Processing software 305 need not create container index files if replication target<br>
303 does not store any content units that would have entries in the container index files.<br>
Thus, for example, if replication target 303 does not store any content units whose<br>
content addresses have a timestamp that indicates a time of storage between March 20,<br>
2005 at 11:30:15 and March 20,2005 at 11:30:29, then it may not be necessary to create<br>
a container index file that corresponds to the March 20,2005 at 11:30:15 - March 20,<br>
2005 at 11:30:29 time period, as there would be no entries in the container file if it were<br>
to be created.<br>
	Similarly, it should be appreciated that a directory in the time-based directory<br>
structure need not be created if there are rio files to be stored in the directory. For<br>
example, referring to directory structure 200 in Figure 2, there is a subdirectory 203 in<br>
the directory structure that corresponds to February 2005, If there are no content units<br>
initially stored on storage system 301 during February 2005 and no content units<br>
replicated to replication target 303 during February 2005, then subdirectory 203 (and all<br><br>
WO 2007/001596		PCT/US2006/014180<br>
-23-<br>
of the subdirectories that would normally descend therefrom in the hierarchy) need not<br>
be created.<br>
	In one embodiment, each container index file may also have an associated header<br>
file, called an index header file, that may be used to aid in locating a particular entry<br>
within the container index file and to aid in deletion of content units. To aid in locating<br>
an entry in the container index file, the index header file may include, for example, an<br>
array of pointers into the container index file. Each pointer in the array may indicate the<br>
location of an entry in the container index file and the array may be organized, for<br>
example, based on hashes of the content addresses stored in entries in the container index<br>
file. Thus, to locate an entry in the index container file using a content address of a<br>
corresponding content unit, the content address may be hashed to determine the location<br>
of the pointer to the entry in the array. The pointer may then be used to determine the<br>
location of the entry in the container index file that corresponds to the hashed content<br>
address.<br>
	The index header file may also include information helpful in managing deletion<br>
of content units. In one embodiment of the invention, deletion may be handled as<br>
follows. When processing software 305 receives a request to delete a content unit and<br>
identifies the content unit by its content address, rather than locating the content unit and<br>
removing its corresponding entries from the appropriate container file and container<br>
index file, the entries may remain in the files and a notation that the content unit has been<br>
deleted may be recorded so that subsequent requests to access the content unit may be<br>
denied. Such a notation may be made in any suitable way, as the invention is not limited<br>
hi this respect. In one embodiment, the notation may be recorded in the index header<br>
file.<br>
	For example, as shown in Figure 5, a deletion data structure 500 may be stored hi<br>
the index header file. The deletion data structure associates a bit with each entry in the<br>
index container file associated with the index header file. If the bit for an entry is at one<br>
value (e.g., has a value of' 1'), then the entry has not been deleted, whereas if the bit for<br>
an entry is at the other value (e.g., has a value of '0'), then the entry has been deleted.<br>
When processing software 305 receives a request to store a content unit and creates an<br>
entry corresponding to the content unit in a container index file, processing software may<br>
also add a bit for this entry in the deletion data structure 500 in the corresponding index<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-24-<br>
header file with the bit initially set (i.e., having a value of' 1 ')• When a subsequent<br>
request to delete the content unit is received, the bit may be reset to a value of 0'<br>
indicating that the content unit has been deleted. As a result, when processing software<br>
305 receives a subsequent request to read the data, processing software may check the<br>
deletion data structure 500 in the index header file to determine if the content unit has<br>
been deleted prior to returning the content unit. If it is determined that the content unit<br>
has been deleted, a response indicating that the content unit does not exist and/or that the<br>
content unit has been deleted may be returned to the accessing entity.<br>
	The index header file may also include any other suitable information, such as the<br>
current number of entries in its associated container index file. Further, the example of<br>
the deletion data structure described above is only one implementation of a data structure<br>
that may be used to track which content units have been deleted. The invention is not<br>
limited to this particular example, as the deletion data structure may take any suitable<br>
form.<br>
	As mentioned above, although in one embodiment individual entries from<br>
container index files and container files are not removed in response to a delete request,<br>
an entire container index file and index header file may be deleted if a delete request for<br>
each entry in the container index file has been received. For example, as mentioned<br>
above, a container index file may have an associated index header file that includes a<br>
deletion data structure. If each bit in the deletion data structure is set to '0', indicating<br>
that a delete request for each entry in the container index file has been received, then<br>
both the index header file and the container index file may be deleted in accordance with<br>
one embodiment.<br>
	In one embodiment, each container file may also have a header file, called a<br>
container header file, associated with it. The container header file may be used to<br>
determine when a container file may be deleted. For example, a container header file<br>
may indicate how many content units are stored in its associated container file and how<br>
many of these content units have been deleted. Thus, for example, when processing<br>
software 305 receives a request to delete a content unit, processing software 305 may<br>
determine in which container file the content unit is stored using the appropriate<br>
container index file and, in addition to updating the deletion data structure in the index<br>
header file associated with the container index file, may also update the container header<br><br>
WO 2007/001596		PCT/US2006/014180<br>
-25-<br>
file to reflect the number of content units that have been deleted from its associated<br>
container file. When the number of deleted content units is the same as the number of<br>
content units currently stored in the container file, then the container file and its<br>
associated container header file may be deleted.<br>
	The description above provides one example of a manner in which it may be<br>
determined if a content unit has been deleted and/or when a container file, container<br>
index file, and index header file may be deleted. The invention is not limited to this<br>
particular example, as any these determinations may be made in any suitable way.<br>
	As discussed above, in addition to receiving access requests to retrieve one or<br>
more particular content units (e.g., identified by content addresses), processing software<br>
305 may also receive a query access request that requests identification of content units<br>
that satisfy one or more criteria. In one embodiment of the invention, processing<br>
software 305 may process time-based query requests that request identification of<br>
content units stored to replication target 303 during a time range specified in the request.<br>
This may be done in any suitable way, as the invention is not limited in this respect. For<br>
example, in one embodiment, in response to a query request, processing software 305<br>
may determine which leaf directories in the time based directory structure fall within the<br>
time range specified in the request. Processing software 305 may access the container<br>
files stored in these directories and return the content addresses of content units stored<br>
therein.<br>
	In one embodiment, processing software 305 may, either, in addition to or instead<br>
of the returning the content addresses, return the content units themselves. Because a<br>
container file and its associated container header file does not include information<br>
indicating which of the content units stored in the container file have been deleted, in one<br>
embodiment processing software may, in response to the time-based query, identify<br>
content units that have been deleted, when used with such an embodiment.<br>
	To address this issue, in one embodiment, the container header file for a container<br>
file may also include a deletion data structure, similar to deletion data structure included<br>
in the index header file, that indicates which content units in the associated container file<br>
have been deleted. To maintain this data structure, when a delete request is received for<br>
a content unit, the deletion data structure in the container header file for the container file<br>
in which the content unit is stored should be updated. Further, in embodiments in which<br><br>
WO 2007/001596PCT/US2006/014180<br>
-26-<br>
processing software 305, in response to a time based query request, returns a content<br>
address of identified content units but does not return the content unit itself, multiple-<br>
container files may have to be transferred from the storage device to the memory of<br>
replication target 303 to determine the content addresses of content units that match the<br>
specified time range. Often, the container files may be large because they include the<br>
content of many content units. As a result, transferring these files from the storage<br>
device may increase latency in responding to the time based query request.<br>
	In another embodiment, rather than maintaining a deletion data structure in the<br>
container header file of a container file, a pointer to the container index file that<br>
references a content unit may be stored with the entry for each content unit in a container<br>
file. Thus, when a time-based query request is received, processing software 305 may<br>
access the container files that are stored in leaf directories that fall within the specified<br>
time range and, before identifying a content unit in response the request, may use the<br>
pointer to the container index file in the entry for the content unit to determine if the<br>
content unit is deleted (e.g., via the deletion data structure in the index header file). In<br>
this embodiment, it is not necessary to maintain a deletion data structure for each<br>
container file and update it whenever a content unit stored in the container file is deleted.<br>
Rather, a back pointer to the appropriate container index file may be included in the<br>
content unit's entry in the container file when the content unit is initially stored.<br>
	In the embodiments in which a container header file includes a deletion data<br>
structure or in which container file entries include back pointers to container index files,<br>
many large container files may be transferred from the storage device to the memory of<br>
the replication target to obtain the content address for a content unit that meets the<br>
criteria specified in a time based query request, even though the content of the content<br>
unit need not be returned in response to the request. Further, in embodiments in which<br>
HSM techniques are employed, not only would these large container files have to be<br>
moved from the storage device to the memory of the replication target, these container<br>
files may also first have to be moved from a slower storage device in the storage<br>
hierarchy (e.g., a tape drive) to the storage device which may be, for example, a disk<br>
drive.<br>
	To address this, in one embodiment a storetime container file may be employed.<br>
A storetime container file, like a container file, may correspond to a specific time period,<br><br>
WO 2007/001596		PCT/US2006/014180<br>
-27-<br>
and may have entries for content units stored during that time period. Thus, a storetime<br>
container file may be stored in the leaf directory that encompasses the time period of the<br>
storetime container file. When a content unit is initially stored in a container file, an<br>
entry for the content unit may be made in the appropriate storetime container file.<br>
	An example of a storetime container file 700 is shown in Figure 7. Storetime<br>
container file 700 includes two entries: 701a and 701b. Each of these entries<br>
corresponds to a content unit stored in a container file and may include information that<br>
may be used in responding to a time-based query request For example, an entry may<br>
include the content address of the content unit, a pointer to the container index file that<br>
references the content unit, the time of storage of the content unit, and the size of the<br>
content of me content unit. Any other suitable information maybe included, as the<br>
invention is not limited in this respect.<br>
	When a time based query request is received, processing software 305 may<br>
determine the leaf directories that correspond to the time range specified in the request<br>
and access the storetime container files stored in those directories. For each entry in the<br>
storetime container files, processing software 305 may determine if the content unit<br>
corresponding to the entry has been deleted by using the pointer to the container index<br>
file in the entry to access the deletion data structure in its associated index header file. If<br>
the content unit has been deleted, it may not be identified in response to the request. If<br>
the content unit has not been deleted, then the content address of the content unit may be<br>
returned in response to the request, along with any other suitable information, such as,<br>
for example, the time of storage of the content unit and the size of its content.<br>
	In one embodiment, a storetime header file may be created for each storetime<br>
container file. The storetime header file may be used, for example, to determine if a<br>
storetime container file may be deleted (i.e., if the content units corresponding to all the<br>
entries in the storetime container file have been deleted). The storetime header file may<br>
indicate the current number of entries in the storetime container file (which may be<br>
updated when entries are added to the storetime container file) and may indicate the<br>
number of entries that correspond to deleted content units (which may be updated each<br>
time a content unit corresponding to one of the entries is deleted). If the number of<br>
entries corresponding to deleted content units is the same as the number of entries in the<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-28-<br>
storetime container file, then storetime container file may be deleted (e.g., by processing<br>
software 305)<br>
	In one embodiment, in addition to responding to query requests to identity<br>
content units stored during a specified time range, processing software 305 may respond ,<br>
to query requests to identity content units deleted during a specified time range. This<br>
may be done in any suitable way, as the invention is not limited in this respect.<br>
	For example, a deletion container file may be created that corresponds to a<br>
particular time period and may have entries for content units deleted during that time<br>
period. The deletion container file may be stored in the leaf directory that corresponds to<br>
the time period of the deletion container file. When a content unit is deleted, an entry for<br>
the content unit may be made in the deietion container file that encompasses the time of<br>
deletion of the content unit. An example of a deletion container file 800 that includes<br>
two entries, 801a and 801b, is shown in Figure 8. Each entry in the deletion container<br>
file may correspond to a deleted content unit and include any suitable information. For<br>
example, an entry may include the content address of the deleted content unit, the time of<br>
deletion, and the reason for deletion.<br>
	When a query request is received requesting identification of content units<br>
deleted during a specified time range, processing software 305 may determine the leaf<br>
directories that correspond to time periods falling within the specified time range.<br>
Processing software 305 may then access the deletion container files stored in these<br>
directories and return information for each content unit identified in the deletion<br>
container files. Any suitable information may be returned, as the invention is not limited<br>
in this respect. For example, in response to the query request, the content address of<br>
content units deleted during the time range may be returned, along with the time of<br>
deletion of the content units and the reason for deletion.<br>
	The aspects of the present invention described herein can be used with systems<br>
that store two different types of content units: blobs and content descriptor files (CDFs),<br>
with each blob being referenced by at least one CDF. A blob may store application data,<br>
while a CDF that references the blob may store metadata about the blob. Accessing<br>
entities may not directly access blobs and may only directly access CDFs. Thus, an<br>
accessing entity may not be aware of the content address of a blob, but only the content<br>
address of a CDF. To access a blob, an accessing entity may send a request for the CDF<br><br>
WO 2007/001596		PCT/US2006/014180<br>
-29-<br>
that references the blob. In response, the accessing entity may receive the requested<br>
CDF and the blobs referenced by the CDF. In this regard, an accessing entity may also<br>
not directly request deletion a blob. The accessing entity may request deletion of a CDF<br>
that references the blob. If there are no CDFs referencing a blob, the blob may be<br>
deleted.<br>
	In one embodiment, separate container files may be used for blobs and CDFs.<br>
Thus, a leaf directory in the time based directory structure may have some blob container<br>
files and some container files (i.e., if there were blob(s) and CDF(s) stored to replication<br>
target 303 during the time period of the leaf directory). Similarly, separate container<br>
index files may be used for blobs and CDFs. As mentioned above, hi one embodiment,<br>
blobs may not be directly deleted by an accessing entity. Thus, hi one embodiment,<br>
rather than including a deletion data structure in the index header file associated with a<br>
blob container index file associated, the index header file may include a reference count<br>
map. The reference count map includes an entry for each blob entry hi the blob<br>
container index file that indicates how many CDFs are referencing the blob. The<br>
reference count map for a blob may be updated when a new CDF is created that<br>
references the blob or when a CDF referencing the blob is deleted, m this respect, if<br>
every entry in the reference count map is '0', indicating that there are no CDFs<br>
referencing any of the blobs referenced hi the blob index container file, then the blob<br>
index file may be deleted.<br>
	As mentioned above, container files may be deleted when the information in the<br>
container header file indicates that all content units stored in the container file are<br>
deleted. However, in one embodiment that employs blob and CDF content unit types,<br>
CDF container files may not be deleted, even if it is determined that every CDF stored hi<br>
the CDF container file has been deleted. This may be done for any suitable reason and<br>
the invention is not limited in this respect. For example, the CDF container file may<br>
serve as an audit log, such that information about deleted CDFs (and deleted blobs<br>
referenced by the deleted CDFs) still exists on the replication target and may be used to<br>
determine information about the deleted content units. In embodiments hi which CDF<br>
container files are not deleted, it may not be necessary to maintain a container header file<br>
for CDF container files. Because the container header file is primarily used to determine<br>
if its associated container file may be deleted (i.e., by detemining if all content units in<br><br>
WO 2007/0015%	PCT/US2006/014180<br>
-30-<br>
its associated container file have been deleted) and because CDF container files are not<br>
deleted, it may not be necessary to create and maintain a container header file for CDF<br>
container files.<br>
	Applicants have appreciated that, in some situations, it may be desirable to allow<br>
storage of a particular content unit only one time. Thus, if a user attempts to store a<br>
content unit that is already stored on the computer, the computer may bypass storage of<br>
the content unit, so that two copies of the same content unit are not stored on the storage<br>
system. However, from the perspective of the entity requesting storage of the content<br>
unit, the storage system has accepted and processed the storage request. This may be<br>
done in any suitable way, as the invention is not limited in this respect.<br>
	In one embodiment where content addresses for content units do not include a<br>
timestamp, when a request to write a content unit is received, the content address may be<br>
input to a hash function to derive a time value, as discussed above. This time value may<br>
be used to select a directory that stores a container index file for the content unit. The<br>
appropriate container index file corresponding to the time value may be selected and it<br>
may be determined if there is another content unit having the same content address<br>
already stored therein. If there is another content unit with the same content address<br>
stored therein, another copy of the content unit need not be saved in a container file in<br>
the time based directory structure. However, the reference count for the content unit in<br>
the reference count map discussed above may be incremented so that a request from a<br>
first entity that stored a first copy of the content unit to delete the content unit will not<br>
result in deletion of the content unit so that a second entity that stored a second copy of<br>
the content unit may still access the content unit.<br>
	In embodiments in which content addresses for content units include timestamps<br>
indicating an initial time of storage of the content unit, two copies of the same content<br>
unit may have different timestamps in their content addresses. Thus, when a request to<br>
store a content unit is received, it may be difficult to determine if a previous copy of the<br>
content unit has been stored. To address this, in one embodiment a single instance store<br>
(SIS) file may be employed. When a request to write a content unit is received, in<br>
addition to storing an entry for the content unit in a container index file and storing the<br>
content unit in a container file, the content address (or a portion of the content address)<br>
of the content unit may be input into a hash function that outputs a time value based, at<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-31-<br>
least in part, on the content address. The timestamp may be removed from the content<br>
address prior to inputting the content address into the hash function such that the hash<br>
function only operates on the portion of the content address that is generated using the<br>
content of the content unit. An SIS file corresponding to the content unit may be created<br>
in the time based directory corresponding to the time value output by the hash function.<br>
The SIS file may indicate the content address of the content unit. The SIS file may<br>
further indicate the location of and identify the container index file which includes an<br>
entry for the content unit. When a write request to store another content unit having the<br>
same content is received, processing software 305 (Figure 3) may input the portion of the<br>
content address generated using the content of the content unit to the hash function to<br>
generate a time value. The directory corresponding to the time value may be located and<br>
it may be determined if there is an SIS file that includes Hie content address (excluding<br>
the timestamp) of the content unit. When the SIS file is found, the container index file<br>
corresponding to the first copy of the content unit may be located and the location of the<br>
container file that stores the first copy of the content unit may be determined. Then, an<br>
entry may be made for the second copy of the content unit in a container index file in the<br>
directory corresponding to the timestamp in the content address of the second copy of the<br>
content unit. The entry may indicate as the location of the content unit the container file<br>
that stores the first copy of the content unit. In this manner, a second copy of the content<br>
unit need not be stored, but the content may be located using either the content address of<br>
the first copy of the content unit or the content address of the second copy of the content<br>
unit.<br>
	In one embodiment, the aspect of the present invention described herein can be<br>
used in systems that employ virtual pools. Virtual pools are discussed in detail in<br>
application serial nos. 10/910,985,10/911,330,10/911,248,10/911,247, and 10/911,360,<br>
listed in Table 1 below. Content units may be logically grouped together for any suitable<br>
reason. For example, content units may be grouped together to control access to certain<br>
content units. That is, a first host computer may only be permitted to access content<br>
units in Virtual Pool A, while a second host computer may only be permitted to access<br>
content units in Virtual Pool B.<br>
	In one embodiment, information may be included, in an index container file,<br>
storetime container file, and/or deletion container file, indicating in which virtual pool(s)<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-32-<br>
the content unit referenced by that entry belongs (if any). When an access request (e.g., a<br>
read, write or query request) is received, processing software 305 may determine in<br>
which virtual pool each requested content unit belongs and determine if the requesting<br>
entity is permitted to access the virtual pool(s) before responding to the request.<br>
	Many of the examples described above employed the use of a time based<br>
directory structure. In some of the examples, the use of time based directory structure is<br>
convenient because the content address for content units to be stored included a<br>
timestamp which aided in selection of directory in which to store the content unit.<br>
Further, the time based directory structure can be used to aid in locating content units<br>
when responding to a time based query request or a deletion time based query request.<br>
However, it should be appreciated the invention is not limited to use in a time-based<br>
directory structure. Indeed, the file system directory structure may be organized in any<br>
suitable way. For example, the directory structure may be organized based on the hash<br>
value in the content addresses of content units, rather than time, or in other ways.<br>
	Further, in the examples described above, files (e.g., container files, container<br>
index files, storetime container files, and deletion container files, and their associated<br>
header files) are stored in the leaf directories of the directory structure. The invention is<br>
not limited to storing the above-described files in leaf directories, as such files may be<br>
stored in any suitable directory in the directory structure, as the invention is not limited<br>
in this respect.<br>
	Further, in many of the examples above a content address was used as the<br>
identifier in identifying content units. The invention is not limited to use with a content<br>
address as the identifier as any suitable identifier may be used.<br>
	Additionally, many of the examples provided above are described in the context<br>
of a storage system replicating content units to a replication target (e.g., a host<br>
computer). The invention is not limited to use with systems that employ replication, as<br>
embodiments of the invention may be used in any suitable system configuration. For<br>
example, embodiments of the invention may be used on a system (e.g., a host computer)<br>
that is used as the primary storage location of content units instead of, or in addition to,<br>
serving as the backup storage location (i.e., the replication target).<br>
	The above-described embodiments of the present invention can be implemented<br>
on any suitable computer or system. Examples of suitable computers and/or systems are<br><br>
WO 2007/001596		'PCT/US2006/014180<br>
-33-<br>
described in the patent applications listed below in Table 1 (collectively "the CAS<br>
applications"), each of which is incorporated herein by reference. It should be<br>
appreciated that the computers and systems described in these applications are only<br>
examples of computers and systems on which the embodiments of the present invention<br>
may be implemented, as the invention is not limited to implementation on any of these<br>
content addressable storage systems, or to content addressable storage systems at all.<br>
Table 1<br>
Title	Serial No.	Filing Date<br>
Content AddressableInformation, Encapsulation,Representation, Andransfer	09/236,366	January 21, 1999<br><br><br><br>
Access To Content	09/235,146	January 21,1999<br>
Addressable Data Over A		<br>
Network		<br>
System And Method For	09/391,360 •	September 7,1999<br>
Secure Storage Transfer		<br>
And Retrieval Of Content		<br>
Addressable Information		<br>
Method And Apparatus For	10/731,790	December 9, 2003<br>
Data Retention In A		<br>
Storage System		<br>
Methods And Apparatus	10/731,613	December 9, 2003<br>
For Facilitating Access To		<br>
Content In A Data Storage		<br>
System		<br>
Methods And Apparatus	10/731,796	December 9,2003<br>
For Caching A Location		<br>
Index In A Data Storage		<br>
System		<br><br><br>
WO 2007/001596	PCT/US2006/014180<br>
-34-<br><br>
Methods And Apparatus	10/731,603	December 9,2003<br>
For Parsing A Content		<br>
Address To Facilitate		<br>
Selection Of A Physical		<br>
Storage Location In A Data		<br>
Storage System		<br>
Methods And Apparatus	10/731,845	December 9, 2003<br>
For Generating A Content		<br>
Address To Indicate Data		<br>
Units Written To A Storage		<br>
System Proximate In Time.		<br>
Methods And Apparatus	10/762,044	January 21, 2004<br>
For Modifying A Retention		<br>
Period For Data In A		<br>
Storage System		<br>
Methods And Apparatus	10/761,826	January 21,2004<br>
For Extending A Retention		<br>
Period For Data In A		<br>
Storage System		<br>
Methods And Apparatus	10/762,036	January 21,2004<br>
For Indirectly Identifying A		<br>
Retention Period For Data		<br>
In A Storage System		<br>
Methods And Apparatus	10/762,043	January 21, 2004<br>
For Indirectly Identifying A		<br>
Retention Period For Data		<br>
In A Storage System		<br>
Methods And ApparatusFor Increasing Data StorageCapacity	10/787,337	February 26,2004<br><br><br><br><br>
WO2007/001596						PCT/US2006/014180<br>
35-<br><br>
Methods And Apparatus	10/787,670	February 26, 2004<br>
For Storing Data In A		<br>
Storage Environment		<br>
Methods And Apparatus	10/910,985	August 4, 2004<br>
For Segregating A Content		<br>
Addressable Computer		<br>
System		<br>
Methods And Apparatus	10/911,330	August 4,2004<br>
For Accessing Content In A		<br>
Virtual Pool On A Content		<br>
Addressable Storage		<br>
System		<br>
Methods and Apparatus For	10/911,248	August 4,2004<br>
Including Storage System		<br>
Capability Information In		<br>
An Access Request To A		<br>
Content Addressable		<br>
Storage System		<br>
Methods And Apparatus	10/911,247	August 4,2004<br>
For Tracking Content		<br>
Storage In A Content		<br>
Addressable Storage		<br>
System		<br><br><br>
WO 2007/001596						PCT/US2006/014180<br>
-36-<br><br>
Methods and Apparatus For	10/911,360	August 4, 2004<br>
Storing Information		<br>
Identifying A Source Of A		<br>
Content Unit Stored On A		<br>
Content Addressable		<br>
System		<br>
Software System For	11/021,892	December 23,2004<br>
Providing Storage System		<br>
Functionality		<br>
Software System For	11/022,022	December 23,2004<br>
Providing Content		<br>
Addressable Storage		<br>
System Functionality		<br>
Methods And Apparatus	11/022,077	December 23,2004<br>
For Providing Data		<br>
Retention Capability Via A		<br>
Network Attached Storage		<br>
Device		<br>
Methods And Apparatus	11/021,756	December 23,2004<br>
For Managing Storage In A		<br>
Computer System		<br>
Methods And Apparatus	11/021,012	December 23,2004<br>
For Processing Access		<br>
Requests In A Computer		<br>
System		<br>
Methods And Apparatus	11/021,378	December 23,2004<br>
For Accessing Information		<br>
In A Hierarchical File		<br>
System		<br><br><br>
WO 2007/001596							PCT/US2006/014180<br>
-37-<br><br>
Methods And ApparatusFor Storing A ReflectionOn A Storage System	11/034,613	January 12,2005 ,<br>
Method And Apparatus ForModifying A RetentionPeriod	11/034,737	January 12, 20Q5<br>
Methods And ApparatusFor Managing Deletion ofData	11/034,732	January 12, 2005<br>
Methods And ApparatusFor Managing The StorageOf Content	11/107,520	April 15, 2005<br>
Methods And ApparatusFor Retrieval Of ContentUnits In A Time-BasedDirectory Structure	11/107,063	April 15,2005<br>
Methods And ApparatusFor Managing TheReplication Of Content	11/107,194	April 15,2005<br><br>
	The above-described embodiments of the present invention can be implemented<br>
in any of numerous ways. For example, the embodiments may be implemented using<br>
hardware, software or a combination thereof. When implemented in software, the<br>
software code can be executed on any suitable processor or collection of processors,<br>
whether provided in a single computer or distributed among multiple computers. It<br>
should be appreciated that any component or collection of components that perform the<br>
functions described above can be generically considered as one or more controllers that<br>
control the above-discussed functions. The one or more controllers can be implemented<br>
in numerous ways, such as with dedicated hardware, or with general purpose hardware<br>
(e.g., one or more processors) that is programmed using microcode or software to<br>
perform the functions recited above.<br><br>
WO 2007/001596	PCT/US2006/014180<br>
-38-<br>
	In this respect, it should be appreciated that one implementation of the<br>
embodiments of the present invention comprises at least one computer-readable medium<br>
(e.g., a computer memory, a floppy disk, a compact disk, a tape, etc.) encoded with a<br>
computer program (i.e., a plurality of instructions), which, when executed on a processor,<br>
performs the above-discussed functions of the embodiments of the present invention.<br>
The computer-readable medium can be transportable such that the program stored<br>
thereon can be loaded onto any computer environment resource to implement the aspects<br>
of the present invention discussed herein. In addition, it should be appreciated that the<br>
reference to a computer program which, when executed, performs the above-discussed<br>
functions, is not limited to an application program running on a host computer. Rather,<br>
the term computer program is used herein in a generic sense to reference any type of<br>
computer code (e.g., software or microcode) that can be employed to program a<br>
processor to implement the above-discussed aspects of the present invention.<br>
	It should be appreciated that in accordance with several embodiments of the<br>
present invention wherein processes are implemented in a computer readable medium,<br>
the computer implemented processes may, during the course of their execution, receive<br>
input manually (e.g., from a user).<br>
	The phraseology and terminology used herein is for the purpose of description<br>
and should not be regarded as limiting. The use of "including," "comprising," "having,"<br>
"containing", "involving", and variations thereof, is meant to encompass the items listed<br>
thereafter and additional items.	j<br>
	Having described several embodiments of the invention in detail, various<br>
modifications and improvements will readily occur to those skilled in the art. Such<br>
modifications and improvements are intended to be within the spirit and scope of the<br>
invention. Accordingly, the foregoing description is by way of example only, and is not<br>
intended as limiting. The invention is limited only as defined by the following claims<br>
and the equivalents thereto.<br>
	What is claimed is:<br><br>
-39-<br>
CLAIMS<br>
1.	A method of managing content units in a file system, the method comprising acts<br>
of:<br>
	receiving a first request to store a first content unit, the first content unit having a<br>
(first content address that is computed based, at least in part, on the content of the first<br>
content unit;<br>
	in response to the first request, storing the first content unit in a file in the file<br>
system;<br>
	receiving a second request to store a second content unit that is logically distinct<br>
from the first content unit, the second content unit having a second address that is<br>
computed based, at least, in part, on the content of the second content unit; and<br>
	in response to the second request, storing the second content unit in the file.<br>
2.	The meihod of claim 1, wherein the file system includes a time-based director)'<br>
structure having a plurality of directories, wherein each of the plurality of directories<br>
corresponds to a period of time, and wherein the file is stored in one of the plurality of<br>
directories that corresponds to a period of time during which the first and second request<br>
requests were received.<br>
3.	The method of claim 2, where the first request is received from a storage system<br>
that stores the first content unit, and wherein the first content address includes a<br>
timestamp that indicates a time related to the time of storage of the first content unit on<br>
the storage system.<br>
4.	The method of claim 3, further comprising acts of:<br>
in response to the first request, determining one the plurality of directories that<br>
corresponds to a period of time that includes the time indicated in the timestamp; and<br>
storing, in the one the plurality of directories that corresponds to a period of time<br>
that includes the time indicated in the timestamp, an indication of the file that stores first<br>
the content unit.<br>
5.	The method of claim 4, further comprising an act of:<br>
AMENDED PAGE<br><br>
-40-<br>
	in response to the first request, associating an identifier with the first content unit.<br>
6.	A computer that accesses a content unit having a first content address that is<br>
based, at least in part, on the content of the content unit, wherein the content unit is<br>
stored in a file in a file system, the computer comprising:<br>
	an input; and<br>
	at least one controller, coupled to the input, that:<br>
		receives from an application program, via the input, a request to access<br>
	the content unit, wherein the request identifies the content unit using the first<br>
	content address, and wherein the file in which the content unit is stored stores at<br>
	least one additional content unit, the at least one additional content unit having a<br>
	second content address that is based, at least in part, on the content of the<br>
	additional content unit;<br>
		locates the file in which the content unit is stored using the content<br>
	address; and<br>
		locates the content unit in the file in which the content unit is stored.<br>
7.	The computer of claim 6, wherein the file system includes a time-based directory<br>
structure having a plurality of directories, wherein each of the plurality of directories<br>
corresponds to a period of time, and wherein the file is stored in one of the plurality of<br>
directories that corresponds to a period of time during which the content unit was stored<br>
in the file system.<br>
8.	The computer of claim 7, wherein the content address for the content unit<br>
includes a timestamp.<br>
9.	The computer of claim 8, wherein the content unit was stored in the file system<br>
via replication from a storage system that stores the content unit and wherein the<br>
timestamp corresponds to a time at which the content unit was stored on the storage .<br>
system.<br>
AMENDED PAGE<br><br>
-41 -<br>
10. 	The computer of claim 9, wherein the file system is a hierarchical file system and<br>
the plurality of directories are arranged in a hierarchical tree, comprising at least one root<br>
directory and a plurality of non-root directories that each has a parent directory, wherein<br>
at least one of the plurality of directories in the tree correspond to a period of time<br>
subsumed by a period of time corresponding to its respective parent directory.<br><br>
One embodiment of the invention is directed to the containerization of content units that are accessed using an identifier. Applicants have appreciated that file systems sometimes impose limits on the number of files that may be stored therein that are too restrictive. Thus, in one embodiment, multiple content units may be stored in a single file, called a container file, in a file system. Each content unit may have an identifier associated with it. When an accessing entity requests access to a previously-stored content unit and provides the identifier for the content unit, the identifier may be used to locate the container file in which the content unit is stored.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=lkU4grx27RVYiv2yUF5sLw==&amp;amp;loc=wDBSZCsAt7zoiVrqcFJsRw==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=lkU4grx27RVYiv2yUF5sLw==&amp;amp;loc=wDBSZCsAt7zoiVrqcFJsRw==</a></p>
		<br>
		<div class="pull-left">
			<a href="268378-a-device-for-guiding-of-loquid-liquid-in-a-column.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="268380-method-and-apparatus-for-monitoring-an-evaporator.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>268379</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1554/KOLNP/2007</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>36/2015</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>04-Sep-2015</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>27-Aug-2015</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>01-May-2007</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>EMC CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>176 SOUTH STREET, HOPKINTON,MASSACHUSETTS 01748,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>TODD STEPHEN J</td>
											<td>36 THOMAS FARM CIRCLE, SHREWSBURY, MASSACHUSETTS 01545</td>
										</tr>
										<tr>
											<td>2</td>
											<td>ARMANGAU PHILLIPE</td>
											<td>51 SEMINOLE ROAD, ACTON, MASSACHUSETTS 01748</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 17/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2006/014180</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2006-04-14</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>11/165,103</td>
									<td>2005-06-23</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>11/165,104</td>
									<td>2005-06-23</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>3</td>
									<td>11/165,102</td>
									<td>2005-06-23</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/268379-methods-and-apparatus-for-managing-the-storage-of-content-in-a-file-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 07:09:03 GMT -->
</html>
