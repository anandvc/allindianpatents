<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/252360-occasionally-connected-application-server by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:24:23 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 252360:OCCASIONALLY-CONNECTED APPLICATION SERVER</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">OCCASIONALLY-CONNECTED APPLICATION SERVER</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Abstract Providing a framework for developing, deploying and managing sophisticated mobile solutions, with a simple Web-like programming model that integrates with existing enterprise components. Mobile applications may consist of a data model definition, user interface templates, a client side controller, which includes scripts that define actions, and, on the server side, a collection of conduits, which describe how to mediate between the data model and the enterprise. In one embodiment, the occasionally-connected application server assumes that data used by mobile applications is persistently stored and managed by external systems. The occasionally-connected data model can be a metadata description of the mobile application&#x27;s anticipated usage of this data, and be optimized to enable the efficient traversal and synchronization of this data between occasionally connected devices and external systems.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
OCCASIONALLY-CONNECTED APPLICATION SERVER<br>
COPYRIGHT NOTICE<br>
A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.<br>
CLAIMS OF PRIORITY<br>
U.S. Provisional Application No. 60/573,077 entitled "MOBILE APPLICATION SERVER" by Bosworth et al, filed May 20, 2004. [Attorney's Docket No. BEAS-01537US0]; and<br>
U.S. Patent Application No. 11/122,294 entitled "OCCASIONALLY-CONNECTED APPLICATION SERVER" by Bosworth et al, filed May 4, 2005. [Attorney's Docket No. BEAS-01537US1].<br>
FIELD OF THE INVENTION<br>
The current invention relates generally to mobile application architectures, and more particularly to mobile application architectures for developing, deploying and managing applications for occasionally connected mobile devices.<br>
BACKGROUND OF THE INVENTION<br>
Computers and computing devices have become smaller, faster and more efficient. As a result, their functionality has evolved and they are able to store and process more information. However, there is a still a limit to what a device can store and process locally.<br>
Lately, the development of mobile connected systems have enabled even more functionality for portable devices. These devices, including laptop computers, PDAs, cell phones, notebook computers, blackberry-type devices, and other mobile devices can be connected to the internet wherever a strong<br><br>
connection exists. Though applications for these devices come in several forms, users historically prefer a web base model because of the ease of application deployment and subsequent changes. Additionally, web based pages are very simple and intuitive for users to use.<br>
There are several problems with the latest developments of mobile devices web browsing. It is not easy to get connections wherever a user is. The connection is typically through a standard phone connection, which depends on cellular phone signal strength. There are currently many dead zones in cellular phone networks, which can cause downtime for connections between a mobile device and a web server.<br>
This is even more troublesome when considering the interaction necessary to provide web page content through a typical browser. When a user interacts with a web browser, the browser will request more information from a server based on user input. This requires an active connection between the browser and a web server in order to retrieve new information to present to a user. Thus, when a user is interacting with a web browser on a mobile device and enters an area with weak signal strength or a dead zone, the weak connection (or lack thereof) will likely provide errors in the content received by the mobile device. Thus, the user is often unable to interact with the web page in this manner.<br>
What is needed is a mobile application architecture framework that provides an intuitive user interface and a more reliable mechanism for providing content to a user on a mobile device. The framework should also provide for developing, deploying and managing sophisticated mobile solutions while enabling a simple Web-like programming model that integrates with existing enterprise components.<br>
SUMMARY OF THE INVENTION<br>
In one embodiment, the occasionally-connected application server platform provides a framework for developing, deploying and managing sophisticated mobile solutions, with a simple Web-like programming model that integrates with existing enterprise components.<br><br>
Occasionally-connected applications may consist of a data model definition, user interface templates, a client side controller, which includes scripts that define actions, and, on the server side, a collection of conduits, which can describe how to mediate between the data model and the enteiprise. In one embodiment, the occasionally-connected application server assumes that all data used by occasionally-connected applications is persistently stored and managed by external systems such as web services. The data model can be a meta data description of the connected-connected application's anticipated usage of this data, and can be optimized to enable the efficient traversal and synchronization of this data between occasionally connected devices and external systems.<br>
The occasionally-connected data model can describe the structure (and other properties) of persistent application data. The occasionally-connected data model itself can be synchronized with a browser so that the client is able to intelligently to traverse data and synchronize data with the server.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
FIGURES 1A-B are illustrations of an architectural overview in accordance with one embodiment of the present invention.<br>
FIGURE 2 is an illustration of an asynchronous interaction diagram in accordance with one embodiment of the present invention.<br>
FIGURE 3 is an illustration of a programming model for a MAS application in accordance with one embodiment of the present invention.<br>
FIGURE 4 is an illustration of an entity relationship diagram in accordance with one embodiment of the present invention.<br>
FIGURE 5 is an illustration of an UML Entity Relationship Diagram in accordance with one embodiment of the present invention.<br>
FIGURE 6 is an illustration of a node instance diagram in accordance with one embodiment of the present invention.<br>
FIGURE 7 is an illustration of select operations in accordance with one embodiment of the present invention.<br><br>
FIGURE 8 is an illustration of an input output matrix in accordance with one embodiment of the present invention.<br>
FIGURE 9 is a CRM schema type diagram in accordance with one embodiment of the present invention.<br>
FIGURE 10 is an illustration of a page flow for part of a CRM application in accordance with one embodiment of the present invention.<br>
FIGURES 11A-B are illustrations of synchronization method of one embodiment of the present invention.<br>
FIGURES 12A-D illustrate exemplary keyref definitions of one embodiment of the present invention.<br>
DETAILED DESCRIPTION<br>
In one embodiment, the occasionally-connected application server platform provides a framework for developing, deploying and managing sophisticated mobile solutions, with a simple Web-like programming model that integrates with existing enterprise components.<br>
Connected-connected applications may consist of a data model definition, user interface templates, a client side controller, which includes scripts that define actions, and, on the server side, a collection of conduits, which describe how to mediate between the data model and the enterprise. In one embodiment, the occasionally-connected application server assumes that all data used by mobile applications is persistently stored and managed by external systems. The data model can be a meta data description of the mobile application's anticipated usage of this data, and can be optimized to enable the efficient traversal and synchronization of this data between occasionally connected devices and external systems.<br>
The occasionally-connected data model can describe the structure (and other properties) of all persistent application data. The model itself can be synchronized with the mobile browser so that the client is able intelligently to traverse data and synchronize data with the server.<br><br>
The occasionally-connected data model can describe the data that will be<br>
cached and synchronized on the client and, optionally, cached on the server.<br>
Much of the programming model is described by meta data, which affords<br>
administrators and end users a high level of control over deployed applications.<br>
&gt;	In one embodiment, the programming model can be folly supported<br>
within WebLogic Workshop of BEA Systems, San Jose, California — using Workshop's visual design tools and roundtrip development model, and enabling developers to leverage other WebLogic Platform components such as LiquidData, and Integration.<br>
Building mobilized solutions can as straight-forward as building Workshop Web applications and not require a specialist mobile team. The goal is a great mobile experience with great total cost of ownership from development, deployment, maintenance, to daily use.<br>
Figures 1A-B illustrates an overall system architecture 100 of one embodiment, which comprises a mobile browser 110, occasionally-connected application server 120 and external Web services 140.<br>
The occasionally-connected application server 120 (OCAS), such as a Mobile Application Server (MAS), can mediate exchanges of data between client applications running on the mobile browser and external systems accessed through Web services. This mechanism can have two stages: first, the OCAS 120 can coordinates the translation of data between external systems and the occasionally-connected data model; second, the OCAS 120 can coordinate synchronization between the client cache and the external Web services.<br>
One embodiment of the present invention is an occasionally-connected application server 120 for mobile clients 111. The occasionally-connected application server 120 can comprise memory to store a occasionally-connected data model 127, such as a mobile data mobile; and a cache 128 to store data nodes as defined by the occasionally-connected data model 127. The occasionally-connected application server 120 can cache data nodes in the cache 128 as indicated by metadata in the occasionally-connected data model.<br><br>
The occasionally-connected application server 120 can be software run on one or more machines. The occasionally-connected application server 120 can ran on top of or be a part of an application server. The occasionally-connected client 111 can be a personal digital assistant (PDA), phone, notebook computer or other mobile computing device. The clients can also include stationary computers especially those with intermittent contact with a server.<br>
The occasionally-connected application server 120 can translate data between external systems, such as web services 140, and data nodes defined by the occasionally-connected data model 127.<br>
One embodiment of the present invention is a system including an occasionally-connected application server 120. The occasionally-connected application server 120 can be configured to provide an application to a client. The application can allow a client to read and update application data without requiring current access to the occasionally-connected application server. The occasionally-connected application server 120 can be adapted to obtain application data from an external system to send to the client. The occasionally-connected application server can be adapted to translate data from the external system into data nodes. The external system can be a service bus, a web service or some other system.<br>
The occasionally-connected data model 127 can indicate the mobile client's anticipated usage of external data and obtain external data before it is requested by the mobile client 111.<br>
The data nodes can be independent chunks of data, such as XML data. The model data model 127 can include an XML definition, such as an XML schema or XML DTD, for the data nodes.<br>
One embodiment of the present invention is a system including an occasionally-connected application server 120. The occasionally-connected application server 120 can be configured to provide an application to a client. The application can allow a client to read and update application data without requiring current access to the occasionally-connected application server. The occasionally-connected  application  server  120  can be     adapted  to  obtain<br><br>
application data from an external system to send to the client. The occasionally-connected application server can be adapted to translate data from the external system into data nodes. The external system can be a service bus, a web service or some other system.<br>
The mobile client 111 can transfer the data nodes and the occasionally-connected data model 115 to produce a display at the mobile client 111. An adaptive user interface server 126 can construct HTML pages from the data nodes in the cache 128 and the occasionally-connected data model 127 for clients 130. Clients 130 can include traditional web browsers that have consistent access to the server 120. The Adaptive UI Server 126 can provide a mechanism for running client applications on the server, enabling access from thin clients (e.g., ordinary Web browsers, SMS phones, etc.).<br>
The mobile client 111 can run an application using the data nodes and the occasionally-connected data model 115 without being in contact with the occasionally-connected application server 120. The data nodes in the cache 113 and occasionally-connected data model 115 can be used by a sync client 112 at mobile browser 110 to produce a display such as the HTML view 119. In one embodiment, templates can be used to produce the display at the mobile browser 110.<br>
The data nodes and occasionally-connected data model can be synchronized between the occasionally-connected application server 120 and the mobile client 111. This synchronization can be done in the background as a connection between the mobile client 111 and the occasionally-connected application server 120 is available.<br>
One embodiment of the present invention is an occasionally-connected application server 120 comprising a synchronization unit 131, such as a sync engine, to synchronize data nodes, such as data nodes in cache 128, with a client 111 for an application defined by the occasionally-connected data model; and a conduit manager 124 to translate between data from external systems and the data nodes defined by the occasionally-connected data model 127.<br><br>
One embodiment of the present invention is method comprising, at an occasionally-connected application server 120, storing an occasionally-connected data model 127 defining nodes and relations between nodes; and, at the occasionally-connected application server 120, caching data nodes as defined by the occasionally-connected data model 127. The occasionally-connected application server 120 can cache data nodes as indicated by metadata in the occasionally-connected data model 127.<br>
One embodiment of the present invention is an occasionally-connected application server 120 comprising a memory to store an occasionally-connected data model 127 and a cache 128 to store data nodes as defined by occasionally-connected data model 127. The data node including a primary key and a synchronization state. The primary key identifies the data mode. The data node can also include at least one secondary key. The synchronization state can be used to synchronize the data node with a mobile client. The occasionally-connected data model 127 can include an XML schema for the date node.<br>
One embodiment of the present invention is an occasionally-connected application server 120. The occasionally-connected application server 120 can include a memory to store an occasionally-connected data model 127, the occasionally-connected data model 127 can define nodes and relations between nodes, and a conduit manager 124 to translate between data from external systems and data nodes defined by the occasionally-connected data model 127.<br>
The conduit manager 124 can use conduits 137 which define transforms between data nodes defined by occasionally-connected data model 127 and data for requests and responses for a specific web service 140. The transforms can be contained as meta data.<br>
A request transform can include an XQuery function that creates outgoing message body. A response transform include an XQuery function that processes incoming response and creates data nodes defined by the occasionally-connected data model 127.<br>
One embodiment of the present invention is an occasionally-connected application server 120 for mobile clients 111 comprising a conduit manager 124<br><br>
which evokes external web service 140 operations. The conduit manager 124 can uses conduits 137. The conduits can define transforms between data defined by an occasionally-connected data model and requests and responses for a specific web service 140.<br>
One embodiment of the present invention is a method comprising at an occasionally-connected application server 120, using conduits 137 to transform between data nodes in an occasionally-connected data model 127 and requests and responses for web services 140, the data nodes being XML data; and at the occasionally-connected application server 120, using the data nodes to provide data to a mobile client 111 for a mobile browser display. The data nodes can be transferred to the mobile client 111 for the display.<br>
One embodiment of the present invention is a mobile client 111 comprising data nodes, which can be stored in cache 113. The data nodes can be in the XML format. The data nodes at the mobile client can have an associated synchronization state. The synchronization state can indicate whether the data node has been synchronized with a server 120. The data nodes can be synchronized in the background as access to the server is made available and a display at the mobile client 111 is made using the data modes at the mobile client 111 without requiring current access to the server 120.<br>
The synchronization states can include an indications that the data node was locally created or modified; an indication that the data node was locally created or modified and ready for synchronization with server; and an indication that that the data node has a server synchronization is pending; an indication that the data node was synchronized with the server; and, an indication that that synchronization was rejected by the server; an indication that there was a conflict between a local modification and a server update. These and other synchronization states can be used to update data nodes at the client 111.<br>
The mobile client 111 can be transferred the data nodes and the occasionally-connected data model from the server 120 to produce a display at the mobile client. The mobile client 111 can run an application using the data nodes and the occasionally-connected data model 115 without being in current contact<br><br>
with a server.  The synchronization of the data nodes between the server 120 and the mobile client 111 can be done in the background.<br>
One embodiment of the present invention is an occasionally-connected application server 120 comprising an occasionally-connected data model 115 defining node types and the relations between nodes; and data nodes. The data nodes can be in the XML format. The occasionally-connected application server 120 can pass synchronization states for the data nodes back and forth with the mobile client 111 to synchronize the data node. The data nodes can be synchronized in the background as access to the server is made available and a display at the mobile client 111 is made using data modes at the mobile client 111 without requiring current access to the server 120.<br>
One embodiment of the present invention is a method for synchronizing a mobile application on a mobile device. The method comprises displaying a first user interface on the mobile device, the first user interface derived from a template stored on the mobile device; receiving a first input from a user on the mobile device; updating a synchronization parameter in the mobile device; displaying a second user interface on the mobile device, the second user interface derived from a second template stored on the mobile device and selected based on the user input; and retrieving data from an application server, the data including one or more templates selected based on the synchronization parameter.<br>
One embodiment of the present invention is a mobile unit 111 comprising a local cache 113 of data nodes in the XML format, and an occasionally-connected data model 115 defining node types and the relations between nodes, wherein the mobile unit 111 uses the data nodes and the occasionally-connected data model to produce an application which is displayed at the mobile unit.<br>
A template 135 can be used for producing a interface for the data nodes at the mobile unit.<br>
One embodiment of the present invention is a mobile unit 110 comprising a local cache 128 of data nodes in the XML format; an occasionally-connected data model 115 defining node types and the relations between nodes; and actions that allow the modification of the data nodes.<br><br>
One embodiment of the present invention is a mobile unit 110 comprising a memory storing an occasionally-connected data model 115 and a local cache 113 of data modes as defined by the occasionally-connected data model 115. The data nodes including primary keys and synchronization states.<br>
In one embodiment at least one of the data modes includes a least one secondary key. The synchronization state can be used to synchronize the mode data with an occasionally-connected application server. The occasionally-connected data model 115 can include at least one XML schema for the data node.<br>
One embodiment of the present invention is an occasionally-connected application server 120 for mobile clients comprising a conduit manager to translate between external systems, such as web services 140, and an occasionally-connected data model 127. A cache 128 can be used to store data nodes as defined by the occasionally-connected data model 127; and adaptive user interface server 126. Some mobile clients 111 are transferred the data nodes and the occasionally-connected data model to produce a display at the mobile client 111 and other clients receive HTML pages from the occasionally-connected application server 120 which are constructed by the adaptive user interface server<br>
126	using the data nodes and occasionally-connected data model.<br>
Clients 130 served by the adaptive user interface server 124 can have a traditional browser. Mobile clients 111 can have a special browser 110 that uses data nodes and the occasionally-connected data model to produce a display.<br>
One embodiment of the present invention is a method comprising at a server 120, storing data nodes as defined by an occasionally-connected data model<br>
127	and the occasionally-connected data model 127; and transferring to some<br>
clients 111 the data nodes and the occasionally-connected data model so that the<br>
client can produce a display; and transferring to other clients 130 HTML pages<br>
constructed at the server from the data nodes and the occasionally-connected data<br>
model.<br>
One embodiment of the present invention is an occasionally-connected data model comprising nodetypes describing the structure of nodes.   The nodes<br><br>
cazi be logically independent units of data; and keyref declarations that describe the relations between nodes.<br>
The nodes can include a root node. A variable can point to the root node. A mobile browser 110 can use data nodes and the occasionally-connected data model 115 to produce a display at a mobile unit 111. The occasionally-connected data model 115 can include a node graph. The node graph can indicate which data modes to cache.<br>
The nodetypes can include a XML definition, such as an XML schema, that is a complex type definition. The keyref declaration can define a key and key ref. The key can be a primary key. The keyref can be a foreign key definition referencing a primary key. The keyref definition can define legal traversals between nodes in a data graph.<br>
One embodiment of the present invention is an occasionally-connected data model comprising nodetypes which are an XML definition of nodes structure; and meta data, such as a keyref definition, that describes the relations between nodes. The nodes can be logically independent units of data.<br>
One embodiment of the present invention is a method for implementing a proxy, comprising mapping a web service operation to data within a programming model, such as an occasionally-connected data model, receiving a request regarding associated with the data; and initiating a invoke to a corresponding web service operation.<br>
One embodiment of the present invention is a mobile unit 111 comprising a local cache 113 of application data nodes, the data nodes being in the XML format, an occasionally-connected data model 115 defining node types and the relations between nodes; and a template 135 for producing an interface for the data nodes.<br>
The template 135 can be an XHTML template. The template 135 can use Spath expressions.<br>
The template 135 can access a current position in the occasionally-connected data model 115. A current variable can indicate the current position. In<br><br>
one embodiment, the template 135 does not modify the occasionally-connected data model.<br>
In one embodiment, the template 135 can invoke actions. Actions can modify data nodes. The actions can allow the modification of the data nodes without a connection to the server 120.<br>
The template 135 can be usable for multiple applications, each application having its own occasionally-connected data model and data node. The template 135 can be validated by a browser 11Q.<br>
Figures 11A-B are illustrations of a synchronization method of one embodiment of the present invention. In the example of Figure 11 A, the client 1102 includes a client version of "data node A" 1104. The client version of "data node A" 1104 has the sync state "ready for sync". The client version of "data node A" 1104 can include data constructed or modified at the client 1102. In the example of figure 11 A, there is no active connection between the client 1102 and the server 1108. The client version of "data node A" 1104 can be used by an application at the client without waiting for synchronization. The changes to "data node A" can be included in a message in message queue 1106 to be sent when a connection is available.<br>
The server 1108 has a server version of "data node B" 1110 which has not been sent to the client 1102. The server version of "data node B" 1110 can be constructed from data obtained from the "web service B" 1116. The conduit manager can use "conduit B" 1114 to translate response data from the "web service B" 1116 into the server version of "data node B" 1110. The "data node B" can be included in a message in message queue 1118 to be sent when a connection is available.<br>
Figure 11B show the situation when a connection is made available. The client version of "data node A" 1104 can be sent to the server 1108; and the client version of "data node A" 1104 can have its sync state set to "awaiting sync". The server 1108 can cache a server version of "data node A" 1111. The conduit manager 1112 can use "conduit A" 1115 to construct request data to send to "web<br><br>
service A" 1117. The client 1102 can store a client version of "data node B" 1105 obtained from the server 1108.<br>
The use of data nodes that are synchronized in the background with a server allow clients with intermittent connectivity to the server to run applications with the local version of the data nodes, and be updated as conductivity is made available.<br>
The following description gives one non-limiting implementation of one embodiment The discussion below gives one embodiment, but those skilled in the art will understand that other implementations of the above-described concepts can be done. Any potentially limiting language given below is to be interpreted in<br>
the context of the specific non-limiting implementation and is not meant to limit<br>
the general concepts.<br>
One embodiment of the present invention is a system for providing an occasionally connected access mechanism, comprising a browser 110. The browser 110 can be configured to be implemented on a mobile device 111 and provide a user interface to a user. The user interface can be derived from a template 135. An application server 120, the application server 120 configured to provide a persistent data store and receive and transmit information with the browser.<br>
In one embodiment, the Occasionally-connected application server 120 (MAS) runs on top or is a part of an application server, such as BEA Systems' WebLogic server. Occasionally-connected application server 120 contains a persistent data store to store application meta data, and a data cache 128 to optimize client requests.<br>
The Occasionally-connected application server 120 can be accessible to the mobile browser via a collection of Web based synchronization services, which can extend the SyncML standard. This enables different types of clients to leverage the MAS data model and synchronization capabilities.<br>
The Occasionally-connected application server 120 need not keep the full state of the client. Instead, the Occasionally-connected application server 120 can intelligently cache data based on meta data in the occasionally-connected data<br><br>
model 127. Additionally, the Occasionally-connected application server 120 can incorporates a dynamic content adaptation mechanism, known as the Adaptive Ul Server 126, that is capable of delivering mobile application functionality to thin clients (e.g., HTML Web site, WAP, SMS).<br>
hi one embodiment, the occasionally-connected data model can be a meta data description of the mobile application's anticipated usage of external data, and be optimized to enable the efficient traversal and synchronization of this data between occasionally connected devices and external systems.<br>
The occasionally-connected data model can be a relational model that describes nodes of data (or entities) associated with external services, and traversals (or relations) between them. For example, given a Web service that provides access to a Customer Relationship Management (CRM) application, the data model might have nodes for Accounts, Contacts, and Purchase Orders, etc., with traversals that let the application "navigate" from a given node (e.g., an Account) to all related nodes (e.g., Contacts and Purchase Orders).<br>
The occasionally-connected data model can be surfaced to the developer as a virtual XML document with a manifest variable, $root which points to the root node in the data model. Navigation to related nodes can be defined within the virtual XML document via keyref declarations. This enables a simple traversal syntax using a subset of XPath notation used hi ECMAScript for XML and known in this document as SPath. In addition, the mobile browser can always have as context, a current position within the data model (for example a particular customer or set of orders). The template and script can access this current position through another manifest variable $current.<br>
In one embodiment, the mobile browser 110 is, or includes, an extension of a Web browser that enables occasionally connected laptops and other devices to run applications regardless of whether they happen to be connected or offline. The browser can incorporates the same HTML renderer as current Web browsers, but also a user interface template and page flow mechanism, a data cache with intelligent synchronization capabilities, and an extended scripting language that provides access to the data cache.<br><br>
The mobile browser's user interface can consist of page templates. Templates can be XHTML pages with embedded bindings to cached data using SPath expressions. In one embodiment, Templates have no server side dependencies, so they can be rendered regardless of the status of the browser's network connection (i.e., online or offline).<br>
Templates can generate user interface events, which can be captured by a controller; the controller can call action scripts, which are able to modify the data in the client cache and determine page flow. The chont synchronization unit can automatically synchronize data accesses and changes with the Occasionally-connected application server 120.<br>
Applications can be provisioned to the mobile browser 110 by pointing to a URL, which references an XML application package implementing the client user interface and occasionally-connected data model for the application. The application can then be synchronized to the sync client 112. Furthermore, once an application has been deployed, application updates can be automatic and seamless.<br>
In one embodiment, the Adaptive UI Server 124 can be a proxy that runs the client application (templates, page flow, actions, etc.) for each active user. It can generate HTML pages (or SMS, etc.), which are sent to the browser 130, and the HTML pages can contain suitable hyperlinks that generate HTTP requests, which the adaptive server interprets into corresponding action calls. The adaptive server 126 can use the same synchronization mechanism as the mobile browser 110.<br>
Client applications can communicate with the server via synchronization. The synchronization process can trigger conduit requests to fetch new or more recent data, or to request client changes to be posted back to the external Web services 140. Conduits 137 can'contain meta-data that describes how to package the Web service requests and how to interpret their responses in the context of the data model.<br>
For example, supposing a client application modifies the rating code for a particular Account node (record) that is cached on the client; the synchronization<br><br>
mechanism can generate an update command that is sent to the server. If the client application then retrieves Contacts associated with the Account, and then adds a new Contact, then the synchronization mechanism can generate commands to fetch and add the corresponding data nodes. Conduits can describe how to invoke the various Web service operations required to implement each of these operations.<br>
The system can use standard Web services to exchange information with external data resources and business processes. The conduit mechanism can enable the Occasionally-connected application server 120 to call these operations to update the mobile data cache 128. Operations can act as getters and setters for a particular data type; a collection of operations can be managed by a conduit, which can act as an adapter. The conduit manager can coordinate synchronization requests from the OCAS's data cache, and conduit operations.<br>
Conduits can be the meta data used to associate Web services with three types of requested actions related to the data model:<br>
?	Navigating to related data; e.g. getting Contacts associated with an Account;<br>
?	CRUD operations; i.e., requests to create, read, update, and delete data; for example, creating a Contact related to an Account, updating the Contact details, or even requesting that the Contact be deleted;<br>
?	Custom operations, which are actions that need to take place in the enterprise related to some data, but are opaque to the data model; for example, requesting that a task be closed.<br>
The   Conduit   meta   data   can   map   the   OCAS   data   model   and<br>
synchronization commands to and from SOAP messages associated with the corresponding Web service operations. Conduit meta data can be defined using XML Query or XScript.<br>
A principal disadvantage of the current Web browser architecture with respect to mobility is the synchronous (blocking) request-response messaging protocol (i.e., HTTP). In the OCAS, messaging may be asynchronous. That is, user interface activity (e.g., browsing pages and modifying data) can run asynchronously with respect to the network connectivity and synchronization requests may run asynchronously with respect to the browser.<br><br>
FIG. 2 illustrates an exemplary asynchronous interaction between mobile browser 210, OCAS 220, and external Web services 230. The system implements reliable, ordered, message queues between the browser and the OCAS, and may use durable JMS queues between the OCAS and Web services (for asynchronous operation calls).<br>
If the browser is online, then sync messages can be enqueued and later sent to the OCAS. Otherwise, the synchronization unit can keep track of these events and generates sync messages whenever a connection is established.<br>
On the server, if the OCAS has cached data related to the client's synchronization request, then it can respond immediately. If the cache does not hold the appropriate data (or the data is stale) then the synchronization unit can call the conduit manager. The synchronization unit can then deliver the updated data to the browser. Since there may have been multiple conduits invoked for a particular sync request, the OCAS may deliver multiple sync messages to the browser.<br>
When a sync message is received by the browser, the local cache can be updated and an event sent to the controller. If data that is currently being displayed has been modified (i.e., data bound to the current template) then controller can cause the current page to be refreshed. That is, the page data bindings can be recomputed and the page incrementally redisplayed in the browser, without flickering or losing current user input, caret, or focus.<br>
OCAS applications can consist of client and server components. FIG. 3 illustrates the programming model 300 for an exemplary OCAS application. Programming model 300 includes mobile client 310, OCAS 320 and external system 330.<br>
In one embodiment, all communication to external systems (i.e., the enterprise) can be achieved via Web services (i.e., SOAP messages). The server programming model can comprise of a data model definition 3223 for each application, and a set of conduit definitions 324 that describe Web service operations. The data model consists of a set of XML Schema definitions that describe data types and relations.  Conduit definitions contain XScript and XML<br><br>
Query (XQuery) functions that map incoming and outgoing SOAP messages onto the data model.<br>
The client programming model can comprise of the data model 311 (which is a copy of the model defined on the server), a set of XHTML templates 312, and a controller definition 313, which includes an XPF page flow definition and XScript actions and functions. The contents of the entire application can be described by a single XML file, which is used by the framework automatically to provision application components to the client<br>
In one embodiment, each OCAS application may have its own occasionally-connected data model. The occasionally-connected data model can describe the logical structure (and other properties) of the application data, as exposed by the back-end applications via Web services. The occasionally-connected data model can consists of nodetypes, which describe the nodes (or entities) in the data model, and keyrefs, which define the relationships between the nodetypes. The occasionally-connected data model can act as the lingua franca used by the other OCAS components to process data or to exchange data with each other.<br>
The actual design of an application's data model (which is done by the application designer) can take into account the anticipated usage of the data, so as to optimize both data access by the client applications and data synchronization between the server and occasionally connected devices.<br>
Additional meta-data can also be specified to make it easier for applications to display data-driven (i.e., automatic) user interfaces. In one embodiment, the occasionally-connected data model only describes the data; the OCAS assumes that all operational data is stored and managed (owned) by the external systems i.e., no operational data permanently resides in the OCAS.<br>
The occasionally-connected data model can be used to describe the data that may be cached both on the client and on the server and can be essentially a virtual cached view on top of data in the enterprise fetched through Web services. In one embodiment, within the occasionally-connected data model, there is a<br><br>
magic starting node, known as mas:root (referenced by $root in the programming model) from whence everything flows.<br>
From any node can be possible to access related nodes via traversals. Nodes can conform to XML Schema definitions (/schema/* .xsd). Traversals can also be defined by schema definitions, using keyref declarations.<br>
An automatic synchronization mechanism can coordinate changes between client and server data. Data can be retrieved and exchanged with external system via a mechanism known as conduits. Conduits can be configured by a set of conduit files (/conduit/* .jsx) that define conduit operations—XScript and XQuery functions that invoke and process the results from external Web service operations.<br>
Conduit operations can consist of a pair of XML Query functions associated with a given keyref; one function can format the outbound request to the appropriate Web service operation, the other can process the inbound response. Conduit operations can also define procedural logic in the associated XScript function.<br>
The occasionally-connected data model can represented as a data graph consisting of nodes and fraversals—analogous to entities (i.e., table rows) and relations (i.e., primary/foreign key fields) in a relational database. A node is a logically independent unit of data (or entity—for example, a customer, purchase order, or contact record) and can be represented as an XML data object, which is defined by an XML schema. Inside the data cache, each node can include a primary key, synchronization state (e.g., including a sequence number), and possibly, multiple foreign keys that reference other nodes. A nodetype can describe the information about a particular type of node; this can include an XML Schema definition, which describes the structure of the data nodes. A traversal can be a directional relationship between two nodes. Traversals can be primarily a mechanism for navigating from one node to a set of related nodes. For example, an Account may be associated with a set of Contacts and a set of Tasks, each of which may also be associated with a Contact. Relations between nodes can be defined by a keyref declaration.  It can define both source and target nodetypes,<br><br>
and can include meta data to determine cardinality or the nodeset (e.g., exactly 1, 0 or more, 1 or more, etc.) The conduit manager's meta data can be associated with the keyref and determines whether or not nodes can be created, updated, linked, or removed. For example, the conduit's meta data determines whether or not there is a known Web service operation for inserting a Note about an Account or for updating an Account. A specific collection of nodes defined by a keyref can be called a nodeset.<br>
Data Nodes<br>
Data Nodes can contain structured data (i.e., an XML document), but can be atomic with respect to traversals; i.e. In one embodiment, a traversal represents a specific relationship between two nodes, but cannot reference data inside a particular node; nor can data inside a node reference another node.<br>
Often a single enterprise document may be made up of multiple nodetypes. For example, a purchase order may contain a sequence of line items (each with product references), and a customer reference. In this case, purchase order, line item, product and customer may all be represented as different nodetypes.<br>
la the case of these "composite" nodes, keyrefs within the data model can define cardinality; for example, a line item is associated with exactly one product. Conversely, depending on the needs of the application, a single purchase order nodetype might be defined to contain all of the above information in a single schema. The decision lies with the application designer—based on the need to independently link different nodes based on different traversals, collections and template requirements. For example, if line items are never linked or displayed outside of the purchase order then it might make sense to define a composite purchase order-line item nodetype.<br>
Relational Model<br>
The occasionally-connected data model can consist of schema and keyref declarations that are analogous to the relational entity and relation (primary/foreign key) constructs.<br>
Primary and Foreign Keys<br><br>
An example CRM system (referenced throughout this document for purposes of illustration) is implemented using a relational database. The Entity Relationship Diagram (ERD) 400 illustrated in FIG. 4 represents the account, contact, event, and user entities.<br>
The account, contact and user entities are defined by the following SQL.<br>
CREATE TABLE	account (<br>
pkey	INT NOT NULL PRIMARY KEY,<br>
parentPkey	INT FOREIGN KEY REFERENCES account(pkey),<br>
ownerPkey	INT FOREIGN KEY REFERENCES user(pkey),<br>
name	VARCHAR,<br>
type	CHAR<br>
)<br>
CREATE TABLE contact (<br>
pkey	INT NOT NULL PRIMARY KEY,<br>
accountPkey	INT NOT NULL FOREIGN KEY REFERENCES account (pkey) ,<br>
ownerPkey	INT FOREIGN KEY REFERENCES user (pkey) ,<br>
first	VARCHAR,<br>
last	VARCHAR,<br>
email	VARCHAR<br>
)<br>
CREATE TABLE user (<br>
pkey	INT NOT NULL PRIMARY KEY,<br>
login	VARCHAR<br>
)<br>
Both account and contact entities contain a foreign key reference to a user (owner); each contact entity defines a foreign key reference to an account. Also, each account has an optional foreign key referencing a parent account (i.e., accounts have sub accounts).<br>
Sample Queries<br>
Given the primary key of an account, pa, the following SQL selects all contacts:<br>
SELECT * FROM contact WHERE accountPkey = pa<br>
Given the primary key of a contact, pc, the following SQL selects the account:<br>
SELECT account.* FROM account, contact WHERE account, pkey = contact .accountPkey AND contact.pkey = pc<br>
However, given a full contact record, c, this simple SELECT query selects the corresponding account:<br>
SELECT * FROM account WHERE account.pkey * c.accountPkey<br><br>
Join Tables<br>
Suppose that events can belong to multiple accounts and contacts (e.g., a sales meeting with two accounts present). This would be modeled using a join table, for example:<br>
CREATE TABLE event (<br>
pkey	INT NOT NULL PRIMARY KEY,<br>
title	VARCHAR,<br>
details       VARCHAR )<br>
CREATE TABLE event_account (<br>
eventPkey     INT FOREIGN KEY REFERENCES EVENT(pkey), accountPkey    INT FOREIGN KEY REFERENCES ACCOUNT(pkey)<br>
)<br>
Here, the many-to-many relationship is modeled by the event_account join table. Given the primary key of an account, pa, the following SQL G°in) selects all related events:<br>
SELECT event.* FROM event, event_account WHERE event_account.accountPkey = pa AND event.pkey = event_account.eventPkey<br>
Similarly, given the primary key of an event, pe, the following SQL selects all related accounts:<br>
SELECT account.* FROM account, event_account<br>
WHERE event_account .eventPkey ~  pe<br>
AND account.pkey = event_account.accountPkey<br>
XML Schemas<br>
XML Schemas can define the nodetypes in the data model used by the application. The schemas subdirectory may contain multiple .xsd files—all of which are loaded by the framework on start-up.<br>
Schema type definitions can consist of two parts: a complexType definition, which describes the type's structure and a meta data definition (using the mas namespace), which for example, defines how to construct a label for a particular type.<br>
For example, the following schema fragment defines the contact type.<br><?xml version="l.0"?><br><xsd targetnamespace="http://example.com/"></xsd>
elementFormDefault="qualified" attributeFormDefault="unqualified"<br>
xmlns:xsd="http://www.w3 .org/2001/XMLSch.ema"<br>
xmlns :mas=" run :bea. com"<br>
xmlns="http://example.c6m/"&gt;<br><br><element name type=',1contactType"'><annotation><appinfo><br><nodeannotation><br><label>$node.first + " " + $node.last</label> </nodeannotation></appinfo></annotation><br><xsd: complextype name="contactType"><sequencer></sequencer><element name="salutation" type="contactSalutationEnum"></element><element name type="xsd:string"></element><xsd: element name type="xsd:string"></xsd:><element name="email" type="xsd:string"></element><br><simpletype namett><restriction base="xsd:string"><xsd: enumeration value="Mr"></xsd:><enumeration value="Mrs"></enumeration><enumeration value="Ms"></enumeration><enumeration value="Dr"></enumeration></restriction></simpletype><br>
The following XML represents a contact element.<br><contact><br><salutation>Mr</salutation><br><first>Roger</first><br><last>Reed</last><br><email><a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="ef9d80888a9daf8e8c828ac18c8082">[email&#160;protected]</a></email></contact><br>
KeyRef Basics<br>
The occasionally-connected data model can consist of standard XML Schema definitions for all application types. The schemas can define nodes that contain XML elements and attributes that are references to other XML nodes. The definition of these references can be made using key ref declarations.<br>
A keyref definition can consist of two parts: key and keyref.<br>
The key definitions can define the places in the document that contain primary keys. For example, the following key says that an accountKey occurs in each <account> element as an attribute called id.<br><xschkey name="accountKey"><br><selector xpath="account"></selector><br><field xpath></field><br>
In one embodiment, a key may uniquely identify a single node. Keys may not be used to identify repeating elements within a node (e.g., if line items are<br><br>
defined within the schema for purchase order, then key definitions may not be used to define individual line items).<br>
The keyref definitions can define the places in the document that contain foreign keys; the refer attribute refers to an associated key definition. For example, the following keyref says that each contact contains an account attribute, which is a foreign key referencing the accountKey definition (above).<br><keyref name="contactAccountRef" refer="accountKey"><br><selector xpath="contact»/&gt;&lt;br/&gt;
&lt;xsd:field xpath="></selector></keyref><br>
There can be many keyref (foreign key) definitions referencing the same (primary) key definition.<br>
Type and Instance Diagrams<br>
UML is used to illustrate nodetype and keyref diagrams.<br>
FIG. 5 illustrates the UML Entity Relationship Diagram (ERD) 500 for the sample CRM application. In this diagram, each entity represents an application nodetype (i.e., schema). Note, the root entity is a system nodetypes<br>
The arcs represent relations (i.e., keyref definitions), where the black diamond represents the target nodetype of the source nodetype's foreign key. The star annotation represents a many-to-one relation. Each arc is labeled with the corresponding keyref s alias name. FIG. 6 illustrates a node instance diagram for the CRM use case.<br>
Namespaces<br>
An exemplary name space embodiment is given below. The server programming model can use namespaces to distinguish between framework and application XML elements. Namespace definitions can be included as attributes within the top-level element of an XML source file.<br>
Elements prefixed with the mas namespace represent system elements.<br>
xmlns :Tnas="urn:bea.*mas"<br>
By convention, elements prefixed with the app namespace prefix represent the application.<br>
xmlns:app="http://example.com/"<br><br>
Also, by convention (in this document), the ws namespace prefix is used to indicate elements defined by an example Web service definition (i.e., WDSL file); the sf dc prefix is used to indicate the SalesForce Web service.<br>
xmlns:ws="http: //www.openuri.org/" xmlns:sfdc="urn:partner.soap.sforce.com"<br><br><label>spath-expression</label><br>
Example The following label definition constructs a string from the contact's first and last name.<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><complextype name="contactType"><all><br><xsd: element name="first" type="*'xsd:" string></xsd:><br><element name="last" type="xsd:string"></element><br><element name="email" type="xsd:string"></element></all><br><attribute names type="xsd:string" use="required" mas:type="pkey"></attribute><attribute name="ownerId" type="xsd:string" use="required"></attribute><attribute name type="xsd:string" use="required"></attribute></complextype><br>
The contact type already defines a primary key:<br><xsd: key name=" contactPrimaryKey"><selector xpath="contact"></selector><field xpath="@id"></field><br><br>
The following key definition defines that the email element within the contact node may also be used as a key.<br><xsd name="contactEmailKey"><br><xsd: selector xpath="contact,,/&gt;&lt;br/&gt;
&lt;xsd:field xpath=" email></xsd:><br>
The following keyref definitions define the two foreign key elements within the message node.<br><xsd name="messageFromRef" refer></xsd><selector xpath="message"></selector><br><xsd: field xpath='fffrom"/'><br><keyref name="messageToRef" refer="contactEmailKey"><selector xpath="message/to"></selector><br>
	3    .    .C!    _1    J	J-1-	MM/<br></keyref><br>
Note, the messageFromRef keyref could also be written as follows (although, the framework always uses the form above; note, the messageToRef must be written in the form above since there may be multiple <to> elements):<br><keyref name="messageFromRef" refer="contactEmailKey"><br><selector xpath="message/from"><br><field xpath=".»/&gt; &lt;/xsd:keyref&gt;&lt;br/&gt;
One-to-Many (Collections)&lt;br/&gt;
One-to-Many relationships can be implemented either as inverse keyrefs, or as manifest foreign key values contained within a data node.&lt;br/&gt;
Inverse Keyrefs&lt;br/&gt;
All many-to-one traversals may declare an inverse keyref that defines a one-to-many traversal.&lt;br/&gt;
Manifest Keyrefs&lt;br/&gt;
 &lt;br/&gt;
Certain nodetype' s schema declarations may define complex XML documents that contain a repeated sequence of elements—each of which may contain a foreign key value.&lt;br/&gt;
Example&lt;br/&gt;
The following schema definition describes a purchase order entity.&lt;br/&gt;
&lt;xsd:element name=llpurchaseOrder" type="purchaseOrderTypen&gt; &lt;xsd:complexType name=" purchaseordertype><sequence><br><element name="price" type="xsd:double"></element><br><xsd complextype name="linelterns"><br><xsd: sequence maxoccurs="unbounded"><complextype ref><sequence><br><element name='HprodId"' type="xsd:string"></element><br></sequence></complextype></xsd:></xsd></sequence><xsd: attribute name type="xsd:string" mas :></xsd:><br><br>
The following key declaration defines the primary key for the purchase order nodetype.<br><key name="purchaseOrderKey"><br><xsd: selector xpath></xsd:><field xpath="id"></field></key><br>
The following keyref declaration identifies the elements within the purchase order that are foreign keys referencing products.<br><keyref name="purchaseOrderProductRef" refer="productKey" mas:alias="purchaseOrder:products"><br><selector xpath-></selector><field xpath="prodId"></field></keyref><br>
This relationship can be illustrated by figure 12A. For example, the following XScript expression retrieves the product referenced by the first line item of the purchase order.<br>
var product *= purchaseOrder.©©products.*;<br>
Many-to-Many<br>
Many-to-many relations are implemented as pairs of one-to-many relations. An example is given in figure 12B.<br>
I.e., account and event declare the following schemas:<br><cxsd: complextype name="ac count Type "><xsd.-all><br><element name="name" type="xsd:string"></element><br><br><br><attribute name="id" type="xsd:string" use="required" mas:type="pkey"></attribute><attribute name="ownerIdt' type=" xsd:string use="required"></attribute><attribute name="parentId" type="xsd:string"></attribute>oO<br><complextype name="eventType"><xsd><br><element name="first" type="xsd:string"></element><element name="lastr type=" xsd:string></element><br>
ocsd:attribute name="id" type="xsd:string" use="required" mas:type="pkey"/&gt; </xsd></complextype><br>
And declare the following keyref definitions:<br><keyref name="accountEventRef' refer=" eventkey><br><selector xpath="account"></selector><br><field xpath='nevents"/'><br><keyref name="eventAccountRef* refer=" accountkey><selector xpath="event"></selector><field xpath="accounts"></field><br></keyref><br>
In one embodiment, many-to-many keyrefs cannot declare inverse keyrefs since, in general, the framework would not have enough information to maintain consistency.<br>
One-to-One<br>
In one embodiment, one-to-one relations are implemented as paired many-to-one relations.<br>
Example<br>
Supposing each user of the system also has a contact record as shown in figure 12C.<br>
I.e., contact and user define the following keyrefs:<br><keyref name="userContactRef" refers mas></keyref>
mas:inverseAlias="user"&gt;<br><selector xpath="user"></selector><br><field xpath="@contactId"></field><br>
One-to-one keyrefs should always declare an inverse keyref.<br>
var contact = user.©©contact; contact.©©user == user;<br>
System Data Types<br>
Node Schema Definition<br>
The following XML schema defines the structure of a'node.<br><br><br>
In one embodiment, for each application there is a special root node, which has the nodetype mas: root; this node does not contain application data and may not be modified. The framework automatically creates an instance of the root node, which is referenced via the $root variable. Keyrefs may reference mas: root as their source type, for example:<br><keyref name="accounts" sourcetype="mas : root" targettype="app:contact"></keyref><br>
In one embodiment, nodes may either be instantiated by a client programming or by server conduits.<br>
Nodeset Schema Definition<br>
Apart from the root node, all nodes belong to a nodeset, which corresponds to a keyref. A nodeset is defined by the following XML Schema:<br><?xml version^"1. 0"?><br><schema targetnamespace='Hrun:bea.com"&lt;br/'>
elementFormDefault="qualified" attributeFormDefault== "unqualified"<br>
xmlns:xsd="http://www.w3.org/200l/XMLSchema"<br>
xmlns=:" run; bea. com" &gt;<br>
otsd: element name="nodeSet"&gt; <xsd . complextype><sequence><br><element ref="node" maxoccurs='7Munbounded"/'><br><attribute name="keyref" type="xsd:string"></attribute></element><br>
he <nodeset> element contains an unbounded sequence of <node> elements. Each nodeset corresponds to a keyref (defined by the keyref attribute), which determine the nodetype of the contains node elements.<br>
Synchronization States<br><br><br><br>
In one embodiment, client applications do not directly call Web service operations—instead the conduit mechanism maps the semantics of individual (constrained) Web service operations onto the programming model against the client's virtual XML document (e.g., CRUD semantics (create, read, update, delete), navigating, custom operations, etc.) Client data model changes are synchronized to the server, which then triggers the conduit manager to invoke the external Web service operations.<br>
In one embodiment, conduits define a coordinated set of Web service operations for a particular keyref. Each keyref can be associated with exactly one conduit. Web services may be interfaces to existing systems such as databases, LDAP directories, ERP applications, and Web sites. They may also be wrappers that abstract complex long running asynchronous processes (workflows) coordinated by procedural logic (e.g., WLIJPD).<br>
In one embodiment, although Web services used by the system may have certain requirements (e.g., each record must include a unique primary key, and ideally a sequence number or timestamp), there are no occasionally-connected data model specific requirements placed on them. Therefore, the MAS may be one of many consumers of these resources.<br>
In one embodiment, conduits do not assume that the Web sendee was written with the data model in mind; that is, the types passed into the request may not be isomorphic to the nodetypes in the data model, and the responses may also be different. Therefore, the schema used by the Web service request and response do not need to be the same as the schema for any of the nodes in the data model.<br>
Conduits can contain metadata to map from the data model into the request document for the Web service operation invocation, and to map from the Web service response back into the data model. These nieta data are known as transforms, and can be expressed in the XML Query language. Indeed, the transform model is general enough that a Web service may return a response document that maps to several different related nodes in the data model and still successfully map back into the data model.<br><br>
Meta data that is crucial to the MAS cache (i.e., the record type's primary key and sequence number/timestamp) can also mapped using transforms.<br>
Conduit File Overview<br>
The conduits subdirectory may contain multiple . j sx files—all of which are loaded by the framework on start-up; these files contain conduit definitions. Conduit files can consist of XScript and XQuery functions that implement conduit operations; these files can also contain meta data defined in comment blocks. The annotations model enables the developer to use both visual tools and script editors to build conduit files.<br>
Each conduit file can contain a header comment that may declare the<br><br>
The conduit file also contains (possibly multiple) object declarations that represent Web service controls. Control definitions appear in the header block immediately before the corresponding variable declaration.<br>
Example<br><br><br><br><br><br>
mas:transform	Declares associates request and response<br>
	transforms.	<br>
mas:namespace	Declares the default namespace for the function,	<br>
mas:field                      Declares custom source fields that are required to<br>
	1 call the function,	<br>
mas:operation<br>
The mas: operation tag has the following attributes:<br>
Attribute	Description<br>
type	Operation type (e.g., "select", "insert", "update", etc.<br>
	)	<br>
keyref	Keyref name that defines select relation.	<br>
inverse	If true, then implements the inverse keyref definition-<br>
node                             | Nodetype for insert/update/delete operations.<br>
Operations can reference either a keyref or schema (node) definition.<br>
©mas : opex~ation type=" operationType"  keyref ~" keyref Name" @mas:operation type="operationType"  node="nodeType"<br>
The inverse attribute indicates that the operation is called on the inverse keyref.<br>
®mas:operation type="operationType"  keyref *="keyrefName"   inverse="true"<br>
For example, given the following keyref and key definitions:<br><keyref name="contactAccountRef' refers" accountkey mas:alias mas:inversealias-><selector xpath="contact"></selector><br><field xpath="©account"></field></keyref><br><key name='ItaccountKey"'><br><selector xpath="account"></selector><br><field xpath="@id"></field></key><br><key name="contactKey"><br><selector xpath="contact"></selector><br><field xpath="@id"></field></key><br>
The conduit can implement the following select operations:<br>
/** ©mas:operation type="select" keyref="app:contactAccountRef" */ function selectAccount($msg, $source) { return ws.invoke($msg);<br>
}<br>
/** ©mas:operation type="select" keyref=uapp:contactAccountRef" inverse="true"<br>
V<br>
funciton selectContacts($msg, $source) {<br>
return ws.invoke($msg) ; }<br>
The traversal contact. ©©account would call selectAccount (), while<br>
account .©©contacts . * would call selectContacts (). mas:transform<br>
The mas: transform tag has the following attributes:<br><br><br><br>
For an insert, update, and delete operations, the default body can be as<br>
follows:<br>
I'**<br>
*	@mas:operation type="insert |update (delete"  keyref ~"keyrefNajneu<br>
*/	-<br>
function operatioi2TypeSourceType{$msg,   $node)   {<br>
return ws.invoke($msg); }<br>
The $node variable contains the node to be inserted/updated/deleted.<br>
For a custom operation, the body can be as follows:<br>
/**<br>
*	@mas;operation type="custom"  node="node.Wajne"  name="qperationName"<br>
*/ function opera tionT}speSourceType{$msg,   $ source,   $node)   {<br>
return ws. invoke ($msg) ,-}<br>
Here, the $node variable contains the query object created by the client calling the custom operation.<br>
Transforms<br>
Operations may optionally define request and response transform functions using the mas: transform annotations.<br>
For example, the following operation implements the select operation that retrieves contacts given an account identifiers (i.e., the inverse keyref defined by<br>
contactAccountRef):<br>
/**<br>
*	select contacts for an account: $account.©©contacts.*<br>
*	@mas:operation type="select" keyref="app:contactAccountRefn inverse="true"<br>
*	©mas:transform type="reguest" function«MselectContacts_request"<br>
*	@mas:transform type="response" function="selectContacts__responseu<br>
*/<br>
function selectContacts ($msg, $source) {<br>
return ws.invoke{$msg); }<br>
The request transform can be called before the conduit operation is invoked; it returns the XML body of the outbound message, which is inserted into<br>
the message object, $msg, passed to the conduit operation.<br>
/**<br>
*	©mas:namespace target="sfdc"<br>
*	©language:body type="xguery"<br>
*/ function selectContacts_request($source) { <query><br><guerystring><br>
SELECT * FROM Contact<br>
WHERE Accountld * "{string($source/@id)}" </guerystring></query><br>
}<br><br>
The response transform can be called after the conduit operation returns (unless the operation returns an <error> object). It is passed the XML message body returned from the service control's invoke ()   function. The response<br>
transform returns a list of application nodes to the conduit manager.<br>
/**<br>
*	©mas:namespace fcarget="app"<br>
*	©language:body type^'xguery"<br>
*/ function selectContacts__response ($respQnse) {<br>
for $i in $response/sfdc:queryResponse/sfdc:result/sfdc: records return<br><contact id="{string($i/sfdc:Id)}" accountid="{string($i/sfdc:AccountId)}"><br><modified>{string($i/sfdc:SystemModstamp) }</modified><fist>{string($i/sfdc:FistKame)) <last>{string($i/sfdc:LastName)}</last><email> {stx~ing ($i/sfdc:Email) } </email></fist></contact><br>
)<br>
Note, the conduit operation is able to manipulate the header and body of the service response message before the body is processed by the response transform.<br>
Conduit Operations<br>
Conduit operations can map Web service operations onto framework operations that are exposed to the application programming model.<br>
Each operation can defines a pair of queries that map the corresponding incoming and outgoing XML messages received from and sent to the associated Web service operation. These transforms consist (typically) of XQuery expressions that translate data from the external system data format, to the MAS application data format defined by the schemas.<br>
Operation Types<br>
In the client programming model, operations can be invoked either on nodes (including $root), or on keyrefs. For example:<br>
$root.create{xml};	//  create node<br>
node.@@Jceyref .create (xml);	// create and link node<br>
node.@@keyref.*;	// implicit select<br>
node.QQkeyref .select (spath);	II  deep select<br>
node.update () ;	// update node<br>
$root. foo(jonl) ;	// custom operation<br><br>
Depending on the operation type, different input parameters are required to be passed to the conduit operation.<br>
Except for update and delete, all other operations are passed (part of) the node that represents the context (or source) of the operation (the mas:field declaration determines how much of the source node is transferred to the server). This is referenced by the conduit functions using the $ source variable.<br>
In the case of update operations (i.e., insert, update, and custom operations), the data node used to invoke the conduit operation is referenced in the XQuery transform using the $node variable. In addition, all operations have implicit access to the $user system variable, which contains information about the current user.<br><br><br>
[0100]	Each conduit operation may define a pair of queries (transforms)<br>
that create and process XML objects corresponding to incoming and outgoing XML messages received from and sent to the associated Web service operation.<br>
Transform functions can be declared using the mas: transform annotation on the corresponding conduit function. By convention transform function names can use the same name as the conduit function with the _request and _response suffixes. However, in some cases, response transforms may be reused by multiple conduit operations.<br>
Transforms can be implemented as XQuery (XML Query) functions.<br>
Example<br>
The following operation implements the select operation that retrieves contacts  given  an  account identifier  (i.e.,   the  inverse  keyref defined by<br>
contactAccountRef):<br>
/**<br>
*	select contacts for an account: $account .©©contacts. *<br>
*	®mas:operation type="select" keyref="app:contactAccountRef" inverse-"true"<br>
*	©mas:transform type="request" function="selectContacts_request"<br>
*	©mas:transform type="response" function="selectContacts_response"<br>
*/ function selectContacts($msg, $source) {<br>
return ws.invoke($msg);<br>
}<br>
*	©mas:namespace target="s£dc"<br>
*	©language:body type="xquery"<br>
*/<br>
function selectContacts_reguest($source) { <query><br><guerystring><br>
SELECT * FROM Contact<br>
WHERE Accountld -  "{string($source/@id)}"  <br>
}<br>
/**<br>
*	©mas•.namespace target="app"<br>
*	©language:body type="xquery"<br>
*/<br>
function selectContacts_response($response)   {<br>
for $i in $response/sfdc:queryResponse/sfdc:result/sfdc:records return<br><contact id="{string($i/sfdc:Id) }" accountid="{string($i/sfdc:Accountld)}"><br><tnodified>{string ($i/sfdc:SystemModstamp) } <fist>(string ($i/sfdc:FistName&gt;} <last>{string($i/sfdc:LastName)}</last><email>{string($i/sfdc:Email)}</email></fist></tnodified></contact><br><br>
The request transform can construct the body of the SOAP message that invokes the query Web service operation. The response transform processes the body of the Web service operation's response SOAP message and constructs a set of <contact> nodes.<br>
Request Transforms<br>
The request transform can create the outgoing Web service message from framework and data model elements. Depending on the operation type (see operations table  above)  the transform can reference the  following  syst&amp;m<br><br>
service operation, which expects a SOAP message with a body that conforms to the following XML Schema definition.<br>
^element name="query"&gt; <complextype><segiaence><br><element name="queryString" type="xsd:string"></element> ^/element&gt;<br>
The following transform references the $source system variable to specify<br>
the Accountid foreign key required for the query.<br>
/**<br>
*	@mas:namespace target="sfdc"<br>
*	©language;body type=nxquery"<br>
*	@mas:namespace target=Hsfdc"<br>
*/<br>
function selectContacts_request{$source) { <guery><br><guerystring><br>
SELECT * FROM Contact<br>
WHERE Accountid « "{string($source/@id))"  </guerystring></guery> }<br>
For example, this might generate the following outgoing SOAP message<br>
body;<br><br><br><br>
For example, an incoming SOAP message body might be in the following form:<br><queryresponse xmlns : sfdc="urn:enterprise, soap, sf orce. com"><results></results><records xsi:type="urn:Contact"><id>1234</id><accountld>1000 <email><a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="077562686062754766646a622964686a">[email&#160;protected]</a></email><sf dc : firstname>Roger <lastname>Reed </lastname></sf></accountld></records><br><records xsi :type="urn .-Contact "><id>5678</id><accountid>1000</accountid><sf dc emailssarah com dc: emails firstname>Sarah <br>
The $response system variable points to the top-level <queryrespouse> element (within the SOAP message body). Therefore, the following XPath expression should be used to reference the array of <contact> elements.<br>
$response/sf dc: crueryftesponse/sf dc: result/sf dc: records<br>
The following transform processes the incoming SOAP message and<br>
creates a list of <contact> elements.<br>
*	@mas:namespace target="app"<br>
*	©language:body type="xquery"<br>
*/<br>
function selectContacts_response(^response) {<br>
for $i in $response/sfdc:queryResponse/sfdc: result/sf dc: records return<br><contact id="{string($i/sfdc;Id)}» account!d="><br><modified>(string($i/sfdc:SystemModstamp) )</modified><fist>{string($i/sfdc:FistName)} <eraails>
}<br>
All request transforms generate nodes, which may be cached by the server, and synchronized with the client's data model.<br>
Permissions<br>
The operations defined by a conduit determine the operations that may be invoked on corresponding nodesets on the client. For example, if the conduit does not define an insert operation, then the client cannot attempt to create and insert a node for the corresponding nodeset—if it attempts to do so (e.g., in a custom action) this will trigger a runtime error. The client side programming model will enforce these constraints.<br><br>
For example, suppose account is pointing to a particular account node, and that account nodes are associated with the orders keyref. In this case, unless there is a defined conduit insert operation associated with the orders keyref, then the following code would case an error.<br>
account.©quotes.create{<br><quotereguest><br><prodid>Al10<br> ) ;<br>
Similarly, unless the update operation is defined for the contact nodetype, then the following code would also cause a error. contact.address.zip = "11201";<br>
In one embodiment, the implementation of client operations (e.g., the createO function) are matched with conduit operations (e.g., insert). For example, the conduit operation, insert, both inserts a node and traversals it to another node using a keyref relationship; therefore the creation of a node on the client must be atomically paired with a traversal operation to a corresponding nodeset.<br>
The meta data describing implemented conduit operations is accessible to the user programming model (via the associated keyref). The automatic user interface is able to use this information to generate basic menus (insert, update. etc.)<br>
Error Handling<br>
The conduit mechanism distinguishes between two kinds of errors: system errors (e.g., protocol and transport errors), and application errors (e.g., invalid data). Furthermore, application errors can be raised in two different ways: as a SOAP fault (i.e., protocol level error), and as part of the SOAP (or plain XML) response message.<br><br>
there is an error in the processing of a message; this can be either due to an infrastructural failure (e.g., transport failure), a protocol failure (e.g., badly formed<br><br>
message), or an application state error (e.g., update failed). System errors arise if there is an error creating or processing the outgoing or incoming SOAP message (e.g., XQuery transform error).<br>
Application errors arise if the external application rejects an operation request based on the values that are passed as part of the message body (e.g., update failed). SOAP faults are raised by the SOAP stack during the invocation of the invoke () function on the Web service control<br>
Normally the body of the XML object returned by the conduit operation is processed by the response transform. However, if the operation returns a system <error> object, then this object passed directly to the conduit manager. Note, either the main conduit function, or the response transform may return<br><mas: error> objects.<br>
The <mas: error> schema definition is given below:<br><xsd: complextype name=" errorType11 &gt; &lt;xsd:sequence&gt;&lt;br/&gt;
&lt;xsd:element name=" pkey type="xsd:any" minoccurs="0" maxoccurs="l"></xsd:><xsd element name="system" type="mas : systemErrarType" tttaxoccurs="!"></xsd><element narae="message" type="xsd:string"></element><element name="field" type="mas:errorFieldType" maxoccurs="unbounded"></element><br></mas:></mas:></error></prodid></quotereguest></eraails></fist></contact></contact></contact></queryrespouse></sf></records></queryresponse></segiaence></complextype></contact></guerystring></query></error></node></nodeset></sequence><br><complextype name="systemErrorType"><sequence><br><element name="code" type='nxsd:any"/'><element name="message" type="xsd:string"></element></element></sequence></complextype></xsd><br><complextype name="errorFieldType"><xsd: sequenco></xsd:><element name="code" type="xsd:any"></element><element name="message" type="xsd:string"></element><br><attribute name='*xpath"' type="xsd:string"></attribute></complextype><br>
I.e., the <mas: error> object has the following form:<br><error><br><mas: pkey>primar3'-.fcey<: pkey><mas: system><br><code>error-code</code><br><mas :message>messasre-strin3-</mas><br><mas :message>message-strin3r</mas><field xpath="spath-expression"><br><code>error-code</code><br><mas :message>jnessage~string</mas></field><br></mas:></:></mas:></error><br><br>
Each error object may contain the primary key of the node affected by the error. For select operations, this will be the source node's primary key; for update and delete operations this will reference the updated node.<br>
System errors can be logged by the server. All other error values can be returned to the client and passed to the corresponding callback function.<br>
An error object is returned to the application's callback function; this object has properties corresponding to the schema above.<br>
Examples<br>
The following operation returns a system error if the invoke () function<br>
invocation returns an error.<br>
/**<br>
*	@mas:operation type="select" keyref= n keyref Name"<br>
*/ function operationTypeSourceType($msg, $source) { var response = control.invoke{$msg); if (response.error) { return<br><error><br><mas: systemxmas :message>syste/n-error </mas:></error>;<br>
}<br>
return response; }<br>
Where appropriate, it can be the responsibility of the conduit operation to retry failed invoke () invocations. In this case, the conduit has to ensure that the Web service operation either is idempotent, or that some form of reliable messaging is employed.<br>
The following operation returns a system error after retrying the invoke {)<br>
function on failure.<br>
/**<br>
*	®mas:operation type="select" keyref= n keyref Name"<br>
*/ function operationTypeSourceType ($msg,   $ source) { for (i=0; i
var response = control.invoke($rasg); if (!response.error) {<br>
return response;      //OK<br>
}	.  .  ..<br>
}<br>
return<br><error><br><mas: systemxmab :message>Retry failed </mas:></error>;<br>
}<br>
The following operation first checks for a system error if the invoke 0 function returns an error, otherwise it returns a general application error. If<br><br>
invoke ()  succeeds, but the Web service response includes application errors,<br>
then it calls a utility function to parse the error message and returns a compound<br><error> object that may contain multiple <f ieid> errors. /**<br>
* @mas: operation type-^'create" keyref=r,,./ceyre.f.NaJne,,<br>
*/ function operationTypeSourcerj'pe($msg, $source) { var response = control.invoke($msg); if (response.error) {<br>
if (response.error.code == 101) { return<br><mas: error><mas: system><br><mas : code>(response.erx*or. code}<:><mas :message>system-error</mas></:></mas></mas:>;<br>
}<br>
else {<br>
return<br><error><br><mas :message>general -error</mas></error>;<br>
} }<br>
// check for application errors<br>
if (response.body.createResponse.result.errors) {<br>
return process_error(response.body.createResponse.result.errors);<br>
)<br>
return response;      //OK<br>
)<br>
// utility function to process field errors function process_error(errors) { var fields; for (i=0; i<errors.length i></errors.length>
var path = jnatch^ath(errors [i] .fields [0] ); fields +=<br><field xpath="*'{path}&quot;"><br><code>{$i/statusCode}</code> <message>{$i/message}</message><br>
}<br>
return <error>{fields}</error>; }<br>
CRUD Operations<br>
CRUD (Create Read Update Delete) operations represent the four basic relational data operations. These operations can map directly onto the MAS data model and client programming model.<br>
Note, the Web service's contact schema has a different shape from the application's contact schema defined above. The select operation examples below illustrates how this mapping is achieved.<br>
Select<br><br>
The select operation can enable the framework to retrieve nodes defined by a keyref for a particular source node. Typically, all conduits define a select operation since this is the basic mechanism used to retrieve nodes by the client application.<br>
Subsequent select operations (for different keyrefs) can be invoked to construct the data graph. For example, navigating from an account node to the purchase orders keyref invokes the getPurchaseOrders operation of the AccountManager Web service; then, navigating from a purchase order node to the line items keyref will call the getLineitems operation of the orderManager Web service.<br>
Select operations have the following form:<br>
/**<br>
*	®mas -. operation type= "select"  keyref="keyrefName"   [inverse^"true" 3<br>
*	©mas: transform  type="request"   function-" furic tionName_request"<br>
*	@mas:transform .type^'response"   function="func,tionName_respo.nse"<br>
*/<br>
function functionWame($msg/ $source) {<br>
return ws.invoke($msg);<br>
}<br>
Select operations are used to retrieve nodes corresponding to the keyrefName defined for a particular source nodetype; e.g., selecting the account referenced by ihe foreign key for a particular contact node. The inverse attribute defines that the operation implements the reverse relation; e.g., selecting all contacts that reference a particular account by via a foreign key.<br>
Keyref definitions can have the following form:<br><keyref name="nkeyrefName*" refer="targetType"></keyref>
mas:alias="relationName"  mas:inverseAlias="inverse£e2ationWaine"&gt; <selector xpath="sourceType"></selector><field xpath="r" oreigiajtey></field><br></field></mas:></f></error></mas:></schema></field></keyref><br>
In relational terms, the select operation corresponds to the following SQL expression:<br>
SELECT * FROM keyref.targetType WHERE primaryjcey = $source/foreign_key<br>
An operation implementing the inverse keyref corresponds to the following SQL expression:<br>
SELECT * FROM keyref. sourceType WHERE foreignJeey = $source/primary_key<br><br><br><br>
©language:body type^'xquery"<br>
*	©mas:namespace target="sfdc"<br>
*	©raas:field xpath="©accountId"<br>
*/<br>
functipn..fieJLectAccoiintByContact_request ($source) { <query><br><querystring><br>
SELECT * FROM Account<br>
WHERE Id = {string($source/©accountId) )  <br>
}<br>
/**<br>
*	©language:body type="xguery"<br>
*	©mas:namespace target="app"<br>
*/<br>
function selectAccountByContact_response ($response) {<br>
let $i := $response/sfdc:queryResponse/sfdc:result/sfdc:records return<br><account id="{string($i/sfdc:Id)}H&gt;&lt;br/&gt;
&lt;modified&gt;{string&lt;$i/sfdc:SystemModstamp) }&lt;/modif ied&gt; &lt;name&gt;{string($i/sfdc:Name)}&lt;/name&gt; &lt;type&gt;{string($i/sfdc:Type)}&lt;/type&gt; &lt;/account&gt; }&lt;br/&gt;
The conduit operation function can be auto generated by the platform; it can reference the accountownerRef  keyref definition and has declarations&lt;br/&gt;
(generated by tools) to the request and response transform functions.&lt;br/&gt;
/**&lt;br/&gt;
*	©mas:operation type=" select keyref="contactAccountRef"></account>
*	©mas: transform type= " request" function=" selectAccountByContact__request"<br>
*	©mas : transform tvne=MreRnr&gt;nsA" fimrsi- i OTI—« ggO g»r'i-&amp;r'l-»viTii-pyp^ritac* response " */<br>
function selectAccountByContact($msg, $source) { return ws.invoke($msg);<br>
}<br>
Request Transform<br>
The request transform can reference the $ source variable that represents the account node. The function annotations can declare the language (XQuery) and target namespace of the outgoing message document (referencing a namespace prefix declared in the conduit file's header annotation).<br>
The function can also declares a field annotation indicating that the ©accountid attribute of the contact node is required by the function; this declaration can ensure that the foreign key value is sent from the invoking client to the server as part of the synchronization request.<br><br>
/**<br>
*	©language:body type="xquery"<br>
*	(annas : namespace target="sfdc"<br>
*	©mas:field xpath="©accountId"<br>
*/ function selectAccountByContact_request($source) {<br><guery>	. .<br><guerystring><br>
SELECT * FROM Account<br>
WHERE Id = {string{$source/@accountId))<br></guerystring><br></guery></querystring></query><br>
)<br>
Response Transform<br>
The response transform can reference the $ response variable that represents the XML body of the message returned from the Web service. The function annotations can also declare the language (XQuery) and the target namespace of the XML object returned to the conduit manager.<br>
The function can assume that a single record is returned by the Web service <query> request. The function can transform this into a single <account> node with the corresponding primary key (id) and data fields conforming to the schema definition (including the <modified> element representing the sequence<br>
number).<br>
/**<br>
*	©language:body type="xquery"<br>
*	®mas:namespace target="app,t<br>
*/<br>
function selectOwnerByAccount_response($response) {<br>
let $i := $response/sfdc:gueryResponse/sfdc:result/sfdc:records return<br><account id="(string($i/sfdc:Id)}n&gt;&lt;br/&gt;
&lt;modified&gt;{string($i/sfdc:SystemModstamp)}&lt;/modified&gt; &lt;name&gt;{string($i/sfdc:Name)}&lt;/name&gt; &lt;type&gt;{string{$i/sfdc:Type)}&lt;/type&gt; &lt;/account&gt;&lt;br/&gt;
}&lt;br/&gt;
The &lt;account&gt; node can be returned to the conduit manager and synchronized back to the calling application. The conduit manager may also elect to place the node into the server's cache.&lt;br/&gt;
Inverse Selects (One-to-Many)&lt;br/&gt;
The many-to-one relationships defined by foreign keys can, of course, be thought of in the reverse direction as a one-to-many relationship.&lt;br/&gt;
Given the same schema and keyref definitions as in the section above, it is natural to think of a set of contact nodes belonging to an individual account node:&lt;br/&gt;
 &lt;br/&gt;
&lt;xsd:complexType name=" contacttype><all><br><element name="first" type="xsd:string"></element><br><element name="last" type="xsd:string"></element><br><element name="email" type="xsd:string"></element><br><element names type="xsd:string"></element></all> .<br><attribute names type="xsd:string" use="required" mas:type="pkey"></attribute><attribute name="ownerId" type="xsd:string" use="required"></attribute><attribute name="accountId" type="xsd:string" use="required"></attribute><br><keyref name="contactAccountRef" refer="accountKey" mas:alias="account"></keyref>
mas:inverseAlias="contacts"&gt;<br><selector xpath="contact"></selector><br><field xpath="@accountId"></field></account></modified></account></query></xsd.-all></cxsd:></field></selector></keyref><br>
This time,  however, the mas:inverseAiias  attribute of the keyref definition is used to traverse the keyref in the reverse direction:<br>
var contacts = account.©©contacts.* ;<br>
The following conduit operation implements this inverse keyref relation:<br>
/**<br>
*	©mas:operation type="select" keyref="contactAccountRef" inverse="true"<br>
*	@mas:transform type="request" function="selectCqntactsByAccount_request"<br>
*	©mas:transform type="response" functions"selectContactsByAccount_response"<br>
*/<br>
function selectContactsByAccount{$msg, $source) {<br>
return ws.invoke($msg); }<br>
/**<br>
*	©language:body type="xquery"<br>
*	®mas:namespace target="sfdc"<br>
*	©mas:field xpath="@id"<br>
*/<br>
function selectContactsByAccount_request($source) { <query><br><querystring><br>
SELECT * FROM Contact<br>
WHERE accountld = {string($source/@id)} </querystring></query><br>
}<br>
/**<br>
*	©language:body type="xquery"<br>
*	©mas:namespace target="app"<br>
*/<br>
function selectContactsByAccount_response ($response) (<br>
for $i := $response/sfdc:queryResponse/sfdc:result/sfdc:records return<br><contact id="{string($i/sfdc:Id)}" accountid="{string ($i/sfdc: Accountld)}"><br><modified>{string ($i/sfdc:SystemModstamp) }</modified><fist>{string($i/sfdc:FistName)} <last>{string($i/sfdc:LastName)}</last><email>{string{$i/sfdc:Email) }</email></fist></contact> }<br>
The conduit operation function can be auto generated by the platform; it references   the   accountownerRef   keyref  definition   and   has   declarations<br><br>
(generated by tools) to  the request and response transform functions.  The<br>
operation also declares that it represents the inverse keyref relationship.<br>
/**<br>
*	©mas:operation type="selectH  keyref="contactAccountRef"   inverse^"true"<br>
*	©mas:transform type="request"   function="selectContactsByAccount_requestn<br>
*	©mas :transf orm type="response"   function=,,selectCon.tactsByAccount_response"<br>
*/<br>
function selectContactsByAccount($msg, $source) {<br>
return ws.invoke($msg}; )<br>
Request Transform<br>
The request transform can reference the $ source variable that represents the contact node. The function annotations declare the language (XQuery) and target namespace of the outgoing message document (referencing a namespace prefix declared in the conduit file's header annotation).<br>
The function can also declare a field annotation indicating that the ©id attribute of the account node is required by the function; this declaration can ensure that the foreign key value is sent from the invoking client to the server as<br>
part of the synchronization request.<br>
/**<br>
*	©language:body type="xquery"<br>
*	©mas:namespace target="sfdc"<br>
*	@mas:field xpath="@id"<br>
*/ function selectContactsByAccount_reguest($source) { <query><br><querystring><br>
SELECT * FROM Contact<br>
WHERE accountld = {string($source/@id)} </querystring></query><br>
}<br>
Response Transform<br>
The response transform can reference the $ response variable that represents the XML body of the message returned from the Web service. The function annotations can also declare the language (XQuery) and the target namespace of the XML object returned to the conduit manager.<br>
The function can assume that multiple records are returned by the Web sendee <query> request. The function iterates through the results and transforms them into a set of <contact> nodes. Each node can contain the corresponding primary key (id) and data fields conforming to the schema definition; this includes the account foreign key (accountld attribute) and sequence number (<modif ied> element).<br><br>
*	©language:body type="xquery"<br>
*	©mas:namespace target="app"<br>
*/<br>
function selectContactsByAccount_response($response) {<br>
for $i := $response/sfdc:queryResponse/sfdc:result/sfdc: records return<br>
^contact id="{string{$i/sfdc:Id) }" accountId="{string($i/sfdc:Accountld)}"&gt;<br><modif ied>{ string ($i/sfdc: SystemModstamp) }</modif><fist>{string($i/sfdc:FistName)} <last>{string($i/sfdc:LastName)}</last><email>{string($i/sfdc:Email)}</email></fist></modif></contact> }<br>
The <contact> nodes can be returned to the conduit manager and synchronized back to the calling application. The conduit manager may also elect to place these nodes into the server's cache.<br>
Non-Relational (Context Free) Selects<br>
It is possible to define relations between nodes that do not depend on foreign key values. For example, a set of nodes may be defined by a query that uses the current user's information, or other external information (e.g., time of day, real time data, external system state). In these cases, the nodeset may be attached to arbitrary nodetypes within the data model. Typically, however, these nodesets are attached to the root node.<br>
Conduit select operations can reference a keyref definition; since context-free selects, by definition, do not require the context of the source node, in one embodiment, they are always implemented on inverse keyrefs.<br>
The following example illustrates how, in the CRM demo, the set of accounts for the current users is retrieved by a conduit select operation. The account nodetype has the following key definition.<br><key name="accountKeyn mas:alias=naccounts"> ocsd:selector xpath="account "/&gt;<br><field xpath="@id"></field></key><br>
The mas:alias attribute indicates that the nodeset of accounts is traversable from the root node; i.e.,<br>
var accounts = $root.©©accounts.*;<br>
The conduit can be implemented in the same way as the inverse keyref<br>
select operation (above).<br>
/**<br>
*	@mas:operation type="select" key^'accountKey" inverse="true"<br>
*	®mas:transform type="request" function="selectAccounts_request"<br>
*	@mas: transform type="response" functions"selectAccounts_response"<br><br>
"/ function selectAccounts($msg, $source) { return ws.invoke($msg);<br>
}<br>
*	©language:body type="xquery"<br>
*	©mas:namespace target="sfdc"<br>
V function selectAccounts_request{$source) { <query><br><querystx><br>
SELECT *.Account FROM Account, User WHERE User.Alias = {string($user/useraame)} AND User.Id = Account.OwnerId  </querystx></query><br>
}<br>
/**<br>
*	©language :body type="xquery,l<br>
*	©mas:namespace target="appw<br>
*/<br>
function selectAccounts_response($response) {<br>
for $i := $response/sfdc:queryResponse/sfdc:result/sfdc:records return<br><account id="{string($i/sfdc:Id)}"><br><modified>{string{$i/sfdc:SystemModstamp)}</modified><name>{string($i/sfdc:Name)}</name><type>{string($i/sfdc:Type)}</type></account> }<br>
Request Transform<br>
The request transform can reference the $user system variable, which is used to construct the request query sent to the Web service.<br>
*	©language:body type="xquery"<br>
*	@mas:namespace target="sfdc"<br>
*/ function selectAccounts_request($source) { <query><br><querystring><br>
SELECT *.Account FROM Account, User WHERE User.Alias = {string($user/username)) AND User.Id = Account.Ownerld </querystring></query><br>
}<br>
In this case, the service can implement a join query that selects all accounts that are owned by the current user (i.e., have an ownerid foreign key that matches the ID of the current user). Note, the transform does not reference the $ source variable.<br>
Response Transform<br>
The response transform can process the set of accounts returned by the Web service operation in the same way as the response transforms defined in previous sections.<br><br>
*	©language:body type="xguery"<br>
*	®mas:name space t arget ="app"<br>
*/<br>
function selectAccounts_response($response) {<br>
for $i := $response/sfdc:gueryResponse/sfdc:result/sfdc:records return<br><account id="{string($i/sfdc:Id)}"><br><modified>{string($i/sfdc:SysteraModstamp))</modified><name>{string($i/sfdc:Name)}</name><type>{string($i/sfdc:Type)}</type></account> }<br>
Note, the ©mas: root id attribute can be automatically computed by the conduit manager when the set of <account> nodes are returned to it.<br>
Insert<br>
Insert operations can be called by the conduit manager when a client application synchronizes newly created nodes to the server.<br>
On the client, nodes can be created in one of two ways; i.e., the create () function can either be called on a keyref or on the root node:<br>
var node  = source. ®@keyref. create (<xml>) ;      // contextual create<br>
var node = $root.create(<xml>);	// context free create<br>
hi both cases, just the node's XML object can be transferred to the server (i.e., not the source node). This is because in the case of a contextual create operation, the node must contain a foreign key value that references the source node; this value is set automatically by the framework based on the keyref definition.<br>
Insert operations have the following form:<br>
/**<br>
*	@mas:operation type="insert" node="i2odeName"<br>
*	©mas: transform type="request" function="functionName_reguest"<br>
*	@mas:transform types="response" function^"functionName_responsen<br>
*/ function functionName($msg, $source) {<br>
return ws.invoke($msg); }<br>
Insert operations can be used to create nodes corresponding to the schema referenced by the nodeName declaration.<br>
The insert operation's request transform creates the message body for the Web service operation; it can reference the following system variables, which<br><br><br><br>
The node's primary key (and, optionally, sequence number) can be returned to the conduit manager, which synchronizes this information back to the client. Nodes are initially created on the client with a temporary primary key; this value must be replaced by the external system's primary key.<br>
Nodes typically include foreign key values that reference other nodes. If multiple nodes are created on the client that reference each other, then the system has to ensure that the insert conduit operations are called in the appropriate dependency order, and that primary key values returned from the Web service are used to replace temporary foreign key values for pending nodes.<br>
Non-Relational Inserts<br>
In one embodiment, non-relational insert operations do not have foreign keys that reference other nodetypes within the data mode. For example, the user nodetype can be defined by the following schema:<br><xsd name="userType"><br><all><br><xsd: element natne=" email" type="xsd:string"></xsd:><br></all><br><attribute name='nid"' type="xsd:string"></attribute></xsd></xml></xml></account></contact></query></to></xsd:><br>
Suppose an administration application was able to create new users for the system; the client code to do this might be as follows:<br>
$root . create (<user><email>b6b@acme,com</email></user>) ;<br>
In one embodiment, this would require the following insert conduit operation:<br><br>
*	@mas:operation type="insert" node="app:user"<br>
*	®mas:transform type="request" function="insertUser_request"<br>
*	®mas:transform type="response" function="insertUser_response"<br>
*/ function insertUser($msg, $node) { return ws.invoke($msg);<br>
}<br>
/**<br>
*	©language:body type="xquery"<br>
*	©mas:namespace target=,rsfdc"<br>
*/ function insertUser_reguest($node) { <create><br><sobjects xsi:type=',,User"'><br><email>{string($node/app:email)} </email></sobjects></create><br>
}<br>
/**<br>
*	©language:body type=nxquery"<br>
*	©tnas: namespace targets"app"<br>
*/ function insertUser_response($response)    {<br><user id></user> }<br>
Request Transform<br>
The request transform can reference the $node variable that represents the user node created by the application. The function annotations canf declare the language (XQuery) and target namespace of the outgoing message document<br>
(referencing a namespace prefix declared in the conduit file's header annotation).<br>
/**<br>
*	©language:body type="xquery"<br>
*	©mas:namespace target^'sfdc"<br>
*/ function insertUser_request ($node) { <create><br><sobjects xsi:type="Usern&gt;&lt;br/&gt;
&lt;Email&gt;{string($node/app:email)}&lt;/Email&gt; &lt;/sObjects&gt; &lt;/create&gt;&lt;br/&gt;
)&lt;br/&gt;
Response Transform&lt;br/&gt;
The response transform can reference the $response variable that represents the XML body of the message returned from the Web service. The function annotations can also declare the language (XQuery) and the target namespace of the XML object returned to the conduit manager.&lt;br/&gt;
On success, the Web service can return a message body that conforms to the following schema definition.&lt;br/&gt;
 &lt;br/&gt;
&lt;element name=" createresponse><complextype><sequence><br><element narae="result" minoccurs="1" type="tns:SaveResult"></element></sequence></complextype><br><complextype name="SaveResult"><sequence><br><element name="id" type="tns:ID"></element><br><element name="success" type="xsd: boolean"><br><element name="errors" minoccurs="0" maxoccurs="unbounded"></element>
type="tns:Error"/&gt;<br></element></sequence></complextype><br>
The transform can create a partially constructed <user> node that contains<br>
the primary key attribute (id) defined by the application's schema.<br>
/**<br>
*	©language:body type="xguery"<br>
*	@mas:namespace target="app"<br>
*/<br>
function	insertUser_response($reaponse)   {<br><user id="{string($response/sfdc:createResponse/sfdc:result/sfdc:id))"></user><br>
}<br>
This primary key value can be processed by the conduit manager and synchronized with the client application.<br>
Relational Inserts<br>
Relational inserts can involve nodes that contain foreign key values that reference other nodes within the cache.<br>
For example, the contact schema, below, defines foreign keys for an owner node (©ownend) and account node (@accountid).<br><complextype name="contactType"><all><br><element name="first" type="xsd:string"></element><br><element name="last" type="xsd:string"></element><br><element name="email" type="xsd:string"></element></all><br><attribute name="id" type="xsd:string" use='Hrequired"' mas:type="pkey"></attribute><xsd: attribute name="ownerId" type="xsd:string" use="required"></xsd:><xsd: attribute name="accountId" type='nxsd:string"' use="required"></xsd:></complextype></user></sobjects></create></xsd></xsd:><br>
Initially, the contact XML object may be constructed by an XScript assignment:<br>
var contact = <contact><br><first>Sarah</first><br><last>Smith</last><br><email>sarah®acme. com</email></contact>;<br>
Nodes that contain foreign keys may be created in a number of ways. Given the contact XML object above, and variables representing owner and contact nodes, the following function creates a contact node by calling the<br><br>
create ()  function on the root node. Note, foreign keys must be set before create () is called.<br>
function createContactl(account, owner, contact) { contact.©©account = account; contact.©©owner = owner;<br>
return $root.create(contact); }<br>
However, the following functions achieve the same goal:<br>
function createContact2(account, owner, contact) { contact.©©owner = owner;<br>
return account.©©contacts.create(contact)<br>
}<br>
function createContact3(account, owner, contact) ( contact.©©account = account;<br>
return owner.©©contact = contact; }<br>
Note in both of these cases, the missing foreign key value is supplied by the framework before the node is synchronized to the server. Therefore, regardless of how the node is created by the application, the conduit operation need only be bound to the nodetype.   The conduit operation can be implemented in the same<br>
way as the operation defined in the previous section:<br>
/**<br>
*	@mas:operation type="insert" node="app:contact"<br>
*	®mas:transform type="requestM function="insertContact—request"<br>
A ©mas:transform type="response" function*"insertContact_response"<br>
*/<br>
function insertContact($msg, $node) {<br>
return ws.invoke($msg); )<br>
*	©mas:namespace target="sfdc"<br>
*	©language:body type="xquery"<br>
*/<br>
function insertContact_request($node) { <create><br><sobjects xsi:type><br><accountid>{string($node/app:@accountld}) </accountid><ownerld>{string($node/app:@ownerld}) <firstname>{string($node/app:first)}</firstname><lastname>{string($node/app:last)}</lastname><email>{string($node/app:email)}</email></ownerld></sobjects></create><br>
)<br>
/**<br>
*	©mas:namespace target="app"<br>
*	©language:body type="xcfuery" */<br>
function insertContact_response($response) {<br><contact id="{string($response/sfdc:createResponse/sfdc:result/sfdc:id)}"></contact><br><br>
This primary key value returned by the response transform can be processed by the conduit manager and synchronized with the client application. This value replaces the temporary primary key assigned by the application when the node was first created.<br>
However, in one embodiment, if multiple nodes that reference each other are created by the application, then primary key values returned by the server must also be used to update foreign key values of nodes that reference newly inserted nodes.<br>
For example, the following function first creates an owner node, then creates a contact node that references it.<br>
function createContact4(account) {<br>
var owner ~  $root.create(<user><email>sarah®acme.com</email></user>);<br>
var contact = <contact><br><first>Sarah</first><br><last>Smith</last><br><email><a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="5d2e3c2f3c351d3c3e3038733e3230">[email&#160;protected]</a></email></contact>;<br>
contact.©©owner = owner;<br>
return account.create(contact); }<br>
The conduit insert operation for the user node is called before the conduit insert operation for the contact node, and that the contact node's ownerid attribute contains the appropriate foreign key value returned from the first conduit operation.<br>
Sequence Numbers<br>
In some cases the Web service method that is called to create a node may not return a sequence number. The conduit is able to make multiple Web service calls within a single conduit operation to retrieve this information.<br>
For example, the conduit operation defined in the previous section is extended below:<br><br>
*	@mas:operation type="insert" node="app:contact"<br>
*	®mas:transform type="request" function*"insertContact_request"<br>
*	©mas:transform type="response" function="insertContact_response"<br>
*/ function insertContact($msg, $source) { var response = ws.invoke($msg); var id = response.sfdc:createResponse.sfdc:result.sfdc:id;<br>
// retrieve sequence number<br>
var msg2 = createMessage(requestTimestamp(id));<br>
var response2 = ws* invoke(msg2) ;<br>
// return both responses<br>
response.body += response2 .body .sfdc:query-Response; return response; }<br>
/**<br>
*	©language:body type=nxquery"<br>
*	®mas:namespace target="sfdc"<br>
*/ function requestTimestamp($id) { <query><br><querystring><br>
SELECT Id, SystemModstamp FROM Contact WHERE Id * "($id)"  </querystring></query><br>
}<br>
/**<br>
*	©language:body type="xquery"<br>
*	©mas:namespace target="sfdc"<br>
*/ function insertContact_request($node) { <create><br><sobjects xsi:type="Contact"><br><accountid> {string{$ncds/app: Saccouutld}} «;/AL;«jumiLId&gt; <ownerld>{string($node/app:@ownerId}) <firstname>{string($node/app:first)}</firstname><lastname>{string($node/app:last)}</lastname><email>{string($node/app:email)}</email></ownerld></accountid></sobjects></create><br>
}<br>
/**<br>
*	©language:body type^xquery"<br>
*	©mas:namespace target="app" */<br>
function insertContact_response ($response) {<br><contact id=" {stx_ing ($response/sf dc: createResponse/sf dc: result/sf dc: id) } "><modified><br>
{string ($response/sfdc -.queryResponse/sfdc:records/sfdc: SystemModstamp) }<br></modified></contact><br>
}<br>
Request Transform<br>
The request transform can create the same Web service message as defined in the previous section:<br><br>
*	©language:body type="xguery"<br>
*	©mas-.namespace target=nsfdc"<br>
*/ function insertContact_request($node) {<br><create><br><sobjects xsi><br><accountid>{string($node/app:@accountId))  {string($node/app:@ownerId}) <firstname>{string($node/app:first)}</firstname><lastname>{string($node/app:last)}</lastname><email>{string($node/app:email)}</email></accountid></sobjects></create><br>
}<br>
Conduit Function<br>
However, in this case, the conduit's auto generated XScript function can be modified to invoke two Web service calls. First, the message returned from the request transform can be used to insert the node and to retrieve the inserted node's<br>
primary key.<br>
/**<br>
*	@mas:operation type="insert" node="app:contact"<br>
*	©mas:transform type»Mrequest" function="insertContact_requestH<br>
*	©mas .-transform type=?" response" function="insertContact_response"<br>
*/<br>
function insertContact($msg, $source) { var response » ws.invoke($msg); var id = response . sfddcreateResponse . sfdc : result. sfdc: id;<br>
Next, a new message object is created by passing the inserted node's primary key, id, into a helper XQuery function, requestTimestamp (), defined in the conduit.<br>
// retrieve sequence number<br>
var msg2 = createMessage(requestTimestamp(id));<br>
var response2 = ws.invoke(msg2);<br>
Helper functions declare the same language and namespace annotations as transforms, however they are not referenced by the conduit operation's annotation. The function constructs the appropriate message to invoke a conduit operation to return the sequence number for the newly created node:<br>
*	©language:body type="xquery"<br>
*	®mas:namespace target="sfdc"<br>
*/<br>
function requestTimestamp($id) { <query><br><guerystring><br>
SELECT Id, SystemModstamp FROM Contact WHERE Id = »{$id}"  </guerystring></query><br>
}<br>
Finally, the results of both Web service operations can be combined by creating a single XML object composed of both message bodies:<br><br>
// return both responses<br>
response.body += response2.body.sfdc:queryResponse; return response; }<br>
Response Transform<br>
The response transform can processe the XML object created by the conduit function and returns a single  node containing both the primary key and the sequence number of the node.<br>
*	©language:body type="xgueryr<br>
*	®mas:namespace target="app"<br>
*/ function insertContact_response($response) {<br><contact id-><br><modified><br>
{string($response/sfdc:queryResponse/sfdc:records/sfdc:SystemModstamp)}<br></modified></contact><br>
}<br>
Update<br>
Update operations can be called by the conduit manager when a client application modified a node.<br>
When the enterprise is requested to update data, it is possible that it will refuse—either because there is a policy/process that denies it or because someone else changed the data first. The first problem is unavoidable and requires that the update operation, like all others, can handle failures. The framework can implement an optimistic concurrency model for the second case.<br>
When an update request is sent to a Web service operation it can include not only the changed values, but a sequence number that can be used to determine whether the record was up-to-date when it was modified. (The conduit manager cab compute an MD5 hash based on the nodes values if the Web service on the select operation doesn't return its own sequence number.)<br>
On the client, nodes can be modified by script expressions, however, updates are not synchronized to the server until the update () function is called on a particular node; for example:<br>
function modify(contact, address) { contact .email *= address;<br>
contact.update() ; }<br>
In one embodiment, neither client applications nor update operations may modify key values (i.e., any field described by key definitions).<br><br><br><br>
©language:body type="xguery"<br>
*	©mas: namespace target="sfdc"<br>
V function updateContact_request($node) { <update><br><sobjects xsi:type=" Contact,l&gt; ? '    &lt;Id&gt;{string($node/app:@id})&lt;/Id&gt;&lt;br/&gt;
&lt;LastModifiedDate&gt;{string($node/app:modified}) &lt;/LastModif iedDate&gt; &lt;AccountId&gt; {string ($node/app:©accountld}) &lt;/AccountId&gt; &lt;0wnerld&gt;{string ($node/app:@ownerId}) &lt;/OwnerId&gt; &lt;FirstName&gt;(string($node/app:first)}&lt;/FirstName&gt; &lt;LastName&gt;{string($node/app:last))&lt;/LastName&gt; &lt;Email&gt;{string($node/app:email)}&lt;/Email&gt; &lt;/sObjects&gt; &lt;/update&gt; }&lt;br/&gt;
/**&lt;br/&gt;
*	©language:body type=nxquery"></sobjects>
*	©mas:namespace target="app"<br>
*/ function updateContact_response($response)   {<br>
let  $i   :=  $response/sfdc:queryResponse/sfdc:result/sfdc:r-ecords return<br><contact id="{string($i/sfdc:Id)}"><br><modified> {string {$i/sfdc: SystemModstamp) } </modified></contact><br>
}<br>
Request Transform<br>
The request transform can create the Web service message used to invoke<br>
the update operation:<br>
/**<br>
*	©language:body type="xquery"<br>
*	®mas:namespace target="sfdc"<br>
*/ function updateContact_reguest($node) {<br><update><br><sobjects xsi:type="Contact"><br><id>{string($node/app:©idJ)<br><lastmodifieddate>{string ($node/app:modified}) </lastmodifieddate><br><accountid>{string($node/app:©accountId}) </accountid><br><ownerld>{stringf$node/app:@ownerIdJ) <br><firstname>{string($node/app:first)}</firstname><br><lastname> {string ($node/app:last) )</lastname><br><email>{string($node/app:email)}</email></ownerld></id></sobjects></update><br>
}<br>
The request transform can be passed in the node's primary key and an element, LastModif iedDate, that represents the timestamp when the record was retrieved from the service. This enables the Web service operation to implement optimistic concurrency; i.e., if the timestamp value sent to the operation does not match the current system timestamp value, then the operation fails.<br>
Conduit Function<br><br>
As with the insert operation, the conduit's auto generated XScript function can be modified to invoke two Web service calls. First, the message returned from<br>
the request transform is used to update the node.<br>
/**<br>
*	®mas:operation type="update" node="app:contact"<br>
*	©mas:transform type="request" function="updateContact_request"<br>
*	©mas:transform type="response" function="updateContact_response"<br>
*/<br>
function updateContact {$msg, $source) {<br>
ws.invoke($msg);<br>
Next, a new message object can be created by passing the updated node's primary key, id, into a helper XQuery function, re quest Time stamp (), defined in the conduit (this is the same function defined for the insert operation above).<br>
// retrieve sequence number<br>
var msg2 = createMessage(reguestTimestamp(id)) ;<br>
var response2 = ws.invoke(msg2);<br>
Finally, the result of the second Web sendee operation can be returned to be processed by the response transform.<br>
return response2; }<br>
Response Transform<br>
The response transform can process the XML object created by the conduit function and returns a single <contact> node containing both the primary key<br>
and the sequence number of the node.<br>
/**<br>
*	©language:body type="xquery"<br>
*	@mas:namespace target="app"<br>
*/<br>
function updateContact_response($response) {<br>
let $i := $response/sfdc:queryResponse/sfdc:result/sfdc:records return<br><contact id="{string($i/sfdc:Id)} "><br><modified>{string($i/sfdc:SystemModstarap)}</modified></contact> }<br>
Conflict Management<br>
Node conflicts can occur when a client tries to modify and synchronize a "stale" node that has already been updated (either by another client or other exogenous change process) in the external system. A stale node is one that has a different sequence number than the current sequence number held by the server.<br>
If the MAS has cached a more recent version of the node than the one the client is trying to update, then it may respond directly with the updated node (i.e.,<br><br>
without invoking the conduit operation), setting the mas: state  attribute to<br>
"conflict".<br>
If the conduit operation rejects the update because the node is stale, then can return an up-to-date node with the appropriate mas: state attribute; this may involve another round-trip to select the up-to-date node.<br>
Example<br>
The following update operation function checks for an error value returned<br>
by the Web service. The request transform is the same as is defined above. /**<br>
*	©mas:operation type="update" node="app:contact"<br>
*	®mas:transform type="request" functions"updateContact_request"<br>
*	©mas:transform type=Hresponse" function="updateContact_responseu */<br>
function updateContact($msg, $source) { var response = ws.invoke($msg);<br>
// check for error<br>
if (I   response-body.sfdc:updateResponse.sfdc:result.sfdc:success) {<br>
// retrieve server's record<br>
msg = createMessage(selectContact_reguest ($source/@id));<br>
response = ws. invoke (msg) ;<br>
// set state expando<br>
var node = response.body .sfdc: query-Response, sfdc: result. sfdc: records ;<br>
node.@state="conflict";<br>
}<br>
else (<br>
// retrieve sequence number<br>
msg * createMessage (requestTimestamp($source/@id)) ;<br>
response = ws. invoke (msg) ;<br>
}<br>
return response; }<br>
/**<br>
*	©language:body ltype=,lxquery"<br>
*	©mas:namespace targets"appM<br>
*/<br>
function updateContact_response ($responseJ {<br>
let $i := $response/sfdc:queryResponse/sfdc:result/sfdc:records<br>
if ($i.@l= null)<br>
then<br><contact id="{string($i/sfdc:Id)}" accountid="{string($i/sfdc:Account!d)}"></contact>
mas:state="{$response.result.©state)"&gt; <modified>{string($i/sfdc:SystemModstamp)}</modified><fist>(string($i/sfdc:FistName)} <last>{string($i/sfdc:LastName)}</last><email>{string($i/sfdc:Email)}</email></fist></contact> else<br><contact id="{string($i/sfdc:Id)}"><br><modified>{string($i/sfdc:SystemModstamp))</modified></contact> }<br>
Conduit Function<br><br>
The conduit function can first check for an error value returned by the Web service.<br>
function updateContact{$msg, $source) { var response = ws.invoke($msg) ;<br>
// check for error<br>
if (! response, body. sfdc:updateResponse.sfdc : result .sfdc : success) {<br>
If an error is returned, then the function can send a request query to the Web sendee for the entire node; here, the operation reuses the context free select operation's request transform:<br>
// retrieve  server's record<br>
msg = createMessage (selectContact_request ($source/@id)) ;<br>
response  = ws.invoke (msg) ;<br>
The operation then created an expando state attribute so that the response transform can detect that the conflict record has been retrieved from the server.<br>
// set state expando<br>
var node ^ response.body. sfdc :query-Response . sfdc-.result. sfdc :records;<br>
node.@state="conflict" ;<br>
If the original Web service method succeed then the function just requests just the updated sequence number (as above).<br>
// retrieve sequence number<br>
msg = createMessage(requestTimestamp($source/@id));<br>
response = ws . invoke (msg) ;<br>
Regardless of whether the update succeeded either response is processed by the response transform.<br>
return response; }<br>
Response Transform<br>
The response transform can first check to see if the state expando attribute was created by the conduit operation. If it was, then the transform can construct a complete node element; otherwise it can return just the primary key and sequence number as above.<br>
function updateContact_response ($response) {<br>
let $i := $response/sfdc:queryResponse/sfdc:result/sfdc:records<br>
if ($i.©state ! = null)<br>
then<br><contact id="{string($i/sfdc:Id))" accountid=" {string ($i/sfdc:AccountId) }" mas:state="{$i.©state}"><br><modi>{string($i/sfdc:SystemModstamp) )<:><fist>{string{$i/sfdc:FistName)} <last>jstring($i/sfdc:LastName)}</last><email>{string ($i/sfdc:Email)}</email></fist></:></modi></contact> else<br><contact id="{string($i/sfdc:Id)}»&gt;&lt;br/&gt;
&lt;modified&gt;{string($i/sfdc:SystemModstamp)}&lt;/modified&gt; &lt;/contact* )&lt;br/&gt;
 &lt;br/&gt;
Linking and Unlinking (Modifying Foreign Keys)&lt;br/&gt;
Nodes can be modified by XScript expressions. This also applies to foreign key values. The examples in this section use the account and contact nodetypes, which declare the following key definitions.&lt;br/&gt;
&lt;xsd:key natne=" accountkeyn><br><selector xpath="account"></selector><br><field xpath="@id'7&gt; &lt;/xsd:key&gt;&lt;br/&gt;
&lt;xsd:key name=" contactprimarykey><br><selector xpath="contact"></selector><br><field xpath="@id"></field><br><key name="contactEmailKey"><br><selector xpath="contact"></selector><br><field xpath-></field></key><br>
The following function would generate a runtime error, since an attempt is made to modify a node's key value.<br>
function foobar(contact) {<br>
contact.first = $context.first;<br>
contact.last = $context.last;<br>
contact. email = $context.email;      // runtime error }<br>
However, the following function successfully changes the account attribute, which changes the foreign key value, which references the account node.<br>
function foo(contact, account) { contact.rirst = ^context.first; contact.last = $context.last;<br>
contact.©©accountld = account;      // changes account foreign key<br>
contact.update(); }<br>
Here, the foreign key is defined by the following keyref declaration:<br><keyref name="contactAccountRef" refer="accountKey" mas:alias="account"><br><selector xpath="contact"></selector><br><field xpath="©accountld"></field></keyref><br>
Similarly, the function below uses the += operator (a.k.a. link () function) to add a contact node to the set of contacts for the account:<br>
function bar(account, contact) {<br>
account.©©contacts += contact;<br>
}<br>
This one-to-many relation is defined by the following keyref declaration, which includes an inverse relation:<br>
cxsd: keyref name=,,contactAccountRef"   refer="accountKey" mas:alias=,1accouIlt1, mas rinverseAliass11 contacts"&gt; <selector xpath="contact"></selector><br><field xpath="@accountldH/&gt; &lt;/xsd:keyref&gt;&lt;br/&gt;
 &lt;br/&gt;
In reality (i.e., the external database) this operation can be implemented by setting the account foreign key of the contact entity (row) to the primary key of the account. Setting a foreign key value in a source node (e.g., contact.@@accountid) should naturally enable a reverse traversal from the target node back to the source node (e.g., account.©©contacts. *), and vice versa.&lt;br/&gt;
Given the above definition, the following functions are equivalent.&lt;br/&gt;
function fool(contact, account) { contact.first = $context.first; contact. last = $context. last ,*&lt;br/&gt;
contact.©©accountld = accounts-update (contact) ;&lt;br/&gt;
}&lt;br/&gt;
function foo2(contact, account) { contact .first « $context . fix-st ; contact, last = $context. last ,*&lt;br/&gt;
account .©©contacts +- contact;&lt;br/&gt;
update(contact); }&lt;br/&gt;
In one embodiment, the schema's foreign key element (or attribute) declaration matches the external system's constraints (or those implied by the Web service operations' semantics). In particular, NOT NULL foreign key values (e.g., declared on a database table field), should be mirrored by xsd:use" required in the case of an attribute and minoccurs=',ri"' maxoccurs="i" element.></field>
For example, given the definitiqns above, the following function would generate a runtime error.<br>
function foo(contact) {<br>
contact.first « ^context.first; contact.last = $context.last;<br>
contact .©©accountld = null;<br>
update(contact) ; }<br>
Custom Queries<br>
Data can be retrieved by implementing select conduit operations that relate to a defined keyref relationship between two nodetypes; i.e., a foreign key value contained within one node identifies the primary key of a related node. The output<br><br>
of these select operations can be nodes that are folded into the local cache by the framework.<br>
Custom queries can be conduit queries (or other procedural logic) that are opaque to the client programming model; i.e., do not explicitly select (or modify) data based exclusively on primary and foreign key relationships. For example, a search operation may return a set of XML objects that match a natural language expression.<br>
The different kinds of operations are characterized by the matrix 800 of FIG. 8. Operations have inputs and output that is classified as either temporary data or permanent data. In one embodiment, temporary data is not part of the application's node graph; i.e., it is not defined by schema, key or keyref declarations, and is not automatically folded by the framework into the local cache. Temporary data is not assumed to be persistent, although it may be referenced by system $context or $session variables* which have life cycles determined by the client application framework. Permanent data can consist entirely of application data nodes defined by schema.<br>
hi one embodiment, there are two mechanisms for implementing custom queries:<br>
1.	Custom Operations can allow the client to pass an opaque, temporary<br>
XML object (document) to a specific conduit operation. The operation can<br>
asynchronously return a temporary XML document to a client callback.<br>
For example, the following custom operation, myQuery, takes an XML object <myrequest> as input, and return an XML object the<br>
myCallbackO function:<br>
$root.myQuery(<myrequest>product mobile application</myrequest>,<br>
tnyCallback) ;<br>
function myCallbacJc{myOutput)   { }<br>
2.	Custom Objects can involve the creation of a non-persistent node (defined<br>
by schema), which becomes part of the graph. The operation can be<br>
invoked when the client "traverses through" a corresponding keyref, in<br>
which case, the custom object is passed as the Ssource node into the<br>
corresponding select conduit operation.<br>
For example, the following custom object <taskquery> is sent to the select<br><br>
conduit operation defined for the keyref that relates task nodes to taskQuery nodes:<br>
var query = $root.©otaskQueries- create(<taskquery priority="l"></taskquery>); var tasks = query.©©tasks.*;<br>
Custom Operations<br>
Custom operations can be a mechanism for calling custom conduit operations (functions). Both the function inputs and outputs can be XML document literals (not defined by schema). In one embodiment, the framework does not fold results directly into the local cache.<br>
For example, suppose we wanted to retrieve a set of email addresses for contacts (for a particular account) who have not opted out of receiving email.<br>
The following code client code calls a custom operation, getList, that is passed an XML object, <query>.<br>
function bar() {<br>
account .getList (<guery optedout="false,,/&gt;/ callback) ;&lt;br/&gt;
}&lt;br/&gt;
function callback(result) {&lt;br/&gt;
for (i = 0; i &lt; result.length; i++) { addAddress(result [i] .email);&lt;br/&gt;
} }&lt;br/&gt;
The callback processes results once they are returned from the MAS.&lt;br/&gt;
The XQuery function below implements the custom request:&lt;br/&gt;
/**&lt;br/&gt;
*	@mas:namespace target=" sfdc></guery>
*	©mas:field xpath="@id"<br>
*	©language:body type^xquery"<br>
*/<br>
function foo_reguest ($source, $query) { <query><br><guerystring><br>
SELECT Id, Email FROM Contact WHERE Accountld = "{string($source/@id)}" AND HasOptedOutOfEmail = {boolean{$query/@optedOut)}  </guerystring></query> }<br>
The response from the Web service can be processed by the following function. Note, the results are returned to the client callback as a single XML<br>
document—i.e., this is not interpreted as nodes that are folded into the local cache.<br>
/**<br>
*	©mas:namespace target«napp"<br>
*	©language:body type="xquery" */<br>
function foo__response ($response) {<br>
for $i in $response/sfdc:queryResponse/sfdc:result/sfdc:records return<br>
^contact id="{string($i/sfdc:Id)}"&gt;<br><br><email>{string($i/sfdc:EmailJ}</email></query></taskquery></myrequest></field></contact>
The custom operation definition can declare the client function name and<br>
the context for the operation.<br>
/**<br>
*	custom operatoin on contact: account.getList(<query optedout="false"></query>);<br>
*	@mas:operation type="custom" node="app:account" name="getList"<br>
*	@raas:transform type= "request" function="foo_recruest"<br>
*	©mas:transform type="response" function="foo_reBponseH<br>
*/<br>
function foo{$msg,   $source,   $query)   { $msg.header += createHeader{); return ws.invoke($msg);<br>
}<br>
Custom Objects<br>
Custom objects can involve the creation of a non-persistent node (defined by schema), which becomes part of the graph. The operation can be invoked when the client "traverses through" a corresponding keyref, in which case, the custom object can be passed as the $ source node into the corresponding select conduit operation.<br>
In effect, the custom object can contain the input data for a conduit operation that will return nodes bound to the custom object. This cam enable the results to become part of the client cache—and for these nodes to be referenced by subsequent client templates and actions, and for the operation to be rerun to keep these results up to date.<br>
For example, the following schema declaration can define a custom object, taskQuery, which is used to select a subset of task nodes based on the value of the priority attribute.<br><xsd.-complextype name="taskQuery"><br><attribute name="priority" type="xsd:string"></attribute><br>
The following key definition ensures that each taskQuery object is unique:<br><keyref name="taskQueryKey"><br><selector xpath="taskQuery"></selector><br><field xpath="©priority"></field></keyref><br>
The following keyref definition is used to bind taskQuery nodes to the root node; it declares a dummy foreign key attribute mas: root that references the root node; the inverseAlias attribute declares a traversal from the root node to<br>
the set of taskQuery nodes; i.e., $root. @@taskQueries . *.<br><br><keyref name="taskQueryRootRef" refer="mas:rootKey" mas:inversealias="taskQueries"><br><selector xpath="taskQuery"></selector><br><field xpath="®mas:rootId"></field></keyref><br>
The following keyref defines the relationship between taskQuery nodes and the task nodes that are returns by the conduit query operation. Each task node declares a dummy taskQuery foreign key attribute that identifies the corresponding query that selected it; the inverseAiias attributed declares a traversal   from   the   taskQuery   node   to   the   set   of   task   nodes;   i.e.,<br>
query.©©tasks.*.<br><keyref name="taskTaskQueryRef" refer="TaskQueryKey" mas:inversealias="tasks"><br><xsd: selector xpath="task,l/&gt;&lt;br/&gt;
&lt;xsd:field xpath="></xsd:></keyref><br>
These keyref definitions define the following relationships between the root node and taskQuery and task nodes as shown in figure 12D.<br>
The taskQuery nodes may be created by client script using the standard<br>
create () function.<br>
function init() {<br>
var f = $root.©©taskQueries.create{<taskquery priority="l"></taskquery>); }<br>
In one embodiment, there is no conduit insert operation defined for the taskQueryRootRef keyref, so this client script does not trigger any server<br>
activity.<br>
The following template traverses the inverse taskTaskQueryRef<br>
keyref definition.<br><repeater i></repeater>
source="$root.©©taskQueries.where(priority=='l').©©tasks.*"&gt;<br><p>{$s}</p> <br>
This causes an implicit select on the associated conduit operation; the repeater's source attribute references the taskNode created above, and this is used as the source context for the traversal; i.e., the node, <taskquery priority="5l">, is passed into the operation as the Ssource variable.<br>
The corresponding conduit select operation is defined by the following functions:<br><br>
/**<br>
*	®mas:operation type="select" keyref="app:taskTaskQueryRef" inverse='*true"<br>
*	©mas-.transform type="request" function^selectTasks_reguest"<br>
*	©mas:transform type="response" function="selectTasks_response"<br>
*/ function selectTasks ($0139, $source) {<br>
return ws. invoke ($msg) ; )<br>
/**<br>
*	©mas:namespace target="sfdc"<br>
*	®mas:field xpath=n©priority"<br>
*	©language:body type="xquery"<br>
*/<br>
function selectTasks_request($source) { <query><br><querystring><br>
SELECT Id, Priority, Subject FROM Task WHERE Priority = "(string($source/@priority})"  </querystring></query><br>
}<br>
/**<br>
*	©mas:namespace target="app"<br>
*	©language:body type=,,xguery"<br>
*/ function selectTasks_response($response) {<br>
for $i in $response/sfdc:queryResponse/sfdc:result/sfdc:records return<br><task id="{string($i/sfdc:Id)}"></task>
priority="{string($i/sfdc:Priority)}"&gt; <subj ect>{string($ i/sfdc:Subj ect)}</subj><br>
}<br>
Applications can also define conduit select operations to "seed" the custom objects that represent "pre-canned" queries. For example, the following operation implements a select operation that returns a (constant) set oftaskQuery objects when the client traverses $root .@@taskQueries. *.<br>
*	©mas:operation type="select"  keyref="app:taskQueryRootRef"   inverse="true11<br>
*/ function selectTasks ($tnsg,   $source)   {<br>
return   <taskquery priority="l"></taskquery>;<br>
)<br>
This queries could, for example, be referenced by the following template:<br><td>
<br><repeater id="si" source><a href="si.select(si.iterator)__Priority%20(sl%7d_/a__br/_%250A_/netui_repeater_%20_/td_%20_td__br/_%250A_netui_repeater%20id%3d.html" s2 sources> <p>{s2}</p>
<br></a></repeater>
</td>
<br>
The first repeater, si, displays the set of taskQuery objects; the second repeater, s2, displays the resulting tasks retrieved from the taskQuery selected by the first repeater.<br><br><br>
•     Priority 2	•    Sales Meeting<br>
	1 •    Annual report<br>
Of course, it is also possible to define conduit operations that insert, update, and delete custom objects by implementing a Web service that persists these query objects—in effect, treating them as ordinary nodes within the data model.<br>
When a custom object node is modified—either directly by the client application, or indirectly by a sync select operation—all corresponding related nodes can be automatically unlinked from the custom object; i.e., nodes that reference the object via foreign key values, have this foreign key set to null. This ensures that nodes traversed to via a custom object accurately reflect the state of the custom object.<br>
Advanced Select Operations<br>
The select operation can enable the framework to retrieve nodes for a particular keyref. Conduits can define a select operation since this is the basic mechanism used to retrieve nodes by the client application.<br>
Normal select operations can trigger automatically by client applications as they navigate the data model. For example, the following client SPath expression causes the accounts keyref s select operation to be invoked.<br>
$account. @@contacts. *<br>
The conduit select operation can be passed the primary key of the corresponding   account  obj ect.   This   section  details  other  forms  of select operations. Caching and Optimizations<br>
Both the client and MAS can cache the data that are returned by the conduit manager. Therefore, not every data graph traversal need not generate a select request. Both client and server caches can maintain meta data for each node and nodeset that determines how long the corresponding set of data can be relied upon to be up-to-date, before a new select request is generated.<br>
Often, the amount of data that needs to be transferred following a select operation is quite large. Therefore, given the availability of suitable Web service operations, certain optimizations can be implemented by the framework.<br><br>
The seiect_pkey operation is invoked in exactly the same manner as the select operation, however, it returns only sets of primary key values. For example, the select_pkey operation for the corresponding select operation on the<br>
contacts keyref above would implement the following response transform.<br>
/**<br>
*	©language.-body type="xquery"<br>
*	®mas:namespace target="appH<br>
*/<br>
function selectContactsByAccount_response($response) {<br>
for $i := $response/sfdc:queryResponse/sfdc:result/sfdc;records return<br><contact id="{string($i/sfdc:Id)}»&gt;&lt;br/&gt;
&lt;modified&gt;{string($i/sfdc:SystemModstamp)}&lt;/modified&gt; &lt;/contact&gt; }&lt;br/&gt;
The MAS is then able to determine, which (if any) of the node elements are currently in the cache.&lt;br/&gt;
For any node that is not contained within the cache, the framework can&lt;br/&gt;
then call the select_set   operation,   which like the normal select operation&lt;br/&gt;
returns complete nodes for the requested set of pkey values. The select_set&lt;br/&gt;
operation  for  the  example  above would implement the  following request&lt;br/&gt;
transform: /**&lt;br/&gt;
*	©language:body type=»xguery"></contact>
*	@masmamespace target="sfdc"<br>
*/<br>
function selectContacts_request($keyset) { <query><br><guerystring><br>
SELECT * FROM Contact WHERE Id IN (<br>
(<br>
for $x in $keyset<br>
return<br>
}<br>
)  </guerystring></query> }<br>
The response transform can be the same as for the normal select operation.<br>
Selecting Complex Schemas<br>
Select operations may return nodes that are defined as complex documents that contain repeated elements. There is no restriction placed on the complexity of a nodetype's schema definition. However, there may be practical limits to the size of a node record. The next section details the case when a complex document may be split into multiple nodes.<br><br>
Example<br>
The schema below illustrates a purchaseorder nodetype that contains multiple lineitem elements.<br><element name="purchaseorder" type="purchaseOrderType"><complextype name="purchaseOrderType"><seguence><br><element name="price" type="xsd;double"></element><br><complextype name="linelterns»&gt;&lt;br/&gt;
&lt;xsd:sequence maxOccurs=" unbounded><complextype ref="lineitem"><sequence><br><element name='nprodId"' type="xsd:string"></element><br></sequence></complextype></complextype></seguence></complextype><br>
For example, the following XML document illustrates the purchase order<br>
schema.<br><purchaseorder><br><price>1000.00</price><br><lineltems><br><lineltem></lineltem><prodid>widget-X</prodid><br><prodid>Widget - Y<br><br>
* • *<br></prodid></lineltems></purchaseorder><br>
The following conduit function contains a nested loop that generate a set<br>
of purchase orders, each with a nested set of line items.<br>
/**<br>
*	©mas:operation type="select" keyref="purchaseOrderAccountRef" inverse="true"<br>
*	@mas:transform type="request" function="selectPurchaseOrders_request"<br>
*	@mas:transform type="response" function="selectPurchaseOrders_response"<br>
*/<br>
function selectPurchaseOrders($msg, $source) { var response = ws.invoke($msg); var pos = response.sfdc:query-Response, sfdc:result .sfdc:records;<br>
// retrieve line items for each purchase order for fi = 0; i 
var msg2 = createMessage{requestLineltems(pos[i].sfdc:Id));<br>
var response2 = ws. invoke (msg2) ;<br>
pos [i] += response2 . body. sfdc: queryResponse . sfdc : result. sfdc: records;<br>
}<br>
return response;<br>
}<br>
/**<br>
*	©language:body type="xquery"<br><br>
*	©mas.-namespace target="sfdc"<br>
*	iSmas: field xpath="@id"<br>
*/<br>
function selectPurchaseOrders_reguest($source) { <query><br><querystring><br>
SELECT * FROM PurchaseOrder<br>
WHERE PurchaseOrder.Accountld = {string($source/@id)} </querystring><br>
}<br>
*	©language:body type="xguery"<br>
*	@mas:namespace target="s£dc"<br>
*/<br>
function selectLineltems($id) {<br><query><br><querystring><br>
SELECT * FROM Lineltem WHERE Lineltem.PurchaseOrderld = $id  </querystring></query><br>
}<br>
*	©language:body type=="xguery"<br>
*	©mas:namespace target«"appn<br>
*/<br>
function selectPurchaseOrders_response($response) {<br>
for $po := $response/sfdc:queryResponse/sfdc:result/sfdc:records return<br><purchaseorder id="{string($po/ws:Id) } "><price>{string($po/ws:Price))</price><br><linelterns><br>
{<br>
for $li in $po/ws:records f^tv.m<br><lineltem><br><prodid>{string($li/ws:ProdId)}</prodid><br><br>
}<br><br>
}<br>
Selecting Node Trees<br>
Select operations may return nodes that are defined as complex documents that contain repeated elements. There is no restriction placed on the complexity of a nodetype's schema definition.<br>
In some cases, it is desirable to split parts of a complex document into independent nodes, bound by keyref relationships. These nodes form a tree, which is synchronized back to the client and incorporated into the cached data graph.<br>
The advantage of splitting compound documents into multiple nodes is improved performance by retrieving multiple levels of keyrefs in a single<br><br>
operation (e.g., select all contacts for a particular account, and all associated tasks).<br>
Example<br>
In the following schema definitions, both the purchaseOrderType and lineitemType have been declared as nodetypes with the following schema definitions.<br><xsd: complextype name="purchaseOrcLerType"><complextype><xsd: sequence><br><element name="price" type="xsd;double"></element><br><sequence></sequence></xsd:><complextype><br><element name="lineitemType"><complextype><sequence><br><element name="prodId" type="xsd:string"></element><br></sequence></complextype></element><br>
The schema also declares the following key and keyref definitions:<br><key name-><br><selector xpath="purchaseOrder"></selector><br><field xpath="@id"></field></key><br><key name="lineItemKey"><br><selector xpath="lineItem"></selector><br><field xpath="@id"></field><br><xsd: keyref name=",IlineItemPurchaseOrderRef'" refer=" purchaseOrderKey"></xsd:>
mas: inverseAlias="lineItems"&gt;<br><selector xpath="lineltem"></selector><br><f ield xpath="©purchaseOrderld"></f><br>
The Figure 12D represents the corresponding keyrefs.<br>
Whenever compound documents are broken into individual nodes, the framework can ensure that client operations on the constituent nodes (e.g., line items) are supported by the conduit. For example, the client application can be prevented from creating new line item objects unless there is a corresponding insert operation for the lineitems keyref.<br>
The conduit definition below is a modified version of the example above. Here, the inner loop creates node elements within a nodeset element. Note, the inner objects must also each define a primary key.<br><br>
*	®mas:operation type="select" keyref=MpurchaseOrderAccountRef"<br>
inverse="true"<br>
*	@mas:transform type="request" function="selectPurchaseOrders_request"<br>
*	©mas:transform type="response" function="selectPurchaseOrders_respon.se"<br>
*/<br>
function selectPurchaseOrders ($11139, $source) { var response = ws. invoke ($msg); var pos = response.sfdc:queryResponse.sfdc:result .sfdc:records;<br>
// retrieve line items for each purchase order for (i = 0; i 
var msg2 = createMessage(requestLineItems(pos[i] .sfdc:Id) };<br>
var response2 = ws.invoke(msg2);<br>
pos [i] += response2 .body.sfdc:gueryRespon.se. sfdc:result .sfdc:records;<br>
}<br>
return response; }<br>
/**<br>
*	©language:body types"xquery"<br>
*	@mas:namespace target="sfdc"<br>
*	@mas:field xpath="@id"<br>
*/<br>
function selectPurchaseOrders_reguest($source) { <query><br><querystring><br>
SELECT * FROM PurchaseOrder<br>
WHERE PurchaseOrder.AccountId = {string($source/@id) } </querystring></query><br>
}<br>
/**<br>
*	©language:body type="xquery"<br>
*	®mas:namespace target="app"<br>
*/ fonc'ciuii aeiei_:LPurchaseurders_response ($response)   {<br>
for $po   := $response/sfdc:gueryResponse/sfdc:result/sfdc: records return<br><purchaseorder id="{string($po/ws:Id)}"><price>{string($po/ws:Price)}</price><br><masmodeset keyref='rlineItemPurchaseOrderRef"'><br>
{<br>
for $li in $po/ws:records return<br><lineltem id="{string($li/ws:Id)}»&gt;&lt;br/&gt;
&lt;prodId&gt;{string($1i/ws:Prodld))&lt;/prodId&gt;&lt;br/&gt;
&lt;/lineItem&gt;&lt;br/&gt;
}&lt;br/&gt;
&lt;/mas:nodeset&gt; &lt;/purchaseOrder&gt;&lt;br/&gt;
}&lt;br/&gt;
Deep Select&lt;br/&gt;
As discussed above, applications can traverse the data graph using SPath expressions; these traversals can cause the framework to synchronize the required data in the background. In one embodiment, since the synchronization mechanism is invoked asynchronously, it is frequently likely that an SPath expression cannot be fully evaluated against the currently cached data graph.&lt;br/&gt;
 &lt;br/&gt;
For example, the following SPath expression will return an empty list if the keyrefs accounts and contacts have not been previously synchronized and cached by the client.&lt;br/&gt;
$root.©©accounts.*.©©contacts.*.©©tasks.*;&lt;br/&gt;
hi one embodiment, subsequent keyref traversals cannot be initiated unless the preceding nodes are currently resident in the cache. In one embodiment, the client code would first have first to traverse $root. ©©accounts. *, then Avait for a synchronization notification, then select $root.©©accounts.*.©©contacts.*, wait for another synchronization notification, then finally the expression would invoke the synchronization of all tasks for all contacts for all accounts.&lt;br/&gt;
The select () function can enable the client to request the server to evaluate the SPath expression on its behalf, and then to synchronize the resulting graph of nodes to the client. For example:&lt;br/&gt;
$root.select(©©accounts.*.©©contacts.*.©©tasks.*);&lt;br/&gt;
Here, the entire SPath expression is passed to the server, which calls successive keyref traversals and manages the synchronization of the nodes. Note, the server may return the entire graph in one synchronization message or over multiple messages.&lt;br/&gt;
SPath expressions may also contain predicates using the where () function For example:&lt;br/&gt;
$root.select(©©accounts.*.©©contacts.*.©©tasks.*.where(.priority == 1));&lt;br/&gt;
The predicate expression can be resolved on the server before the resulting nodes are synchronized to the client.&lt;br/&gt;
The following expression can be retrieve all contacts and notes for all accounts that have the type=!lDirect" element.></lineltem>
$root. select (©©accounts.where (.type="Direct") .keyref ("contacts" , "notes") . * ,-<br>
Session Management Session state can be managed by the conduit's custom procedural code.<br>
The conduit can define a variable to store a session identifier. This may be<br>
created by the conduit, or returned by the Web service—as in this case:<br>
// session object returned from Web service var sessionld = null;<br><br>
The conduit can define a function that creates and sends a message to initiate the session; the function can then processes the response to extract any session related information returned by the service.<br>
The function below sends the <iogin> message to the Web service and extracts the session identifier from the response body. It also sets the URL of the Web service control returned by the service.<br>
// create and send login message and process results function login() { var body = <login><br><usemarae> {$user. username}  <password> {$user. password) </password></usemarae></login>; var response « ws,invoke(body);<br>
// set session id<br>
sessionld = string (response.body, sfdc: result .sfdc:sessionId) ;<br>
// set "URL for subsequent calls (from this conduit) ws.endPoint = string (response, body. sfdc:result. sfdc-.serverUrl) ;<br>
)<br>
The $user XML variable contains information about the current user; it is a system variable accessible to all functions.<br>
Each conversational method can specify a header containing the session identifier, the following (ordinary) conduit function first checks if a conversation has been started (caiiing login if it hasn7t) then returns the appropriate header XML fragment.<br>
// create conversational header function createHeader () {<br>
if (sessionld =s= null) { login () ;<br>
)<br>
return<br><sessionheader><br><sessiondid>{sessionld}</sessiondid></sessionheader>; )<br>
For example, the following XScript function implements custom session<br>
management required by the Web service:<br>
/**<br>
*	®mas:operation types"select" keyref= "app: contact AcoountRef" inverse="truew<br>
*	©mas: transform type="reguest" function=:"selectContacts_rec[uest"<br>
*	©raas:transform type«"response" function«"selectContacts_response"<br>
*/ function selectContacts ($tnsg, $source) { $msg.header += createHeader(); return ws.invoke($msg);<br>
}<br>
The function is passed in a message object, $msg, that contains a body created by the request transformation.<br><br>
Next, the function calls createHeaderO function to obtain an XML object that contains the necessary header information. This function triggers the login () function (above) if a session has not currently been started The header object is then added to the message.<br>
The invoke () function then sends the message (including the header) to the Web service; this uses the transport provided by the specified control.<br>
User Information<br>
The $user variable contains data about the user on whose behalf the<br><br>
Client Programming Model<br>
A user can access an application by referencing its URL on the MAS. The first time a user does that from a client machine, all the components of an application can be automatically "downloaded" from the server. If the application developer has only specified a data model for the application, the meta data for the data model can be downloaded. The meta data can contain enough information for the mobile browser to provide a minimal user interface for the application. Using the meta data, the mobile browser can initially display the root node and its keyrefs. The user can navigate through the application data by clicking on these keyrefs. As the user selects a keyref, the data sync engine asynchronously fetches the nodes for that keyref and automatically displays the data when available. For example, the user could traverse the Accounts link to cause the Account nodes to be fetched; and then traverse an Account's Contacts keyref to view its Contacts for the Account. This model is functional, but not particularly pleasant—the UI is stark and the experience "jerky" since no data is pre-fetched. This section describes how the application programmer can customize the user interface.<br>
There are two basic artifacts that the programmer uses to customize a client application. The first is "templates" which can be used to present a custom user interface for a set of data. The programmer can attach customized ways to<br><br>
render nodes and nodesets using "templates" which can be XHTML templates with embedded SPath expressions to access data from the data model and embedded elements to repeat over nodesets. The occasionally-connected data model itself is presented as a big virtual XML document rooted in a magic variable, $root. In One embodiment, there is a "current" position within the data model (for example an Account or a Contacts for an Account) and this is available to the template through another magic variable, Scurrent. URL's can express both branching to another template or new "current" data within the template (e.g. going to an Account to its Contacts). While templates can be expressed in XHTML, they can contain an important extension to t he XHTML model itself, "selection" which is explained below. It enables to enable a richer more interactive UI than HTML normally provides but which is possible when the client is also the controller.<br>
The second artifact lets programmers attach offline behavior to buttons and URL's in the page. Every URL can reference "actions" written in ECMAScript for XML (a.k.a. JavaScript) in a page flow file (controller.xpf) which is also placed in the client directory. This file contains a set of script "actions". Actions have full access to the data model so that they can compute values, modify data on the client thus triggering deferred synchronization, explicitly trigger synchronization and deep selects, invoke custom operations, or cause navigation to set currency to another part of the data model. Each "action" in the controller can return both the new currency within the data model (or CONTINUE if the action doesn't actually change "currency" within the data model) and usually the specific template to use in the context of that currency. For example, an action in a page listing Contacts to see related Contacts might simply be a one liner to set the currency to the related Contacts and use the Contact list templates to display them which would be something like:<br>
function showContactsForAccount($account)   { $context.account  »  $account; return   [$account.©©contacts.*,   "ContactsTemplate.tmpl"];<br>
)<br>
Model View Controller<br><br>
MAS client applications can consist of a page flow file (controller .xpf), which may contain XScript actions and functions, and a set of page templates (.tmpi).<br>
The client can maintain a local cache of the application data. This data is described by the occasionally-connected data model and is referenced and manipulated using SPath.<br>
Templates are XHTML pages which contain embedded SPath expressions. These expressions can reference any data in the cache and systems variables and functions Since templates can only reference local data, they can be rendered independent of the machine's network connection state (i.e., enabling users to run the application offline).<br>
The system variable, $current, can act a cursor into the data; $current references either a single node or a node list. The value of $ current can be changed by actions and anchors that invoke system functions; this is known as navigation. The system variable, $context, can provide a mechanism for actions and templates to exchange temporary variables. For example, a template may bind input fields to either context variables or node elements within the cache.<br>
Templates may also contain repeaters, which iterate over a specified part of the data or data mode. Repeaters enable the template to automatically build up complex lists and tables, and enable the user to select individual records and to invoke actions on them.<br>
The page flow mechanism invokes actions in response to user interface and external events. User interface events can be triggered by <a> anchors within templates; external events can be triggered by external sync updates to the data. When the application first starts, it can call the begin () action within the page flow, which determines the first template to be displayed.<br>
Actions can be XScript functions that are invoked by templates and external events. Actions may modify the data, and $current and $context variables that are accessible to the templates. The system variable $page references the currently visible page document; this enables actions to access page controls properties.<br><br>
Navigation can occur when either the $page or $ current system variables are changed by an action. The client cab maintain a history stack of  variables. This enables the user to navigate backwards and forwards through the history and for the template to maintain their context (and, for example, the bound values of input elements).<br>
XScript<br>
SPath Expressions<br>
The client programming model can use ECMAScript for XML (E4X, XScript), which is essentially JavaScript with native support for XML; SPath is an XPath-like language, which enables applications to query the XML data graph. It uses the "dot" operator to "traverse" elements within the graph. Elements may be either regular XML elements or data nodes.<br>
XML Operations<br>
System variables can be prefixed with the '$' symbol and are untyped. The use of other variables is defined by the XScript spec.<br>
The following declarations create variables f oo and bar.<br>
foo   =   100;<br>
var  bai-  =   "Alnhfttnv" •<br>
The var keyword places the variable within the local scope of the current function; variables that do not declare var are placed in the global scope.<br>
The following declaration set the value of foo to the newly created XML object.:<br>
var foo =s <foo>Alchemy</foo>;<br>
Compound XML objects can also be created and referenced as follows:<br>
var foo = <foo><bar>Alchemy; var bax = foo.bar<br>
bar == "Alchemy"<br>
XML object may also declare attributes, which are referenced using the *@* operator, for example:<br>
var foo « <foo id="100"><bar>Alchemy</bar></foo>; var id = foo.@id;<br>
Attributes can be added implicitly (i.e., expando):<br>
foo.©ping =   "200";<br><br><br><br>
The data contained within a node element can be referenced and modified using regular SPath expressions. The following example changes the text value of an element within the $contact node.<br>
account.name  =   "Acme Ltd";<br>
New XML elements may also be created within a node by assignment, for example:<br>
account .address = <addressxstreet>335 Madison<zip>ll211</zip><br>
Data Operations<br>
Relations between nodetypes can be defined by keyref definitions in the occasionally-connected data model. For example, the following declaration specifies that the accounts keyref originates from the root node, and contains nodes of type account (which is defined by a schema).<br><keyref name="accounts" sourcetype="mas:root" targettype="app:account"><br>
In the client programming model, keyrefs can be traversed using the @@ operator. For example:<br>
$root.©©accounts<br>
The keyref() function can also be used to reference named keyrefs.<br>
The following example is equivalent to the example above: $ root. keyref (" account- R " )<br>
The keyref can be thought of as referencing the keyref for the specified parent nodes. The following examples references all account nodes of the accounts keyref of the $root node.<br>
$root.©©accounts.*<br>
$root.keyref("accounts").*<br>
This expression returns a nodeset where each node will be of the type account, for example:<br><account><br><name>Acme</name></account><account><br><name>Bancroft</name></account><br>
The [] operator can be used to access a particular node within a nodeset. The following expression returns the first node in the accounts nodeset:<br>
$root.©©accounts.*[0]<br>
The length () function can be used to return the number of nodes in a nodeset.<br>
$root.©©accounts.*.length()<br><br>
Note, this is quite different from the following expression, which returns the value 1 (one).<br>
$root.©©accounts.length()<br>
Le., $root.@@accounts returns a single element, <accounts>.<br>
The data graph can be filtered using the where () function, which takes an SPafh expression as an argument. For example, the following statement matches all contact nodes in the accounts keyref with specified last name and returns a node list<br>
$ root.©©accounts.*.where(.name == "Acme");<br>
Note, this is equivalent to the following expression.<br>
$root.©©accounts.*.(thisXML.name == "Acme");<br>
Where clauses can evaluate to node lists, and may be followed by a subsequent SPath expressions. For example, the following expression returns a node list of contacts for all accounts named "Acme".<br>
$root.©©accounts.*.where(.name == "Acme").©©contacts.*;<br>
Labels<br>
Each nodetype declaration may define a label, which is an SPath expression that references the node. The label {) function returns the computed string.<br><p>{$context.account.label()}</p>
<br>
Keyrefs may also define labels that are returned by the label () function.<br><p>{$root.©©accounts.label()}</p>
<br>
The label for a node is obtained by the label() function. For example: When a node or keyref is referenced by itself, coercion automatically<br>
invokes the label ()  function. The following examples are equivalent to the<br>
examples above.<br><p>{$context.account}</p> <p> {$ root. @@account s} <br>
Namespaces<br>
In client programming model, all operations can be implemented in the application's own default namespace.<br>
The default namespace is set using the setDefauitName space function.<br>
function begin{) {<br>
$pageFlow. setDef aultNamespace ("http://example.com/") ;<br><br><br><br>
The $ context variable represents additional data that the calling action may wish to pass to the template. This is analogous to a forward bean in JPF, or HTTP GET attributes. Context variables can be preserved as part of the history.<br>
Ssession<br>
The $session variable represents that application's "session" state; unlike the $context object, it does not get stored as part of the history. It is typically used to store information that is relevant to the entire application (i.e., not a specific page). These variables survive for the lifetime of the application and are persisted and dehydrated whenever the application (and browser) shuts down and starts up.<br>
For example, the following function might be used to set a user defined count status variable.<br>
function onExternalSync () {<br>
$session.count = $root.©©messages.*.length();<br>
}<br>
Each page could then include the following XHTML segment, which would be updated automatically whenever the bound status variable changes.<br></p>
<p>You have   {$session.count}  messages.</p>
<br><p>Click<br><a href="%24pageFlow.navigate%20(%24root%20.%c2%a9%c2%a9messages%20.%20_%2c_br/_%250A%27showMessages.html">here</a><br>
to see them</p>
<br>
$current<br>
The $ current variable represents a node (or node list) and is typically used by a template with relative SPath expression to bind UI elements to data.<br>
$user<br><br><br><br><br><br><br><br><br><element name="graph"><complextype><seguence><br><element ref="root" minoccurs="l" maxoccurs='nl"'><br><element refs maxoccurs="Hiinbounded,l"><br><element ref maxoccurs="unbounded"><br><xsd: element ref="note," maxpccurs="unbounded "><br><element ref a maxoccurs="unbounded"></element><element ref="task" maxoccurs="unbounded"><br><xsd ref="quoteRequest" maxoccurs="unbounded "><br></xsd></element></xsd:></element></element></element></seguence><br></complextype><br></element><br><br>
The <graph> element can represent the top level element of the application data model; this can contain exactly one <root> node declaration, plus unlimited instances for each node of each of the application schemas (account, contact, note, event, task, and quoteRequest).<br>
The <root> element can be referenced by the $root system variable. Since the root node is a special system type, there is not user data object contained within a root node.<br>
$root.@@accounts.*;<br>
The occasionally-connected data model can defines the application nodetypes; these can be constructed from the application schema and keyref definitions. For example, the following sample details the account nodetype; this contains the schema elements (name and type), and the keyref definitions (owner,<br>
subAccounts, contacts, notes, events, tasks,   and quotes).<br><element name="account"><complextype><seguence><br><element name type="xsd:string"></element><element name="type" type></element><br><attribute name="ownerId"></attribute><attribute name="parentAccountId"></attribute></seguence></complextype></element><br>
The account node definition defines the elements (and possible attributes) described by the corresponding schema defined on the server. As above, the keyref definition determine the traversals possible from an account node. For example:<br>
var user = account.©©owner;<br>
var contacts = $root.©©accounts.*.©©contacts.*;<br>
Similarly, the following sample defines the contact nodetype.<br><br><element names><xsd complftxtype><seguence><br><element names types></element><element name type="xsd:string"></element><element name='»last"' type="addressType"></element><element name="email" type="xsd:string"></element> — -       <br><attribute name></attribute><xsd: attribute names=',,ownerId"/'></xsd:></seguence></xsd></element></root></root></graph></accounts></keyref></addressxstreet></bar></foo></a></iogin></masmodeset></purchaseorder></key></complextype><: element><br>
The following XML illustrates a client model for how the user accesses this data although, at no time is there ever an actual XML file that looks like this.<br><graph><br><root accounts="al a2"></root><br><account id='rtal"' ownsr="bob" contacts="cl c2u notes=nnl" events="el" tasks='tttl"'><br><name>Acme</name><br><type:>Direct </type:></account><account id="a2" owner="bob" contacts="c3"><br><name>Bancroftc/name&gt;<br><type>Web</type></name></account><br><contact id="cl" owner="bob" events="e2» tasks«" t2><br><salutation>Mr</salutation><br><first>Roger</first><br><last>Reed</last><br><email><a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="52203d3537201233313f377c313d3f">[email&#160;protected]</a></email><br><salutation>Ms</salutation><br><f irst></f><last>Smith</last><br><email><a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="295a485b484169484a444c074a4644">[email&#160;protected]</a></email></contact><contact idsnc2 owner notes="n2"><br><salutation>Ms</salutation><br><firstisarah><br><last>Smith</last><br><email><a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="3142504350597150525c541f525e5c">[email&#160;protected]</a></email><note id="nlti&gt;&lt;br/&gt;
&lt;title:&gt;ROI information/title&gt;&lt;br/&gt;
&lt;body&gt;kttached document details ROI for product&lt;/body&gt; &lt;/note&gt; &lt;note id=" n2><br><title requirements><br></title>Attached document presents customer's current and anticipated needs </note><br><event id assigned="£red"><br><title>Sales meeting</title></event><event id assigned="fred"><br><title>Product demonstration</title></event><br><br><task id="tln assigned=" fred><br><title>Prepare RFP for sales call</title>
<br><status>Not started</status></task><task id="t2" assigned="fred"><br><title>Send white paper to customer</title>
<br><status>Completed</status></task><br><br>
Overview<br>
In one embodiment, there are two ways for the client to modify the data graph. First, input elements in templates can be bound directly to data nodes; this mechanism enables the user to modify XML elements belonging to existing nodes and requires no code. Second, (and typically) the template invokes an action, which modifies the data.<br>
In one embodiment, these changes to the data are not synchronously sent to the server. Instead, a background process synchronizes updates to and from the server. In fact, since the entire page flow mechanism can run independently of network (server) connection, there will typically be multiple offline changes to the data, which will by synchronized and reconciled with the server once a connection is established.<br>
The programming model can also implement a mechanism to defer the synchronization of updated or inserted records. For example, a node could be created that represents a purchase order, but the user may not want to synchronize this until all of the line items have been added and then clicked a "submit" button.<br>
The server may reject synchronization requests due to optimistic concurrency conflicts with other users, or due to external application errors. Each node has synchronization state which is managed by the framework. This can enable the application to display flags that indicate which records are pending synchronization, up-to-date, or rejected by the server.<br>
Schema Validation<br>
When the create() and update() functions are invoked the framework does the following:<br>
A)	validates the object against the application schema, and validates all required foreign keys;<br>
B)	ensures that the cache is consistent for relations that may be traversed in the reverse direction (i.e., inverse relations).<br><br>
If either condition is not met, a runtime error is generated.<br>
Also,   key/keyref  consistency is   enfoi'ced when the  linkO   or unlink()   functions   (also +=/-=  operators)   are  invoked.<br>
Creating Nodes<br>
The following action can create a node using the create () function.<br>
var po = <purchaseorder><date>03/12/05</date>;<br>
po.lineltems += <lineitem><prodid>ABC100</prodid></lineitem> po.lineltems += <lineitem><prodid>XYZ</prodid><qty>200</qty></lineitem><br>
po = ^account. @@purchaseOrders. create (po) ;<br>
The node, po, can be constructed by the XML assignment expression (first line). The second and third expressions modify the XML node. However, the node need not be validated until the create () function is called.<br>
Updating Nodes<br>
Similarly, the application can modify existing nodes by directly accessing the node's data. For example, the following code retrieve a particular purchase order, and then changes the status and adds a new line item:<br>
po = $account.@®purchaseOrders. where(.date == "03/12/05") .*[0];<br>
po. status = "getQuote";<br>
po.lineltems += <lineitem><prodid>DEF</prodid><qty>300</qty></lineitem><br>
$po.upaate();<br>
Again, the update () function is called to validate the node. Creating Nodes<br><br><br>
For example, the following XScript constructs a new contact node within the contacts keyref for the specified $account object.<br>
var contact = <contact><br><salutation>Mr</salutation><br><first>Sydney
<: last>James<br><:email>sydney@james .com </:email></:></first></contact>;<br>
node -  account,@@contacts.create(contact) ;<br>
Nodes are typically created in three stages: first an action creates a context variable, and then causes a template to be displayed.<br>
function init() {<br>
$context.contact = <contact><salutation></salutation><first></first><last></last><email>;<br>
return ["editContact.tmpl«] / }<br>
Next, the template binds input controls to individual context elements.<br><input type="text" netui:bind="$coxitext.email"><br>
Next, the template invokes a second action; the framework automatically transfers HTML input values back into the context variable before calling the action. The action then creates the new node.<br>
function create () {<br>
$context.contact = $account.©©contacts.create($context.contact);<br>
return ["showContact.tmpl"]; )<br>
In the example above, the action replaces the current context variable ($context.contact) with the node constructed by the create() function; this enables the next template (showcontact.tmpi) to reference to created node.<br>
Note,   before   the   create ()    function   is   called   $context. contact    j ust<br>
contains    a   well    formed   XML   element;    afterwards    it   points    to   a validated node   (e.g.,   that  supports  the various node  function.<br>
In one embodiment keyrefs that define an insert conduit operation allow nodes to be created and attempting to create a node on an invalid nodeset will cause a runtime error.<br>
Callbacks<br>
The create () function may also specify a callback function, which is invoked when the sync mechanism receives an acknowledgement from the server that the node has been created (i.e., the associated conduit operation succeeded in returning the new primary key). For example:<br>
function foo(account,   quote)   {<br><br>
node = account.©©requests.create(quote, bar);<br>
}<br>
function bar(request) {<br>
$context.lastRequest = request;<br>
}<br>
The callback function can be passed the created node as a parameter. Updating Nodes<br>
The update () function can be used to synchronize nodes modified on the client.<br>
node.update([callback, id]);<br>
The function is called on a keyref that supports the update conduit operation.<br><br>
nodes, synchronization runs as a background process. However, a modified node is not marked for synchronization unless the update () function is called.<br>
The update!) function can set the syncstate attribute of the associated node to MODIFIED. This mechanism can enable multiple edits to be made to a single node before the node is synchronized.<br>
Example<br>
In the following code, the first two expressions can set the syncstate of the $contact node to DSYNC; and the last expression set the syncstate to<br>
MODIFIED.<br>
contact-first  =   "Bob";<br>
contact .address  =  <addressxzip>10017;<br>
$contact.update();<br>
Callbacks<br>
The update () function may also specify a callback function, which is invoked when the sync mechanism receives an acknowledgement from the server<br><br>
that the node has been updated (i.e., the associated conduit operation succeeded). For example:<br>
function  foo(account,   quote)    { quote.update(bar);       '<br>
)<br>
function bar(request) {<br>
$context.lastRequest = request; }<br>
The callback function can be passed the created node as a parameter.<br>
Conflict Management<br>
In one embodiment, node conflicts occur when a client tries to modify and synchronize a "stale" node that has already been updated (either by another client or other exogenous change process) hi the external system. A stale node is one that has a different sequence number than the current sequence number held by the server.<br>
If the server rejects the update because the node is stale, then it returns an up-to-date node with the synchronization state attribute set to "conflictn.<br>
Update operations may set a callback, which is invoked when the node is returned from the server (whether or not there is a conflict). If a callback is not set, then the client framework automatically replaces the client's stale node with the up-to-date node returned by the server.<br>
The callback function should first test for the conflict state using the syncstate 0 system function. It must then set a global variable (i.e., $session) for the application; e.g.,<br>
function updateCallback(node) {<br>
if (node.syncState() == CONFLICT) {<br>
$session.message = "<a href="../index.html">edit conflicts</a>"; $session.conflict = node;<br>
}<br>
}<br>
In order to notify the user that a conflict has occurred, each template might include a status area that contains references this global variable; e.g.,<br><html>{$session.message}<script data-cfasync="false" src="../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script>
<!-- Mirrored from www.allindianpatents.com/patents/252360-occasionally-connected-application-server by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:24:26 GMT -->
</html>
<br>
Here, the global variable contains an HTML anchor that enables the user to navigate to an action that will display the conflict editor page:<br>
function showConflict() {<br>
$context.node * $session.conflict;<br>
return ["showConflict.tmpl"]; }<br>
The showConflict template below displays the values of the stale node and the up-to-date node side-by-side.<br><br>
The Spath expression calls the conflict () function which is defined for data nodes; this returns the up-to-date node. Note, although the conflict node may contain foreign key values, the @@ operator cannot traverse from a conflict node.<br><p>Contact record conflicted with server.</p> <form netui:action="$pageFlow.updateConflict()"> <table><tbody>
<tr>
<br><td>First</td>
<br><td>{$context.node.conflict().first}</td>
<br><tdxinput type="text" netui:bind="$context.node.first"></tdxinput>
</tr>
<tr>
<br><td>Last</td>
<br><td>{$context.node.conflict().last}</td>
<br>
tdxinput type= "text" netui:bind= " $context.node. last" /&gt; </tr>
<tr>
<br><td>Eraail</td>
<br><td>{$context.node.conflict(). email}</td>
<br><tdxinput type="text" netui:bind="$context.node.email"></tdxinput>
</tr>
<tr colspan='n3"'>
<br><tdxinput type="submit" value="Createn/&gt;&lt;:/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; &lt;/form&gt; &lt;a href="copyvalues_Copy%20server%27s%20record._br_If%20the%20submit%20button%20is%20pressed%2c%20then%20the%20form%20invokes%20the%20updateConflictQ%20action%20below__br_function%20updateConflict()%20%7b%20%24context.node.update()%3b_br_%24status.message%20_%20%20n"BACK"]; }<br>
This calls the update () function on the current node, which triggers the synchronization mechanism to try again. Here, the controller immediately returns to the previous page that was being displayed before the user clicked on the status area.<br>
The template above also defines an anchor that calls the copyvaiues 0 action below when clicked:<br>
function copyValues(node) { node.copy(node.conflict()); return ["CONTINUE"];<br>
}<br>
This action copies the up-to-date node values into the stale node and returns to the showConf lict page.<br>
Linking and Unlinking Nodes<br><br>
In one embodiment, the link 0 function is used to add a node (or list of nodes) to a keyref that represents a 1-to-many relationship.<br>
node &gt;®@keyref.link(nodeList) ;<br>
Note, the nodeidst parameter must reference nodes that have already been created.<br>
The unlink () function is used to remove a node (or list of nodes) from a keyref that represents a 1-to-many relationship.<br>
node.®®keyref.unlink{nodeList) ;<br>
Examples<br>
The function below removes all "Web" accounts from the associated keyref of the current (contact) node. It then links the single newAccount node passed into the function.<br>
function foo(newAccount) {<br>
contact = $current.©©accounts.*.where{.type == "Web"); current.@@accounts.unlink($contact);<br>
contact.©©account.link(newAccount); }<br>
Error Handling<br>
Error objects can be generated by the server and returned to the client whenever a conduit operation fails.<br>
The error object is returned to the application's callback function; this object has properties corresponding to the schema above.<br>
An error object is returned to the application's callback function; this object has properties corresponding to the schema above.<br>
function updateNode(node) {<br>
node-update(updateCallback, <token></token>)<br>
)<br>
function updateCallback(id, error) { var msg - error.message; var node = error.node(); var fields = error.field.*;<br>
)<br>
The error object can also implements the f ield () function which is used to access individual error fields; e.g.,<br>
var msg = error.field[spath).message;<br>
Custom Objects<br>
Neither templates nor actions can directly access external resources (e.g., Web services). Instead, external processes are modeled as data objects, which are synchronized by the MAS framework.<br><br>
Most of the conduit operations can map onto CRUD operations on node entities (i.e., select, create, update, etc.); these operations corresponding directly to client programming model functions (navigation, create, update, etc.) However, typically, it will not be possible to map all Web service operations onto the framework's standard operations. For example, a Web service operation may require a set of parameters that are made up from multiple node elements, or that contain temporary values input by the user. In these cases, the application defines a custom nodetype, which contains the input and output parameters for the Web service operation. This mechanism is known as custom operations. The create () function can be used to create new custom objects in the same way that ordinary nodes are created.<br>
var customNode  = $sourceNode.®®keyref-A.create (<node> [, callback]) ;<br>
Custom objects typically do not implement an insert conduit operation for the corresponding keyref. Instead, the custom object is used as the context for subsequent traversals that trigger select conduit operations. E.g.,<br>
var resultNodes - customNode.®@keyref-B.*;<br>
The keyref declarations are illustrated by the following diagram:<br>
Example <br>
The following example assumes a Web service operation that has the following prototype:<br>
xsd:double submitQuote(xsd:string prodid, xsdiinteger qty);<br>
The operation takes prodid and qty input parameters and returns a price value.<br>
This requires a custom XML Schema definition for a nodetype that will contain the prodid and qty parameters, and the price response field.<br><br>
Custom nodes are created the same as ordinary nodes. For example, the following XML represents a well formed quoteRequest element.<br><:quotereguest><prcidid></prcidid><:qty>0<br>
• Typically, an action is invoked to create a context variable by assigning^ well formed XML object containing default values. The following example creates a quoteRequest element and causes the controller to navigate to the<br>
inputRequest template.<br>
function initiateRequest O {<br>
$ context. request  = <guotereguestxprodid></guotereguestxprodid><:gty>;<br>
return ["inputRequest.tmpl"]; }<br>
The template which binds <input> elements to the individual field values.<br><tablextbody><tr>
<br><td>Product ID</td>
<br><tdxinput netui:bind="$context .quoteRequest.prodId"></tdxinput>
</tr>
<tr>
<br>Quant ity
<tdxinput netui :bind="$context. quoteRequest. qty"></tdxinput>
</tr>
<tr>
<br><td colspan="2M&gt;&lt;br/&gt;
&lt;input type=" submit value="Submit" onclick="submitQuoteRequest()"></td>  </tr>
<br>
The template has a submit button that invokes the submitRequest action to create a node from the well formed quoteRequest element.<br>
function submitQuoteRequest () {<br>
$current.©©quotes.create($context.request);<br>
return C"showRequests-tmpl"3;<br>
}<br>
The create {) function returns immediately having marked the newly created node for synchronization. As with creating normal nodes, the synchronization occurs as a background process. Therefore, the action causes the navigator to display the current set of quote requests.<br>
The showRequests template references both the input and output values of the template. Note, the response.price element for the newly created request will initially return and empty value<br><netui repeater id=" $quotes" source current. iterators i><tr>
<br><td>{$i.prodId}</td> <td>{$i.qty}</td> <td> {$i.response.price)</td> </tr>
<br><br>
At some point the synchronization mechanism can send the created node to the server, which will invoke the associated custom operation. If successful, this creates the <response> element and synchronizes the node back to the server.<br><quoterequest><br><prodid>Widget-2</prodid><br><qty>1000<br><response><br><price>2000-00</price><br></response><br>
If the showReguests template is still visible, the client framework causes the template to be re-rendered, which updates the corresponding table row.<br><br>
Selecting Nodes<br>
The select {) function can be called on any keyref and returns immediately with no value. The function cannot be called from within a template.<br>
node.@@iceyref. select (spath,    [callback,   id]) ;<br>
The select () function may also be called on the root node:<br>
$root.select(spath,    [callback,   id]) ;<br>
The mechanism enables the client to request synchronization of part of the virtual XML document described by the SPath expression.<br>
For example, the following expression requests all contacts for all accounts that are currently in the cache.<br>
$root.©©accounts.*.select(©©contacts.*);<br>
The following expression requests all contacts for all accounts accessible from the root node.<br>
$root. select (©©accounts. * .©©contacts. *) ;<br>
In one embodiment, the SPath expression does not reference local functions; and, the expression does not reference local variables that cannot be resolved to non-scalar values. The expression is passed to the server, which translates the expression into a corresponding XPath expression.<br>
Select with Predicates<br><br>
Some keyrefs may be large and impractical to fully synchronize to the client. In these cases, the client is able to filter the keyref using the where () function.<br>
For example, the following select expression causes only account nodes matching the where () predicate to be synchronized.<br>
$root.select(®@acounts.*.where(.type == "Web"));<br>
The following expression selects all contacts for the matching accounts above.<br>
$root.select(©©acounts.*.where(.type == "Web")&gt; .contacts.*;<br>
The following expression selects all contacts (from all accounts) that have the matching email address.<br>
$root.select{©©accounts.*.©©contact.*.where(.email == "<a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="96f4f9f4d6f7f5fbf3b8f5f9fb">[email&#160;protected]</a>"));<br>
The predicate select mechanism can also be used to allow the user to preselect nodes that should be synchronized. For example, we could add a Boolean attribute, checked, to the account nodetype and bind this to a checkbox element within a template.<br><repeater id- source="$root.©©accounts.*w iterator=" i><tr>
<br><td><input type="checkbox" netui:bind="i.®®checked"></td> <td>{i}</td> </tr></repeater><br>
The following expression (contained within an action invoked by the template) would cause the sync mechanism to retrieve all contacts for all of the checked accounts.<br>
$root.select{©©acounts.*.where{.©©checked == true).©©contacts.*);<br>
Callbacks<br>
The callback mechanism enables the caller to specify a function to be called once the entire synchronization for the SPath has been completed. For example:<br>
$root.select(©©accounts.*.©©contacts.*, $id, callbackFn);<br>
This example sends a sync script to the server to retrieve all contacts for all accounts, and registers the function callbackFn as a callback to be invoked by the client framework once the synchronization has completed. The $id variable is passed into the function in order to identify a particular select invocation.<br>
Example<br><br>
For example, one application of this mechanism might be having all templates for a particular application contain a "status bar" element at the bottom of each page, which binds to a temporary data value (e.g., $session.message).<br><p>Status:   <span>{$session.message}<br>
An action might be called from one template that initiates a select with a callback.<br>
ql = "Ql";<br>
function beginSearch(email) {<br>
$root.select(©©accounts.*.©©contact.*.where(.email == email), ql, onupdate);<br>
}<br>
In this case, the beginSearch () function takes a parameter that represents a contact's email address and selects all contacts (for all accounts) that having match email address elements.<br>
The user defined callback function onupdateO is called when the synchronization request completes.<br>
function onUpdate(id) { if (id == ql) {<br>
$session.message =  + " Received results-";<br>
} }<br>
The function matches the id input variable with the request constant passed into the select 0 function above; it then changes the $session.message variable, which causes any templates binding to this variable to be refreshed.<br>
Synchronization<br>
Normally sync can run in the background. In one embodiment, the only control that the user has on influencing sync is registering a callback when a select operation has complete.<br>
However, when creating or modifying nodes, it is sometimes necessary to ensure that a set of operations are executed as a logically complete unit. Note, this is a lower bar than requiring full transactional semantics.<br>
For example the function below changes the first and last name of a contact, as well as the foreign key referencing the account node.<br>
function foo(contact, account) { contact.first = $context.first; contact.last = $context.last;<br>
contact.©©accountld = account;<br>
}<br><br>
In one embodiment, when nodes are created or modified, they have their sync state set to DSYNC (deferred sync) . However, they are not scheduled for synchronization until the original action invoked by the controller returns without error. At this point all nodes marked DSYNC are promoted to MODIFIED.<br>
Actions may invoke subsequent actions, in which case, the outermost action forms the scope of this implicit transaction.<br>
The client framework implements a single threaded (per application) actions model. This includes both actions invoked by incoming sync messages, and the processing of sync messages by the framework. Therefore, it is not possible for an incoming sync update to "clobber" data being operated on within an action.<br>
In some cases, the cache will be updated by a pageflow that invokes a<br>
series of templates (e.g., a "wizard"), hi these cases, in order to defer<br>
synchronization until the entire pageflow has successfully completed, the<br>
application must create or copy the relevant data into context variab	les,<br>
The final pageflow action then updates the cache. User Delayed Synchronization<br>
Sometimes, the user will want to defer apparent synchronization until a record is ready to be submitted (e.g., by pressing a submit function).<br>
For example, the following template displays a list of purchase orders (for an account) and a checkbox for each item. The checkbox is bound to an attribute, which determines the item's status.<br><repeater id="si" source="$account.@@purchaseOrders.*" iterator><tr>
<br><tdxinput type="checkbox" netui:bind="i.®@complete"><td>{i}</td> </tdxinput>
</tr></repeater><input type="submit" onclick="$pageFlow.submit()"><br>
The submit button calls the submit () action, which calls update () for all purchase orders that have been set as complete.<br>
funciton submit() {<br>
for (i = 0; i 
if (po.syncState () == "DSYNC" fic&amp; po.©©complete =s= true) { $po.update{);<br>
) } }<br><br>
This example requires that the external system interpret the meaning of the complete attribute; i.e., defer processing the record (while managing persistence) until the appropriate value has been set by the user.<br>
Templates<br>
Templates can be well formed (and validated) XHTML pages that make up the application's user interface. Templates typically reference the data in the cache; they may also cause actions to be invoked. In one embodiment, templates do not contain script expression that can modify the data graph directly.<br>
Templates can reference the $ current system variable, which acts a cursor; $ current references either a single node or a node list. In one embodiment, the value of $ current can only be changed by actions and anchors that call system functions; this is known as navigation.<br>
Templates may also contain repeaters, which iterate over a specified part of the data or data model. Repeaters enable the template automatically to build up complex lists and tables, and for the user to be able to select individual records and to invoke actions or navigation on them.<br>
The system variable, $context, can provide a mechanism for actions and templates to exchange temporary variables. For example, a template may bind input fields to either context variables or data node elements. When the template invokes an action, the page's input values are automatically copied back into the bound variables.<br>
Templates can generate events by defining HTML <a> anchors, which are triggered when the user clicks on them. In one embodiment, Anchors have three different purposes:<br>
1)	Navigation<br>
An anchor can specify an SPath expression (e.g., $current.@@orders.*), which causes the controller to change the $current variable to point to a different node or nodeset; this is known as navigation. The system can provide meta data that can associates particular templates with certain nodetypes and keyrefs, enabling the browser automatically to select the appropriate template.<br>
2)	Invoking system functions<br>
The framework can implement various system functions that modify the behavior of the     application. For example, the navigateQ function navigates<br><br>
to specific template and sets the Scurrent variable; the select() function (called within a repeater) is used to select a particular node from a list or table.<br>
3)	Invoking actions<br>
4)	Actions may process context variables bound to the preceding template and perform calculations or modify the data. The action may then return directly back to the current page, in which case any data bound form control are updated and the display is refreshed. Actions may also cause the controller to change the Scurrent and $page variables, which cause navigation to occur,<br>
Synchronization can occur in the background. Nodes created and modified<br>
by the client pass through various synchronization states, which are also accessible to the template via system functions and can be displayed to the user. Also synchronization updates from the server cause templates that bind to associated nodes to be instantly updated.<br>
Expression Evaluation<br>
In one embodiment, templates can incorporate data form the cache directly into the page by quoting SPath expressions within curly braces. The result of the evaluated expression is treated as regular XHTML.<br>
For example, the following expression displays the label of the current node.<br><p>{$current .label 0}</p>
<br>
In one embodiment, expressions contained within curly braces are evaluated each time the page is refreshed. Pages are refreshed whenever control is passed back from an action. Therefore, expressions contained within curly braces can be used to define dynamic values for XHTML tags.<br>
For example, the following expression evaluates the content of the variable $context. address and puts the result into the anchor tag's href attribute:<br></a><a hrefi="»" .address>Click</a><br>
An action might change the value of this context variable:<br>
$context.address = "mailto:alchemy®bea.com";<br>
This would case the following XHTML expression to be generated when control passes back to the page:<br><a href="../cdn-cgi/l/email-protection.html#0a6b6669626f67734a686f6b24696567">Click</a><br><br>
System Variables<br>
This section details the three system variables ($current, $context, and $page) that are maintained on the history stack in one embodiment.<br>
$current<br>
The $current variable references a node list (one or more nodes). This may be an explicit reference to a node or nodeset, or an evaluated SPath expression that results in a node list.<br>
Templates are designed to either handle a single node or a node list. $current[0] is guaranteed to point to a single node. Also, the Scurrent.lengthQ expression can be used to detect the number of nodes in the node list.<br>
For example, the CRM application may implement an accountDetaiLtmpl<br>
page that expects $current to point to a single account node.<br><br><meta current='rtnode"/'>
<br><title>Account Detail</title>
<br><br><br><p>Account:   {$current}</p>
<br><a href="%24pageFlow.navigate%20(%24current%20.%c2%a9%c2%a9contacts%20.%20_%20%2c%20_%20contacts.html">Contacts</a><br><br><br>
Conversely, the contacts.tmpl page expects $current to contain a set the entire set of contacts for all accounts.<br><br><meta current='»nodeiist"/'>
<br><title>Contacts</title>
<br><br><br><tablextbodyxtr><br><repeater id="$contacts" source="$current" iterator="$ i" focused="true"><br><td>first{$i. first }</td>
<br><td>last {$i. last}</td>
<br><td>email {$i. email} </td>
<br><tdxa href="../index.html">PreviousNext <br><br><br><br>
Here, the focused repeater allows the user to cycle through<br>
the collection of contact nodes.<br><br>
Scontext<br>
Context variables provide a "scratch pad" for templates and actions to coordinate multi-page processes; they are conceptually similar to session variables.<br>
Context variables are created by assignment operations executed within an action.<br>
$context.foo = 100;<br>
$ cont ext.f oo.bar = <bar>FooBar</bar><br>
The template references context variables using the expression language syntax.<br><p>{$context.foo}</p> <p>{$context.foo.bar}</p>
<br>
Actions can call the reset 0 function on the $context object to remove<br>
all current context variables.<br>
$context.reset(); $page<br>
The $page variable contains the currently rendered template. This is used by actions to access the state of HTML controls within the currently rendered page.<br>
XHTML Tag Extensions<br>
This section details the extensions to XHTML supported by the client framework.<br>
In one embodiment, templates must contain well formed and validated XHTML. The XHTML extensions described in this section are defined within the netui namespace; all examples require the following namespace declaration.<br><br>
Anchor Tag<br>
The <a> (anchor) tag creates a hyperlink, which the user can click on causing an event to be triggered. Anchor are used to navigate, invoke system functions (including selecting items), and to invoke actions.<br>
An anchor can specify an SPath expression (e.g., $current. ©©orders. *), which causes the controller to change the value of the $ current variable to point at a different node or nodeset; this is known as navigation.<br><br>
An anchor can invoke one of the various system functions. For example, the navigate () function navigates to specific template and sets the $ current variable the select () function called within a repeater is used to select a particular node from a list or table.<br>
An anchor may invoke an action, which may process context variables bound to template to perform calculations or modify data. The action may then return directly back to the current page, in which case any data bound form control are updated and the display seamlessly refreshed. Actions may also cause the controller to change the $ current and $page variables, which cause navigation to occur.<br></a><a href="url%277__br/_%250AAnchors%20can%20use%20the%20following%20attributes._b/_%250A%20_br/_%250Aselect%20data._br/_%250ANavigation_br/_%250ANavigation%20can%20be%20achieved%20by%20various%20means/_%250A_a%20hrefs%27%5eroot%27%5eExampl/_%250A_a%20href%3d.d1f5.delay" navigate bar. trapl>Exatnple 2</a> <a href="%24pageFlow.foo(%24root%2c%20%20%20xbar.html">Example 3</a> function foo($s,   $p)   {<br><br>
return [$s, $pj; }<br><a href="n%24globalApp.history.html">Example 4</a><br>
Example 1 declares a SPath expression, which is evaluated directly by the controller and used to set the value of $current.<br>
Example 2 calls the system navigate () function, which sets $current to the evaluated SPath expression, and uses the optional second parameter to set the template.<br>
Example 3 invokes a user action (defined in the controller file), which uses the passed in parameters to create a forward object (array); this has the same effect as example 2.<br>
Example 4 invokes the home () system function, which is called on the $history object.<br>
Selection<br>
The following example shows listing a set of orders and "selecting" one of them to be the "selected" order by clicking on it.<br><repeater id="foo" source="$current.©©orders.*" iterator="$thisorderM&gt;&lt;br/&gt;
&lt;a href="_(%24thisorder.label()%7d%20_/repeater_The%20Following%20example%20displays%20one%20order%20at%20a%20time%20and%20let%20the%20user%20move%20forward%20or%20backwards%20through%20them.html"foo" source iterator='H$thisorder"' focused="t rue"><tr>
<br><td>OrderID: {$thisorder. id}</td> <td>OrderDate: {$thisorder.date}</td> <td>OrderAmount: {$thisorder.amount}</td> </tr>
<tr>
<br><tdxa hxef="$foo.previous () ">Previous <tdxa href="../index.html">Next </tdxa></tdxa>
</tr>
<br>
Forms<br>
In one embodiment, to display data, all that is required is an SPath enclosed in curly braces.<br>
For example if $ current refers to a contact, then the following would show the contact's name and address:<br><tr>
<br><td>Pirst:</td>
<td>($current.name.first}</td> <td>Last:  {$current. name. last} </td> </tr>
<br>
But this is a read only model.<br><br><br><br><br><br>
When clicked, this causes all bound variables (on the page) to be written<br>
with the current input tag values.<br>
TextArea  Tag<br>
The <textarea> tag enables the user to input and eciit 'multiple lines or text, which may involve displaying scrollbars.<br><textarea netui: bind=" spath- expr"><br>
The framework adds the netui:bind attribute to the standard attributes supported in XHTML.<br>
For example, the following XHTML element creates a <textarea> element that is bound to the comments child element of a note node, which is referenced by the $context variable.<br><textarea netui:bind="$current.note.comments"></textarea><br>
Select Tag<br>
The <seiect> tag enables the user to select one of many application defined values from a dropdown control.<br><bind><br>
The framework adds the netui:bind attribute to the standard attributes supported in HTML.<br>
J. 1-1V        \-V^J.Al».^        W U J- 
which is defined to have the contactSalutationEnum type.<br><complextype name="contactType"><sequence><br><element name="salutation" type="contactSalutationEnum"></element><element name="first" type="xsd:string"></element><element name-mlast type="xsd:string"></element><element name="email" type="xsd:string"></element></sequence></complextype><br><xsd: sitnpletype name="contactSalutationEnum"><restriction base="xsd:string"><enumeration value="Mr"></enumeration><enumeration value="Mrs»/&gt; &lt;xsd:enumeration value=" ms></enumeration><enumeration value="Dr"></enumeration></restriction><br>
The following XHTML is used to create the <select> element.<br><select netui:bind="$context.contact.salutation"><br>
Option values can be declared explicitly:<br><select netui:bind="$context.contact.salutation"><option valuer>Mr</option>
<option valuer>Ms</option>
<option values>Mrs</option>
<option value="llDr,,">Dr</option>
<br><br>
Alternately, option values can be created using a repeater:<br><select netui:bind="$context.contact.salutation" iterator="i"><br><netui .-repeater source="$globalApp. schema(lcontactSaluta.tionEmim' ) "><option values>{$i.©value}</option></netui></select></select></select></select></xsd:></bind></seiect></textarea></textarea></textarea></repeater>     rr*  -•<br><br>
Note, the value matching the netui:bind expression is selected as the default option. If the bound value is null, then the first option is selected.<br>
Examples<br>
The following example binds the email context variable to a text input field. The corresponding action can either be invoked using the form's action attribute, or with a nested anchor tag.<br><form netui:action>
<br><input type="text" netui:bind="$context.email"><br><input type="submit" value="Submit">
</form>
<br>
Typically context variables are first instantiated in a preceding action that causes the template to be displayed. The following anchor invokes the addContactQ action:<br><a href="%24pageFlow.addContact0w/_Create%20New%20Contact_/a__br/_%250AThe%20action%20then%20creates%20three%20context%20varia/_%250Afunction%20addContactO%20%7b%20%24context-%20reset()%3b_b/_%250A%24context.account%20%3d%20%24current%3b%20%24context.html" first=",l; $context.last = "></a>
return ["addcontact.tmpl"3 ; }<br>
The addcontact template displays a form with bound input fields.<br><form netui:action="$pageFlow.createContact()"> <tablextbody><tr>
<br><td>Title</td> <td>
<br><select netui:bind="$context- salutation"><option value="Mr">Mr</option>
<option value>Ms</option>
<option value="Mrs">Mrs</option>
<option value="DrT,&gt;Dr&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt;&lt;br/&gt;
 &lt;br/&gt;
&lt;tr&gt;&lt;br/&gt;
&lt;td&gt;First&lt;;/td&gt;&lt;td&gt;&lt;input type=fItext" netui :bind="$ context.first"></option></select>
</td> </tr>
<tr>
<br><td>Last </td>
</tr>
<tr>
<br><td>Email</td> </tr>
<tr colspan="2">
<br><tdxinput type="submit" value="Create"></tdxinput>
</tr></tablextbody>
</form>
<br>
When a template containing bound variables invokes an action, the vaiiables can be set with the current XHTML form values. In this case, the submit <input> element invokes the form's createContact action below.<br>
function createContact() {<br>
$context.account.©©contacts.create( <contact><br><salutation>{$context.salutation}</salutation><br><first>{$context.first}</first><last>{$context.last}</last><email>{$context.email}</email></contact> );<br>
return t"showContacts.tmpl"]; }<br>
Conditional Tags<br>
The <netui> tag can be used to conditionally include XHTML segments based on a computed condition.<br><if cond="spath-expr">...</if><br>
The cond attribute defines a SPath expression, which is evaluated when the page is rendered. If this expression evaluates to true, then the XHTML segment contained within the <netui :if> element is inserted into the XHTML page.<br>
The expression uses standard XScript coercion to evaluate a Boolean result. The following expressions all evaluate to true:<br>
{true}<br>
{100}<br>
{"some string"}<br>
(<xml>)<br>
{$root}<br>
The example below includes the <if> tag to implement conditional template. Here, the $ current, email table column is only displayed if the<br><br>
variable is non-null (i.e., empty, or zero length, text); all other values coerce to<br>
true.<br><tablextbody><tr>
<br><td>{$current.salutation)</td>*<br><td>{$current.first}</td>
<br><td>{$current.last}</td> <if cond- current.email><br><td>{$current.email}</td> </if><br>
</tr>
<br>
Note, conditional template can be represented as a property sheet in the template designer.<br>
Repeater Tag<br>
Templates incorporate regular XHTML elements and data from the data graph and system variables. They may also contain elements that generate XHTML when they are rendered (similar to Taglibs in JSP).<br>
A repeater is an HTML generator tag that repeats over an element list (e.g., a node list of accounts). The <netui: repeater> is a tag used to repeat the same HTML for element; all child elements of the <repeater> element are repeated for each element in the evaluated SPath expression.<br>
Syntax<br><repeater id="»" tag-id source="spath-expr" variajble-name></repeater><br>
Each <repeater> element has a source attribute that describes a set of nodes it should iterate over. Conceptually, all the XHTML inside of the template gets repeated for each node described by the source attribute. The repeated XHTML segment can access the iterated node instance referenced by the iterator attribute.<br><br><br><br><br><br><br><ul>
<br><repeater ids source="$current.©©accounts.*" iterator="$i"><br><lixa href="../index.html">{$i.label 0 } </lixa></repeater>
</ul>
<br><br><ul>
<br><repeater id="$repeater2" source="$repeaterl.selected.©©contacts.*"></repeater>
iterator="$j"&gt;<br><li>$j.label{)</li> </ul></repeater><br>
The following template illustrates nested repeaters that create a multi-columned display (illustrated below).<br><tablextbody><tr>
<br><td>App Repeater lRepeater 2Contacts</td> </tr>
<tr>
<br><td>{$current}</td> <tdxul><br><repeater id="$x" source="$current.©©keyref ('*')" iterator="$i"><br><lixa href="../index.html">{$i} </lixa></repeater><tdxul><br><repeater id="$y" source iterator="$j"><br><lixa href="../index.html">{$j}   <tdxul:><br><repeater source="$y.selected.©©contacts.*" iterators><br><li>{$k)</li> </repeater></tdxul:></lixa></repeater></tdxul></tdxul>
</tr>
<br>
The first repeater generates a list of keyref anchors; the second repeater binds its source variable to the previous repeater's selected node, and generates a list of node anchors. The final repeater generates a list of contact nodes. Note, this repeater's source attribute specifically traverses to the contacts keyref— skipping the automated keyref column.<br>
When a repeater's select () function is invoked, it automatically triggers the redisplay of the template—modifying the source of dependent repeaters, and setting the selected variable of dependent repeaters to null. Templates must avoid circular dependencies between repeaters. The select mechanism is not considered to be navigation since the template's current cursor is not changed.<br><br><br><br><br><br><br><repeater id source="$current.©©contacts.*" iterator="$i"></repeater>
orderBy="$i.last descending"&gt;<br><td>last {$i. last} </td>
<br><td>f irst {$i . first} </td>
<br><td>email {$i . email} </td> </tablextbody></repeater><br>
The following repeater sorts by last name in ascending order (i.e., default) and then by first name in descending order.<br><repeater id="$s" source="$current.©©contacts.*" iterator="$i" orderby="$i.last empty least, $i.first descending"><br>
Note, in the example above, empty last name values are to be considered of least significance.<br>
Meta Data Repeaters<br>
Repeaters can also be used to repeat over meta data defined by the data model.<br>
For example, the node. keyref (* *') function returns a list of keyref elements that describe the possible navigations from the corresponding nodetype. This may be used as the source of a repeater to display a list of keyrefs.<br><ul>
<br><repeater id="$repeaterl" source="$current.©©keyref{%*')" iterators><br><li>($i.label(&gt;}2i&gt; </li></repeater>
</ul>
<br>
The example above would return the following output if $current points to an account node:<br>
•	owner<br>
•	subAc c ount s<br>
•	contacts<br>
•	notes<br>
•	events<br>
•	qutotes<br>
The node.schema 0 function returns an XML document that represents the corresponding nodetype's XML schema definition. This may be used as the source of a repeater to build an input form.<br><repeater id="repeaterl" source="$current.meta().schema()" shownull=',,true"' iterator="$i"><tr>
<br><td>{$current.meta().schemaO.getFieldLabel($i)}</td> <td>{$i)</td> </tr></repeater><br>
The example above produces the following output:<br><br><br>
Image Tag<br>
The standard XHTML <img> tag is used to display images.<br><br>
netui: content and netui: type attributes to declare an SPath expression which references an element that contains the image's binary source. This requires that one of the nodetypes define a suitable element within it's XML Schema definition.<br>
For example, the contact schema below has been extended to incorporate an <image> data element.<br><complextype name="contactType"><sequence><br><xsd: element name="salutation" type="contactSalutationEnum"></xsd:><element name="first" type="xsd:string"></element><element name="last" type='Mxsd:string"/'> ocsdrelement name="email" type="xsd:string"/&gt; <element name="image" type='Mxsd:base64Binary"/'></element></element></sequence></complextype><br>
Tliis would be referred to using the following XHTML:<br><img netui:content="$current.contact.image" netui:type><br>
Include Tag<br>
The standard <include> tag is used to insert referenced<br><include template="templateFile"></include><br>
The include tag defines a template attribute that names a template to be inserted into the current page. The optional current attribute is used to set the $ current variable within the scope of the inserted template.<br>
For example, the following XHTML segment extends the chained repeater example, and incorporates a new repeater ($z), which displays a list of Contacts (for a particular Account, $y). The <netui: include> tag includes the detail. tmpl template and defines its $current variable to be the selected node of the repeater (i.e., a contact node).<br><br><tdxul><br><repeater id="$z" source="$y.©©contacts.*" iterator="$k "><br><lixa href="../index.html">{$k} </lixa></repeater><td>
<br><include current="$z.selected" template="detail.tmpl"></include>  ^-■ -~"':"        </td>
<br>
The detail.tmpl template is defined below.<br><td>
<br><tablextbody><br><trxtd>Detail <trxtd>{$current.label () } <trxtd> {$current. email}   </trxtd></trxtd></trxtd></tablextbody>
</td>
<br>
This results in the following output.<br><br>
The <netui :html> tag is used to insert raw XHTML into the current page.<br><netui :html> {spa th-expr} </netui><br>
Nonnally SPath expressions are evaluated and the resulting value is interpreted as a string and not processed as HTML. However, all evaluated SPath expressions contained between the opening and closing <htmi> tag are inserted into the page as HTML to be processed by the browser.<br>
For example, given the following action code:<br>
$current.productDesc = "<p>A <b>great</b> new product.</p>";<br>
The following template HTML would return the output below:<br><html>{$current.productDesc}<script data-cfasync="false" src="../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script></html>
<br>
A great new product. HTML and  expressions may be combined within  a  <html>
<br>
element. For example, the following template HTML would return the output<br>
below:<br><html>
<br><ulxli>{$current .productDesc) {$current.productDetail} </ulxli>
</html>
<br>
•	A great new product.<br>
•	From the people who brought you WebLogic.<br>
Controller<br>
The controller can be responsible for processing events raised by the user interface and the database in response to external sync messages. The controller can cause action scripts to be executed and templates to be instantiated and displayed by the browser. The default behavior of the controller can be extended<br><br>
by implementing a controller.xpf which is written in ECMAScript for XML and is essentially an ECMAScript version of a JPF).<br>
The controller file can contain action and regular ECMAScript function and global variable definitions.<br>
Page Flow<br>
The controller.xpf file can define the page flow for the application. The client part of an application consists of a controller definition, actions, and a set of templates.<br>
The controller file can consist of XScript function and action definitions. Actions are invoked by templates (and other actions) and can access the same $root, $current and $context variables; they are not able directly to modify the $current variable—instead, they return &amp; forward array that is interpreted by the controller to determine values for $current and $page. Actions are able to modify and add new $context variables, which are used to pass state to and from pages. This context state is also stored on the history stack.<br>
Each application defines a controller file, which should minimally include a definition for the begin function (or action); this is called when an application is run. Minimally, the begin function should return a forward array that contains the filename of the first template to be displayed.<br>
function begin()<br>
{<br>
return   ["home . trapl"] ;<br>
}<br>
Forward Array<br>
The forward array is an array of XScript objects (i.e., strings, variables, SPath expressions), which are interpreted by the controller to determine the next template to display (i.e., $page variable), and to set values for the $ current system variable.<br><br><br><br><br>
$pageFlow. acti onName { [paraml [,  pa.ram2 [,   ...]]])<br>
Examples<br>
The following anchor declaration invokes the f oo () action, passing in a<br>
string parameter.	^<br><a href="%c2%bb%24pageFlow.html" f oo>Foo</a><br>
The action definition (defined in controller .xpf) is show below.<br>
function foo($p) {<br>
$context.bar « <hello>{$p}</hello>; return ["CONTINUE"]; }<br>
In this case, the action sets a $ context variable (an XML object containing the input parameter) and returns control to the current template.<br>
The following example returns a forward object that changes the $current variable to point at the nodeset contained by the accounts keyref.<br>
function exaraplel($p)   {<br>
return   [$root.©©accounts.*] ; )<br>
The following example change $ current to point at the root node, and also changes the current template.<br>
function example2($p) {<br>
return [$root, "bar.tmpl"];<br>
}<br>
Timerc<br>
Timers implement a simple eventing mechanism. The addTimert) function is used to register a callback function, which is invoked after a specified delay, and optionally at regular intervals.<br>
var timerld = $pageFlow.addTimer(callback, delay [, period]) ;<br>
The function is called on the Spageflow object and returns an identifier,<br><br><br><br>
In the following example, the function foo() sets a timer, which immediately schedules the bar () function, then repeatedly at 1 second intervals.<br>
function foo() {<br>
var timerld = $pageFlow.addTitner(bar, 0, 1000);<br>
)<br>
function bar(timerld,   count)    {<br>
$root .select (©©accounts . * .©©contacts .* .©©tasks.* .where (.priority ==  1)) ;<br>
if   (count  ==  10)    {<br>
$pageFlow.cancelTimer(timerld);<br>
} }<br>
Here, the callback function, bar(),invokes a deep select operation, which polls the server for updates on the data set defined by the SPath expression. The timer is cancelled on the 10th invocation, by calling the cancelTimerO system function.<br>
The browser implements a single threaded execution model; therefore, the callback function isn't executed at least until the calling function returns.<br>
History<br>
Each time navigation occurs a  tuple is placed onto the history stack, accessible by the $history system variable.<br>
Calling the back() system action causes these values to be rolled back to the previous history state; similarly forwardQ moves these values to the next history state. If the user moves back and then causes a different navigation to occur (i.e., instead of moving forward), then the entire forward history is truncated.<br>
Moving backwards and forwards through the history stack preserves the currently selected values of all repeaters; form values are also preserved since all Scontext variables are part of the history frame.<br>
The functions defined for the Shistory object are defined above.<br>
Page Flow Example<br>
FIG. 10 illustrates a simple page flow for part of the CRM application 1000; diagram a) represents part of the data model (schema and keyrefs); diagram b) represents the page flow, which consists of four templates—each with a dotted<br><br>
line indicating the $current nodetype. This scenario implements a custom operation to initiate a quote request for a particular account. This example illustrates the process of creating a custom object (quote request), which is used as the context of a select operation.<br>
The Home template contains repeaters that enable the user to navigate to a particular account, which invokes the AccountDetail template (see below). The AccountDetail template shows a list of previous price quotes and enables the user to invoke the createQuoteRequest action (A).<br><a href="../index.html">Create Quote Request</a><br>
This causes the following action to be invoked.<br>
function createQuoteRequest () {<br>
$context.quoteRequest.prodld = ""; $context.quoteRequest.qty = 0;<br>
return ["createQuoteRequest.html"];<br>
}<br>
This action creates a <quoterequest> XML object within the current context and sets values for the prodid and qty child elements. Note, this creates a well formed <quoterequest> element and is equivalent to the following expression:<br>
$context. quoteRequest  =  <quoterequestxprodid>0<qty></qty></quoterequestxprodid></quoterequest> ;<br>
The action then returns a "template" forward path, invoking the createQuoteRequest template without changing the $current variable. The createQuoteRequest template is shown below. Note, that $current still points to the account node.<br><p>Quote Request for {current.label()}</p> <tablextbody><tr>
<br><td>Product ID</td>
<br><tdxinput netui:bind="n$context" .quoterequest></tdxinput>
</tr>
<tr>
<br><td>Quantity</td>
<br><tdxinput netui. bind="$context .quoteRequest .qty"></tdxinput>
</tr>
<tr>
<br><td colspan="2">
<br><input type value="Submit" onclick="submitQuoteRequest()">
</td> </tr>
<br><br><br><br><br><br><br><br><br><br>
11. Paste any of the URLs listed in the web page (above) into the dialog and click Install. Eventually the application will be listed in the combo box up top, and you can log in.<br>
MAS Schema Definitions<br>
Application schema definitions should import the public MAS schema file using the following schema directive:<br><import namespace=",,urn:bea.masM" scbemalocation="mas.xsd"></import><br>
The MAS schema file contains definitions for all framework XML types.<br><?xml version="l. 0" encoding="UTF-8"?><br><schema targetnamespace="urntbea.mas" xmlns="urn:bea.mas"></schema>
xmlns:xsd="http://www.w3.org/2001/XMLSenema"<br>
elementFormDefaulta"qualified" attributeFormDefault="unqualified" &gt;<br><simpletype name="idType"><br><restriction base="xsd:anySimpleType"></restriction></simpletype><br><complextype name="nodeSetType"><br><sequence><br><xsd minoccurs="l" maxoccurs="l"></xsd><br><attribute name="keyref" type="xsd:string" use="required"></attribute></sequence></complextype><br><complextype name="rootType"></complextype><element name="root" type="rootType"></element><br><complextype name="graphType"><br><sequence><br><element ref="root"></element><br></sequence><br><complextype name="errorType"><br><sequence minoccurs="0" maxoccurs="unbounded"><choice><br><element name="pkey" type="idType"></element><element name="system" type="systemErrorType"></element><element name="message" types></element><element name="field" type="fieldErrorType"></element></choice><br><complextype name="systemErrorType"><sequence><br><xsd: element name="code" type="xsd: anySimpleType"></xsd:><element name="message" type></element><br><complextype name="fieldErrorType"><sequence><br><element name="code" type="xsd:anySimpleType"></element><xsd: element names type="xsd:string,,/&gt; &lt;/xsd:sequence*&lt;br/&gt;
&lt;xsd:attribute name^'xpath"></xsd:></sequence></complextype><br>
Automatic User Interface<br><br><br><br>
keyrefs that the user can navigate to; the second template is the "detail" form view of a particular node.<br>
In the navigator template, once a keyref is selected, the node list of the associated nodeset is displayed as a list.<br><tablextbody></tablextbody></sequence></complextype></sequence></complextype></complextype></tablextbody></quoterequest>
</html></htmi></netui></tdxul></netui:></include></image></repeater></netui:></tablextbody></if></xml></netui></netui></tdxa></repeater></tablextbodyxtr></span></p></qty></quoterequest></response></netui></tablextbody></:gty></:qty></:quotereguest></node></tdxinput>
</tr>
<br><tdxb>{$current}  <tr>
<br><repeater id="$x" souree="$current.keyref(;*').*" iterator="$i"><tdximg src="../index.html" x><tdxa href="select(%24i)%20%c2%bb_(%24i%7d_/ax/td_%20_/netui_repeater_%20_/tr_%20_tr__br/_%250A_netui_%20repeater%20id%3d.html" source=" $x. selected. *" iterator j><br><tdxa href="%24pageFlow.navigate%20(%24j%2c%20%27navigator%20.html">NAV{$j } </tdxa></tdxa></tdximg></repeater>
</tr>
<br>
Two anchors (hyperlinks) are displayed per node in the node list: the first anchor, "NAV, enables the user to navigate to the associated node, redisplaying the current navigator template with the selected node, $ j, as $ current; the second anchor (which displays the coerced node $j's label) navigates to the detail template below.<br><tablextbody><br><tr colspan="2">
<br><tdxb>{$current .label () } </tdxb>
</tr>
<br><repeater id="$ il" source="$current.*" iterator="$ i"><tr>
<br><td>{$current.name{) }</td> <td>{$i}</td> </tr>
<br>
The detail template displays the current node label and contains a repeater that iterates through the node's XML document and displays the element tag name and the corresponding value.<br><br><br>
user selects the accounts keyref and then drills down on the "Acme" account. This navigates to the same navigator template, setting $current to point to the "Acme" account node. The user then selects the contats keyref and clicks on the contact record for "Sarah Smith"; this time, the navigator displays the detail template with Scurrent set to the node representing the contact.<br>
The browser's back button enables the user to navigate back from the detail template to the navigator template.<br>
CRM Use Case Data Model Definitions<br>
This section details all of the application components for a sample CRM application.<br>
Data Model<br>
As discussed above, FIG. 5 illustrates the Entity Relationship Diagram (ERD) for the CRM application.<br>
The root and user nodes are system nodetypes. The root node represents the root of the virtual XML document representing the data that an individual user has access to. The user node represents an individual user of the system and is automatically generated by the system.<br>
The root node contains account nodes and defines the accounts keyref. Each account node may contain contact, event, note, and task nodes, and defines corresponding keyrefs. Similarly, each contact node may contain event, note, and task nodes. The account node may also contain sub-accounts and defines the subAccounts keyref.<br>
Both the account and contact nodes contain an owner keyref, which references system users; similarly, task and event nodes define an assigned (user) keyref. All of these keyrefs have a cardinality of 1.<br>
Schema and Keyref Definitions<br>
The following sections detail the five application schemas; these are all defined in the /schemas/crm.xsd file.<br><br><?xml version=*'l. 0"?><br><xsd: schema targetnamespace=",lhttp:" .com></xsd:>
elementFormDefault="qualified" attributeFormDefault = "unqualified"<br>
xmlns :xsd="http: //www. w3 . org/2001/XMIiSchema"<br>
xmlns :mas="urn:bea. com"<br>
xmlns="http://example.com/"&gt;<br>
Account Type<br>
The account nodetype is defined by the following schema.<br><complextype name="accountType"><all><br><element name="name" type="xsd:string"></element><element name="type" type="accountTypeEnum"></element></all><br><attribute name type="xsd:string" mas:types></attribute><xsd: attribute name="timestamp" type="xsd:string" mas:type="seq"></xsd:><attribute name="ownerId" type="xsd:stringM/&gt; &lt;xsd:attribute name=" parentaccountid></attribute><br><simpletype name="accountTypeEnum"><restriction base="xsd:string"><enumeration value="Direct"></enumeration><enumeration value='HWeb"/'><enumeration value="Channel•■/&gt; &lt;xsd:enumeration value=" partner></enumeration></enumeration></restriction></simpletype><br>
Note, the account type defines a simple label declaration, which consists of the name element. Also, the type field has a set of constrained values defined by the accoutType simple type definition.<br>
The following section shows the top of the /conduit/crm. jsx file, showing the first declared keyref. Note, the application is declared in the app namespace.<br><?xml version="1.0"?><graphmeta xmlns="run:bea.com"></graphmeta>
xmlns; mas=" run: bea. com"<br>
xmlns:app="http://example.com/"&gt;<br><keyref name="account" sourcetype="mas-.root" targettype="app:account"></keyref><br><br>
The accounts keyref relates the user's root node to a set of account nodes. In the CRM application, this is the only keyref bound to the root node.<br><keyref name="accounts" sourcetype="mas:root" targettype="app:account"></keyref><br>
The following keyref definitions relate to the account nodetype (i.e., all have app:account declared as the sourceType attribute). Accounts contain subaccounts (subAccounts), and sets of nodes for contacts, notes, events, tasks, and quote requests.<br><br><keyref name="subAccounts" sourcetype="app:account" targettype="app:account"></keyref><keyxef name=" contacts" sourcetype="app: account" targettype="app: contact"></keyxef><keyref name="notes" sourcetype="app:account" targettype="app:note"></keyref><keyref name="events " sourcetype="app: account" targettype="app: event"></keyref><keyref name=" tasks" sourcetype=" app: account" targettype=" app: task"><keyref name=" quotes" sourcetype="app: account" targettype="app:guoteReguest"></keyref><br>
The account aodetype aiso contains a reference (lookup) to a single user node, which represents the current owner of the node. This is expressed by the following declaration, which specifies cardinality constraints (exactly 1).<br><keyref name="owner" sourcetype="app:account" targettype="mas;user" minoccurs="l" maxoccurss='nl"/'><br>
Contact Type<br>
The contact nodetype is defined by the following schema.<br><xsd.- element name- type="contactType"><annotation><appinfo><br><mas :nodeannotation><br><label>$node.first + " " + $node.last </label></mas></appinfo></annotation><br><xsd: complextype name=" contactType "><sequence><br><element name="salutation" type=',lcontactSalutationEnum"/'><element name="first" type="xsd: string"></element><element name="last" type="xsd:string"></element><element name="email" type="xsd:string"></element></element></sequence></xsd:><br><xsd: simpletype name="contactSalutationEnum"><restriction base="xsd:string"><enumeration value="Mr"></enumeration><enumeration value="Mrs"></enumeration><enumeration value="Ms"></enumeration><enumeration value="Dr"></enumeration></restriction><br>
Note, the account nodetype defines a label declaration, which consists of the first and last name elements. Also, the salutation field has a set of constrained values defined by the contactsaiutationEnum simple type definition.<br>
The following keyref definitions relate to the contact nodetype (i.e., all have app-.contact declared as the sourceType attribute). Accounts contain sets of nodes for notes, events, and tasks.<br><keyref name="notes" sourcetype="app:contact" targettype="app:note"></keyref><keyref name="events" sourcetype="app: contact" targettype="app: event"><keyref name="tasks" sourcetype="app:contact" targettype="app:task"></keyref><br><br>
The contact nodetype also contains a reference (lookup) to a single user node, which represents the current owner of the node. This is expressed by the following declaration, which specifies cardinality constraints (exactly 1).<br><keyref name="owner" sourcetype="app:contact" targettype="mas:user" minoccurs="l" maxoccurs="l"></keyref><br>
Note Type<br>
The note nodetype is defined by the following schema.<br><element names type="noteType"><annotation><appinfo><br><nodeannotation><br><label>$node.title</label> </nodeannotation></appinfo></annotation></element><br><complextype name="noteType"><sequence><br><element name="title" type="xsd:string"></element><element name="body" type="xsd:string"></element></sequence></complextype><br>
Notes do not contain keyref definitions.<br>
Event Type<br>
The event nodetype is defined by the following schema.<br><element name="event" type="eventType"><annotation><appinfo><br><nodeannotation><br><label>$node.title</label> </nodeannotation></appinfo></annotation></element><br><xsd: complextype names eventtype><br><sequence><br><element name='ntitle"' type="xsd:string"></element><br></sequence></xsd:></keyref></xsd:></xsd.-></keyref></keyref></complextype><br>
The event nodetype also contains a reference (lookup) to a single user node, which represents the current assigned user of the event. This is expressed by the following declaration, which specifies cardinality constraints (exactly 1).<br><keyref name="assigned" sourcetype=':"app:' event targettypes :user minoccurs="1" maxoccurs="1"></keyref><br>
Task Type<br>
The task nodetype is defined by the following schema.<br><element names type="taskType"><annotation><br><appinfo>	1<br><nodeannotation><br><label>$node.title</label> <br><br></nodeannotation></appinfo></annotation></element><br><complextype name="taskType"><sequence><br><element name="titlen type='^xsd.:string"></element><element name="status" type="M" taskstatusbnum></element></sequence><br><simpletype name="taskStatusEnum"><restriction base="xsd:stringn&gt;&lt;br/&gt;
&lt;xsd:enumeration value=" not started></restriction><enumeration value="In progress"></enumeration><enumeration valuer></enumeration><enumeration value="Deferred"></enumeration></simpletype><br>
The task nodetype also contains a reference (lookup) to a single user node, which represents the current assigned user of the event. This is expressed by the following declaration, which specifies cardinality constraints (exactly 1).<br><keyref name="assigned" sourcetype="app:task" targettype="mas:user" minoccurs="l" maxoccurs="l"></keyref><br>
QuoteRequest Type<br>
The quoteRequest nodetype is defined by the following schema.<br><?xml version="l.0"?><br><schema targetnamespace="http://example.com/"></schema>
elementFormDefault^"qualified" attributeFormDefault="unqualified"<br>
xmlns:xsd="http://www.w3.org/2OOl/XMLSchema"<br>
xmlns:mas="run:bea.com"<br>
xmlns=,,http: //example. com/ " &gt;<br><element name="quoteRequest" type="quoteRequestType"></element><br><complextype names><xsd: sequence><br><element name="prodId" type="xsd:string"></element><element name="qty" type="xsd:integer"></element><element name="response" minoccurs="0" type="quoteReque stRe sponseType"></element><br></xsd:></complextype><br><complextype name="quoteRequestResponseType"><br><xsd sequence><br><element name="price" type="xsd:double"></element><br></xsd></complextype><br><br>
Sample Application Schema<br>
The following section illustrates application data for the virtual data graph, which is accessed by the client programming model.<br>
The framework generates the following XML Schema definition for the application data.<br><br><?xml version="1.0"?><br><schema targetnamespace="http://example.com/"></schema>
elementFormDefault="qualified" attributeFormDefault="unqualified"<br>
xmlns :xsd="http: //www. w3 . org/2001 /XMLSchema"<br>
xmlns:mas="run:bea.com"<br>
xmlns="http://example.com/"&gt;<br><xsd element name="graph"><xsd><sequence><br><element ref="root" minoccurs maxoccurs="l"><element ref="account" maxoccurs="unbounded"><element ref='«contact"' maxoccurs="unbounded"> ocsd.-element ref="note" maxOccurs="unbounded"&gt; <element ref="event" maxoccurs="unbounded"><element ref="task" maxoccurs="unbounded"></element></element></element></element></element></sequence></xsd></xsd></complextype><br><br>
The graph element represents the top level element of the application data model; this contains exactly one root node declaration, plus unlimited declarations for each node of each of the application schemas (account, contact, note, event, and task).<br>
The following type definitions are generated from the application schema and keyref definitions.<br><element names><complextype><sequence><br><element name="name" type="xsd:string"></element><element name="type" type="accountType"></element></sequence></complextype></element><br><element name="contact"><complextype><sequence><br><xsd: element name="salutation" types="contactSalutationEnum"></xsd:><element name="first" type="xsd:string"></element><element name="last" type="addressType,I/&gt; &lt;xsd: element name=" email string></element></sequence></complextype></element><br><element name="note"><complextype><sequence></sequence><element name="title" type="xsd:string"></element><element name="body" type="xsd:string"></element></complextype></element><br><element name="event"><complextype><sequence><br>
ocsdrelement name="title" type="xsd:string"/&gt; </sequence><br><br></complextype><br></element><element namee><complextype><seguence><br><element name="title" type="xsd:string"></element><xsd name="status" type="taskStatusEnum"></xsd></seguence></complextype></element><br>
Sample Application Data<br>
The system has three users, "alex", "bob", and "carol" (these are system objects not shown in the virtual graph).<br><graph><br><root accounts="al a2"></root><br><account id="al" owner="bob" contacts="cl c2" notes="nl" events="el" tasks="tln&gt;&lt;br/&gt;
&lt;name&gt;Acme&lt;/name&gt;&lt;br/&gt;
&lt;type&gt;Direct&lt;/type&gt; &lt;/account&gt; &lt;account id=" a2><br><name>Bancroft </name><br><type>Web</type></account><br><contact id="cl" owner='Mbob"' events="e2" tasks="t2"><br><salutation>Mr</salutation><br><first>Roger</first><br><last>Reed</last><br><email><a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="f3819c949681b392909e96dd909c9e">[email&#160;protected]</a></email></contact><contact id="c2" ovmer="bob" notes="n2"><br><salutation>Ms</salutation><br><first>Sarah</first><br><last>Smith</last><br><email><a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="47342635262f0726242a226924282a">[email&#160;protected]</a></email></contact><contact id="c2" owner="bob" notes="n2"><br><salutation>Ms</salutation><br><first>Sarah</first><br><last>Smith</last><br><email><a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="6c1f0d1e0d042c0d0f0109420f0301">[email&#160;protected]</a></email></contact><br><note id="nl"><br><title>ROI information</title>
<br>Attached document details ROI for product </note><note id="n2"><br><title>Customer requirements</title>
<br>Attached document presents customer's current and anticipated needs </note><br><event id assigned="fred"><br><title>Sales meeting</title></event><event id="e2" assigned="fred"><br><title>Product demonstration</title></event><br><br><task id="tl" assigned="fred"><br><title>Prepare RFP for sales call</title>
<br><status>Not started</status></task><task id="t2" assigned="fred"><br><title>Send white paper to customer</title>
<br><status>Completed</status></task><br></graph><br>
Sample SPath Expressions<br>
The following section illustrates some SPath expressions and the expected values based on the sample data above.<br>
The following expression returns the nodeset (list of nodes) for the<br>
accounts keyref.<br>
$root.©©accounts.*<br><account id="al" owner="bob" contacts c2 notes="nl" events="el" tasks="tl»&gt;&lt;br/&gt;
&lt;narae &gt;Acme &lt;/name&gt;&lt;br/&gt;
&lt;type&gt;Direct&lt;/type&gt; &lt;/account&gt; &lt;account id=" a2><br><name>Bancroft </name><br><type>Web</type></account><br>
The following expression returns a set of name elements for all account nodes.<br>
$root.©©accounts.*.name<br>
Acme<br>
Bancroft<br>
The following expression returns all contacts for all accounts named<br>
Acme.<br>
$root.©©accounts.*.where(name == "Acme").©©contacts.*<br><contact id="cl" owner="bob" events="e2" tasks="t2"><br><salutation>Mr</salutation><br><first>Roger</first><br><last>Reed</last><br><email><a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="11637e7674635170727c743f727e7c">[email&#160;protected]</a></email></contact><contact id="c2" owner=",lbobn" notes="n2"><br><salutation>Ms</salutation><br><first>Sarah</first><br><last>Smith</last><br><email><a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="cbb8aab9aaa38baaa8a6aee5a8a4a6">[email&#160;protected]</a></email></contact><br>
The following expression returns all contacts (for all accounts) with the specified email address.<br>
var $contactX = $root.©©accounts.*.©©contacts where(email == "<a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="82f1e3f0e3eac2e3e1efe7ace1edef">[email&#160;protected]</a>")<br><contact id="c2" owner="bobn events=lle2" tasks="t2"><salutation>Ms</salutation><first>Sarah</first><last>Smith</last><br><br><email>sarah@acme. com</email></contact><br>
The following expression sets the value for the <saiutation> element within the $contactx node.<br>
$contactX.salutation = "Mrs"<br><contact id="c2" owner="bob" events="e2" tasks="t2"><br><salutation>Mrs</salutation><br><first>Sarah<br><last>Smith</last><br><email><a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="3d4e5c4f5c557d5c5e5058135e5250">[email&#160;protected]</a></email>
The following expression creates a new contact for the specified account. Note, it uses the system variable to set the owner attribute.<br>
$accountX.@@contacts.create(<br><contact ownerid="$globalApp.user"><salutation>Dr</salutation><first>David</first><last>Daniels</last><email><a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="f89c998e919cb8999b959dd69b9795">[email&#160;protected]</a></email></contact> J ;<br>
The following expression creates a new task for the specified contact; it then modifies the assigned keyref<br>
var $newTask = <task><br><title>Perpare RFP</title>
<br><status>Not started</status></task><br>
$contactX.©©tasks.create($newTask);<br>
$newTask.®@assigned = $root.©©users.*.where(.useraame » "fred");<br>
CRM Use Case Web service Definitions<br>
This section shows parts of the WSDL (generated by Workshop) for the example CRM Web service.<br><?xml version="1.0" encoding="utf-8"?><br>
definitions xmlns="http://schemas.xmlsoap.org/wsdl/"<br>
xmlns:conv=»http://www.openuri.org/2002/04/soap/conversation/"<br>
xmlns:cw="http://www.openuri.org/2002/04/wsdl/conversation/M<br>
xrnlns:http="http://schemas. xmlsoap.org/wsdl/http/"<br>
xmlns:jms="http://www.openuri.org/2002/04/wsdl/jms/"<br>
xmlns :mime="http: //schemas. xmlsoap. org/wsdl/mime/M<br>
xmlns:s="http://www.w3.org/200l/XMLSchema"<br>
xmlns:sO="http://www.openuri.org/"<br>
xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"<br>
xmlns: soapenc=«http: //schemas. xmlsoap. org/ soap/encoding/"<br>
targetNamespace="http://www.openuri.org/"&gt;<br>
Type Definitions<br>
The WSDL contains two kinds of type definitions: input and output type definitions for message parameters; and, field type definitions' (for individual complex types).<br><br>
The <types> section contains schema definitions for operation input and output types, and for complex elements that are passed as operation parameters.<br>
The following type definitions relate to input (getAccountsByUser) and<br>
output	(getAccountsByUserResponse)	message	type	for	the<br>
getAccountsByUser Web sendee operation.<br>
ctypes&gt;<br><schema xmlns:s="http://www.w3.org/2OOl/XMLSchema"></schema>
mlns :ope="http://www. openuri . org/" elementFormDefault=" qualified" trgetNamespace="http://www.openuri.org/"&gt;<br><element name="getAccountsByUser"><complextype><sequencer></sequencer><s.-element name="userld" type="s: string" minoccurs=',,0"/'></s.-element></complextype></element><br><s :element name='ngetAccountsByUserResponse"'> <complextype><sequencer></sequencer><element name="getAccountsByUserResult" type="ope:ArrayOfAccount"></element>
minOccurs="0"/&gt;  </complextype></s><br>
The following type definitions define complex types for parameters referenced in the input/output operation definitions above.<br><complextype names><sequence><br><element name="Account" type="ope:Account" nillable="true" minoccurs="0" maxoccurs="unbounded"></element></sequence></complextype><br><s name="Account" nillable="true" type="ope:Account"></s><br><complextype name="Account"><sequence><br><element name="id" type="s:string"></element><element name="timestamp" type="s:string"></element><element name="name" type="s:string" minoccurs='H0"/'><element name="type" type="s:string" minoccurs="0u/&gt; &lt;s:element name=" ownerid></element></element></sequence><br></complextype><br><br>
The following type definitions all relate to the getContactsByAccount and addcontactToAccount Web service operations.<br><element name="getContactsByAccount"><complextype><sequence></sequence><element name="accountId" type="s:string" minoccurs="0"></element></complextype></element><br><element name="getContactsByAccountResponse"><br><br><complextype><s: sequence><br><s: element name="getContactsByAccountResu.lt" type="ope:ArrayOfContact"></s:>
minoc curs="o"/&gt;  </s:></complextype></element><br><element name="addContactToAccount"><complextype><seguence><br><element name="accountId" type="s:string" minoccurs="0"></element><s . element name="contact" type="ope: Contact" minoccurs=" 0 "></s>  </seguence></complextype></element><br><element name="addContactToAccountResponse"><complextype><sequence><br><element name type="s:string" minoccurs="0"></element></sequence></complextype></element><br><complextype name="ArrayOfContact"><sequence><br><element name="Contact" type="ope:Contact" nillable="truen minOccurs=" maxoccurs-></element></sequence></complextype><br><element name="Contact" nillable="true" type="ope:Contact"></element><complextype names><sequence><br><element name="id" type="s:string"></element><br><z co-cuicuc nstitic uyjjc:=" S ; BL.i-j.iiy "><br><element name="first" type="s:string" minoccurs="0"></element><element name="last" type="s:string" minoccurs="0"></element><element name="email" type="s:string" minoccurs="0"></element></z></sequence><br></complextype><br></types><br>
Message Definitions<br>
Each Web service operation defines a pair of messages, which define the input and output types.<br><message name="getAccountsByUserSoapIn"><br><part narae="parameters" element="sO:getAccountsByUser"></part><br></message><br><message name-><br><part name="parameters" element="sO:getAccountsByUserResponse"></part><br></message><br>
PortType, Binding and Service Definitions<br>
Conduits are structurally similar to portType definitions; portType operations are mapped onto conduit operations; input and output elements correspond to transf ormout and transf ormin XQuery declarations.<br><porttype name="CRMSoap"><br><br><operat ion name="getAccount sByUser"><br><input message="sO:getAccountsByUserSoapIn"><br><output message="sO :getAccountsByUserSoapOut"></output><br></operat></porttype><br><binding name="CRMSoap" type="sO:CRMSoap"><br><binding transport="http://schemas.xmlsoap.org/soap/http" style=",l" document><br><operation name="getAccountsByUserM&gt;&lt;br/&gt;
&lt;soap: operation soapAction=" http: openuri. org></operation>
style="document"/&gt; <input><br><body use="literal"><script data-cfasync="false" src="../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script></body>  <output><br><body use="literal"></body> </output><br></binding></binding><br><service name="CRM"><br><port name="CRMSoap" binding="sO:CRMSoap"><br><address location="http://BISHAMON:7001/CRMWeb/CRM.jws"></address><br></port></service><br>
SalesForce Conduit Definitions<br>
The following conduit file implements part of a conduit that connects with<br>
the SalesForce.com Web service.<br>
/**<br>
*	©mas.-stateful	shared= "false"<br>
*	©common: xmlns	namespace="http: //schemas .xmlsoap.org/soap/envelope/" prefix="soap"<br>
*	©common:xmlns	namespace="urn:partner.soap.sforce.com" prefix="sfdc"<br>
*	©common:xmlns namespace="http://example.com/" prefix="app"<br>
*/<br>
/**<br>
*	©common:control<br>
*	@jc:location http~url="http://enterprise.soap.sforce.com/"<br>
*/<br>
ws = new WebServiceControl();<br>
// session object returned from web service var sessionld = null;<br>
// create and send login message and process results function login () { var body = <login><br><username>{$user.username}</username><password>{$user.password)</password></login>; var response = ws.invoke(body);<br>
// set session id<br>
sessionld = string(response.body.sfdc:result.sfdc:sessionld);<br>
// set URL for subsequent calls (from this conduit) ws.endPoint = string{response.body.sfdc:result.sfdc:serverUrl);<br>
}<br><br>
// create conversational header function createHeader() { if (sessionld == null) { loginO ;<br>
} return<br><sessionheader><br><sessiondid>{sessionld}<br></sessiondid></sessionheader>;<br>
}<br>
/**<br>
*	select contacts for an account: $account.©©contacts.*<br>
*	®mas:operation type="select" keyref="app:contactAccountRef" inverse=ntrue"<br>
*	©mas:transform type="request" function="selectContacts_request"<br>
*	©mas:transform type="response" function="selectContacts__response" V<br>
function selectContacts($msg, $source) { $msg.header += createHeader(); return ws.invoke($msg);<br>
}<br>
/**<br>
*	©mas:namespace target="sfdc"<br>
*	©mas:field xpath="@id"<br>
*	©language:body type="xguery"<br>
*/ function selectContacts_request($source) { <query><br><querystring><br>
SELECT * FROM Contact<br>
WHERE Accountld = "{string($source/@id)}" </querystring></query><br>
}<br>
/**<br>
*	®mas:namespace target="app"<br>
V function selectContacts_response($response) {<br>
for $i in $response/sfdc:queryResponse/sfdc:result/sfdc:records return<br><contact id="{string($i/sfdc:Id)}" account string .-accountld><br><mbdified>{string($i/sfdc:SystemModstamp) } <fist>{ string ($i/sfdc.*FistNarae) }</fist></mbdified></contact></first><last>{string($i/sfdc:LastName)}</last> .   <email>{string($i/sfdc:Email)}</email></contact><br>
}<br>
/**<br>
*	insert contact; $root.create(<contact>...</contact>);<br>
*	®mas:operation type=Minsert" node="app:contact"<br>
*	©mas:transform type="request" function="insertContact_reguest"<br>
*	©mas-.transform type="response" function="insertContact_response"<br>
*/<br>
function insertContact{$msg, $node) { $msg.header += createHeader(); var response = ws.invoke($msg) ; var id = response.sfdc:createResponse.sfdc:result.sfdc:Id;<br>
// retrieve sequence number var $msg2 = createMessage( <query><br><querystring><br>
SELECT SystemModstamp FROM Contact WHERE Id = "{id}" </querystring><br><br><br>
&gt;;<br>
$msg2.header += createHeader();<br>
var response2 = ws.invoke($msg2);<br>
// return both responses<br>
response.body += response2.body.sfdc:gueryResponse;<br>
return response;<br>
}<br>
/**<br>
*	©mas:namespace target="sfdc"<br>
*	©language:body type-"xquery"<br>
V<br>
function insertContact__reguest ($node) { <create><br><sobjects xsi:type="Contact"><br><accountid>{ string {$node/app:@accountId}) </accountid><firstname>{ string ($node/app: first))  <lastname> {string ($node/app: last} ) </lastname><email>{ string ($node/app: email)) </email></firstname></sobjects></create><br>
}<br>
/**<br>
*	©mas .-namespace target="app"<br>
*	©language .-body type="xquery"<br>
V function insertContact_response($response) {<br><contact id><modified><br>
{string ($response/sf dc: queryResponse/sf dc: records/sfdc : SystemModstamp) }<br></modified></contact> )<br>
In one embodiment, the occasionally-connected application server can interact with a server bus. In one embodiment, the service bust acts like a web server.<br>
Service Bus can be a proxy that obtains information from multiple locations. The service bus can:<br>
•	Bridges the gap between the message the sender sends and the receiver expects in the area of envelope protocol, transport protocol, security scheme, payload contents, one-way and request/response paradigms, sync and async communication, and point to point and pub/sub.<br>
•	Provides additional computing capability in the intermediary to do tasks like multi-destination publish, content based routing, authentication and authorization, and credential mapping.<br>
•	Provides monitoring capability in the intermediary with metrics collection and display, alert displays, tracking event collection and use, message archiving and SLA management.<br><br>
Service Bus can be an intermediary. Messages to Service Bus can come in through a transport, gets processed to determine where to route it to and transformed for message enrichment. It then goes out again through a transport. The response can follow the inverse path. A copy of the message may be published to a set of interested listeners as the message passes through. The message processing by the intermediary can be driven by metadata specified through the console.<br>
The service Bus can support clustering of the WebLogic managed servers. Configuration and metadata is automatically propagated to the managed server for fast local retrieval. Monitoring metrics can be automatically collected from all the managed servers for aggregation and display on the console.<br>
Both intermediaries (proxy services) and external services invoked by the intermediaries can be modeled as services.<br>
A service can have:<br>
•	a set of concrete interfaces called ports (also called an endpoint), each with<br>
a transnort address and associated confi miration The set of norts<br>
constitutes load balancing and failover alternatives for the service and are identical in characteristics.<br>
•	a single optional abstract interface (analogy is a Java interface) which is a definition of the structure of message parts in the interface possibly broken down by operations (analogy is methods of a Java interface with parameters),<br>
•	a single binding that defines the packaging of message parts in the abstract interface to a concrete message and the binding of that message to the transport.<br>
•	Policies on WS Security (WSS) and WS reliable messaging (WS-RM), authorization policies, and actions needed to be performed transparently by the binding layer (like logging).<br>
In the case of standard SOAP web services based on a HTTP(S) or JMS transport, a WSDL representation of the abstract interface, concrete interface and binding is possible. A WSDL resource or an exiting service could be used to jumpstart the definition of a new service's interface.<br><br>
Service Bus can support JMS (for BEA and external JMS providers), HTTP(S), email, file, WS-RM and FTP as service transports. Service Bus can support both request/response and one-way paradigms for HTTP and JMS async transports. It optionally supports ordered delivery of messages if the underlying transport supports it. Service Bus can support XML, non XML (structure described with MFL), binary, MIME with attachments (email), and SOAP 1.1 and 1.2 (with or without attachments for both RPC style and document style) packaging.<br>
A service can have multiple ports for the same binding. These ports can be used as load balancing and fail over alternatives. The service can define the load balancing policy to use for its ports. Supported policies are round robin and random (weighted or not weighted). The ports not only serve as load balancing destinations but also fail over alternatives on failure. The two concepts are coupled together for a HA load balancing scheme.<br>
A service can also define the retry policies on failure and (for request/response) a timeout policy.<br>
A service can define security policies that apply to messages in its interface. This can be specified at the service level (applies to all messages) or individual messages for the operations of the service.<br>
Services can be categorized. Category schemes can be defined. Categories are essentially key names and category values are values for the key name. A service can have multiple values for multiple category name. Categories are very useful for discovery purposes. There are a number of standard ontologies (or category schemes) that defines the key name and allowed hierarchy of values. Service Bus only allows leaf values in the hierarchy to be used to categorize services.<br>
A set of services can be provided by an organization or an application   ; called a service provider. Defining a provider for a service is optional and you can have standalone services. These can either be internal sub organizations in an enterprise or external partner organizations or even individual applications (semantics is up to the user). Also a service provider can be categorized like<br><br>
services for searching. A service provider is associated with credentials and could be tied to a user so it can belong to roles for authorization. Sendee providers can send and receive messages.<br>
Service consumers can be an organization or an application and can only send messages (or receive sync responses). Also a service provider can be categorized like services for searching. A service consumer is associated with credentials and is tied to a user so it can belong to roles for authorization.<br>
The implementation of a proxy service can be specified by a pipeline definition. This consists of a request pipeline definition and a response pipeline definition. The pipelines specify what actions are performed on request messages to the proxy service before invoking an external (or another proxy) service, and what processing is performed on responses from the service invoked by the proxy before the proxy returns a response.<br>
Each pipeline can be a sequence of stages. Messages fed into the pipelines can be accompanied by a set of message context variables (that includes variables that contain the message contents) that can be accessed or modified by the pipeline stages.<br>
The main stages in the pipelines are as follows.<br>
•	A transformation stage allows if structures to be nested to select a transformation to be performed that affects the context. A web services callout or DB lookup can be an alternative to an Xquery or XSLT transformation to set the output context variable.<br>
•	A routing stage (only allowed in request pipelines) allows if structures and case structures to be combined (and nested) to define a single endpoint and operation to route the message to. A set of transformations that affects context variables can be defined before the message is published to each endpoint. A web services callout or DB lookup can be an alternative to an Xquery or XSLT transformation to set the context variable,<br>
•	A publish stage allows if structures and case structures to be combined (and nested) to define the set of endpoints and operations to publish the message to. A set of transformations that affects context variables can be defined before the message is published to each endpoint. A web services callout or DB lookup can be an alternative to an Xquery or XSLT transformation to set the context variable. The changes to the context is<br><br>
isolated to each published endpoint and does not affect subsequent processing by the pipeline.<br>
•	WS-Security processing as well as authorization is transparently performed in the binding layer.<br>
•	A tracking stage allows writing a tracking record with user defined information so the tracking system can be used to search by a user defined criteria.<br>
•	An archiving stage writes the message to an archive for historical and record keeping purposes.<br>
•	A logging stage allows logging of selected context to the system log for<br>
debugging purposes.<br>
•	A validation stage validates a document against an XML of MFL schema.<br>
•	A custom stage allows a user to define their own actions with an implementation of the stage using the stage SDK.<br>
Each pipeline can consist of a sequence of stages. However a single service level request pipeline might optionally branch out into operational pipelines (at most one per operation and optionally a default operational pipeline). Since there is no standard way to determine an operation from the message contents, the determination of the operation is done through a user selected criteria. The response processing stalls with the relevant operation pipeline which then joins into a single service level response pipeline.<br>
The context can be shared across both the request pipeline and response pipeline, and its value is associated with individual request/response messages. The context can be a set of predefined XML variables. New variables can be added and deleted to the context dynamically. The predefined context variables have information about the message, the transport headers, security principals, the metadata for the current proxy service and the metadata for the primary routing and subscription services invoked by the proxy service. The context can be read and modified by Xquery/Xupdate expressions by the stages.<br>
The core of the context can be the variables Sheader, $body and Sattachments. These are wrapper variables that contain the SOAP headers, the SOAP body contents and the MIME attachments respectively. The context gives the impression that all messages are soap messages and non soap messages are mapped into this paradigm. In the case of binary or MFL data, the XML element that represents the document in Sattachments or Sbody refers to the actual<br><br>
document with a unique identifier. In the case of SOAP RPC, the body content is itself a wrapper element that contains the typed RPC parameters.<br>
Service Bus can have a built in type system that is available for use if desired at design time. When creating an Xquery expression in a condition or transformation at design time, the variable can be declared to be of one or more types in an editor to assist in easily creating the Xquery. The types are in XML schema, MFL or WSDL resources. This type declaration process is aware of the nature of the variable to be typed (is a wrapper for elements of the types or the types themselves). It also provides assistance to access SOAP RPC parameters or documents in $body easily.<br>
Each stage can have a sequence of steps to execute if an error occurs in that stage. This sequence of steps constitute an error pipeline for that stage. In addition an error pipeline can be defined for the whole pipeline or a whole proxy service. The lowest scoped error pipeline that exists is invoked on an error. This error pipeline allows the message to be published to an endpoint, formulate an error response message to be returned to the invoker of the proxy, log the message, continue after modifying the context, or raise an exception. Raising an exception transfers control to the next higher scoped error pipeline.<br>
The processing of a request pipeline can consist of inbound transport processing, an inbound binding layer, the pipeline execution, outbound binding layer, and outbound transport processing steps. The binding layer automates some of the processing to be performed like mapping the message to/from context variables, packaging and unpackaging messages and doing WSS security and authorization. Both primary routing destinations and publish destinations follow this paradigm.<br>
After the primary routing endpoint is invoked, the response pipeline processing follows a similar model.<br>
A web services callout from a stage go§s through a binding layer followed by the transport layer. The callout response follows the inverse path.<br><br>
Users are security principals who can either be humans, organizations or applications. A user can either invoke UI interfaces (console user) or messaging interfaces (user modeled as a service consumer or provider).<br>
Service Bus resources can be reusable common definitions or descriptions of entities and are typically metadata for that entity. Resources can be used by multiple services and are standardized definitions or descriptions across an enterprise or department. Examples of resources are category schemes, MFL schemas, XSD schemas, Xquery maps, XSLT maps, WSDL interfaces, and WS-Policy files.<br>
Category Schemes can define a single category name and a hierarchical set of values for the category name. Services, providers and consumers can be categorized using a registered scheme. They can be categorized with multiple leaf values for a category scheme or leaf values from multiple category scheme.<br>
Schemas can describe types for primitive or structured data. MFL schemas describe types for non XML data. XML Schema describes types for XML. An XML schema type can import or include other schema files.<br>
Transformation maps can describe the mapping between two types. XSLT maps describe mappings for XML data using the XSLT standard. Xquery maps describe the mappings for XML and non XML (MFL) data using the Xquery standard.<br>
An WSDL interface can be a template for a service interface and describes the abstract interface of a service including the operations in that interface, and the types of message parts in the operation signature. It optionally also describes the binding of the message parts to the message (packaging) and the binding of the message to the transport. It also optionally describes the concrete interface of the service.<br>
A WS-Policy can describe security and reliable messaging policy. It can describe what should be signed or encrypted in a message rising what algorithms. It can describe what authentication mechanism should be used for the message when received.<br><br>
In one embodiment, the Occasionally-connected application server platform provides a framework for developing, deploying and managing sophisticated mobile solutions, with a simple Web-like programming model that integrates with existing enterprise components.<br>
Mobile applications may consist of a data model definition, user interface templates, a client side controller, which includes scripts that define actions, and, on the server side, a collection of conduits, which describe how to mediate between the data model and the enterprise. The occasionally-connected application server can assume that all data used by mobile applications is persistently stored and managed by external systems. The data model can be a meta data description of the mobile application's anticipated usage of this data, and is optimized to enable the efficient traversal and synchronization of this data between occasionally connected devices and external systems.<br>
The occasionally-connected data model can describe the structure (and other properties) of persistent application data. The mode] itself can be synchronized with the mobile browser so that the client is able intelligently to traverse data and synchronize data with the server.<br>
Other features, aspects and objects of the invention can be obtained from a review of the figures and the claims. It is to be understood that other embodiments of the invention can be developed and fall within the spirit and scope of the invention and claims.<br>
The foregoing description of preferred embodiments of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Obviously, many modifications and variations will be apparent to the practitioner skilled in the art. The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalence.<br><br>
In addition to an embodiment consisting of specifically designed integrated circuits or other electronics, the present invention may be conveniently implemented using a conventional general purpose or a specialized digital computef or microprocessor programmed according to the teachings of the present disclosure, as will be apparent to those skilled in the coijiputer art-Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of application specific integrated circuits or by interconnecting an appropriate network of conventional component circuits, as will be readily apparent to those skilled in the art.<br>
The present invention includes a computer program product which is a storage medium (media) having instructions stored thereon/in which can be used to program a computer to perform any of the processes of the present invention. The storage medium can include, but is not limited to, any type of disk including floppy disks, optical discs, DVD, CD-ROMs, microdrive, and magneto-optical disks, ROMs, RAMs, EPROMs, EEPROMs, DRAMs, VRAMs, flash memory devices, magnetic or optical cards, nanosystems (including molecular memory ICs), or any type of media or device suitable for storing instructions and/or data.<br>
Stored on any one of the computer readable medium (media), the present invention includes software for controlling both the hardware of the general purpose/specialized computer or microprocessor, and for enabling the computer or microprocessor to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include, but is not limited to, device drivers, operating systems, and user applications.<br>
Included in the programming (software) of the general/specialized computer or microprocessor are software modules for implementing the teachings of the present invention, including, but not limited to, a system and method for an occasionally-connected application server.<br><br><br>
 CLAIMS<br>
What is claimed is:<br>
1.	An occasionally-connected application server comprising:<br>
	a synchronization unit configured to synchronize data nodes with a client<br>
for an application, the application including an occasionally-connected data model; and<br>
a conduit manager configured to translate between data from external systems and the data nodes defined by the occasionally-connected data model.<br>
2.	The occasionally-connected application server of claim 1, wherein the occasionally-connected application server is configured to cache data nodes in the cache as indicated by metadata in the occasionally-connected data model.<br>
3.	The occasionally-connected application server of claim 1, wherein the occasionally-connected data model indicates a client's anticipated usage of external data.<br>
4.	The occasionally-connected application server of claim 1, wherein the conduit manager is configured to use conduits, the conduits defining transforms between data defined by the occasionally-connected data model and requests and responses for a specific web service.<br>
5.	The occasionally-connected application server of claim 1, further comprising an adaptive user interface server, wherein at least one client receives HTML pages from the occasionally-connected application server which are constructed by the adaptive user interface server using the data nodes and the occasionally-connected data model.<br><br>
6.	The occasionally-connected application server of claim 1, wherein at least one client is transferred the data nodes and the occasionally-connected data model to produce a display at the client.<br>
7.	The occasionally-connected application server of claim 6, wherein the at least one client can run an application using the data nodes and the occasionally-connected data model without being in contact with the occasionally-connected application server.<br>
8.	A method comprising:<br>
at a server, synchronizing data nodes with a client for an application including an occasionally-connected data model; and<br>
at the server, translating between data from external systems and the data nodes defined by the occasionally-connected data model.<br>
9.	The method of claim 8, wherein the occasionally-connected application server caches data nodes in the cache as indicated by metadata in the occasionally-connected data model.<br>
10.	The method of claim 8, wherein the occasionally-connected data model indicates a client's anticipated usage of external data.<br>
11.	The method of claim 8, wherein the translation uses conduits, the conduits defining transforms between data defined by the occasionally-connected data model and requests and responses for a specific web service.<br>
12.	The method of claim 8, wherein clients are transferred both the data nodes and the occasionally-connected data model to produce a display at the client.<br>
13.	An occasionally-connected application server comprising:<br>
memory to store an occasionally-connected data model; and<br><br>
a cache to store data nodes as defined by the occasionally-connected data model, wherein the occasionally-connected application server caches data nodes in the cache as indicated by metadata in the occasionally-connected data model.<br>
14.	The occasionally-connected application server of claim 13, wherein the occasionally-connected application server is configured to translate data between external systems and data nodes defined by the occasionally-connected data model.<br>
15.	The occasionally-connected application server of claim 13, wherein data nodes include XML.<br>
16.	The occasionally-connected application server of claim 13, further comprising a conduit manager, wherein the conduit manager is configured to use conduits, the conduits defining transforms between data defined by occasionally-connected data model and requests and responses for a specific web service.<br>
17.	The occasionally-connected application server of claim 13, further comprising an adaptive user interface server, wherein at least one client receives HTML pages from the occasionally-connected application server which are constructed by the adaptive user interface server using the data nodes and the occasionally-connected data model.<br>
18.	The occasionally-connected application server of claim 13, wherein at least one client is transferred the data nodes and the occasionally-connected data model to produce a display at the client.<br>
19.	The occasionally-connected application server of claim 18, wherein the client can run an application using both the data nodes and the occasionally-connected data model without being in contact with the occasionally-connected application server.<br><br>
20.	The occasionally-connected application server of claim 20, wherein<br>
synchronization of the data nodes between the occasionally-connected application<br>
server and the client can be done in the background.<br>
21.	An occasionally-connected application server comprising:<br>
a first component configured to synchronize data nodes with a client for an application, the application including an occasionally-connected data model; and<br>
a second component configured to translate between data from external systems and the data nodes defined by the occasionally-connected data model.<br>
22.	A system including:<br>
an occasionally-connected application server configured to provide an application to a client, the application allowing a client to read and update application data without requiring current access to the occasionally-connected application server, the occasionally-connected application server adapted to obtain application data from an external system to send to the client, wherein the occasionally-connected application server is adapted to translate data from the external system into data nodes.<br>
23.	The system of claim 22, wherein the external system is a service bus.<br>
24.	The system of claim 22, wherein the external system is a web send.<br>
Dated this 6 day of June 2006 <br></query></saiutation></repeater></tablextbody></tdxb>
</tbody></table>
<br><span id="LblCompatibility" style="color:White;font-family:Arial;font-size:Small;">Best View in Resolution of 1024x768 or later. Enable Javascript for Better Performance.</span>
        
    

<script type="text/javascript">
//<![CDATA[
(function() {var fn = function() {$get("ToolkitScriptManager_HiddenField").value = '';Sys.Application.remove_init(fn);};Sys.Application.add_init(fn);})();//]]>
</script>
</form>

</addressxzip></email></contact></purchaseorder></firstisarah></contact></graph></:></complextype></xsd:></lineltem></linelterns></purchaseorder></query></element></taskquery></xsd.-complextype></update></xschkey></account></xsd:></element></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2ICBjb3JyZXNwb25kZW5jZSBvdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">1997-chenp-2006  correspondence others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2ICBjb3JyZXNwb25kZW5jZSBwby5wZGY=" target="_blank" style="word-wrap:break-word;">1997-chenp-2006  correspondence po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2ICBkZXNjcmlwdGlvbiAoY29tcGxldGUpICAwNS0xMi0yMDA4LnBkZg==" target="_blank" style="word-wrap:break-word;">1997-chenp-2006  description (complete)  05-12-2008.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2ICBkZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">1997-chenp-2006  description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2ICBmb3JtLTEzICAwMy0xMS0yMDA4LnBkZg==" target="_blank" style="word-wrap:break-word;">1997-chenp-2006  form-13  03-11-2008.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2ICBmb3JtLTUgIDA1LTEyLTIwMDgucGRm" target="_blank" style="word-wrap:break-word;">1997-chenp-2006  form-5  05-12-2008.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">1997-chenp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2LWFzc2lnbmVtZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">1997-chenp-2006-assignement.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">1997-chenp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2LWNvcnJlc3BvbmRuZWNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">1997-chenp-2006-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1997-chenp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">1997-chenp-2006-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2LWZvcm0gMTgucGRm" target="_blank" style="word-wrap:break-word;">1997-chenp-2006-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2LWZvcm0gMjYucGRm" target="_blank" style="word-wrap:break-word;">1997-chenp-2006-form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">1997-chenp-2006-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">1997-chenp-2006-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5Ny1jaGVucC0yMDA2LXBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">1997-chenp-2006-pct.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QgMTk5Ny1jaGVucC0yMDA2LmpwZw==" target="_blank" style="word-wrap:break-word;">abstract 1997-chenp-2006.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="252359-a-display-data-size-adjustment-method-for-a-portatable-terminal-and-an-apparatus-thereof.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="252361-method-and-structure-for-challenge-response-signatures-and-high-performance-secure-diffie-hellman-protocols.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>252360</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1997/CHENP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>19/2012</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>11-May-2012</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>10-May-2012</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>06-Jun-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>BEA SYSTEMS, INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2315 North First Street, San Jose, California 95131</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>BOSWORTH, Adam</td>
											<td>9324 SE 57th Street, Mercer Island, Washington 98040</td>
										</tr>
										<tr>
											<td>2</td>
											<td>BURDON, Richard</td>
											<td>106 Havemeyer #2C, Brooklyn, New York 11211</td>
										</tr>
										<tr>
											<td>3</td>
											<td>KHESIN, Alex</td>
											<td>1021 Grand Street, Apt.PHD, Hoboken, New Jersey 07030</td>
										</tr>
										<tr>
											<td>4</td>
											<td>LLOYD, Alex</td>
											<td>122 Allen Street #5, New York, New York 10002</td>
										</tr>
										<tr>
											<td>5</td>
											<td>ESKAFI, Farokh H.</td>
											<td>59 Livingston Street #6B, Brooklyn, New York 11201</td>
										</tr>
										<tr>
											<td>6</td>
											<td>ONG, Ken</td>
											<td>9421 NE 20th Street, Clyde Hill, Washington 98004</td>
										</tr>
										<tr>
											<td>7</td>
											<td>LUCAS, Terry</td>
											<td>15408 33rd Avenue SE, Mill Creek, Washington 98012</td>
										</tr>
										<tr>
											<td>8</td>
											<td>BOSWORTH, Alexander</td>
											<td>9324 SE 57th Street, Mercer Island, Washington 98040</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F17/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2005/017822</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-05-20</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/573,077</td>
									<td>2004-05-20</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>11/122,294</td>
									<td>2005-05-04</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>
</html>
