<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/221435-a-system-and-method-for-transmitting-data-in-a-network-by-compression-technique by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:38:41 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 221435:A SYSTEM AND METHOD FOR TRANSMITTING DATA IN A NETWORK BY COMPRESSION TECHNIQUE</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A SYSTEM AND METHOD FOR TRANSMITTING DATA IN A NETWORK BY COMPRESSION TECHNIQUE</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method of transmitting in a network between a source and a receiver a current header field of a current packet using a timer-based compression technique, comprising the steps of: providing from a compressor to() a decompressor an initial value of a header field; calculating at the compressor a compressed header field of the current packet based on the current header field of the current packet and jitter, characterized in the said calculating step comprises the steps of: calculating a jitter effect the network between a source and said decompressor has on the transmission of packets, and calculating the compressed header field as a I portion of a field value, said portion being a function of jitter; receiving the compressed header field of the current packet at the decompressor; estimating the header field of the current packet based on elapsed time at the decompressor between reception of the compressed header field of the current packet and reception of a header field of a previous packet which was decompressed and a decompressed field f i &#x27;- - value of the previous packet; and correcting the estimated current header field based on the compressed header field received at the decompressor.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>TECHNICAL FIELD<br>
The present invention relates to a method and apparatus for compressing a header field in a data packet.   More particularly, the present invention relates to a method and apparatus for compressing a header field ofa data packet using a Timer and a Reference Based Scheme.<br>
For Internet Protocol (IP) based real-time multimedia, Real-Time Transfer Protocol (RTP) protocol is predominantly used on top of User Datagram Protocol (UDP/ IP. RTP is described in detail in RFC 1889. The size of the combined IP/UDP/RTP headers is at least 40 byles for IPv4 and at least 60 bytes for IPv6. 40-60 bytes overhead per packet may be considered heavy in systems (e.g., such as cellular nelworks) where spectral efficiency is a primary concern. Consequently, a need exists for suitable IP/UDP/RTP header compression mechanisms. A current header compression scheme is described in RFC2508, which is able to compress the 40/60 byte IP/UDP/RTP header down lo 2 or 4 bytes over point-to-point links. The existing header compression algorithms are based on the observation that most fields of the IP packet headers remain constant in a packet stream during the length ofa session. Thus, it is possible to compress the header information by establishing a compression state (ihe full header information) at the de-compressor and by simply carrying minimal amount of header information from the compressor to the de-compressor.<br>
RFC2508 is based on the idea that most of the time, the RTP fields that change from one packet lo the next, such as the RTP time stamp, can be predicted by linear extrapolation. Essentially the only information that has to be sent is a sequence number, used for error and packet loss detection (as well as a context ID). When the sender determines that linear extrapolation cannot be applied to the current packet, a first order difference information with respect to the immediately preceding packet is sent. To initiate the session, a hill header is sent. In addition, when the receiver determines that there is packet loss (as detected by a sequence number incrementing by more than t) the receiver will explicitly request the sender to transmit the full header in order to allow a re-synchronization.<br>
However, the header compression defined in RFC2508 is not well suited for certain environments (such as cellular or wireless environments), where bandwidth is at a premium and errors are common. In the RFC2508 header compression scheme, the RTP time stamp is assumed to have most of the time a linearly increasing pattern. When the header conforms to the pattern, essentially only a short sequence number is needed in the compressed header. When the header does not conform to the partem, the difference between the RTP time stamps of the current header and of the previous one is sent in the compressed header. Further optimization is possible by using a coding table. This approach has three drawbacks. The first one is that it is not robust to errors, as the loss of the previous header will invalidate the decompression of the current header. The second one is that RTP time stamp<br><br>
ainerences or jumps can be very large, thus overflowing the coding look up table. For example, if the medium is voice, such large differences can be caused by a silence interval. The third one is that the size of the resulting encoded difference is variable, which makes it more difficult to predict and manage ihe bandwidth to be allocated.<br>
Therefore, there is a need for a header compression scheme that can accommodate an arbitrary jump in ihe value of the field (e.g., in the value of the RTP time stamp), yields a more consistent or constant size, and is more robust to errors.<br>
SUMMARY OF THE INVENTION<br>
According to an embodiment of the present invention, a timer based header decompression technique is provided. An RTP source generates a header field, such as an RTP time stamp. The time stamp is sent over a network to a compressor.   At the compressor, a jitter reduction function (JRF) is used to determine whether the jitter of the received time stamp (header) is excessive. If the jitter is excessive, the packet is discarded. Otherwise, the compressor calculates a compressed header field (compressed time stamp) based on the RTP lime stamp and an initial value of the lime stamp. The compressed time stamp represents jitter which is calculated as an effect the network between the source and the decompressor has on the transmission of packets. The calculated jitter is a cumulation of network jitter representing the effect the network between the source and the compressor has on the transmission of packets and radio jitter representing the effect the network between the compressor and decompressor has on the transmission of packets. It should be noted that the term "network" as used herein is intended to be a broad term so as not to preclude, for example, radio links in a wireless telecommunications network. The RTP packet, including the compressed time stamp, is then transmitted over a link or network to a decompressor.<br>
The decompressor decompresses the compressed time stamp by first calculating an estimate or approximation of the time stamp based on the current value of a timer located at the terminal (i.e., based on elapsed time). The approximation of the time stamp is then refined or corrected based on the compressed lime stamp provided in the packet header. In Ibis manner, the time stamp for the current packet (header) is regenerated based on a local timer and a compressed time stamp provided in the current header.   The packet and the regenerated time stamp are then provided to an RTP endpoint for processing.<br>
The timer-based scheme of the present invention includes several advantages. The term "timer based scheme" as used herein is inclusive of the timer based scheme using a compressed lime stamp and the timer and reference based scheme as disclosed herein. The size of the compressed time stamp<br><br>
(or other header field) is constant and small. Furthermore, the size does not change as a function of the length of interval of silence. No synchronization is required between the timer process at the RTP source (generating the time stamp) and the timer at the decompressor process. Also, this technique is robust to errors, as the partial time stamp information in the compressed header is self contained and only needs to be combined with the decompressor timer value to yield the full RTP time stamp value. Loss or corruption of a header will not invalidate subsequent compressed headers.<br>
A second embodiment of the present invention provides a header-stripping scheme in which<br>
the header (e.g., including the RTP time stamp) is stripped or removed from the RTP packet prior to<br>
transmission. A header stripper and a header generator are connected through a circuit like connection<br>
(e.g., circuit or virtual circuit) or an essentially constant bit rate channel. After initialization, the<br>
header stripper strips or removes the header (including removing the time stamp and sequence number)<br>
from each packet and then transmits the headerless packets to the header regenerator. To eliminate<br>
packet jitter at the header stripper, the packets can be transmitted at a time spacing according to the<br>
RTP time stamp (TS) in the header. Therefore, in this embodiment, the time stamp is not explicitly<br>
provided in the RTP packet (nor even a compressed time stamp). Rather, timing information is<br>
implicitly provided to the to the header regenerator based upon an essentially constant bit-rate channel<br>
between the header stripper and regenerator. The essentially constant bit-rate channel can be provided<br>
in several different ways.	**<br>
in this second embodiment, after initialization occurs (e.g., providing the initial sequence number and time stamp to the header regenerator) the header regenerator can regenerate the time stamps for sequential packets by incrementing a local time stamp counter by TS^stride every T msecs, and regenerate the packet sequence numbers by incrementing a local SN counter by I every packet duration. These fields can be regenerated based only on a local timer or counter due to the essentially constant bit rate channel provided between the header stripper and header regenerator in which no packet jitter is introduced, Therefore&gt; after initialization, these header fields can be regenerated at the header regenerator with reference only to a local clock.<br>
However, one or more basic discontinuity events (e.g., change in packet size or TS_stride, a non-linear shift in the time stamp, etc.) may occur which, if not addressed, could likely invalidate the header-stripping approach which relies only on a local timer or clock for field regeneration. A header string is a sequence of packet headers having known or linearly predictable fields. The transition from one string to another can be caused by any of several discontinuity events. When this occurs, the header stripper identifies discontinuity event and sends updated header infonnation related to the event to the header regenerator to allow time stamp and sequence number regeneration to continue. A similar technique of providing updated header infonnation can be used when there is a handover as<br><br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
The present invention will be more apparent from the following detailed description, when taken in conjunction with the accompanying drawings, in which:<br>
Fig. 1 is a block diagram illustrating an system according to an example embodiment of the present invention;<br>
Fig. 2 is a diagram illustrating an uncompressed format of an RTP packet according to an embodiment of the present invention;<br>
Fig. 3 is a diagram illustrating the uncompressed RTP header format according to an example embodiment of the present invention;<br>
Fig. A is a diagram illustrating a compressed RTP header format according to an example embodiment of the present invention;<br>
Fig. 5 is a diagram illustrating an example operation of header compression and decompression according to an embodiment of the invention;<br>
Fig. 6 is a diagram illustrating an example operation of header compression and decompression according to another embodiment of the invention;<br>
Fig. 7 is a diagram illustrating an example operation of handover according to an embodiment of the present invention;<br>
Fig. 8 is a block diagram illustrating an example stack according to an example embodiment of the present invention;<br>
Fig. 9 is a table illustrating information which may be provided in messages according to an example embodiment of the invention;<br>
Fig. 10 is a diagram illustrating a handover process according to an example embodiment of the present invention;<br>
Fig. 11 is a diagram illustrating an initialization for in-band according to an example embodiment of the invention;<br>
Fig. 12 is a diagram illustrating an initialization for out-of-band according to an example embodiment of the invention;<br>
Fig. 13 is a diagram illustrating the steps of calculating network jitter according to a first method of the present invention;<br>
Fig. 14 is a diagram illustrating the steps of calculating network jitter according to a second method set forth as Option 1 of the present invention; and<br><br>
Fig. 15 is a diagram illustrating the steps of calculating network jitter according to a third method set forth as Option 2 of the present invention.<br>
BEST MODE FOR CARRYING OUT THE INVENTION<br>
I.   Timer Baaed  Scheme  Using  A  Compressed" Time   Stamp<br>
A.   Architecture<br>
Fig. 1 is a block diagram illustrating an system according to an example embodiment of the present invention., A terminal 102 is connected to a IP network 108. Terminal 102 may be a personal computer or the like running RTP/UDP/IP, and providing packetized voice samples in RTP packets for transmission over network 110. Terminal 102 includes a RTF endpoint 104 which identifies this terminal (e.g., including IP address, port number, etc.) as either a source or destination for RTP packets. IP network is provided as an example, however, other types of packet switched networks or the like can be used instead. It should be noted that the term "network" as used herein is intended to be a broad term so as not to preclude, for example, radio links in a wireless telecommunications network. Terminal 102 also includes a local timer 103 for generating a time stamp.<br>
An access network infrastructure (ANI) 110 is connected to IP network 108. A wireless terminal 130 is coupled via radio frequency (RF) link HO to ANI 110. The wireless terminal 130 as described hereincould, for example, be a wireless compressor or a wireless decompressor depending on its environment. This particularly occurs when the source of the packets or the destination of the packets are separate from the wireless terminal 130. RF link 140 includes an uplink 142 (from terminal 130 to ANI 110) and a downlink 144(from ANI 1 lOto terminal 130). ANI 110 interfaces one or more wireless (or radio frequency) terminals (including terminal 130) in a region to IP network 108, including converting between wireline signals (provided from IP network 108) and wireless or RF signals (provided to or from terminal 130). Thus, ANI 110 allows RTP packets received from IP network 108 to be sent over RF link 140 to wireless terminal 130, and allows RTP packets from terminal 130 to be sent over IP network 108 to another terminal, such as terminal 102.<br>
According to an embodiment of the present invention, ANI 110 includes one or more ANI adapters (ANI^AD), such as ANI_AD 112 and AN1_AD 114, each of which preferably includes a timer. Each AN1AD performs header compression (prior to downlink transmission) and decompression (after uplink transmission). Headers (or one or more header fields, such as a time stamp) for RTP packets received from IP network 108 are compressed by AN1_AD 112 prior to transmission to terminal 130 over downlink 142, and packet headers received from terminal 130 are decompressed by ANI_AD 112 before transmission to IP network 108. Therefore, each ANI_AD may be considered to be a compressor/decompressor 115. Each AN1_AD may interface terminals located in a specific or different area within the region to IP network 108. ANI_AD 112 includes a timer 113 for<br><br>
implementing a timer-based decompression technique. ANI AD 112 also includes 3 jitter reduction function (JRF) 1.15 which operates to measure the jitter on packets (orheaders) received over the network 108 and discard any packets/headers which have excessive jiiter.<br>
Additional ANIs, such as AN! 120, may be provided for interfacing other terminals located in additional regions to IP network 108. ANI 120 similarly includes one or more ANIADs, such as AN1_AD 122 (Fig. 1). Each AN1_AD includes a timer and a JRF.<br>
Terminal 130 includes an RTP endpoini 132 which is a source and/or destination (receiver) for RTP packets. Terminal 130 includes a terminal adapter (term_AD) 136 which performs header compression (for packets to be transmitted uplink 142) and decompression (on packets received over downlink 144). Thus, terminal adapter (term_AD) may be considered to be a header compressor/decompressor 137, similar to the ANI_AD.<br>
The terminal adapter (term_AD) 136 also includes a timer 134 (a receiver timer) for calculating an approximation (or estimate) of a RTP lime stamp of a current header. The terminal adapter (term_AD) 136 then uses additional information in the RTP header to refine or correct the time stamp approximation. According to an embodiment of the invention, the time stamp approximation is corrected or adjusted based upon a compressed time stamp provided in the RTP header. In this manner, a local timer and a compressed time stamp can be used to regenerate the correct time stamp for each RTP header. Other terminals (such as terminal 150) may be provided, each including its own RTP endpoint, terminal adapter and timer.<br>
The configuration shown in Fig. 1 is provided merely as an example and the invention is not limited thereto. Rather, Fig. I simply provides one example where RTP data is transmitted over a data link or system (such as wireless link 140) where bandwidth is at a premium and errors are not uncommon. The present invention is not limited to a wireless linlc, but is applicable to a wide variety of links (including wireline links, etc.).<br>
One example application or system where the timer based header compression and decompression scheme may be useful js where Voice over IP (or ]P-telepbony) packets are transmitted over cellular systems. When VoIP is applied to cellular systems, it is important to minimize the overhead of the IP/UDP/RTP header due to the limited bandwidth of the wireless or air (RF) interface. In such a system for example, the ANIAD would interface the IP network to a computer terminal running RTPrtJDPrtP (e.g., terminal 130) and having a cellular or RF interface for receiving RTP packets over the wireless or RF link. This is merely one example application of the compression/decompression technique of the present invention.<br>
Fig. 2 is a diagram illustrating an uncompressed format of an RTP packet according lo an embodiment of the present invention. As shown in Fig. 2, the uncompressed RTP packet includes an<br><br>
JP header, a UDP header 2 ] 2, a RTP header 214 and a payload which could be a voice sample 216.<br>
Fig. 3 is a diagram illustrating the uncompressed RTP header format according (o an example embodiment of the present invention.    As shown in Fig. 3, the uncompressed RTP header includes a lime stamp (TS) 310, a sequence number (S.N.) 312 and some other fields 314. Due to the packet-switched nature of IP network ] 08, RTP packets can arrive out of order. The sequence number 312 is used at the RTP receiver or RTP destination (e.g., terminal 130, Fig. I) to assemble the RTP voice samples in ihe correct order. However, the sequence numbers in the RTP packets will not reflect any non-linear change in the field (e.g., intervals of silence of the voice signal). Therefore, a time stamp (TS) 310 is provided to indicate the relative timing of each packet.<br>
As noted above, there is some concern that the 40-60 byte header overhead supplied by the IP/UDP/RTP headers in each RTP packet is too large. In particular, a 4 byte RTP time stamp is particularly burdensome for RTP packets operating over low speed or limited bandwidth links (such as link 140). As a result, there is a need for a mechanism to effectively compress the RTP headers and particularly compress the time stamp field in the RTP header.<br>
The header compression technique described in RFC 2508 initially sends a complete (uncompressed) RTP packet, including all fields to the RTP destination/receiver. Many of the fields of the headers during a connection are static, and thus, need not be transmitted after the initial packet is sent and received. For most packets, only the sequence number and the time stamp will change from packet to packet. According to RFC 2508, the non-static fields (e.g., time stamp and sequence number) are updated at the receiver by adding (fixed) first-order differences to the previous values of those fields stored at the receiver. For example, the sequence number of each received RTP packet will automatically be incremented by one for each packet. Additional jumps or changes (i.e., different from the first order difference) in the non-static fields must be separately transmitted to the receiver. Unfortunately, in RFC 2508, the loss of the previous header will invalidate the decompression at the receiver. Also, the size of the differences varies which makes it more difficult to manage and predict bandwidth using the compression technique of RFC.2508.<br>
According to an embodiment of the present invention, a technique for header compression is provided that can be used to more effectively compress a RTP time stamp (or other field) of a packet header. According to an embodiment of the present invention, the compression scheme can accommodate an arbitrary jump in the RTP time stamp value, while yielding a constant size compressed RTP header (or constant size RTP time stamp).<br>
Fig. 4 is a diagram illustrating a compressed RTP header format according to an example embodiment of the present invention. As shown in Fig. 4, the compressed RTP header may consist of a message type 4!0 which indicates the type of message, a bit mask 412 which identifies the fields<br><br>
which are changing, and a compressed time stamp field 414. The message type 410 may indicate a compressed time stamp if a compressed time stamp is provided in the packet header. According to an embodiment of the present invention, the compressed lime stamp field 414 includes the k least significant bits (Isbs) of a value which may indicate the time elapsed between packets. According to an embodiment of the invention, the compressed time stamp 414 may provide a portion (i.e., the k least significant bits) of a source counter value (or counter difference). The source counter may be used to generate the time stamp for each RTP packet header. Optional fields 416 can be used to provide updated or changed fields for those fields identified in the bit mask 412.<br>
B. Overall Operation of Time Stamp Compression and Decompression<br>
The compression and decompression of the RTP time stamp will be briefly described, according to an embodiment of the invention. According to an embodiment, an RTP packet is generated at an RTP endpoint (such as RTP endpoint 104 of terminal 102) and is addressed to another RTP endpoint. In this example, RTP endpoint 104 is the source of the one or more RTP packets to be sent to RTP endpoint 132 (the destination) of terminal 130. The RTP packet header includes a time stamp, which is generated at the RTP source (e.g., at terminal 102) based on a wallclock.<br>
The RTP packet is routed over the IP network 108 to the ANi_AD 112ofANI110. The ANI_AD 112 compresses one or more fields in the headers) of the RTP packet. In particular, the ANI_AD compresses the RTP time stamp 310 (Fig. 3) into a compressed time stamp 414 (Fig. 4). Other fields in the header may be compressed by removing them or using some other technique. The RTP packet, including the compressed time stamp 414, is then transmitted over the downlink 144 of RF link 140 to terminal 130.<br>
Upon receipt of the RTP packet with compressed header (i.e., compressed time stamp 414), the terminal adapter (termAD) 136 ofterminal 130 decompresses the time stamp value. The terminal adapter 136 decompresses the compressed time stamp 414 by first calculating an estimate or approximation of the time stamp based on the current value of timer 134. The approximation of the time stamp is then refined or corrected based on the compressed time stamp 414 provided in the packet header. In this manner, the time stamp for the current packet (header) is regenerated based on a local timer (timer 134) and a compressed time stamp provided in the current header. The other fields of the packet header (such as the sequence number) may also be regenerated.   The packet and the regenerated time stamp are then provided to the RTP endpoint 132 for processing. The RTP endpoint 132 then replays the voice samples in the appropriate order (as specified by the sequence numbers) and having the appropriate timing as specified by the regenerated time stamps (e.g., to account for any intervals of silence).<br>
The ANI_AD 112 may also receive compressed headers (including a compressed time stamp)<br><br>
over RF link 140, and decompress the time stamp using the timer-based decompression technique described above. Therefore, the ANIAD [ 12 may typically include a timer to allow the ANI_ADto decompress the compressed time stamp as described above. Similarly, theterm^AD 136 of terminal 130 may also compress the time stamp of the RTP packet prior to transmission of the RTP packet over RFlink 140 to AN] 110. To simplify the explanation of the example embodiments of the invention, the majority of the description will be directed to the downlink path 144. According to an embodiment of the invention, RTP packets may be transmitted in both directions (uplink 142 and downlink 144). Thus, both AN1_AD 112of ANI llOand term_AX&gt; of terminal 130 may operate as a time stamp. compressor (for transmission of the header/packet over the RF link) and a decompressor (after receipt of a compressed header received over RF link 140).<br>
C. Example Embodiments of Time Stamp Compression and Decompression<br>
Example embodiments of time stamp compression and decompression will be briefly described. It is assumed that the data in the RTP packets is voice data. The following variables and formulas are defined only to assist in explaining some of the features of the present invention, but the invention is not limited thereto. Also, the present invention is not limited to systems which use the same or similar types of variables, and is not limited to systems which perform the specific calculations described below. The variables and calculations are merely provided as an example embodiment of the invention.<br>
T - is the time spacing between RTP speech samples. (If there is one speech sample provided in each RTP packet, then T is also the spacing between RTP packet headers).<br>
TS - time stamp<br>
TS_stride - the RTP time stamp is incremented by TS_stride every T msec. In other words, the RTP time stamp increases by TS_stride for every new RTP packet. TS_stride is a constant (e.g., 100) that depends on the voice codec. TSstride is provided to the receiver (terminal 130) and the ANI_AD112.<br>
TS0 - RTPtimestampofthefirstheaderofasessionreceivedatfheRTPreceiver. The first header of a session is considered a synchronization header because it is used for synchronization. TS0 is an initial value of the RTP time stamp provided to both the compressor (e.g., ANI_AD 112) and the decompressor (e.g., term__AD 136) at the beginning of the session (for synchronization). According to an embodiment, the ANI_AD and term_AD are initialized or synchronized by receiving an RTP packet with an uncompressed header (including an uncompressed time stamp providing TS0). According to an embodiment of the present invention, the timer-based decompression technique requires providing an initial time stamp TS0 (e.g., through an initial or synchronization header that is uncompressed) to the time stamp compressor {i.e., ANI_AD 112) and to the decompressor (i.e., term_AD 136) before<br><br>
compressed headers can be properly decompressed (i.e., so the decompressor can correctly regenerate the time stamp).<br>
RTP time stamp of packet header m (generated at time m*T msec) =TS0+TS_stride*m. This assumes that there is one header for each voice sample. As shown in the examples described below, this formula can be extended for the case of multiple voice samples"(eg-, 3 voice samples) per packet header.<br>
m -an integer that indicates the number of speech samples that have been sent, m is reset or cleared to 0 at the beginning of the session,   m is proportional to (or indicates) the amount of time that has elapsed since the beginning of ihe session, m is incremented by 1 every T msecs.<br>
TScurrent = TSO + m_current*TS_stride;   The current time stamp for the current packet header.<br>
Receiver timer- the timer at the RTP receiver (or RTP destination), such as the timer 134 of terminal 130. The local receiver timer is typically free running and will not be reset at the beginning of a session. Rather, elapsed time at the RTP receiver between receipt of two packet headers can be obtained by subtracting the timer value of the current header from the receiver timer value when the previous packet header was received. By allowing the receiver timer to be free running, one receiver timer can be shared by many flows or sessions. Alternatively, the receiver timer can be reset at the beginning of each session. Resetting or clearing a receiver timer at the beginning of a session (i.e., upon receipt of initialization header) would require a dedicated receiver timer (timer process) for each session or flow. The first uncompressed time stamp (TSO) of a session may be provided to the ANI_AD and the term_AD in an initialization header. The first header is provided to initialize the" compressor (ANTAD 112) and the decompressor (term_AD 136). The receiver timer is then incremented by 1 every T msecs. The AN1AD 112 (compressor) uses the TSO value to compress the time stamps of subsequent RTP packet headers. The term_AD 136 (decompressor) uses the TSO value to decompress the compressed time stamp value (e.g., to regenerate the time stamps in subsequently received RTP headers).<br>
currentjimer - the value of the timer at the RTP receiver (e.g., terminal 130) when the current header is received<br>
lasMimer - the value at the time at the receiver when the last header was received. (The currenMimer is stored as the lastjimer for the next header calculation of the time stamp).<br>
m_last - the value of m for the last received header; m indicates the number of voice frames that have elapsed since the initialization header.<br>
To compress the time stamp of the current packet, the ANI_AD 112 calculates the current valueofmas:m_current = (TS_current - TSO) / TS_stride. Therefore, the ANI_AD subtracts the<br><br>
initial value of (he time stamp (at the beginning of the session) from the current time stamp.   This difference is divided by the time stamp stride (TS_stride). However, in some embodiments, it may be unnecessary to actually perform a division operation. Other techniques can be used to appropriately generate m current without performing a division operation, which may require high processor overhead.<br>
The k least significant bits of m_current are then provided as the compressed time stamp 414. The RTP packet including the compressed time stamp 414 is then transmitted over RF link 140 to the RTP destination or receiver (e.g., terminal 130).<br>
At the RTP receiver (e.g., terminal 130), the terminal adapter (Term^AD) 136 decompresses the compressed time stamp 414. The current_timer value of the previous header is first stored as last_limer. Then, when the current header arrives, the term_AD 136 reads the value of the receiver timer 134 and stores this in memory as currentjimer. Next, timer_diff is calculated as: timerjiiff= currenttimer - lastjimer. The ANI__AD calculates the exact value of mcurrent by finding integer d, where:<br>
(-L/2 
k least significant bits of (d +m_last + timcr_diff) = compressed time stamp 414(for the current header).<br>
(Eqn. 2)<br>
As noted, the compressed time stamp received is also k bits. Once d has been calculated using Eqns. 1 and 2, TS_cunrent can then be calculated as:<br>
TS_current = TSO + (d + mjast + timer_diff) * TS_stride.<br>
(Eqn.3). In equation 3, the actual or correct value of m_current is shown in parentheses as (d + m_last + timerjiiff). mjast + timer is the approximation of mcurrent, while d is the difference between approximation of m_current and the correct value of m_current. Also, TSO + (m_last +timer_diff)*TS_stride is an approximation of the current time stamp value, and d*TS_stride is the difference between the approximated current time stamp and the actual (or conect) value of the current time stamp.<br>
Therefore, it can be seen that the RTP receiver first calculates an approximation (or estimate) of the current time stamp based on the elapsed time between receipt of the current header and the previous header (that was correctly decompressed), as: approximated current time stamp = TSO + (mjast + timer_diff)*TSjstride. The approximated current time stamp is then adjusted or corrected by the amount d*TS_stride to calculate the correct current time stamp value (TS_current).<br>
Afer TScurrent is calculated, the current RTP packet (including its regenerated or<br><br>
decompressed time stamp, TS_currenl) is provided up to the RTF endpoint 132. This compression and decompression process is transparent to the RTP endpoints.<br>
Fig. 5 is a diagram illustrating an example operation of header compression and decompression according to an embodiment of the invention. This example applies some of the specific formulas described above to illustrate some features of the present invention. In this example embodiment, it is assumed that the timers at the RTP source 502 and at the RTP receiver 504 have the same frequency but are not typically synchronized. The timer at the RTP source (e.g., incrementing by 1 every T msecs) is used for generating the time stamp, while the timer (e.g., timer 134) at the RTP receiver is used to regenerate or decompress the RTP time stamp.<br>
Referring to Fig. 5, at the beginning of a session, an initialization header 508 is generated at the RTP source, including an initial time stamp value (TSO). The initialization header 508 is transmitted to the AN] and then forwarded to the RTP receiver 504 (e.g., terminal 130). The time stamp in the initialization header is not compressed. Upon receipt of the initialization header, the initial time stamp value (TSO) is stored in memory at the ANI_AD, along with the TS_stride. According to one embodiment, two initialization headers may be transmitted to AN1_AD. ANI_AD can then calculate TS_stride as the second time stamp - first time stamp. Term_AD can similarly calculate TS_stride or receive the value in a packet.<br>
Similarly, when the initialization header 508 is received at the RTP receiver (terminal 130), the initial time stamp (TSO) is stored in memory along with the TSstride. Also, upon receipt 510 of the initialization header 508 (Fig. 5), mcurrent is cleared or reset to zero (0), and the receiver timer is then read and stored as initial_receiver_Jimer, 516. Instead of reading the timer at the beginning of the session, the receiver timer can be reset or cleared. In this example, the value read of the receiver timer at the beginning of the session just happens to be zero (0) for simplicity. Thus, the example shown in Fig. 5 applies to both embodiments (just reading the receiver timer, or resetting it to zero) because the free running timer is read as zero at the beginning of the session. Likewise, it is not necessary to clear mcurrent, but could instead record a value for mcurrent. The receiver timer is thereafter incremented (e.g., by 1) every T msecs. (which is the same frequency as the timer at RTP source 502 used for generating time stamps). The initialization header 508 arrives at the RTP receiver 502 after a fixed delay (bulk delay 512) and a variable delay (cumulative jitter 514).<br>
Next, the RTP source 502 generates the next RTP packet (the first RTP packet of the session after the initialization header). This RTP packet is generated at 3*T msecs after the initialization header was generated, and thus would typically include three (3) voice samples, for example. Other numbers are possible. Therefore, the time stamp for header of this packet is: TS(I) = TSO + 3*TS_stride, as shown in Fig. 5. TS(I) refers to the time stamp generated aAer 3T msecs. after<br><br>
initialization. In this example, it shall be assumed thai TS_stride is 100, for example. TSO is assumed to be 0, for example. Thus, TS( I) = 300.<br>
The time stamp value for this packel, TS( I), is received at the ANIAD and is compressed based upon TS( I) (the time st3mp value), TSO (the initial lime stamp value) and TSstride (the amount the time stamp increments every T msec). According lo an example embodiment, the compressed time stamp can be calculated as the k least significant bits of mcurrent. The ANIAD 112 calculates the current value of m as: m_current = (TS_current - TSO) / TS^slride.    In this example, it shall be assumed that TSstride is 100, for example.    In this example, m_current is calculated as; m_current = (300-0)/I00 = 3. k in this example will be two (2). Thus, the two least significant bits of m_current (11 in binary) are provided as the compressed time stamp 414 for this packet (CTSI), Fig. 5.<br>
The compressed time stamp (CTS1) arrives at the RTP receiver S02 and the term_AD 136 at the RTF receiver regenerates or decompresses the time stamp, TS(1), for the current packet. The value of currenMimer (zero) is stored as lasMimer and m_current is stored as m_last. m_current was previously set to zero at the beginning of the session (i.e., upon receipt of the synchronization header). The receiver timer value (3 in this case) is read and stored as currenMimer. Timer_diff is then calculated as currenMimer - lasMimer, which is 3-0 = 3. Timer_diff + m_Iast is an approximation of m_current.<br>
Next term_AD 136 calculates the exact or corrected value for m_current using equations (1) and (2).    Using equation (2), the two least significant bits of (d + m_last + timer__diff) = CTS I (the compressed timer stamp for current header). In this case, mjast is zero (0), timer_diff is three (3) and CTSI is three (3). Thus, the two least significant bitsof(d + 0+ 3)= 3. Thus, d is equal to zero.<br>
Using equation (3), the decompressed time stamp for this packet is then calculated as TS{ 1) = TS0 + (d + mjast + timer_diff) * TS_stride. Thus, as a result, TS(l)= 0 + (0 + 0 + 3)* 100 = 300. The decompressed time stamp for this packet, TS( 1) = 300, is then provided to the RTP endpoint 132 at the RTP source, along with the RTP data and other decompressed header fields. The correct or actual value for mcunent is (d + mjast + timerdifT). Therefore, for this packet, it can be seen that the approximation of mcurrent is the same as the correct value of m_current (but this is not true in the general case). m_current is then updated to be 3.<br>
The next packet and time stamp is generated at the RTP source, including a time stamp TS(2) = 0+ 6*100 = 600. At ANI_AD, the TS(2) = 600 is compressed into a compressed time stamp as the 2 least significant bits of (600 - 0)/100 = 6. In this case, 6 in binary is \10. Thus, the two least significant bits of 110 is 10. Thus, CTS2 = 10 in binary.<br>
The compressed time stamp for this packet (CTS2) is then received at the term_AD 136 after the receiver timer reaches the value of 7, due to the bulk dfelay and cumulative jitter. The value of<br><br>
currentjimer (3) is stored as lastjimer and m_current (3) is stored as mjast. The current receiver timer value (7 in this case) is read and stored as currentjimer. Timer_diff is then calculated as currentjimer - lastjimer, which is 7-3 = 4. Timer_diff + mjast is an approximation of mcurrent, which is 7.<br>
Next, term_AD 136 calculates the exact or corrected value for mcurrent using equations (I) and (2).    Using equation (2), the two least significant bits of (d + mjast + timer_diff) = CTS2 (the compressed timer stamp for current header). In this case, mjast is 3, timer_diff is 4 and CTS2 is 10 (in binary, which is 3 in decimal). Equation 2 is solved for d as follows:2 lsbs (d + 3 + 4) = 2. Seven in binary is HI.   Thus, d=-I. d is the difference between the approximation of m_current and actual value of m_current. Plugging in d into equation (3), the time stamp for this packet is calculated as TS(2) = 0 + (-1 + 3 + 4)* 100 = 600. Thus, term_AD 136 of RTP receiver has correctly regenerated (e.g., decompressed) the RTP time stamp based on a local timer and a compressed time stamp.<br>
It should be noted that, unlike previous techniques, it is unnecessary to resend an initialization header in the event that one or more packets do not arrive at the RTP receiver.   In other words, synchronization between RTP source and receiver is necessary only once at the beginning of a session or connection. This is because, the current lime stamp is calculated at the RTP receiver based on both mjast and timer_diff. Timer_diff is calculated as currentjimer - lastjimer. Therefore, the values of mjast and lastjimer correspond to the last packet, regardless of which packet was last received (e.g., regardless whether packets sent after the "last" packet were erroneously dropped or lost) . As a result, the timer-based compression scheme according to an embodiment of the invention is robust to errors and decreases bandwidth requirements because it is unnecessary to send a new synchronization packet (e.g., including complete uncompressed values for all headers) in the event that an error is detected (e.g., one or more packets dropped or lost).<br>
In normal operation, the discrepancy between the approximation and the exact value of ra_current is caused by:<br>
a)	Cumulative jitter between the very source of RTP time stamps and the receiver, actual delay = bulk delay + cumulative jitter, where bulk delay is constant and cumulative jitter varies from one header to the next, and 0 s cumulative jitter ^maximum cumulative jitter, and<br>
b)	Possible asynchronicity between the timer process and the decompressor process, depending on the timer implementation. Due to the asynchronicity, there can be an error of plus or minus or one (+ or -1) in the timer value (currentjimer).<br>
Fig. 6 is a diagram illustrating an example operation of header compression and decompression according to another embodiment of the invention.   Like Fig. 5, Fig. 6 is a diagram illustrating the effect of jitter and timer asynchronicity. In Fig. 5, the receiver timer is reset or cleared only at the<br><br>
beginning of the session. (This is not necessary as the receiver timer can be allowed just to continue to run.) However, in the example embodiment illustrated in Fig. 6, the receiver timer is reset or cleared to zero (0) for each packet. Thus, when a compressed packet header is received, the timer value is read, which indicates the timer_diff value described above (since the timer indicates the elapsed time since the last packet header). There may be many different ways to implement the invention. What is important is that a timer difference should be measured indicating the elapsed time (as measured by the local receiver timer) between the last successfully decompressed time stamp and the current time stamp (timer_diff as described in Fig. 5).<br>
Referring to Fig. 6, header n is generated with time stamp- TSO + 3*TS_stride. This time stamp of header n is compressed and transmitted lo the R.TP receiver, and decompressed. The timer is then reset at the receiver. The next headers, (n+1), (n+2) and (n+3) are generated and sent, but only header (n+3) is received (i.e., header n+l and n+2 are lost). For simplicity header (n+2) and (n+3) are not shown in Fig. 6. Header (n+l) is shown in Fig. 6 as header tn+n. Header (m+n) is generated and sent, with time stamp TS = TSO + 6*TS_stride. This time stamp of header (m+n) is compressed and then sent to the RTP receiver. The timer value is 4 (indicating timer_diff). This value is used to decompress the time stamp for header (m+n). Therefore, the example of Fig. 6 is very similar to the example shown in Fig. 5, except the timer is reset after receiving each header in Fig. 6.<br>
Regardless which technique is used (either Fig. 5 or Fig. 6), an effective timer-based compression scheme can be used. However, if the cumulative jitter is excessive, it may not be possible to regenerate a correct time stamp based on the compressed time stamp. In many instances, the following condition should be satisfied by k to allow the timer based compression scheme illustrated in Figs 5 and/or 6 to work properly: [Condition 1 ] (Maximum integral jitter + 2) 
where Maximum integral jitter (Mil) is the maximum cumulative jitter, expressed in units of T msec, rounded to the next higher integer. For example, if T = 20 msec, a maximum cumulative jitter of 15 msec will result in MIJ = 1. 2 is added to the MIJ to account for the possible error caused by the timer asynchronicity.<br>
Due to the conversational real-time requirements, the cumulative jitter in normal operation may be only a few times T msec. Therefore, in such a case, a value of k equal 4 is more than sufficient, as up to a 16 speech sample (i.e., 16*T msecs) discrepancy can be corrected at the RTP receiver. Abnormal or error situations may result in the jitter exceeding the normal values. A jitter reduction entity can be added upstream of the compressor to ensure that jitter, as seen by the compressor, remains within acceptable bounds.<br>
The advantages of the time stamp compression scheme illustrated in Figs. 5 and/or 6 include:<br><br>
a)	The size of the time stamp is constant and small. The compressed header typically consists<br>
of a message type, which indicates the type of message (kl bits), a bit mask which indicates which<br>
field are changing, and a field that contains the k least significant bits of mcurrent (k bits). Assuming<br>
that the same 4-bit MST1 bit mask is used as in RFC2508, and kl =4, the size of compressed header<br>
when only the RTP TS changes (this case is by far (he most frequent) is 1.5 bytes. Furthermore, the<br>
size does not change as a function of the length of interval of silence.<br>
b)	As shown in, for example, in Fig. 6, the receiver timer operates at the same frequency as the RTP source timer (used to generate the original time stamp); Phase synchronization between the source timer and receiver timer is not required (because it is the time elapsed as measured the receiver timer is what is used to regenerate the time stamp).<br>
c)	At the receiver, no synchronization is required between the timer process and the decompressor process. For example the timer process may increment the timer by 1 every T msecs, while the decompressor process is woken to perform decompression when a new header is received. However, it is not required that the point at which the timer increments be aligned or synchronized with the point where the header is received (see Fig. 6).<br>
d)	Robustness to errors, as the partial RTP TS information in the compressed header is self contained and only needs to be combined with the receiver timer to yield the full RTP TS value. Loss or corruption of a header will not invalidate subsequent compressed headers<br>
e)	No memory or values needs to be maintained or stored by the compressor for the purpose of RTP TS compression/decompression<br>
I). Handoff<br>
According to an embodiment, each AN1AD is assigned to a specific area (e.g., interfaces terminals located in a specific area). Terminals (such as terminal 130) can move from one area to another. When a terminal moves from one area to another, the terminal must be handed off, or switched from one ANI_AD to another ANI_AD.<br>
One case of handoff to consider is inter-ANl_AD handoff, where there may be a disruption caused by switching from the old AN1_AD to a new AN1_AD. The issue is how to maintain continuity of information through the handoff so that after handoff, the compression/decompression at lerm__AD 136 and the new ANI_AD continue without disruption.<br>
1. Downlink<br>
There is no discontinuity on the receiver side, which is the terminal (e.g., terminal 130, Fig. I). The compressor"s role is transferred from one AN1AD to another. After handoff, the headers are routed on a new path going through the new ANI_AD instead of the old ANI_AD. In addition, depending on the design of the system, there may or may not be rerouting of in-transit packets during<br><br>
handoff. In-transit packets are those generated by the source but not yet arrived at the receiver by the time of handoff. Rerouting attempts to deliver the in-transit packets to the terminal.<br>
To perform the handoff, the old ANI_AD must transfer the initial value of the time stamp for the session (TSO) and TS_stride to the new ANIAD. These two values allow ihe new AN]_AD to continue to compress new time stamps {in new packet Headers) received from the RTP source (e.g., terminal 102). Let Currentjieader be the very first header to be decompressed by the term^AD after handoff, and its TScurrent its RTP time stamp. The term_AD can decompress TS_currertt as long as the following condition is met: [Condition 2] (Downlink Transient integral jitter + 2) 
If Currentjieader is the header of a rerouted in-transit packet, total delay of Currentjieader = total delay caused by routing and rerouting. In practice, systems should preferably be designed to keep downlink transient jitter in the same value range as the cumulative jitter in stable state (i.e. without handoff). Therefore, based on these assumptions (which may not always apply), no specific handoff-related problems for downlink are expected if condition 1 (noted above) is met. 2. Uplink<br>
In this uplink description, the term_AD 136 of the terminal (e.g., terminal 130) compresses the time stamp and sends it over the RF link 140 to the local or corresponding ANI_AD. The RTP source in this case is the terminal 130. Even as the RTP source (the terminal 130) changes physical locations (requiring a handoff at ANIAD), the receiver"s (decompressors"s) role is transferred from one ANI_AD to another. The RTP source stays anchored at the terminal (e.g., terminal 130, Fig. 1).<br>
Fig. 7 is a diagram illustrating an example operation of handoff according to an embodiment of the present invention. To minimize air interface overhead, some information needs to be transferred from an old ANIAD 710 to a new ANI__AD 712 for handoff. That information is the timer value at the old AN1_AD. The old ANIAD 710 reads (or takes a snapshot of) the current value of the Timer (T_u) at the old AN1__AD and sends it to the new ANI_AD, along with TSO, TS_stride and m_current, block 714 (Fig. 7). The new ANI__AD resumes incrementing its timer starting from (T_u). Let Tjransfer 715 (Fig. 7) be the time to transfer the Timer. Also, the timer processes at the<br><br>
old and new AN1_AD may have a phase difference which is at most T msec. Let Current_header be the very first header to be decompressed by the new AN1AD after handoff, and TS_current be its RTP time stamp. The new ANf_AD can decompress TS_current as long as the following condition is met: [Condition 3] (Uplink Transient integral jitter + 2 +l)
Specifically, Fig. 7 also illustrates the uplink transient jitter, which includes the bulk delay difference and T_transfer. In this example, the old AN1_AD decides to prepare for the handoff before the timer increments the timer. Therefore it sends Tji = 0 to the new AN1_AD 712. Tjransfer is approximately T msec. At the new ANI_AD 712, due to the asynchronicity of the timer process, almost T msec elapse before timer gets incremented. There is also a cumulative jitter on the new path for header (n+m). As a result, the timer value read when header (n+m) is received is 2, while the real value should be 4. Thus, there is a skew of -2. As long as condition 3 is met, the skew can be eliminated and the RTP time stamp can be correctly decompressed.<br>
According to an embodiment, T_u is transmitted on a high speed signaling network connecting the old and new AN1_AD. Consequently, the time T_transfer should be at most only a small few T msecs. However, the cases where the transfer of T_u is not successful, or not timely enough must be considered. In those cases, the new ANI_AD will notify the term_AD, which sends the full (uncompressed) RTP time stamp until an acknowledgment is received.<br>
E. Jitter Reduction<br>
According to an embodiment of the present invention, the timer-based compression scheme which uses a compressed time stamp and a local receiver timer may be predicated on the following conditions being met. [Condition 1] (Maximum integral jitter + 2) 
Due to the conversational real-time requirements, one can reasonably expect that the various jitters above are on the order of a few T msec in normal operation. Therefore, a small value of k, e.g. 4 is usually more than sufficient to allow any skew or error to be corrected. However, abnormal conditions on the path from the RTP source to the receiver (failures, etc.) or other situations may exists<br><br>
in which jitters become excessive (where the correct time stamp cannot be generated based on the compressed lime stamp and local receiver timer). To deal with these cases, a jitter reduction function (JRF) 115 (Fig. I) can be provided as a front end to the compressor, to filler out (or discard) packets having excessive jitter (e.g., where any of conditions 1, 2 or 3 above are not met).<br>
To screen out or identify packets having excessive M1J, thejitter reduction function (JRF) calculates thejitter of each packet received over network 108. If the measured packet jitter is greater than 2l - 2, this is considered excessive jitter and the packet is discarded. Otherwise, the header (or header field) is compressed (as described above) and then transmitted to the receiver terminal (e.g., terminal 130).<br>
The JRF calculates the jitter of the current packet as follows: jitter = absolute value of (TS2-TS1 - JRF timer^diff), where TS2 is the time stamp of the current packet, TSI is the time stamp of the previous packet, and JRF timer_diff is the difference in the JRF_timer between the current packet and the previous packet (elapsed time). This jitter value is compared to 2* - 2. If thejitter is greater than 2k<br>
-	2, the packet is discarded, Otherwise, the packet header is compressed at the AN1_AD and the packet<br>
with the compressed header is sent to the RTP receiver.<br>
This jitter reduction (unction (JRF) 115 is an effective technique to limit the jitter on the packets received by the receiver terminal (because the jitter introduced over the RF link may be considered negligible). Moreover, the JRF operates to more efficiently use the available bandwidth over the RF link 140. In the absence of the JRF 115, one or more packets having a jitter greater than ~t<br>
-	2 might be transmitted to the RTP receiver over link 140. However, at the receiver, if the jitter is<br>
excessive (i.e., condition 1 is not met), the correct time stamp value cannot be generated, causing the<br>
receiver to discard the packet. Thus, JRF merely operates to filter out those packets having excessive<br>
jitter that would be discarded at the receiver anyway (avoiding waste of valuable bandwidth over link<br>
140).<br>
II. Header-Stripping Scheme<br>
A second embodiment of the present invention provides a timer-based header stripping scheme in which a header or one or more header fields (e.g., including the RTP time stamp) is stripped from the RTP packet prior to transmission across the low bandwidth link (e.g., across RF link 140, Fig. 1). In such a case, the time stamp is not explicitly provided in the RTP packet. Rather, timing information can be implicitly provided to the to a header regenerator for incrementing Ihe local timer based upon an essentially constant bit rate channel or a circuit-like connection between the header stripper (e.g., which may exist at an ANI_AD) and the header regenerator (e.g., which may exist at terminal 130).<br>
A. Header Stripping Overview<br>
Header stripping is based on the idea that for some applications or services, it is not necessary<br><br>
to transport all of the information contained in the IP/UDP/RTP headers, either because they do not change, or because they are not essential to the application/service. Basic voice is a typical example. To provide a service equivalent to existing cellular voice service (e.g., over RF link 140, Fig. I), the only variable header information that is essential is the RTP time stamp (TS). It is also desirable to maintain transparency for RTP sequence number (SN). Transparency here (for the SN) means that the SN after stripping/regeneration is equal to the original SN. Header stripping relies on the implicit timing information provided by a circuit-like connection or essentially constant bit rate channel (where no packet jitter is introduced) to allow the RTP time stamp to be regenerated based only on a local timer or counter. This eliminates the need lo send the time stamp explicitly (or even send a compressed time stamp). To achieve transparency of SN, compressed SNs can be used in combination with the timing information from the circuit-like channel or connection. A circuit-like connection preferably provides a channel having an essentially constant bit rate. When there is no voice sample (e.g. silence interval), the channel may or may not be allocated to other traffic and/or users. Advantages of this header stripping scheme include:<br>
a)	Lowest header overhead, unmatched by any other scheme (even less than the compressed<br>
header technique described above in Figs. 1 -6).<br>
b)	Robustness to errors, since the timing information from circuit-like transmission or<br>
essentially constant bit rate channel is inherently unaffected by errors<br>
c)	Possibility to switch during a call to header compression (e.g., technique of Figs. 1-6), if so<br>
desired. This may be helpful if the call becomes multimedia, as a non-voice medium is added to voice.<br>
Furthermore, note that header stripping does not mandate or preclude stalistical multiplexing, which if<br>
implemented, could occur at a lower layer.<br>
Fig. 8 is a block diagram illustrating an example stack according to an example embodiment of the present invention. A header stripper stack 802 and a header regenerator stack 830 are shown. As an example, the header stripper stack 802 illustrates some of the components that may be used to strip one or more header fields from the packet, while the header regenerator stack 830 illustrates some of the components that may be used to regenerate the packet header. The header stripper stack 802 could be provided, for example, within a type of AN1 adapter (e.g., AN1_AD 112, Fig. 1), while the header regenerator stack 830 may reside, for example, at a type of terminal adapter (e.g., term_AD 136, Fig. 1).<br>
Referring to Fig. 8, the header stripper stack 802 includes RTP and UDP layers 804, an IP layer 806. The RTP/UDP/1P layers generate an RTP packet 808 (which includes a time stamp in the RTP header). Next, at the header stripper stack 802, the RTP packet 808 is provided to a header stripper (HS) 810 for stripping or removing one or more headers or header fields. Layers LI and L2<br><br>
812 are provided, where L2 may be a data link layer and layer LI may be a physical layer, for example. Other layers could be provided as necessary. Similarly, the header regenerator stack 830 includes corresponding layers LI and L2 820, a header regenerator (HR) 822 which regenerates the header (including the RTP time stamp) to provide the complete RTP packet 824 (including RTP/UDP/1P headers). The packet 824 is provided to IP layer 826 and then to UDP and RTP layers 828. The layers LI and L2 of the header stripper stack 802 and header regenerator stack 830 are in communication across a link 81S or air interface (such as an RF link 140) or across a network.   For example, Voice over IP packets are passed through the header stripper 810 before transmission over the link 815 (e.g.. wireless link or network). At the receiving end (at header regenerator stack 830), the header regenerator 822 regenerates the headers before delivery to the recipient. Layers L2/LI may provide the circuit-like connection, i.e., providing an essentially constant bit rate channel between the header stripper 810 and header regenerator 822. In addition, for maximum efficiency, layer LI may also perform voice payload optimization like uneven bil protection, in addition to optimized channel coding and interleaving. Note that the concept of header stripping is applicable regardless of whether payload optimization is done or not.<br>
In operation, The header stripper (HS) 810 eliminates the jitter in the incoming RTP packets, and plays them back according to the RTP time stamp (TS) in the header. Here, eliminating jitter means scheduling the transmission of the voice sample on the circuit-like connection or essentially constant bit rate channel in accordance with the time stamp. In other words, the packets, after removal or stripping of the headers, are transmitted on the circuit-like channel or essentially constant bit rate channel at times based upon their time stamp in the packet. Packets with excessive jitter are discarded, using the jitter reduction function (JRF 115, Fig. 1), for example. The header regenerator (HR) 822 reconstructs the LP/UDP/RTP fields, which can be classified into the following categories:<br>
a)	Static: Value does not change for the duration of the session, e.g. IP addresses<br>
b)	Non-static: Value could in principle change from one packet to the next, but in practice, for voice, the only non-static field that is essential to preserve through header stripping is the RTP time stamp (TS). RTP sequence number (SN) is also preserved. Static fields can be transferred once and for all as part of a full header in the initialization phase, al the start of the session. A reliable delivery mechanism can be used, (e.g. using Acknowledgments or Acks from the RTP receiver to acknowledge receipt of the initialization information). The time stamp and sequence number will be briefly discussed.<br>
1. RTP Time Stamp (TS)<br>
In the case of voice, RTP time stamp (TS) increases linearly as a function of the wall clock (i.e., source timer) at the RTP source. If the time interval between consecutive voice samples is<br><br>
Tmsec, then RTP time stamp of header n (generated at time n*T msec) = RTP time stamp of header 0 (generated at time 0) + TSstride * n, where TS_stride and T are constants dependent on the voice codec. This is true if there is one packet per speech (voice) sample. More generally, RTP time stamp (TS) are of the form TSO + m *TS_stride, where TSO is 
At the beginning of a session or connection, an initialization phase is performed to initialize the RTP receiver (i.e., initialize the header regenerator). In the initialization phase, the header stripper keeps sending initialization information (Init_info) until an Ack is received from the receiver. Init_info{n) consists essentially of the full IP/UDP/RTP header n (including an initial time stamp and sequence number). The RTP sequence number is used to identify this particular initialization header, since subsequent initialization headers will include larger sequence numbers (assuming the first initialization header is not acked).<br>
At the header regenerator (HR) 822, when lnit_info(n) is correctly received, the HR 822 sends anack(n). Once the header regenerator (HR) 822 has acked a full header, the HS 810 stops sending full headers.   The HR 822 also starts a local time stamp counler that is initialized to the RTP time stamp received in the lnit_info(n). TheTS counter is similar to the receiver timer in Fig. 1, but theTS counter is incremented by TS_stride every T msecs (rather than by 1, but it is the same principle as the receiver timer). For subsequent stripped speech frames (i.e., RTP packets where the headers have been stripped or removed), the RTP TS is regenerated from the time stamp (TS) counter. The receiver timer (TS timer) has the same frequency as the clock or timer used at the RTP source (i.e., source timer) to generate the time stamp. Moreover, the circuit like connection provides an essentially constant bit rate, and thus, the packet delays are not variable or do not change from packet to packet. As a result, there is no packet jitter due to the essentially constant bit rate channel. Therefore, after the RTP receiver receives the initialization information, including an initial time stamp value (TSO), the RTP receiver can regenerate a correct time stamp for each subsequent packet (after initialization) based only on the time stamp counter (or receiver timer).<br>
The essentially constant bit rate channel provided between the header stripper 810 and header regenerator 822 need only provide a predetermined number of bits over a predetermined period of time between the header stripper 810 and the header regenerator 822, but this function can performed a variety of different ways. For example, the channel can be a constant bit rate channel that is dedicated to the stripper 810 and regenerator 822 or shared among several users. The channel can provide, for example one bit every millisecond, or provide 100 bits every 100 milliseconds but where the data rate may not be constant (i.e., may vary) within a 100 ms period. As an additional example, the channel may provide the predetermined number of bits through one or more data bursts between the header<br><br>
stripper and header regenerator. For example, the channel may provide a chunk or burst of 1000 bits every 10 milliseconds. Thus, the essentially constant bit rate channel need only provide a predetermined number of bits over a predetermined period of time, but can accomplish this using different techniques.<br>
2. RTP Sequence Number (SPf)<br>
RTP SN (as seen by the HS 810) normally increases by 1 from one packet to the next. The only exceptions are when packets are lost or misordered. In the uplink, packet loss or Disordering is not expected to happen, since the header stripper (HS) 810 and RTP source are very close to each other. Therefore, the following applies to the downlink. The HS 810 does limited buffering to attempt to reorder packets before stripping their headers. Packet with RTP SN n is considered lost if it is still not received by the time packet with RTP SN (n+1) has its header stripped. Packet with RTP SN m is misordered if, by the time it is received, packet with RTP SN k has had its header stripped, and k &gt; m. The length of the reordering buffer is a design parameter. Too long a buffer will result in an excessively large delay, while too short a buffer will result in too many discarded packets. The parameter also depends on the quality provided by the IP network 108 upstream of the HS 810. The HR 822 maintains a SN counter which is its best estimate of SN. By observing the Init_info, the HR 822 can obtain the initial SN and the number of bits contained in a packet also known as packet size (p_size). The HR 822 initializes the SN counter with the SN in IniMnfo. The HR 822 then "counts" the speech bits received over the essentially constant bit rate channel and increments the SN counter 1 for every p_size bits of speech (it is not incremented when no packet is received, e.g. during a silence interval). According to an embodiment, the HR 822 does not actually count the received bits. Rather, the SN counter at the HR 822 is incremented by 1 every packet duration, where a packet duration is the time required to receive a packet of bits (p_bits). Thus, the packet duration will be a function of tie packet size (p_size) and the bit rate(which is constant over the circuit like connection.<br>
Thus, it can be seen that after initialization occurs (providing the initial SN and TS to the HR 822), the HR 822 can generate the time stamps for sequential packets by incrementing the TS counter by TS_stride every T msecs, and by incrementing the SN counter by 1 every packet duration. Therefore, after initialization, these fields can be regenerated at HR 822 with reference only to a local clock (assuming TS^stride and packet duration are known by HR 822). The incrementing of SN counter based on time (packet duration) rather than an actual counting of received bits is more robust to errors. In the event one or more bits are dropped before reaching the HR 822, the SN counter will reflect the true value and will not be affected by the lost bits.<br>
B. Discontinuities and Strings<br>
The above description indicates that TS and SN can be completely stripped by HS 810 prior to<br><br>
transmission across a link (e.g., RF link 140), and then regenerated by the HR 822 maintaining a local clock or tinier (e.g., incrementing TS counter by TS_stride every T msecs and incrementing SN counter by 1 every packet duration). However, one or more basic discontinuity events may occur which, if not addressed, could likely invalidate the timer-based regeneration approach described above. Some of the discontinuity events may include:<br>
a)	Event "New spurt": Transient change in the TS difference between packet n and (n+1) (start of a new talk spurt); this may also be described as a non-linear change or a shift in the time stamp (TS).<br>
b)	Event "Size change": Change in RTP packet size (p_size), caused by a change in the number of speech frames packed in a packet and/or size of the speech frame<br>
c)	Event "Stride change": Change in TS_stride (caused, e.g., by a change in payload type PT).<br>
We define a header string as a sequence of packet headers such that all the packets have the same size (p_size), sequence numbers are consecutive, i.e. n, (n+1), (n+2), etc., and the time stamps(TSs) of consecutive packets are spaced apart by the same increment TS_stride.  In other words, a header string may be considered to be a string of headers having some packet fields in common (e.g., packet size), and other fields which increase linearly across consecutive packets, such as SN and TS. A string is usually a talk spurt (e.g., a series of voice samples provided between intervals of silence).<br>
The transition from one string to another can be caused by any of the discontinuity events, singly or even in combination. In this scheme, when a string begins (and the previous string has ended), the HS 810 determines which discontinuity event has occurred, and accordingly sends the needed string initialization (string_rnii) information to the HR 822.<br>
Fig. 9 is a table illustrating information which may be provided in messages according to an example embodiment of the invention. Initjnfo typically includes a full header (including fall SN and TS), and is sent from the HS 810 to HR 822 (to initialize HR 822) at the beginning of the session. HS 810 will continue to resend the inUJirfb until receiving an ack from HR 822, before proceeding with sending of the headerless data packets. Thereafter, there may be one of more strings which can occur, which may require additional updates of fields or values which change from one string to another. These changed values are provided to the HR 822 using stringjnit<br>
Stringjnit includes the p_size value (if it has changed from the previous string), and the TSstride value (if it has changed from the previous strfcg). If no non-linear shift occurs to the TS from one string to the next, the HR 822 can continue to regenerate the TS based on the TS counter used in the old string.  However, if a non-linear shift in the time stamp (TS) occurs between strings (i.e., loss of timing), the updated time stamp must be explicitly sent in the string_init from the HS 810 to the<br><br>
HR 822. The updated TS can be sent as a compressed time stamp 414 (see Fig. 4) described above so long as condition 1 is met, as described above. Otherwise, if condition J is not met, the fu]l updated time stamp must be transmitted to the HR 822.<br>
In ack mode, after the HS 810 sends the string_init to the HR 822, the HS 810 may require the HR 822 to acknowledge (or ack) receipt of the updated string information (string_init) before the HS 810 can send the further data packets {headerless packets) to HR 822. In acknowledged or ack mode, the HS 810 repeatedly sends a string_init message to the HR 822 until the HS 810 receives an ack from HR 822 for a strrag_init message. After receiving an ack from the HR 822, the HS 810 will then send the remaining packets of the string as stripped-header packets (since the TS and SN for packets of the new string can now be regenerated using only a local clock or timer). The ack requirement (in acknowledged mode) for the string__init message prevents the HS 810 from sending a new string without notifying the HR 822. For example, if the HS 810 sends a new string_init message (e.g., providing -updated fields or information related to a discontinuity event) while the link between the HS 810 and HR 822 is temporarily broken, the HS 810 cannot proceed to send header-stripped packets until first receiving the ack from the HR 822.<br>
Once the HS 810 is confident that the HR 822 has received the stringjnit information, speech frames (e.g., data packets) are then sent without the header for the remainder of the string. For these headerless frames, TS and SN are regenerated by using a local clock at the HR 822. The HS 810 can determine the events as follows:<br>
a)	Event "New spurt": TS difference between packet having SN = n and packet having SN = (n+I) is different from TS_stride. This means the beginning of a new string or talk spurt. In this case, to ensure SN synchronization, stringjnit consists of a SN or compressed SN (C_SN). If there were no SN information sent, the HR 822 cannot be sure that incrementing SN counter by 1 every packet duration will give an accurate SN. This is because there could have been a link disconnection, during which speech bits were lost between the HS 810 and HR.<br>
b)	Event "Size change": Size of RTP packet having SN = n is different from previously received packet; this will affect the value of packet duration (the rate at which SN counter is incremented).  string_init includes new p_size value.<br>
c)	Event "Stride change": Determined from analyzing payload type (FT) field in RTP packet; string init includes new TS__stride value.<br>
These discontinuity events are provided only as examples. Other types of discontinuity events are possible.<br>
Events can happen in combination (compound event). In that case, string_imt includes all the infonnation from the corresponding basic events. For example, if "New spurt" happens in combination<br><br>
with "Size change", string_init = {C_SN, new p_size value}<br>
C.	Procedure to send Init_info, Striag_init<br>
Init_info is normally sent in ack mode, whereby the HS 810 will send Init_info until acked by the HR 822. Stringjnit can be sent in ack or unack mode. In ack mode, the HS 810 will send String_init at every packet until acked by the HR 822. Once an ack "is received, the HS 810 sends only speech bits for the remainder of the string, without any header. In unack mode, the HS 810 will send String_init a certain (predetermined) number of times before sending speech bits only for the remainder of the string. Optionally, the stringjnit can be repeated at some interval during the string to ensure the HR 822 is synchronized (e.g., has the proper values).<br>
A compound event which includes the "Size change" or "Stride change" basic event will typically require StrirJg_init to be sent in ack mode. In that case, string__init will carry a generation number. The generation number is a counter incremented whenever p_size or TSjstride changes. It is used in the case where p_size or TS_stride change in rapid succession, to keep track of which change has been acked by the HR 822. For example, if p_size changes from value p_size_0 to p_size_l, then again to value p_size_2, the HS 810 will send string_init containing p_size_l, with generation number say 3, then subsequently another stringjnit containing p_size_2, with generation number 4. The receipt of an ack subsequent to the second stringjinit will be ambiguous, if it didn"t carry the generation number of the string_init being acked. If the compound event is only "New spurt", String_init (C_SN) can be sent in ack or unack mode. The unack mode is based on the idea that C_SN will be repeated at least at the start of every talk spurt.  Therefore the probability that the HR 822 will never resyncbrcmize its SN is asymptotically small. In addition, if the SN is desynchronized, it is only caused by packet loss between the HS 810 and HR 822. Therefore the effect of a SN desynchronization is that regenerated SN 
D.	Handover<br>
When the header stripping/regeneration is applied to cellular systems or other systems where station terminals can move from one network adapter (ANI_AD) to another, handovers or handoffs should be considered.<br>
The handover can be modeled as going through three phases: handover preparation, handover execution and handover completion. There is a function called handover (HO) manager (which may be provided in the ANI110) that decides to start handover preparation. Traditionally, handover<br><br>
preparation consists of exchanging signaling messages with the target system to reserve resources in the target system and obtain necessary information on the target cell. Handover execution is initiated by the source HO manager sending a HO command to the receiver terminal (or mobile station), along ^m\hJ^^jgg0^a\*u\iiii:^m^.lMJ!!i\. m response to HO command, the terminal (or mobile station) executes the handover. Handover completion involves exchange of signaling between the terminal or mobile station and the target system, notification to the source, and release of resources no longer needed (e.g. at the source).<br>
1. Uplink<br>
The ANI_AD acts as a HR 822 for the uplink data transmission (see uplink 142, Fig. 1). The target ANI_AD has to be provided with the necessary information to regenerate the full header. The main constraints include continuity of RTP TS and RTP SN through handover (HO).<br>
Fig. 10 is a diagram illustrating a handover process according to an example embodiment of the present invention. The terminalBO (or mobile station MS), as an example, may notify the spurce ANI_AD 112 that the packet size has changed using a string_init message, step 902. The source ANI_AD 112 acknowledges this update to the p_size, step 904. Subsequently, the terminal 130 moves to a new area covered by the target ANI_AD 114, and the HO manager 901 notifies the source AN1_AD of preparation for a handover (handoff), step 906. The source ANI_AD then sends a HO^initialization (HOjnitji) information to the target ANI_AD 114, step 908. HO_initji is an estimated view of the full IPAJDP/RTP header. The estimated view consists of the last regenerated header, but with a RTP TS replaced by TS0__u, m_last_u, TS_stride_u, and value of TS Timer_u. These values are related to TSJast, the RTP TS of the last regenerated header as follows: TSJast = TS0_u + mjast __u* TS_stride_u. TS Timerji is a counter at the source ANI_AD that was incremented by 1 every T msec. In addition, HO_init_u includes p_size_u (current size of packet in the uplink direction). From HO_init_u, the target AN1_AD derives the static fields,.as well as approximate initial values for changing fields (RTP TS and RTP SN). A handover command is sent from the HO manager 901 to the terminal 130 {mobile station), step 910, causing the terminal 130 to switch and now use the target ANI_AD for communication. However, a HO manager may not be necessary as other techniques can be used to initiate a handover.<br>
A handover is considered as breaking any ongoing string. Therefore, after handover completion, the very first speech sample to be sent is always handled like a new string, which requires sending initialization information (HO_sync_u), step 912. There are three significant points in time: ST1, which is the start of HO preparation, ST2, which is the receipt by MS of HO command, and ST3, which is the time the source ANI_AD took the snapshot of its internal information to be sent in<br><br>
HO_init_u. Let HOT be the time elapsed from ST1 to ST2. From the system design, there is an upper bound on HOT: HOT 
In all cases, HO_sync_u includes C_SN. C_SN is needed because there was a break caused by HO.   C_TS is needed if the bit rates, packet durations, etc. in the source and target systems are not synchronized. This is likely to be the case. HO_sync_u is preferably sent in ack mode.<br>
HO_init_u and HO_sync_u are used by the target ANI_AD 114 to regenerate the fall header as follows. All fields except TS and SN are copied from HO_init_u. SN is obtained by decompressing C_SN in HO_sync_u. TS is determined by decompressing C_TS in HO_sync_u. 2. Downlink<br>
The HS role is transferred from one ANI_AD to another. After handoff, the headers are routed on a new path going through the new ANI_AD instead of the old AN1_AD. As a result, there could be a discontinuity in the timing for the RTP TS regeneration at the terminal 130 (MS).<br>
To handle handover for the uplink, when the HO manager decides to start handover preparation, it will notify the source ANI_AD. The source ANI_AD then sends a HO_initialization (HO_init_d) information to the target ANI_AD. HOjnit_d consists of pjsized and TS_stride_d, which are the values last acknowledged by the MS, along with their generation number. The first time when the target ANI_AD wants to send speech after HO, the target ANI_AD has to send HO_sync_d. HO_sync_d consists- of C__TS and C_SN. If the new p_size differs from pjsize_d, HO_sync_d also contains the new value of<br>
p_size. If not, HO_sync_d just contains the generation number n of p_size_d. The MS uses the generation number to retrieve the correct p_size. This assumes the MS kept in memory the last few values of p_size, along with their generation number. The same algorithm applies to TS_stride. HO_init_d is sent until acked by the MS_AD. HO_sync_d is sent in ack mode. Handover process is depicted in figure 2. The case shown is: the most recent change in p_size_u has been acknowledged by time ST2 - HOT_max.<br>
. Sending Messages<br>
Each of the above information can be sent in-band or out-of-band. In the in-band<br><br>
approach, the information is sent on the speech channel by stealing the least significant voice bits. In the out-of-band approach, a dedicated transient channel is set up and tom down when an ack ts received. A combination of in-band and out-of-band is possible, whereby the out-of-band approach is attempted, but the in-band approach is a fall back solution if there is no resource for a transient channel. Acknowledgments can be sent in-band, or out-of-band on their own dedicated ack channel, or out-of-band piggybacked on the other dedicated transient channels (TIC, etc.)<br>
1.	In-band<br>
Regardless of how the circuit-like speech channel is realized, it can be modeled as a channel that can transmit B bits every T milliseconds. If S is the size of a speech frame in bits, SiB, With the envisioned voice codecs, Init_info is expected to be larger than S. Therefore an Init_info cannot be sent in the space ofa single speech frame. However, there is a factor R&gt;=1 such as (R-])*S <hi r the init_info can be carried on circuit-like channel by splitting them in chunks of b bits and sending one chunk every t mseconds. a full header will consume space consecutive speech samples. fig. is diagram illustrating an initialization for in-band according to example embodiment invention. if there continuous voice activity sent are init_jnfo initjinfo inimnfo etc. until ack received. these messages shown as stripper acks but not before hs sends second packet next from hr payload then regenerates sn ts other fields.></hi>
IniMnfo (0) takes the place of speech samples 0, I,..., (R-l), Init_info(R) takes the place of speech samples R, (R+1),..., (2R-1), and so on. If there is discontinuous voice activity, say header 0 is followed by a L*T msec silence interval, then Init_mfo(0) is repeated: The other information (stringjnit, HO_sync_d, HO_syuc_u, Ack), all have a size well below S, so they fit into the space of a speech frame. They steal the least significant voice bits. For simplicity, the analysis does not take into account the expansion caused by channel coding, but the concept is valid with or without channel coding. Initialization process for in-band case is shown in figure 3.<br>
2.	Out-of-band<br>
Fig. 12 is a diagram illustrating an initialization for out-of-band according to an example embodiment of the invention. In the out-of-band approach, a separate channel is set up with the appropriate bandwidth, to carry just the Init_info concurrently with, speech, which is carried on a speech channel. The separate channel is called the transient initialization channel (TIC). The system can attempt to allocate enough bandwidth for the TIC to permit sending a full header once every T msec. The TIC is designed to have a fixed timing relationship with the speech channel.<br><br>
Acknowledgments can be sent out-of-band by allocating a transient acknowledgment channel (TAC), or sent out-of-band, but piggybacked on a forward transient channel. HO_sync_u can be sent out-of-band over a transient uplink handover synchronization channel (TUHOSC). TUHOSC is torn down when HO_sync_u is acked. The same applies to HO_sync_d, which uses a transient downlink handover synchronization channel (TDHOSC).<br>
3.	Failure Cases<br>
There can be cases where the target ANI_AD will not have HOinit by the time the handover execution is finished. Reasons include excessive delay on the signaling network between the two ANI_ADs, need to execute handover quickly, etc. In those cases, the network will send a notification to the MS, which then restarts the initialization process, like at the beginning of the call.<br>
4.	Common Case Where P-Size and TS_stride are Constant<br>
The case where p_size and TS_stride are constant is by far the most common for voice. In this case, none of the considerations caused by possible change of p_size and TS_stride apply. The generic scheme is simplified. HO_init_d is not needed. HO_syncji and HO_sync_u only carry CJ5N and C_TS. String_init carries C_SN. It carries<br>
CJTS only if there is a timing change from one string to the next. The terminal (MS) does not have to keep in memory the last few values of p_size and TS_stride. In case of HO, the terminal (MS) does not have to determine whether to include p_size_u in HO_sync_u.<br>
As described above, the only information in the UVUDP/RTP headers that is essential for basic voice are the static fields and RTP time stamp (TS) and the. RTP sequence number (SN) is also very desirable. The scheme described herein achieves transparency for these information fields, and provides an advantageous header overhead compression efficiency. Continuity of all static and non-static fields is maintained through handover. Bandwidth management is also made easier, because in-band as well as out-of-band approaches are possible. Since transparency is maintained for RTP TS and RTP SN, it is even possible to switch back and forth between the header stripping scheme and the header compression scheme described herein that maintains transparency for all the fields. Switching to header compression may be needed when for example, another medium is added to voice.<br>
HI.      Timer and Reference Based Scheme<br>
A.        Timer and Reference Based Scheme Overview<br>
The timer and reference based scheme is based on the observations that (1) RTP time stamps when generated at the RTP source are correlated with a linear function of elapsed time between packets, and (2) RTP TS are of the form TSO + index*TS_stride, where TSO and TS_stride are constant, and index is an integer (hereinafter index will be referred to as the packed RTP TS).<br><br>
Therefore, in normal operation, the RTP time stamps received at the decompressor are also correlated with continually incrementing timer, with a distortion created only by the cumulative jitter between the source and the decompressor. Since the cumulative jitter includes "network" jitter (jitter between the source and the compressor) and "radio" jitter (jitter between the compressor and decompressor), the compressor can calculate an upper bound of the cumulative jitter by adding to the observed network jitter an upper bound of the radio jitter. The compressor then just sends as compressed RTP TS the "k" least significant bits of the packed RTP TS. The decompressor decompresses RTP TS by first calculating an approximation, and then refining the approximation with the information in the compressed RTP TS to determine the exact value. The approximation is obtained by adding to the RTP TS of the previously decompressed header a value proportional to the time elapsed since the previously decompressed header was received. The exact value of RTP TS is determined as the one closest to the approximation, whose k least significant bits of the corresponding packed RTP TS match the compressed RTP TS. The compressor chooses a value k as the smallest value pennitted that would allow the decompressor to decompress correctly, based on the upper bound of the cumulative jitter.<br>
B.	Case of Voice<br>
First, the timer and reference based scheme will be described with respect to voice. As an example, if the time interval between consecutive speech samples is 20 msec, then RTP time stamp of header n (generated at time n*20 msec) = RTP time stamp of header 0 (generated at time 0) + TS_stride* n, where TS_stride is a constant dependent on the voice codec. Consequently, the RTP TS in headers coming into the decompressor also follow a linear pattern as a function of time, but less closely, due to delay jitter between the source and the decompressor. In normal operation (absence of crashes or failures), the delay jitter is bounded, to meet the requirements of conversational real-time traffic.<br>
In this scheme, the receiver uses a timer to obtain an approximation of the RTP TS of the current header (the one to be decompressed), then refines the approximation with the additional information received in the compressed header.<br>
For example, assume the following:<br>
The Last_header is the last successfully decompressed header, where TS_last is the last RTP TS, and pJTSJast is the last packed RTP TS (at the receiver);<br>
T is the normal time spacing between two consecutive speech samples;<br>
TS_stride is the RTP TS increment every T msec;<br>
Current_header is the header of a current packet to be decompressed, where TS_current is the current RTP TS, and p_TS__current is the current packed RTP TS;<br><br>
RFH is the sequence number of a header whose ack was received by the compressor, where TS_RFH is the RTF TS, and p_JS_RFH is the packed RTP TS;<br>
Timer is a timer incremented every T msec, where both the compressor and decompressor each maintain their a Timer, denoted S_timer and R_timer respectively;<br>
T_RFH is the value of the Timer when RFH has been received, and T_current is the value of the same Timer when the Current_header has been received; and<br>
NJitter(n, m) is the observed network jitter of header n relative to header m (header n is received subsequently to header m),<br>
where Njitter (n,m) is calculated by the compressor as follows: N_Jitter(n,m) = Timer(n,m)- (packed RTP TS of header n - packed RTP TS of header m),<br>
where Timer(n,m) is the time elapsed from header m to header n, expressed in units of T msec. N_Jitter(n,m) can be positive or negative. N_Jitter at the compressor is the network jitter, quantized in units of T msec.<br>
R__Jitter(n,m) is the radio jitter of header n relative to header m, predicted by the compressor. R_Jitter depends only on the characteristics of the compressor-decompressor channel (CD-CC). R__Jitter does not have to be calculated precisely, a good upper bound for R_jitter is sufBcient. For example, an upper bound can be Max-radiojitter, the maximum jitter on the CD-CC, if it is known.<br>
Thus, according to the above, cumulative jitter for a packet is calculated as the sum of network jitter and radio:<br>
Further, RTP TS is calculated as follows;<br>
RTP TS = TSO + index*TS_stride,<br>
where TSO 
Thus TS Jast = TSO + radexJa5t*TS_5tride, and TS_current =TS0 + index_current*TS_stride.<br>
1.	Compressor<br>
The compressor sends in the compressed header, k least significant bits of p_TS_current.<br>
The compressor runs the following algorithm to determine k: Calculate Max_networkjitter;<br>
Calculate Jl = Max_networkJitter + Max_radioJitter + J,<br>
where J = 2 is a factor to account for the quantization error caused by the Timers at the compressor and decompressor, which can be +1 or -1; and<br><br>
Find the smallest integer k that satisfies a condition of: (2*J1 + I)
Network jitter at the compressor can be calculated according three different methods, namely a first method illustrated in Fig. 13 a second method iJJustrated in Fig. 14 and a third method illustrated in Fig. 15. The second and third methods are described below as Option 1 and Option 2 respectively. The first method is adequate for calculating network jitter. However, the preferred methods for calculating network jitter at the compressor are the second and third methods described as Option 1 and Option 2 respectively below.<br>
As illustrated in Fig. 13, according to the first method network jitter for a particular packet at the compressor is calculated using information with respect to the immediately preceding packet. Thus, for example, network jitter for packet 2 (j2) is calculated using information with respect to packet 1, network jitter for packet 3 (j3) js calculated using information with respect to packet 2, network jitter for packet 4 (j4) is calculated using information with respect to packet 3, and network jitter for packet 5 (j5) is calculated using information with respect to packet 4.<br>
Thus, according to Fig. 13, network jitter for packet 2 equals the calculated jitter j2, network jitter for packet 3 equal the calculated jitter j3, network jitter for packet 4 equals the calculated jitter j4, and network jitter for packet 5 equals the calculated jitter j5.<br>
Option 1:<br>
The steps used to calculate network jitter for the second method of Option 1 are illustrated in Fig. 14. In Option 1 network jitter for a particular packet is calculated using information with respect to a reference packet. Thus, assuming packet 2 is the reference packet as illustrated in Fig. 14, jitter j3 of packet 3 is calculated using information with respect to the reference packet 2, jitter j4 of packet 4 is calculated using information with respect to the reference packet 2, and jitter JS of packet 5 is calculated using information with respect to the reference packet 2.<br>
According to the second method of Option 1 as illustrated in Fig. 14, if it is assumed that jitter j3 = 2, jitter j4 = 3 and jitter j5 - -1, then prior to packet 5 NJitter_min *= 2 and Njitter_max = 3, whereas at packet 5 NJitterjnin = -I and NJitter_max = 3. Thus, maximum (Max) network jitter at packet 5 = Njitterjnax - NJitter_min = 4. Accordingly, Max_networkjitter for packet 5 is 4. The equations for calculating network jitter according to the method of Option 1 and a description thereof are set forth below.<br>
The network jitter of a current packet is calculated according to the method of Option 1 as follows:<br>
NJitter (Current_header, RFH) = (T_current-T_RFH) - (pJTS_current - p_TS_RFH);<br><br>
Update Njitter_max and N_jitter_min, where N_jitter_max is defined as Max {N jitter(j, RFH)}, for all headers j sent since RFH and including RFH. NJitter_mjn is defined as Min {N_jitter(j, RFH)}, for all headers j sent since RFH and including RFH; and<br>
Calculate Max__networkJitter = (Njitter_max -Njitter_mra).<br>
It should be noted that "NJitterrnax and N_jjter_nfm can be positive or negative, but (Njitter_max - NJitter_min) is positive.<br>
Option 2:<br>
The steps used to calculate network jitter for the third method of Option 2 are illustrated in Fig. 15. In Option 2, network jitter at a particular packet is calculated using jitter calculations between the packet of interest and each of a predetermined number of preceding packets. The predetermined number of preceding packets is defined as a window and such window can be of any value. In the example illustrated in Fig. 15, the window has a value of 4 preceding packets. The window could be set at any other value such as, for example, 7 packets. Further, the window could, for example, be set to be a value equal to the number of packets since the last reference packet.<br>
As illustrated in Fig. 15, network jitter for packet 5 is calculated using information with respect to packet 1 j(5,1), packet 2, j(5,2), packet 3 j(5, 3) and packet 4, j(5,4). As illustrated in Fig. 15, ifthe network jitter calculated for packet5 with respect to each of packet 1 isj(5,l)=-2, packet 2 is j(5,2) = 3, packet 3 is j(5,3) = 4, and packet 4 is j(5,4) ~ 7, then the max_networkJitter = 7. The equations for calculating network jitter according to the third method of Option 2 and a description thereof are set forth below.<br>
The network jitter of a current packet is calculated according to the method of Option 2 as follows:<br>
Calculated NJitterfCurrentJieader, j) = (T_current-TJ) - (pJTS_current - p_TSJ) for all headers j sent before the current header, and belonging to a window W, where TJ is the timer value when header j was received, and pJTSj is the packed RTF TS of header j; and<br>
Calculate Max_networkJitter= {Max NJrtter(Current Jieader, j)|over all j in the window W.<br>
In the case where a feedback from the decompressor is available, the window W includes headers sent since the last header know to be correctly received (e.g., acknowledged). In the case of no feedback, the window W includes the last L headers sent, where L is a parameter.<br>
2.        Decompressor<br>
To decompress RTP TS of Currentheader, the receiver calculates the time elapsed since the Lastjbeader was received, in units of T msec. That time, Timer (CurrentJieader,<br><br>
Last_neader) is added to p_TS_Iast, to give an approximation of p_TS_current. The receiver then determines the exact value of p_TS_current by choosing the value closest to the approximation, whose k least significant bits match the compressed RTF TS. TS_current is then calculated as TSO + (p_TS_current)*TS-stride.<br>
Timer(CuTTent_header, Last_header) can be calculated as (T_current - T_last), where T_current and T_last are the values of RJTimer when Current_header and Lastheader were received respectively.<br>
3.	Proof of correctness<br>
In order to prove corrections of the timer and reference based scheme the following is assumed:<br>
Approx_TS is the approximation of p_TS_current, calculated by the decompressor as p_TS_last + Timer (Current_header, Last_header); and<br>
Exact_TS is the exact value of p_TS_current.<br>
Based on the above then:<br>
lApprox_TS-Exact_TSl
Due to the definition of Max_network_jitter at the compressor<br>
|Jitter(Current__header, Last_header)| s Jl,<br>
Where Jl= Max_networkjitter + Max_radio_jitter+ J.<br>
J is a factor added to account for the quantization error caused by the Timers at the compressor and decompressor, which can be+1 or-1. Therefore, J = 2 is sufficient.<br>
Thus, it follows that:<br>
[ApproxJTS-Exact_TS| s Jl<br>
To calculate the xact_TS without ambiguity, it is sufficient to choose k such that the condition of (2*J1+1) 
4.	Case of Packet Misordering Before the Compressor<br>
Packet Misordering can be detected by a decreasing RTF sequence number (RTP SN). When that happens, the compressor can encode the packed RTP TS using a different scheme, for example, VLE. The decompressor is notified of the different encoding by appropriate indicator bits in the compressed header.<br>
Another option is to apply the normal Timer and Reference Based Scheme algorithm -Misordering will likely result in a larger value of k.<br><br>
5.	Uplink<br>
In wireless systems, for the uplink direction, the network jitter is zero (since both the RTP source and the compressor are located in the wireless terminal), and the radio jitter is normally bounded and controlled to remain very small. Therefore, the expected k will be very small and constant, which minimizes the header size fluctuation. This is a very significant advantage for bandwidth management, since for the uplink, the terminal usually has to request for increased bandwidth from the network. Furthermore, there is no packet misordering. Consequently, the timer based scheme is extremely well suited for the uplink.<br>
6.	Downlink<br>
For the downlink direction, the network jitter is not zero, but the overall jitter is normally small to meet the real-time requirements. The expected k will still be small and usually constant. There may be more fluctuation in k, but the bandwidth management is less of an issue, since the network controls the bandwidth allocation.<br>
7.	Handoff<br>
In cellular systems, there is a MS-tc-network radio link and network-to-MS radio link, denoted uplink and downlink respectively. When compression/decompression is applied to cellular links, there is an MS-based function, MS_AD (MS adaptor), which does compression and decompression for the uplink and downlink respectively. There is a network-based entity, called ANI_AD (access network infrastructure adaptor) that does decompression and compression for uplink and downlink respectively.<br>
The specific case of handoff to consider is inter-ANI_AD handoff, where there may be a disruption caused by switching from the old AN1_AD to a new AN1_AD. The issue is how to maintain continuity of information through the handoff so that after handoff, the compression/decompression at MS_AD and the new ANI_AD continue without disruption.<br>
There are two alternative methods for handoff, described below:<br>
a.	First method<br>
The first method uses the scheme of taking a snapshot of context information exchanged between the ANI_AD and MS_AD, with the handshake method, as disclosed in the related application Serial No. 09/522,497, filed on 09 March 1999, the same date as the present application for "AN EFFICIENT HANDOFF PROCEDURE FOR HEADER COMPRESSION" by K, Le. For the RTP TS, the context information contains the full RTP TS of a reference header. Right after handoff, the compressors (MS_AD for uplink and ANI_AD for downlink) temporarily discontinue using the timer-<br><br>
based scheme and send a compressed RTP TS with respect to the reference value. For example, VLE encoding as disclosed in the related application Serial No. 09/522,497, filed 09 March 1999, the same date as Ihe present application for "AN EFFICIENT HANDOFF PROCEDURE FOR HEADER COMPRESSION" by K. Le could be used. Once an acknowledgement has been received, the compressor uses the acknowledged value as the RFH, and switches Back to the timer-based scheme.<br>
b.	Second Method<br>
The second method keeps using the timer-based scheme across the handoff.<br>
i.	Downlink<br>
There is no discontinuity on the receiver side, which is the MS. The compressor"s role is transferred from one ANI-AD to another. After handoff, the headers are routed on a new path going through the new ANI_AD instead of the old ANI_AD.<br>
-Compressor<br>
The old ANI_AD transfers to the new ANI_AD a snapshot of the following information: T_RFH, p_TS_RFH, current value of SJTimer, TSO, and TSjstride, using the handshake method. (The snapshot values will be denoted with a star, e.g., TRFH*). The new ANIAD initializes its SJTimer with the current value of S-timer received from the old ANI_AD and starts incrementing that timer every T msec. Initialization of the Sjimer with the current Sjimer value of the old ANI_AD is a - conceptual description. If there is a singe Sjimer shared by multiple flows, the actual Sjimer is not reinitialized. Rather, the offset between that Sjimer and the value from the old ANI_AD is recorded. The offset is taken into account in future calculations. To compress the very first header after handoff, the new AM_AD sends the k least significant bits of p_TS_current. The new ANI_AD determines k, the number of bits to be used, as follows:<br>
32 = Upper bound of NJitter(CurrentJieader, RFH*) + Max_radioJitter + J,<br>
Where k is selected to satisfy a condition of (2*J2+1) 
In the above, Max_radioJitter is the maximum jitter on the segment between the new ANI_AD and the MS-AD.<br>
An Upper bound of NJitter(CurrentJieader, RFH*) is calculated as follows:<br>
| Timer(Current_header, RFH*)-(p_TS_current -pJTSJtFH*)| + Tjransfer, where Timer(Current_header, RFH*) is (T_current-T_RFH*);<br>
T_current is the value of SJTimer at the new ANI_AD when Current_header was received;<br>
T-RFH* is the value received from the old AN1_AD;<br>
Tjransfer is an upper bound of the time to transfer the context information from old ANI_AD<br><br>
to new ANI_AD, expressed in units of Tmsec; and<br>
J = 2.<br>
-Decompressor<br>
To decompress RTP TS of Currea^h^der, the receiver calculates the time elapsed since RFH was received, in units of T msec. That time, TimertCurrentJieadef, RFH), is added to pJTSJRFH, to give an approximation of p_TS_current. The receiver then determines the exact value of p_TS_cuirent by choosing the value closet to the approximation, whose k least significant bits match the compressed RTP TS. TS_current is then calculated as TSO + (pJTS_current)*TS__stride.<br>
The time elapsed since RFH was received can be calculated as (T_current-T_RFH).<br>
-Failure case<br>
When the context information cannot be transferred to the new ANI_AD in a timely maimer, the new ANI_AD will send the ful RTP TS until an acknowledgment is received.<br>
ii.        Uplink<br>
The decompressor role is transferred from one ANI_AD to another. The compressor stays anchored at the MS.<br>
-Decompressor<br>
The old AM_AD transfers to the new ANI_AD a snapshot of the following information: T_RFH*, pJTS_RFH*, current value of RJTimer*, TSO, and TS_stride, using the handshake method. The new AN1_AD initializes its RJTimer with current value of RJTimer received from the old ANI_AD2 and starts incrementing that timer every T msec. Initialization of the R_timer with the current Rjtimer value of the old AN1_AD is just a conceptual description. If there is a single R_timer shared by multiple flows, the actual R_timer is not reinitialized. Rather, the offset between that Rtimer and the value from the old ANI_AD is recorded. That offset is taken into account in future calculations. To decompress the very first header after handoff, the new ANI__AD calculates Timer(CurremJheader, RFH) adds it to pJTS_RFH*&gt; to give an approximation of p-TS-current. The receiver then determines the exact value to pJTS_current by choosing the value closest to the approximation, whose k least significant bits match the compressed RTP TS. TS_current is then calculated as TSO + (pJTS^current)* TS_stride.<br>
Timer(CuTrent_header, RFH) can be estimated as (T_current-T_RFH*). T__current is the value of RJTimer when Curremjheaderwas received.<br>
-Compressor<br>
The MSAD sends the k least significant bits of p-TS_current It determines k, the number of bits to be used, as follows:<br><br>
Calculate 32 ~ Upper bound of N_jitter(Current_header, RFH*) + Max_radio_jitter + J,<br>
When k is selected to satisfy a condition of(2*J2+1) 
Upper bound of NJitter(CurTent_header, RFH*) is calculated as [Timer(Current_headef,~ RFH*)-(p_T S_current_header-p_TS__RFH*)i + Tjransfer,<br>
where Timer(Currenr_header, RFH*) is (T_current-T_RFH*);<br>
T_current is the value of SJTimer at the new ANI_AD when Current header was received;<br>
T_RFH* is the value received from the old ANI_AD;<br>
T_transfer is an upper bound of the time to transfer the context information from old AM_AD to new AN1_AD, expressed in units of T msec; and<br>
J=2<br>
-Failure Case<br>
When the context information cannot be transferred to the new AN1_AD in a timely manner, the new ANI_AD will notify the MS_AD, which sends the full RTP TS until an acknowledgment is received.<br>
8.        Performance of the Scheme<br>
Due to the conversational real-time requirements, the cumulative jitter in normal operation is expected to be at most only a few times T msec. Therefore, a value of k around 4 or 5 is sufficient, as a jitter of up to 16 to 32 speech samples can be corrected.<br>
The advantages of this scheme are as follows:<br>
The size of the compressed header is constant and small. The compressed header typically includes a message type, which indicates the type of message (kl bits), a bit mask which indicates which field are changing, and a field that contains the k least significant bits of index_current (k bits). Assuming that 4-bit MSTi bit mask is used, and kl = 4, the size of compressed header when only the RTP TS changes (this case is by far the most frequent) is 1.5 bytes. Furthermore, the size does not change as a function of the length of interval of silence.<br>
No synchronization is required between the timer process and the decompressor process.<br>
Robustness to errors, as the partial RTP TS information in the compressed header is self contained and only needs to be combined with the receiver timer to yield the full RTP TS value. Loss or corruption of a header will not invalidate subsequent compressed headers.<br>
The compressor needs to maintain little memory information:<br><br>
T_RFH, p-TSJRFH, NJivter_max, NJitterjnm, TSO, and TS_srride in Option 1 and {T-j, p-TS-j}, for all j in window W, TSO, and TS-stride in Option 2.<br>
C.	Jitter Reduction<br>
Due to the conversational real-time requirements, one can reasonably expect that the various jitters described above are on the order of a few T msec"s jn normal operation. However, one cannot rule out cases where the jitter is larger and would therefore require a larger k. For example, there can be abnormal conditions on the path from the RTP source to the receiver (failures, etc.),  during which jitters become excessive. Also, there may be cases where a constant value of k is desired or desirable. To deal with these cases, a jitter reduction function can be implemented as a front end to the compressor to filter out packets with excessive jitter (i.e., jitter exceeding some threshold value). In the stationary case (no handoff), the jitter is calculated as J1 and compared to a stationary threshold as follows:<br>
Jl = (nJitter_max-NJitter_min) + Max_radioJitter + J.<br>
In the handoff case, the jitter is calculated as J2 and compared to a handoff threshold as follows:<br>
J2= |Timer(Cmrent_heacler, RFH*) - (p_TS-current-p_TS_RFH*)| + T_transfer+Max_radioJitter + J.<br>
The main difference with respect to the stationary no-handoff case, is the addition of TJransfer. In practice, to be able to execute handoff in 100 msec, T_transfer must be bounded by about 100 msec, so T_transfer = about 5 or 6 in units ofTmsec(T=20 msec). A value of k=5 is sufficient.<br>
The stationary and handoff thresholds may or may not be the same.<br>
D.	Case of Video<br>
In the case of an RTP video source, it is not necessarily true that there is a constant time spacing between packets, and furthermore, the RTP TS does not necessarily increment by a constant stride from one packet to the next. However, the RTP TS and time spacing between packets are discrete. Thus, as follows:<br>
RTP time stamp of packet m = RTP time stamp of packet 0 (generated at time 0) + TS_stride* [index + adjustfm)],<br>
where TS_stride is a constant dependent on the codec, and adjust(m) is an integer that depends on m and reflects the differences with respect to a linear behavior like in voice; and<br>
the time spacing between two consecutive packets is an integer multiple of T msec.<br><br>
In what follows, that behavior at the RTP source is referred to as adjusted linear behavior. Using the same notation as for voice, TS^last = TSO + TS+stride* [indexjast + adjust (indexjast)], and TS_current = TSO + TS_stride" [index_current) + adjust (index-current]. The Adjust parameter can be positive or negative. Thus, the main difference compared to voice is the additional term Adjust.<br>
The RTP TS is headers coming into the decompressor also follow an adjusted lineai pattern as a function of time, but less closely, due to the delay jitter between the source and the decompressor. In normal operation (absence of crashes or failures), the delay jitter is bounded, to meet the requirements of conversational real-time traffic.<br>
As above it is assumed that the packed RTP TS of Current_header=index_current + adjust(index_current). The same notation will be used with respect to p_TS_current, for example,<br>
Compressor<br>
The compressor sends in the compressed header the k least significant bits of p_TS_cwreDt. The algorithm to determine k is the same as for voice. Decompressor<br>
The algorithm to be used is the same as for voice.<br>
1.	Handoff<br>
The two alternative methods for handoff described for voice, apply as well to video.<br>
2.	Value of k<br>
For voice, it was shown that k = 4 or 5 is sufficient (2k = 16 or 32). In the case of video, a larger value of k is required due to Adjust. Since the video is structured in 30 frames per second, ]Adjustj
Several embodiments of the present invention are specifically illustrated and/or described herein. However, it will be appreciated that modifications and variations of the present invention are covered by the above teachings and within the purview of the appended claims without departing from the spirit and intended scope of the invention.<br>
While the present invention has been described in detail and pictorially in the accompanying drawings it is not limited to such details since many changes and modifications recognizable to those of ordinary skill in the art may be made to the invention without departing from the spirit and the scope thereof.<br><br><br>
We claim:<br>
1. A method of (transmitting in a network between a source and a receiver/ a current header field of a current packet using a timer-based compression technique, comprising the steps of:<br>
providing from a compressor to a decompressor an initial value of a header field;<br>
calculating at the compressor a compressed header field of the current packet based on the current header field of the current packet and jitter, (whereir} the said calculating step comprises the steps of:<br>
calculating a jitter effect the network between a source and said decompressor has on the transmission of packets, and calculating the compressed header field as a portion of a field value, said portion being a function of jitter;<br>
receiving the compressed header field of the current packet at the decompressor;<br>
estimating the header field of the current packet based on elapsed time at the decompressor between reception of the compressed header field of the current packet and reception of a header field of a previous packet which was decompressed and a decompressed field value of the previous packet; and<br>
correcting the estimated current header field based on the compressed header field received at the decompressor.<br><br>
2.	A method as claimed in claim 1, wherein said calculating a jitter effect<br>
comprising the steps of:<br>
calculating a jitter effect of the network before the compressor; and calculating a jitter effect of the network between the compressor and decompressor.<br>
3.	A method as claimed in claim 2, wherein said jitter effect of the network between the compressor and decompressor is set to an upper bound value for jitter.<br>
4.	A method as claimed in claim 2, wherein said calculating a jitter effect of the network before the compressor comprises the step of:<br>
calculating jitter effect of a current packet using information with respect to a reference packet.<br>
5.	A method as claimed in claim 2, wherein said calculating a jitter effect of the<br>
network before the compressor comprises the step of:<br>
calculating jitter effect of a current packet using information with respect to said current packet and each of a predetermined number of preceding packets.<br>
6.	A method as claimed in claim 2, wherein said calculating a jitter effect of the<br>
network before the compressor comprises the step of:<br>
calculating jitter effect of a current packet using information with respect to said current packet and each preceding packet up to a reference packet.<br><br>
7.	A method as claimed in claim 1, wherein said calculating at the compressor the<br>
compressed header field of the current packet comprises the step of:<br>
calculating the compressed header field of the current packet as the least significant k bits of the field value, where k is an integer.<br>
8.	A method as claimed in claim 1, wherein said header field comprises a time stamp.<br>
9.	A method as claimed in claim 1, wherein said header field comprises an RTP time stamp.<br>
10.	A method as claimed in claim 1, wherein said calculating at the compressor the compressed header field of the current packet comprises the step of;<br>
converting the field value into another value, referred to as a packed value, which takes fewer bits to represent; and calculating the compressed header field of the current packet as the least significant k bits of the packed value, where k is an integer.<br>
11.	A method of decompressing a current header field of a current packet<br>
transmitted in a network from a compressor to a decompressor comprising the steps<br>
of:<br>
receiving a compressed header field of a current packet at the decompressor, said compressed header field having be^n calculated at the compressor as a oortion of<br><br>
a field value which is calculated as a jitter effect the network between a source and the decompressor has on the transmission of packets;<br>
calculating an approximation of the header field of the current packet at the decompressor based on elapsed time since arrival of a previous compressed header field at the decompressor and a decompressed field value of the previous packet;<br>
calculating a header field correction amount for the current packet at the decompressor based upon the compressed header field of the current packet; and<br>
decompressing the compressed header field of the current packet at the decompressor by adjusting the approximation of the header field of the current packet an amount based upon the header field correction amount.<br>
12.	A method as claimed in claim 11, wherein said jitter effect the network between the source and the decompressor has on the transmission of packets is calculated by calculating a jitter effect of the network between the compressor and calculating a jitter effect of the network between the compressor and decompressor.<br>
13.	A method as claimed in claim 12, wherein said jitter effect of the network between the compressor and decompressor is set to an upper bound value for jitter.<br>
14.	A method as claimed in claim 12, wherein said calculating a jitter effect of the network before the compressor comprises the step of:<br>
calculating jitter effect of a current packet using information with respect to a reference packet.<br><br>
15.	A method as claimed in claim 12, wherein said calculating a jitter effect of the<br>
network before the compressor comprises the step of:<br>
calculating jitter effect of a current packet using information with respect to said current packet and each of a predetermined number of preceding packets.<br>
16.	A method as claimed in claim 12, wherein said calculating a jitter effect of the<br>
network before the compressor comprises the step of:<br>
calculating jitter effect of a current packet using information with respect to said current packet and each preceding packet up to a reference packet.<br>
17.	A method as claimed in claim 11, wherein the compressed header field is calculated as the least significant k bits of the field value, where k is an integer.<br>
18.	A method as claimed in claim 11, wherein the compressed header field is calculated as the least significant k bits of a packed value, where k is an integer; and wherein the decompressor calculates an approximation of the packed value based on time elapsed since arrival of a previous packet and a decompressor packed value of the previous packet.<br>
19.	A method of performing a handoff between first and second network entities in a system, the first and second network entities interfacing a mobile decompressor to a source terminal when the mobile decompressor is located in first and second areas,<br><br>
respectively, the method comprises the step of:<br>
receiving an initial value of a header field at the first network entity and at the mobile decompressor from a source terminal, the first network entity interfacing the mobile decompressor, located in a first area, to a source terminal;<br>
receiving a header field of a first packet that is addressed to the mobile decompressor at the first network entity from the source terminal;<br>
compressing the header field of the first packet at the first network entity and sending a first compressed header field of the first packet to the mobile decompressor, said first compressed header field being calculated as a portion of a field value which is calculated as a first jitter effect the network between the source terminal and the mobile decompressor has on the transmission of packets;<br>
receiving and decompressing the first compressed header field of the first packet at the mobile decompressor based on time elapsed since arrival of a previous packet and decompressed field value of the previous packet;<br>
the mobile decompressor moving from the first area to the second area;<br>
transmitting the initialization information to the second network entity to initialize the second network entity for compression;<br>
receiving and compressing, at the second network entity, a header field of a second packet from the source terminal that is addressed to the mobile decompressor, and sending a second compressed header field of the second packet to the mobile decompressor, said second compressed header field being calculated as a portion of a<br><br>
field value which is calculated as a second jitter effect the network between the source terminal and the mobile decompressor has on transmission of packets and the time to transmit the initialization information to the second network entity; and<br>
receiving and decompressing the second compressed header field of the second packet at the mobile decompressor based on time elapsed since arrival of a previous packet and decompressed field value of the previous packet.<br>
20.	A method as claimed in claim 15, wherein each of said first and second jitter effect the network between the source terminal and the decompressor has on the transmission of packets is calculated by calculating a jitter effect of the network before the compressor, and calculating a jitter effect of the network between the compressor and decompressor.<br>
21.	A method as claimed in claim 20, wherein said jitter effect of the network between the compressor and decompressor is set to an upper bound value for jitter.<br>
22.	A method as claimed in claim 19, wherein said first packet is a packet immediately preceding handoff and said second packet is a packet immediately succeeding handoff.<br>
23.	A method as claimed in claim 20, wherein said calculating a jitter effect of the network before the compressor comprises the step of:<br><br>
calculating jitter effect of a current packet using information with respect to a reference packet.<br>
24.	A method as claimed in claim 20, wherein said calculating a jitter effect of the<br>
network before the compressor comprises the step of:<br>
calculating jitter effect of a current packet using information with respect to said current packet and each of a predetermined number of preceding packets.<br>
25.	A method as claimed in claim 20, wherein said calculating a jitter effect of the<br>
network before the compressor comprises the step of:<br>
calculating jitter effect of a current packet using information with respect to said current packet and each preceding packet up to a reference packet.<br>
26.	A method as claimed in claim 19, wherein said header field comprises a time stamp.<br>
27.	A method as claimed in claim 19, wherein the compressed header field is calculated as the least significant k bits of the field value, where k is an integer.<br>
28.	A method as claimed in claim 19, wherein the compressed header field is calculated as the least significant k bits of a packed value, where k is an integer; and<br><br>
wherein the decompressor calculates an approximation of the packed value based on time elapsed since arrival of a previous packet and a decompressor packed value of the previous packet.<br>
29. A method of performing a handoff between first and second network entities, the first and second network entities interfacing a mobile compressor to a receiver terminal when the mobile compressor is located in first and second areas, respectively, the method comprising the step of:<br>
receiving an initial value of a header field at a first network entity from a mobile compressor;<br>
receiving in the first network entity, a first compressed header field of a first packet received from the mobile compressor, said first compressed header field having been calculated at the mobile compressor as a portion of a field value which is calculated as a first jitter effect the network between a source and a decompressor has on transmission of packets;<br>
decompressing, in the first network entity, the first compressed header field of the first packet based upon the time elapsed since arrival of a previous packet and decompressed field value of the previous packet;<br>
the mobile compressor moving from the first area to the second area;<br>
sending initialization information to the second network entity to initialize the second network entity for compression;<br>
receiving, in the second network entity, a second compressed header field of a second packet received from the mobile compressor, said second compressed header<br><br>
field having been calculated at the mobile compressor as a portion of a field value which is calculated as a second jitter effect the network between the source and the decompressor has on transmission of packets and the time to transmit the initialization information to the second network entity; and<br>
decompressing, at the second network entity, the second compressed header field of the second packet based upon the time elapsed since arrival of a previous packet and decompressed field value of the previous packet.<br>
30.	A method as claimed in claim 29, wherein said first and second jitter effect the network between the source and the decompressor has on the transmission of packets is calculated by calculating a jitter effect of the network before the mobile compressor, and calculating a jitter effect of the network between the compressor and decompressor.<br>
31.	A method as claimed in claim 30, wherein said jitter effect of the network between the compressor and decompressor is set to an upper bound value for jitter.<br>
32.	A method as claimed in claim 29, wherein said first packet is a packet immediately preceding handoff and said second packet is a packet immediately succeeding handoff.<br>
33.	A method as claimed in claim 30, wherein said calculating a jitter effect of the network before the mobile compressor comprises the step of:<br><br>
calculating jitter effect of a current packet using information with respect to a reference packet.<br>
34.	A method as claimed in claim 30, wherein said calculating a jitter effect of the<br>
network before the mobile compressor comprises the step of:<br>
calculating jitter effect of a current packet using information with respect to said current packet and each of a predetermined number of preceding packets.<br>
35.	A method as claimed in claim 30, wherein said calculating a jitter effect of the<br>
network before the mobile compressor comprises the step of:<br>
calculating jitter effect of a current packet using information with respect to said current packet and each preceding packet up to a reference packet.<br>
36.	A method as claimed in claim 29, wherein said header field comprises a time stamp.<br>
37.	A method as claimed in claim 29, wherein the compressed header field is calculated as the least significant k bits of a packed value, where k is an integer; and<br>
wherein the decompressor calculates an approximation of the packed value based on time elapsed since arrival of a previous packet and a decompressor packed value of the previous packet.<br>
38.	A method as claimed in claim 29, wherein the compressed header field is<br>
calculated as the least significant k bits of the field value, where k is an integer.<br><br>
39.      A communication system comprising:<br>
a source providing a plurality of packets, each packet including a header field, the source being coupled to a network;<br>
a receiver including a decompressor;<br>
a network entity coupled to the network and to the receiver by a network between the network entity and the receiver, the network entity including a compressor for performing header field compression for at least some of the packets sent from the source and directed to the receiver, the network entity including a jitter reduction function for calculating jitter in the packets directed to the receiver terminal and discarding packets having a jitter that is greater than a predetermined value, wherein the jitter is calculated as a total of an amount of jitter caused by the network between the source and the decompressor included in the receiver.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgYXNzaWdubWVudC5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgY2xhaW1zLWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che claims-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgY29ycmVzcG9uZGVuY2Utb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgY29ycmVzcG9uZGVuY2UtcG8ucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgZGVzY3JpcHRpb24gKGNvbXBsZXRlKS1kdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che description (complete)-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgZHJhd2luZ3MtZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che drawings-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgZm9ybS0xLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgZm9ybS0xOC5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgZm9ybS0yNi5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgZm9ybS0zLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgZm9ybS01LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgcGN0IHNlYXJjaCByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che pct search report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgcGN0LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che pct.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTM4MC1jaGUgcGV0aXRpb24ucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1380-che petition.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="221434-printed-page-tag-encoder.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="221436-device-for-the-high-pressure-supply-of-fuel-to-an-internal-combustion-engine.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>221435</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2002/1380/CHE</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>37/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>12-Sep-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>23-Jun-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>02-Sep-2002</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>NOKIA CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>KEILALAHDENTIE 4, FI-02150 ESPOO,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>LE, KHIEM</td>
											<td>935 VILLAGE PARKWAY, COPPELL, TX 75019,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04 L 29/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2001/07573</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2001-03-09</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09/522,363</td>
									<td>2000-03-09</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/221435-a-system-and-method-for-transmitting-data-in-a-network-by-compression-technique by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:38:42 GMT -->
</html>
