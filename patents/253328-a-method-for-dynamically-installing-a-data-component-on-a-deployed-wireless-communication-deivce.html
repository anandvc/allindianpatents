<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/253328-a-method-for-dynamically-installing-a-data-component-on-a-deployed-wireless-communication-deivce by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:53:45 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 253328:A METHOD FOR DYNAMICALLY INSTALLING A DATA COMPONENT ON A DEPLOYED WIRELESS COMMUNICATION DEIVCE</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD FOR DYNAMICALLY INSTALLING A DATA COMPONENT ON A DEPLOYED WIRELESS COMMUNICATION DEIVCE</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Systems and methods for dynamic installation of modular software applications (140) or hardware device drivers (130) are provided. A wireless communication device (20) sends a request to an update module server (60) identifying a requested software or hardware module (140, 130). The update module server (60) responds with an instruction set for installing the requested module and the software or hardware module itself. Upon receipt, the device (20) executes the instruction set to install the requested module, making any necessary adjustments or deletions to data in persistent storage (240) in order to accommodate the requested module (140, 130). Subsequently, the wireless communication device (20) is reconfigured or rebooted to complete the installation and configuration.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FIELD OF THE INVENTION<br>
The present invention generally relates to the field of wireless communications and more<br>
particularly relates to interchangeable software applications, hardware drivers,<br>
communication interfaces and components of the operating system in a wireless<br>
communication device.<br>
BACKGROUND OF THE INVENTION<br>
Conventional wireless communication devices typically become isolated computing<br>
platforms once they are deployed (i.e., sold to a consumer). Consumers typically must bring<br>
the wireless communication device (also referred to herein as "wireless device," "handset,"<br>
and "mobile device") to a service station for upgrades to the operating system or any<br>
integral software application such as a phonebook.<br>
Additionally, if the consumer wants to replace a hardware component of a wireless<br>
communication device, the wireless device must be brought into a service station.<br>
Generally, hardware replacements are prohibitively expensive if the wireless device is not<br>
broken and under warranty. Even so, when a wireless device under warranty has a hardware<br>
component replaced, the new component is merely a working version of the component<br>
being replaced. Thus, when a consumer purchases a wireless communication device, the<br>
consumer is locked into the physical configuration of the wireless device for the life of the<br>
wireless communication device.<br>
An additional drawback of conventional wireless communication devices is that new<br>
external devices, such as a digital cameras, are limited to the specific, proprietary device that<br>
is offered by the manufacturer of the handset. Thus, a consumer's choice of external<br>
devices that enhance a wireless communication device is severely limited. Therefore, what<br>
is needed is a system and method that overcomes these significant problems found in the<br>
conventional systems as described above.<br><br>
SUMMARY OF THE INVENTION<br>
Conventional wireless communication devices are isolated computing platforms. Once a<br>
wireless communication device has been deployed, updates to the software on the device<br>
require that the handset be brought into a service station where the software suit can be<br>
upgraded and the handset reconfigured. This is particularly true where updates to the<br>
operating system are involved or integral applications such as the address book.<br>
Additionally, the software suite on a deployed handset is static and inflexible and does not<br>
allow a user to customize the various applications to suit his or her needs.<br>
For a user of a wireless communication device to take advantage of advances in technology<br>
embodied in the physical device, a new device must be purchased. If a new model with an<br>
improved display is released by the manufacturer, the user has no way to upgrade the<br>
handset. Additionally, if a hardware component malfunctions or breaks. The entire handset<br>
requires replacement, or in some instances the handset can be sent back to the manufacturer<br>
where it is refurbished. Unfortunately, this refurbishing doesn't allow for upgraded, newer<br>
components to be used. The manufacturer must replace the component with a working<br>
version of the same component.<br>
A first embodiment provides systems and methods for dynamic installation of modular<br>
software applications and operating system components. When a handset is instructed to<br>
install a new software module, the handset sends a request to an update module server<br>
identifying the new application or software module to be installed. The update module<br>
server responds with an instruction set for installing the software module and the software<br>
module itself. Upon receipt, the handset installs the software module, making any necessary<br>
deletions to applications or modules in persistent storage on the handset. Finally, the<br>
handset can be reconfigured or rebooted to complete the installation and configuration.<br>
A second embodiment provides systems and methods for interchangeable modular hardware<br>
components on a wireless communication device. When a handset component is obsolete or<br>
a new and improved component is available, the new component can be swapped with the<br>
old component. When the handset is powered up after having a hardware component<br><br>
replaced, the handset recognizes that a new component is present. Upon recognizing the<br>
new component, the handset queries the component to obtain information about the<br>
components characteristics. Once this information has been obtained, the handset queries<br>
the update server over a wireless communication network for an optimized device driver<br>
that will allow the handset to utilize the improved functionality of the new component.<br>
Additionally, die handset may query the update server for new software applications that<br>
also exploit the improved functionality of the new component. The update server responds<br>
with an instruction set for installing the device driver and the device driver itself. Upon<br>
receipt, the handset installs the device driver and reconfigures or reboots to complete the<br>
installation and configuration.<br>
Another embodiment provides for dynamically updating a communication interface on the<br>
wireless device to facilitate communication with the external device.Upon detecting a<br>
connection from an external device, either by a direct physical link, direct wireless link, or<br>
remote wireless link, the wireless communication device obtains summary information<br>
about the external device. If a communication interface for the external device is not already<br>
present in the wireless communication device, the wireless device sends a portion of the<br>
external device's summary information to a remote interface server and requests the<br>
appropriate interface. Upon receipt of the interface, the wireless communication device<br>
installs the interface and then proceeds to establish communication with the external device.<br>
BRIEF DESCRIPTION OF THE ACCOMPANYING DRAWINGS<br>
The details of the present invention, both as to its structure and operation, may be gleaned in<br>
part by study of the accompanying drawings described below, in which like reference<br>
numerals refer to like parts.<br>
Figure 1 is a high level block diagram illustrating an example wireless communication<br>
network.<br>
Figure 2 is a block diagram illustrating an example representation of data in persistent<br>
storage on a wireless communication device.<br><br>
Figure 3A is a block diagram illustrating components of a data storage area for a modular<br>
software interface component.<br>
Figure 3B is a block diagram illustrating components of a data storage area for a modular<br>
hardware detector component.<br>
Figure 3C is a block diagram illustrating components of a data storage area for a modular<br>
external device detector component.<br>
Figure 3D is a block diagram illustrating an example operation code library and<br>
corresponding runtime instruction set.<br>
Figure 3E is a block diagram illustrating an example set of runtime instructions.<br>
Figure 4 is a flow diagram illustrating an example process for a user initiated software<br>
module download.<br>
Figure 5 is a flow diagram illustrating an example process for activating a resident software<br>
module on a wireless communication device.<br>
Figure 6 is a flow diagram illustrating an example process for a network initiated software<br>
module download.<br>
Figure 7 is flow diagram illustrating an example process for installing a software module on<br>
a wireless communication device.<br>
Figure 8 is flow diagram illustrating an example process for expiring a software module on<br>
a wireless communication device.<br>
Figure 9 is flow diagram illustrating an example process for paying for using a software<br>
module on a wireless communication device.<br><br>
Figure 10 is a block diagram illustrating an exemplary wireless communication device that<br>
may be used in connection with the various embodiments described herein.<br>
Figure 11 is a block diagram illustrating an exemplary computer system as may be used in<br>
connection with various embodiments described herein.<br>
Figure 12 is a block diagram illustrating an example wireless communication device and<br>
modular hardware components.<br>
Figure 13 is a flow diagram illustrating an example process for obtaining summary<br>
information from a new hardware component on a wireless communication device.<br>
Figure 14 is a flow diagram illustrating an example process for requesting a device driver<br>
for a new hardware component from a remote server.<br>
Figure 15 is a flow diagram illustrating an example process for installing a device driver for<br>
a new hardware component on a wireless communication device.<br>
Figure 16 is a flow diagram illustrating an example process for configuring a new hardware<br>
component on a wireless communication device.<br>
Figure 17A is a block diagram illustrating an example direct physical connection between a<br>
wireless communication device and an external device.<br>
Figure 17B is a block diagram illustrating an example direct wireless connection between a<br>
wireless communication device and an external device.<br>
Figure 17C is a block diagram illustrating an example remote wireless connection between a<br>
wireless communication device and an external device.<br><br>
Figure 18 is a flow diagram illustrating an example process for obtaining summary<br>
information from an external device.<br>
Figure 19 is a flow diagram illustrating an example process for requesting interface software<br>
from a remote server.<br>
Figure 20 is a flow diagram illustrating an example process for installing interface software.<br>
Figure 21 is flow diagram illustrating an example process for initializing an external device.<br>
DETAILED DESCRIPTION<br>
Disclosed herein are systems and methods for dynamically updating software modules and<br>
software applications and for updating device drivers on a wireless communication device<br>
via an over-the-air link. For example, methods and systems as disclosed herein allows for a<br>
wireless communication device to request a new software or driver module from an update<br>
server and receive that new module in an wireless communication data package. Upon<br>
receipt of the data package, the wireless device installs the requested module and if<br>
necessary, deletes other modules to make space for the new module in persistent storage. If<br>
necessary, the wireless device also reconfigures the wireless device for use of the new<br>
module and may also initiate a reboot of the device.<br>
Another embodiment as disclosed herein provide for a wireless communication device and<br>
method for dynamically recognizing and interfacing with an external device. For example,<br>
one method as disclosed herein allows for a wireless communication device to recognize the<br>
presence of an external device via a wired or wireless communication link. Upon<br>
recognition, the wireless communication device queries the external device to obtain<br>
summary profile information about the device. The wireless communication device then<br>
queries a server over a wireless communication network and receives a response comprising<br>
an interface to facilitate communication between the devices.<br>
After reading this description it will become apparent to one skilled in the art how to<br>
implement the invention in various alternative embodiments and alternative applications.<br><br>
However, although various embodiments of the present invention will be described herein, it<br>
is understood that these embodiments are presented by way of example only, and are not<br>
limitations. As such, this detailed description of various alternative embodiments should not<br>
be construed to limit the scope or breadth of the present invention as set forth in the<br>
appended claims.<br>
Figure 1 is a high level block diagram illustrating an example wireless communication<br>
network 10. In the illustrated embodiment, the wireless communication network 10<br>
comprises a plurality of wireless communication devices 20 and 30 communicatively<br>
coupled with a network 50 via a plurality of base stations 40 and 42. Additional wireless<br>
communication devices and base stations can also be employed as part of the wireless<br>
communication network 10. The wireless communication network 10 also comprises a<br>
update module server 60, which is coupled with a data storage area 70. The wireless<br>
communication devices 20 and 30 are communicatively coupled with the update module<br>
server 60 via the base stations 40 and 42 and the network 50.<br>
Wireless communication device 20 can be any sort of device with the ability to<br>
communicate within the wireless communication network 10 and execute software modules<br>
and/or have modular hardware components replaced. Preferably, wireless communication<br>
device 20 also has a persistent storage area. For example, wireless communication device 20<br>
may be a cell phone, a personal digital assistant ("PDA"), a laptop computer, wristwatch, or<br>
any other device configured for wireless communication. Wireless communication devices<br>
may also be referred to herein as "handsets" or "mobile phones" or "mobile devices."<br>
In the illustrated embodiment, the connection between external device 22 and handset 20 is<br>
a direct physical connection 24. External devices can also be coupled with handsets via a<br>
wireless link such as a direct wireless link 34 or a remote wireless link 36 between external<br>
device 32 and handset 30. In one embodiment, the direct physical connection 24 can be a<br>
hardwired physical connection between the handset 20 and the external device 22, for<br>
example a serial cable or a wired network connection. Alternatively, the direct wireless<br>
connection 34 can employ local networking protocol or bluetooth or infrared. External<br>
device 32 may also be connected to handset 30 through a remote wireless connection 36 that<br><br>
links the devices via a base station such as base station 42. Additionally, external device 32<br>
can also be connected to handset 30 through a remote wireless connection 36 that links the<br>
devices via a network such as the internet or network 50.<br>
Base station 40 is configured to communicate over-the-air with a plurality of wireless<br>
communication devices and includes a transceiver (not shown) that converts the over-the-air<br>
communications to wired communications that travel over network 50. Preferably, network<br>
50 is a private network operated by a wireless carrier which provides the infrastructure for<br>
handoffs between base stations such as base station 40 and 42. Additionally, network 50<br>
preferably provides the communication link between various applications, services, and<br>
other computer based servers such as update module server 60.<br>
Network 50 may also serve as the conduit for connections to other networks (not pictured)<br>
such as an Integrated Services Digital Network ("ISDN"), Public Switched Telephone<br>
Network ("PSTN"), Public Land Mobile Network ("PLMN"), Packet Switched Public Data<br>
Network ("PSPDN"), and the Internet, just to name a few.<br>
Update module server 60 can be implemented as a single computer or as a plurality of<br>
servers logically arranged to provide dynamic instruction sets and software and hardware<br>
modules to mobile devices and to execute dynamic instruction sets received from mobile<br>
devices. In the illustrated embodiment, update module server 60 is coupled with a data<br>
storage area 70 that preferably houses a plurality of executable interfaces and a set of server<br>
operation codes, handset operation codes and executable instructions corresponding to the<br>
server operation codes. The features of a general purpose computer that may implement the<br>
update module server 60 are later described with respect to Figure 11. One function of the<br>
update module server 60 is to receive requests from a handset 20, 30 and respond to those<br>
requests by providing the handset with an executable software module, or a device driver for<br>
exchanged handset hardware, or an executable interface for communication with an external<br>
device.<br>
Figure 2 is a block diagram illustrating an example representation of data in persistent<br>
storage 240 on a wireless communication device 20. The general features of wireless<br><br>
communication device 20, 30 that allow it to function as such are later described with<br>
respect to Figure 10. In the illustrated embodiment, the operating system 100 is resident in<br>
persistent storage 240. The operating system 100 preferably comprises the fundamental<br>
executable program or programs that allow the device to function. In addition to the<br>
operating system 100, application data 110 and user interface 120 are in persistent storage<br>
240. The application data 110 preferably comprises the user information and application<br>
information that an application needs to function or that an application uses to provide its<br>
service.<br>
The user interface 120 may comprise both the executable user interface application and the<br>
user interface data that is used by the application. In an alternative embodiment, the user<br>
interface application portion may be included as part of the operating system and the user<br>
interface 120 may comprise ancillary user data or custom data or other data usable by the<br>
user interface application or the user. The persistent storage area 240 additionally comprises<br>
one or more device drivers such as device driver 130, device driver 132, all the way up to<br>
device driver n. These device drivers are preferably executable applications that facilitate<br>
communication between the handset and another device, or possibly between the core<br>
handset and an integral device such as the display, keypad, speaker, microphone, or<br>
earphones, just to name a few.<br>
Additionally shown as part of the persistent storage 240 are a series of software applications<br>
or modules such as applications 140, 142, 144, 146, and on up to application n. As<br>
illustrated, a large number of applications may be resident as part of the persistent storage<br>
240. The only limit on the number of applications that can be stored in persistent storage<br>
240 is the physical limit of the storage 240.<br>
Figure 3a is a block diagram illustrating elements of data 240 of an example wireless<br>
communication device 20. In the illustrated embodiment, the data 240 has a number of<br>
applications 242 comprising a modular software interface 200, a software license manager<br>
205, and a runtime engine 230. Other data elements 244, which may be included in the<br>
application data 110 as illustrated in Figure 2, comprise a server operation code ("opcode")<br>
library 210, handset opcode library 220, and runtime instructions 260.<br><br>
The modular software interface 200 is preferably configured to receive user requests to<br>
install new software modules and applications. Additionally, the modular software interface<br>
200 is preferably configured to receive network initiated software module downloads and<br>
software application downloads. The modular software interface 200 may comprise a user<br>
interface module that is adaptable to accept commands from a user for user initiated<br>
downloads. Additionally, the modular software interface 200 may comprise a<br>
communication module adaptable to receive communications from a network server for<br>
network initiated downloads.<br>
In one embodiment, the modular software interface 200 receives a command from a user to<br>
download a particular software module. The modular software interface 200 is preferably<br>
configured to communicate with the runtime engine 230 to create a request for the software<br>
module to be downloaded from a network server. In an alternative embodiment, the modular<br>
software interface 200 receives a command that originated from a network server. The<br>
modular software interface 200 is preferably configured to parse and interpret the command<br>
to determine what software module the network server is requesting that the handset<br>
download and install. Upon validation of the request from the network, the modular<br>
software interface 200 then proceeds to communicate with the runtime engine 230 to effect<br>
the download.<br>
Additionally, the modular software interface 200 can be configured to determine the<br>
available space in persistent storage 240 where the software module is to be installed. For<br>
example, upon receiving a request to install a new software module, the modular software<br>
interface 200 determines the amount of disk space (or other persistent storage space)<br>
available on the handset. In one embodiment, to determine the available storage space, the<br>
modular software interface 200 may query the operating system 100 of the handset, as<br>
discussed above with reference to Figure 2. If enough space is available, then the modular<br>
software interface 200 can proceed to communicate with the runtime engine 230 as<br>
described above.<br><br>
If there is not enough persistent storage space to install the requested software module, the<br>
modular software interface 200 queries the user or the network 50 (depending on where the<br>
request originated) to identify a software module or other data in persistent storage that can<br>
be deleted. Alternatively, the modular software interface 200 may determine what data can<br>
be deleted, for example, by querying the operating system or identifying older versions of<br>
the requested software module.<br>
Additionally, the modular software interface 200 is preferably configured to instruct the<br>
operating system 100 to delete the identified software module or other data in persistent<br>
storage 240 in order to provide enough availability for the new software module. If no<br>
persistent storage space is available, and none can be obtained by deleting data or software<br>
modules already occupying space in persistent storage, then the modular software interface<br>
200 can notify the user or network that space is not available to install the requested<br>
software module.<br>
Continuing with Figure 3A, the handset opcode library 220 preferably includes the universe<br>
of operation codes that represent each function or executable code segment that the handset<br>
can be instructed to execute by the update module server 60, illustrated in Figure 1.<br>
Advantageously, handset opcode library 220 includes the operation codes that serve as place<br>
holders for the actual executable machine code functions or code segments. As such, the<br>
handset opcode library 220 preferably contains a list of all available operation codes that<br>
correspond to each and every function that can be executed by the handset 20, 30.<br>
Similarly, the server opcode library 210 preferably includes the universe of operation codes<br>
that represent each server side function or executable code segment. Advantageously, server<br>
opcode library 210 may only include the operation codes for the actual executable machine<br>
code functions or code segments, which do not reside on the wireless communication device<br>
20. As such, the server opcode library 220 contains a list of all the operation codes for each<br>
available server function that can be executed by the update module server 60 on behalf of<br>
the handset 20, 30. In the preferred embodiment, the number of available server functions<br>
can well exceed the number of available handset functions because the update module server<br><br>
60 does not suffer from the minimal resources typically found on mobile devices such as,<br>
for example, cell phones and PDAs.<br>
Runtime engine 230 is preferably configured to process dynamic instructions sets. One<br>
example of a dynamic instruction set is a set of instructions to install a software module.<br>
Another example of a dynamic instruction set is a set of instructions to install a device<br>
driver for a new hardware component. The processing of dynamic instruction sets includes<br>
translation of opcodes into executable instruction sets and execution of those instruction<br>
sets. For example, a set of handset opcodes may be received from the update module server<br>
60 along with a data payload. The opcodes are then translated into executable instructions<br>
for the handset. The processing of dynamic instruction sets also includes compilation of<br>
opcodes and corresponding data payloads for delivery to the update module server 60.<br>
Preferably, runtime engine 230 can be launched by wireless communication device 20, 30<br>
on an as needed basis so that it runs only when necessary and consumes a minimal amount<br>
of system resources (e.g. memory, CPU cycles, etc.) on the handset 20, 30.<br>
Referring now to Figure 12, a block diagram illustrates an example wireless communication<br>
device 620 and modular hardware components. In the illustrated embodiment, the handset<br>
620 comprises a plurality of hardware modules including a screen 680 and a keypad 682.<br>
Additional hardware modules are also typically included in handset such as handset 620 and<br>
may include a radio chipset, for example. A hardware module is a component of the handset<br>
620 that is capable of electrical communication within the handset. Inert components with<br>
no communication ability such as the casing are not considered to be hardware modules.<br>
In the illustrated embodiment, the display screen 680 is interchangeable with a new display<br>
screen 690. For example, the screen 680 may be limited to displaying monochrome while<br>
the screen 690 may be capable of displaying color. Similarly, the keypad 682 is<br>
interchangeable with a new keypad 692. For example, the new keypad 692 have the ability<br>
to illuminate the keys while the keypad 682 may not have this ability.<br>
Figure 3B is a block diagram illustrating elements of data 240 of another example wireless<br>
communication device 20. In the illustrated embodiment, the data 240 has a number of<br><br>
applications 242 comprising a modular hardware detector 202 and a runtime engine 230.<br>
Other data elements 244, which may be included in the application data 110 as illustrated in<br>
Figure 3A, comprise a server operation code ("opcode") library 210, handset opcode library<br>
220, and runtime instructions 260.<br>
The modular hardware detector 202 is preferably configured to determine when a new<br>
hardware module has been exchanged with a previous hardware module. In one<br>
embodiment, the modular hardware detector 202 function upon power up to detect the<br>
presence of a new hardware module. Alternatively, the modular hardware detector 202 may<br>
operate during the power on mode to detect any new hardware mat was "hot" swapped, or<br>
otherwise replaced while the handset 20 was powered on. The modular hardware detector<br>
202 can be implemented as a combination of electromechanical and software components to<br>
carry out the detection function and is preferably in communication with the runtime engine<br>
230 to inform the runtime engine of newly detected hardware modules.<br>
Additionally, the modular hardware detector 202 can be configured to determine the<br>
available space in persistent storage 240 where a new device driver is to be installed. For<br>
example, upon detecting a new hardware module, the modular hardware detector 202<br>
preferably determines the amount of storage space used for the current device driver, e.g.,<br>
device driver N illustrated in Figure 2, and the amount of storage space needed for the new<br>
device driver. In one embodiment, to determine the storage space used for the current device<br>
driver, the modular hardware detector 200 may query the operating system 100.<br>
Additionally, to determine the amount of storage space needed for the new device driver, the<br>
modular hardware detector 202 may query the update server 60, illustrated in Figure 1,<br>
through the runtime engine 230 to obtain that information.<br>
If the current device driver and the new device driver are the same size or if the new device<br>
driver requires less storage space than the current device driver, men the new device driver<br>
can be installed in the same place in persistent storage where the current device driver is<br>
located. If the new device driver requires more storage space than the current driver, then<br>
the modular hardware detector 202 preferably can install the new device driver in another<br>
portion of the persistent storage area 240 that is newly allocated for device driver storage by<br><br>
the modular hardware detector 200. Alternatively, the modular hardware detector 202 may<br>
also query the user to identify data in persistent storage that can be deleted to make room for<br>
the new device driver.<br>
The modular hardware detector 202 is preferably configured to instruct the operating system<br>
100 to delete the current device driver after installation of the new device driver is<br>
successful. Preferably, the current device driver is backed up in persistent or volatile storage<br>
during the installation process for the new device driver.<br>
Referring now to Figure 17A, a block diagram illustrating an example direct physical<br>
connection 84 between a wireless communication device 80 and an external device 82 is<br>
shown. The direct physical connection 84 can be made through a standard or proprietary<br>
cable that connects to both the external device 82 and the handset 80. Alternatively, the<br>
direct physical connection 84 may be achieved by a coupling of the handset 80 and the<br>
external device such that no actual cable is employed and the resulting coupled devices<br>
become an integral unit.<br>
Figure 17B is a block diagram illustrating an example direct wireless connection 85 between<br>
a wireless communication device 86 and an external device 88. The direct wireless<br>
connection 85 can be made through a variety of wireless links such as bluetooth, infrared, or<br>
the 802.11 and 802.15 families of wireless communication.<br>
Figure 17C is a block diagram illustrating an example remote wireless connection between a<br>
wireless communication device 90 and an external device 98. The remote wireless<br>
connection may comprise a link 96 between the external device 98 and a base station 94 and<br>
also a link 92 between the handset 90 and the base station 94. There may also be interstitial<br>
networks and base stations (not shown). The remote wireless connection may be established<br>
using conventional wireless communication protocols or remote wireless networking<br>
protocols such as the 802.11 and 802.15 families of wireless communication.<br>
Figure 3C is a block diagram illustrating components of data 240 of an example wireless<br>
communication device 20, 30. In the illustrated embodiment, the data 240 has a number of<br><br>
applications 242 comprising an external device detector 204 and a runtime engine 230.<br>
Other data elements 244, which may be included in the application data 110 as illustrated in<br>
Figure 2, comprise a server operation code ("opcode") library 210, handset opcode library<br>
220, and runtime instructions 260.<br>
The external device detector 204 is preferably configured to determine when an external<br>
device has been physically connected to the handset 20, 30, or when an external device is<br>
attempting a connection to the handset 20, 30 via a wireless link. Additionally, the external<br>
device detector 204 is preferably capable of detecting pilot signals or other broadcast<br>
wireless signals to determine if an external device is within proximity of the handset such<br>
than a connection can be made. The external device detector 204 can be implemented as a<br>
combination of electromechanical and software components to carry out the detection<br>
function.<br>
Although Figures 3A and 3B and 3C illustrate three separate examples of a modular<br>
software interface 200, a modular hardware detector 202, and an external device detector<br>
204, it should be appreciated that the interface 200, the hardware detector 202 and the<br>
external device detector may reside in a persistent storage area 240 of a communication<br>
device 20 in any combination.<br>
Figure 3D is a block diagram illustrating an example operation code library and<br>
corresponding runtime instruction set 260. The handset opcode library 220 and runtime<br>
instruction set 260 are preferably housed in the data storage area 240 of the handset 20, 30.<br>
In one embodiment, the executable instructions in the runtime instruction set 260<br>
correspond in a one-to-one relationship with the opcodes contained in the handset opcode<br>
library 220. Alternatively, a single opcode in the handset opcode library 220 may<br>
correspond to a sequence of many executable instructions in the runtime instructions 260.<br>
Figure 3E is a block diagram illustrating an example set of runtime instructions 260. In the<br>
illustrated embodiment, any number of executable instructions can be included in runtime<br>
instructions 260, from instruction 1 through instruction n. Optimally, a large number of<br><br>
functions are available in runtime instructions 260 and yet consume very little resources<br>
(e.g. persistent memory) of the handset 20, 30.<br>
Figure 4 is a flow diagram illustrating an example process for a user initiated software<br>
module download. Initially, in step 300 the handset receives the application request from<br>
the user. The request may be received, for example, by the modular software interface 200.<br>
Next, in step 302 the runtime engine is launched. Once the runtime engine is running, the<br>
engine can compile a set of server opcodes according to the action that needs to be taken, as<br>
shown in step 304. In this case, the set of server opcodes to be compiled is preferably for<br>
downloading the requested software application or module. The set of server opcodes may<br>
be obtained from a background process running on the wireless device. Alternatively, the<br>
server opcode set may be obtained from a process running on the wireless device under the<br>
direction of a user. The compiled set of server opcodes preferably causes the server to reply<br>
with the requested software module, as previously described.<br>
For example, the wireless device receives an instruction from a user to download an<br>
extension module to the phone book application so that a total of 500 contacts can be<br>
maintained rather than the previous 100 contacts. The user provides the name or<br>
identification of the new software module to be downloaded. A server opcode set is then<br>
compiled that instructs the modular software server to provide the handset with the<br>
appropriate software module so that the handset may increase the total number of contacts.<br>
In such a case, the result is a server opcode set generated by the runtime engine, as shown in<br>
step 304.<br>
Once the server opcode set has been generated, the runtime engine includes the name or<br>
identification information in the data payload that will be delivered with the server opcode<br>
set. For example, the runtime engine may fetch the application or software module data<br>
from persistent or volatile memory, or execute an instruction that returns the data needed,<br>
for example through the modular software interface 200. Once the data has been obtained,<br>
the run time engine 230 next inserts the data into the server opcode set, as illustrated in step<br>
306. One simple way to achieve this is to append the data payload to the server opcode set<br>
in a single data packet.<br><br>
Once the data payload has been combined with the server opcode set, then the runtime<br>
engine sends the server opcode set with the corresponding data payload to the server, as<br>
shown in step 308. After the server opcode set and data payload has been sent, the runtime<br>
engine may be terminated to free up resources on the wireless device, as illustrated in step<br>
310.<br>
Figure 5 is a flow diagram illustrating an example process for activating a resident software<br>
module on a wireless communication device. The process shown in Figure 5 may be carried<br>
out through the use of opcode sets or through the use of some other wireless data<br>
communication means. Initially, in step 320, the handset requests a license from a network<br>
license server. The software license manager 205, illustrated in Figure 3A, preferably<br>
initiates mis step. The network license server can be the same server as the update module<br>
server 60 or it may be a different and separate server. Once the request has been sent, the<br>
handset 20, 30 next receives payment requirements from the network license server as<br>
shown in step 322. In response, the handset provides payment details to the network license<br>
server, as illustrated in step 324.<br>
In one embodiment, the handset may be configured to provide payment details<br>
automatically. Alternatively, the handset may be configured to request mis information from<br>
the user to ensure mat the user is willing to pay for the requested license. After sending the<br>
payment details, in step 326 the handset receives an acknowledgement of the license<br>
server's receipt of the payment details. In one embodiment, this acknowledgement may also<br>
serve as a confirmation that the payment has been processed.<br>
Once the acknowledgement has been received, in step 328 the handset next receives a<br>
license or activation key from the license server. Preferably, the activation key is configured<br>
to allow use of the application on the handset. Once the key has been received, men the<br>
application can be activated as illustrated in step 330.<br>
Figure 6 is a flow diagram illustrating an example process for a network initiated software<br>
module download. Initially, in step 336, the wireless device receives a set of handset<br><br>
opcodes. The set of handset opcodes can be received via an over-the-air communication<br>
link, for example a link with a wireless communication network. Preferably, the opcodes<br>
are optimized to minimize the amount of data sent over-the-air. Additionally, a data payload<br>
can be included with the set of opcodes received by the handset. In the illustrated<br>
embodiment, the handset opcode set is received from a network update module server 60.<br>
In step 338, the wireless device launches its runtime engine to process the handset opcode<br>
set. Alternatively, the handset may first authenticate the network server sending the handset<br>
opcode set. As illustrated in step 340, the runtime engine parses the handset opcode set and<br>
then extracts the data payload in step 342. If no data payload exists, then this step can be<br>
skipped, however, the network update module server 60 may include the executable<br>
software application in the initial transmission. Alternatively, the handset opcode set may<br>
instruct the handset to request the software module from the server. If a data payload does<br>
exist, then the resulting data can be stored in an available portion of volatile memory for<br>
later use.<br>
Next, in step 344, the runtime engine obtains the executable instructions that correspond to<br>
the opcodes in the handset opcode set. These instructions can be obtained from the remote<br>
runtime instructions set stored in persistent storage on the data storage area of the handset.<br>
Once the executable instructions corresponding to the opcodes in the handset opcode set<br>
have been obtained, the runtime engine executes the instructions, as illustrated in step 346.<br>
When the instructions are being executed, any necessary data to be operated on (or installed)<br>
can be obtained from volatile memory where the data payload is stored. Alternatively, or<br>
additionally, any necessary data to be operated on may be obtained as the result of an<br>
executed instruction.<br>
For example, the data payload may comprise the software application that the network has<br>
requested the handset to install. Additionally, one or more of the opcodes in the handset<br>
opcode set preferably correspond to one or more executable instructions for storing the data<br>
payload in persistent memory on the handset. In this example, once the data payload<br>
comprising the software module is stored in persistent memory, the handset may thereafter<br><br>
allow the application to be used by a user, or alternatively by a remote network command.<br>
Alternatively, the data payload may replace a portion of persistent memory that contains an<br>
outdated software application or module or one selected for deletion in order to make room<br>
for the new software module. Thus, the handset opcode set and data payload operate on the<br>
wireless device to install new software modules for the handset. Additional opcodes and<br>
instructions may also be employed to configure the new module or application once it has<br>
been installed, if necessary.<br>
Once the instruction set has been executed in its entirety by the runtime engine, the runtime<br>
engine can be terminated, and then the application may be executed, as shown in step 348.<br>
A particularly illustrative example will explain how the network initiated download may be<br>
employed. If a handset is in a vehicle that has been lost or stolen, the handset may be<br>
contacted by the network and instructed to download a GPS module (assuming the handset<br>
has GPS capable hardware). Once the GPS module is downloaded and installed, the GPS<br>
module may begin reporting location information to the network, which in turn may be<br>
provide to the owner of the vehicle or the authorities to facilitate tracking of the vehicle.<br>
Advantageously, this may all be accomplished without the knowledge of the people in<br>
proximity to the handset.<br>
Figure 7 is flow diagram illustrating an example process for installing a software module on<br>
a wireless communication device. Initially, in step 350, the wireless device receives a set of<br>
handset opcodes. The set of handset opcodes can be received via an over-the-air<br>
communication link, for example a link with a wireless communication network.<br>
Preferably, the opcodes are optimized to minimize the amount of data sent over-the-air.<br>
Additionally, a data payload can be included with the set of opcodes received by the<br>
handset. In the illustrated embodiment, the handset opcode set is received from a network<br>
software module server.<br>
In step 352, the wireless device launches its runtime engine to process the handset opcode<br>
set. Alternatively, the handset may first authenticate the network server sending the handset<br>
opcode set. As illustrated in step 354, the runtime engine parses the handset opcode set and<br>
then extracts the data payload in step 356. If no data payload exists, then this step can be<br><br>
skipped, however, the network software module server may include the executable software<br>
application in the initial transmission. Alternatively, the handset opcode set may instruct the<br>
handset to request the software module from the server. If a data payload does exist, then<br>
the resulting data can be stored in an available portion of volatile memory for later use.<br>
Next, in step 358, the runtime engine obtains the executable instructions that correspond to<br>
the opcodes in the handset opcode set. These instructions can be obtained from the remote<br>
runtime instructions set stored in persistent storage on the data storage area of the handset.<br>
Once the executable instructions corresponding to the opcodes in the handset opcode set<br>
have been obtained, the runtime engine executes the instructions, as illustrated in step 360.<br>
When the instructions are being executed, any necessary data to be operated on (or installed)<br>
can be obtained from volatile memory where the data payload is stored. Alternatively, or<br>
additionally, any necessary data to be operated on may be obtained as the result of an<br>
executed instruction. Once the instruction set has been executed in its entirety by the<br>
runtime engine, in step 362 the runtime engine can be terminated, and then the application is<br>
available for use, as shown in step 364.<br>
Figure 8 is flow diagram illustrating an example process for expiring a software module on<br>
a wireless communication device. Initially, in step 370, the handset receives an expiration<br>
notice. The expiration notice can be received via a wireless communication network and<br>
originate from a licensing server communicatively coupled with the handset via the<br>
network. In one embodiment, the expiration notice may be linked to a trial period for the<br>
software module or may be linked to an annual license fee for the module.<br>
Once the expiration notice is received by the handset, the handset determines in step 372<br>
whether it has been instructed to automatically renew the license or make an initial payment<br>
for the module. If the handset determines that it is not authorized or has not been instructed<br>
to automatically renew or pay, then in step 374 the handset notifies the user of the expiration<br>
notice for the software module.<br>
The notification can be made by presenting a message on the display of the handset or by<br>
generating a text message that is stored in memory on the handset for later review. The<br><br>
notification may also be visual such as a message on the display or a blinking light or it may<br>
also be audio such as a prerecorded message or tone. Alternatively, the blinking light or<br>
audio tone (or vibration of the handset) may indicate that a message is available for the user<br>
and the message may provide the detail of the expiration notice. Additionally, the handset<br>
may also send a message to the network (or the network may initiate the process) such that a<br>
pre-recorded voice message is left in the user's voice mail box that informs the user of the<br>
expiration notice. A variety of other notification methods may also be employed, as will be<br>
understood by those having skill in the art.<br>
Once the user has been informed of the expiration notice, the handset receives an instruction<br>
from the user in step 376. This instruction is examined by the handset in step 378 to<br>
determine if the license should be renewed (or if the initial payment should be made). If the<br>
instruction from the user is to not renew (or pay), then in step 380 the handset deactivates<br>
the software module. In one embodiment, the handset may wait until the end of the license<br>
period or evaluation period before deactivation. Additionally, if no instruction is received<br>
from the user as determined by step 378, the lack of an instruction can be interpreted as a<br>
negative response and the software module deactivated in step 380.<br>
If the handset, in step 378 determines that the instruction from the user is to renew or pay,<br>
then the handset sends a renewal instruction (or initial payment instruction) to the network<br>
or license server, as illustrated in step 382. Additionally, if, in step 372 the handset<br>
determines that it is authorized to automatically renew or pay, then the handset also sends<br>
the appropriate instruction in step 382. On the receiving end of the renewal instruction (e.g.,<br>
the license server), the payment may be effected by a credit card charge or the addition of a<br>
line item on the customer's bill for the handset service.<br>
In response to the instruction to pay or renew, the handset may receive a license or a key<br>
that can be employed to instruct the software to continue operation or to allow additional<br>
functionality, as shown in step 384. In step 386, the application is activated with the license<br>
or key so that the user may thereafter use the software module or application for the new<br>
license period.<br><br>
Figure 9 is flow diagram illustrating an example process for paying for using a software<br>
module on a wireless communication device. Initially, in step 390, an application may<br>
collect usage data for the application itself or for other applications on the handset. This<br>
data can preferably be stored in persistent memory on the handset. Next, in step 392 the<br>
runtime engine is launched. Once the runtime engine is running, the engine can compile a<br>
set of server opcodes, as shown in step 394. The compiled set of server opcodes preferably<br>
causes the server to process the usage data contained in the corresponding data payload,<br>
which is inserted into the opcode set (or appended to the opcode set) in step 396.<br>
Once the data payload has been combined with the server opcode set, then the runtime<br>
engine sends the server opcode set with the corresponding data payload to the server, as<br>
shown in step 398. After the server opcode set and data payload has been sent, the handset<br>
preferably receives billing details from the server, as shown in step 399. Preferably, the<br>
billing details relate to the usage data provided with the server opcode set. Finally, the<br>
runtime engine may be terminated to free up resources on the wireless device.<br>
Figure 13 is a flow diagram illustrating an example process for obtaining summary<br>
information from a new hardware component. Initially, in step 700, the handset powers up.<br>
Preferably, upon power up the handset investigates its various hardware components, for<br>
example, by communicating with each component to determine its status. Alternatively, if<br>
the handset is already operational, the handset may, on its own initiative (e.g., due to a pre-<br>
scheduled event) or by way of an external instruction (e.g., received from a network or<br>
user), initiate the same investigation process to determine the status of the various hardware<br>
components.<br>
Next, in step 702 the handset detects a new hardware component. The new component does<br>
not need to be a new functional component, but can be a replacement of a previous hardware<br>
module, e.g., a new display screen. Upon detecting a new hardware component, the handset<br>
next determines in step 704 the type of component it is, for example, screen, keypad, radio<br>
chipset, or the like. The handset then queries the new component in step 706 to obtain<br>
information about the new component. This new component information is received by the<br>
handset in step 708 and preferably stored in persistent or volatile memory. In one<br><br>
embodiment, the new hardware module information includes an identifier that uniquely<br>
identifies the new hardware module.<br>
Figure 14 is a flow diagram illustrating an example process for requesting a device driver<br>
for a new hardware component from a remote server. Initially, in step 720 the runtime<br>
engine is launched. Once the runtime engine is running, the engine can compile a set of<br>
server opcodes, as shown in step 722. The set of server opcodes may be obtained from a<br>
background process running on the wireless device 20, 30. Alternatively, the server opcode<br>
set may be obtained from a process running on the wireless device under the direction of a<br>
user. The compiled set of server opcodes preferably causes the server to reply with an<br>
executable device driver to allow the handset to communicate with and fully utilize the<br>
functionality of the new hardware module.<br>
For example, the wireless device detects a new hardware module has been installed. The<br>
new hardware module is queried and summary profile information is obtained. A server<br>
opcode set is compiled instructing the server to provide the handset with an executable<br>
device driver for the new hardware module so that the handset may communicate widi the<br>
new hardware module. In such as case, the result is a server opcode set generated by the<br>
runtime engine, as shown in step 722.<br>
Once the server opcode set has been generated, the runtime engine includes the information<br>
for the new hardware module in the data payload mat corresponds to the server opcode set.<br>
For example, the runtime engine may fetch the hardware module information from<br>
persistent or volatile memory, or execute an instruction that returns me data needed. Once<br>
the data has been obtained, me runtime engine next inserts the new hardware module<br>
information into the server opcode set, as illustrated in step 724. One simple way to achieve<br>
mis is to append the data payload to the server opcode set in a single data packet.<br>
Once the data payload has been combined with me server opcode set, men the runtime<br>
engine sends the server opcode set widi me corresponding data payload to me server, as<br>
shown in step 726. After the server opcode set and data payload has been sent, the runtime<br><br>
engine may be terminated to free up resources on the wireless device, as illustrated in step<br>
728.<br>
Figure 15 is a flow diagram illustrating an example process for installing a device driver for<br>
a new hardware component on a wireless communication device. Initially, in step 730, the<br>
wireless device receives a set of handset opcodes. The set of handset opcodes can be<br>
received via an over-the-air communication link, for example a link with a wireless<br>
communication network. Preferably, the opcodes are optimized to minimize the amount of<br>
data sent over-the-air. Additionally, a data payload can be included with the set of opcodes<br>
received by the handset.<br>
In step 732, the wireless device launches its runtime engine to process the handset opcode<br>
set. As illustrated in step 734, the runtime engine parses the handset opcode set and then<br>
extracts the data payload in step 736. The data payload is preferably stored in an available<br>
portion of volatile memory for later use. Next, the runtime engine obtains the executable<br>
instructions that correspond to the opcodes in the handset opcode set as shown in step 738.<br>
These instructions can be obtained from the remote runtime instructions set stored in<br>
persistent storage on the data storage area of the handset.<br>
Once the executable instructions corresponding to the opcodes in the handset opcode set<br>
have been obtained, the runtime engine executes the instructions, as illustrated in step 740.<br>
When the instructions are being executed, any necessary data to be operated on can be<br>
obtained from volatile memory where the data payload is stored. Alternatively, or<br>
additionally, any necessary data to be operated on may be obtained as the result of an<br>
executed instruction. Preferably, the execution of the instruction set causes the device<br>
driver for the new hardware module to be installed on the handset.<br>
For example, the data payload comprises the device driver needed by the handset to<br>
communicate with the new hardware module. Additionally, one or more of the opcodes in<br>
the handset opcode set preferably correspond to one or more executable instructions for<br>
storing the data payload in persistent memory on the handset. In this example, once the data<br>
payload comprising the device driver is stored in persistent memory, the handset may<br><br>
thereafter communicate with the new hardware module using the device driver, which<br>
preferably is configured to take full advantage of the functionality of the new hardware<br>
module.<br>
Alternatively, the data payload may replace a portion of persistent memory that contains an<br>
outdated device driver for the hardware component that was replaced. Thus, the handset<br>
opcode set and data payload operate on the wireless device to install a new device driver for<br>
the new hardware module. Additional opcodes and instructions may also be employed to<br>
configure the new device driver or other aspects of the handset once the new device driver<br>
has been installed.<br>
Once the instruction set has been executed in its entirety by the runtime engine, the runtime<br>
engine can be terminated, as shown in step 742. Advantageously, the runtime engine may<br>
be launched and terminated so that it only runs when necessary. This saves system<br>
resources on the wireless device, for example it may save volatile memory space, CPU<br>
cycles, and battery life. Once the device driver for the new hardware module has been<br>
installed and configured for use, as illustrated in step 746, the handset may begin using the<br>
new hardware module in the course of normal operation.<br>
Figure 16 is flow diagram illustrating an example process for configuring a new hardware<br>
component on a wireless communication device. Initially, in step 750, the handset uses the<br>
new device driver to send a setup request to the new hardware module. Next, in step 752,<br>
the handset receives a response from the new hardware module. In one embodiment the<br>
response may comprise more comprehensive profile information about the hardware module<br>
that can be interpreted by the device driver to fine tune the operation of the device. For<br>
example, the response may provide the device driver with additional information relating to<br>
the hardware component or its communication capabilities such as its interface version or<br>
other information to make communication between the device driver and the new hardware<br>
module more efficient.<br>
Alternatively, the response may be an indication of an unsuccessful attempt to communicate<br>
with the new hardware module, as determined in step 754. If the setup request received a<br><br>
response indicating that the setup was unsuccessful, the handset returns to step 750 and<br>
sends another setup request. In one embodiment, the handset may cycle through a<br>
predetermined number (e.g., N) of setup requests until a request that is formatted correctly is<br>
provided to the new hardware component. For example, the various setup requests may<br>
conform to different versions of the interface or different communication modes for the<br>
device driver.<br>
There may also be synchronization issues for the device driver and the new hardware<br>
module to work through in an iterative process. Accordingly, the particular setup request<br>
that receives a successful response may advantageously provide the device driver with<br>
important information about the version of the firmware that is installed on the new<br>
hardware module, the capabilities of the new hardware module, and other information about<br>
the new hardware module. Once a successful response is received from the new hardware<br>
module, as determined in step 754, the handset may proceed to use the new hardware<br>
module in the course of normal operation as shown in step 756. If no successful response is<br>
received in the N setup requests, the old device driver can be restored. Advantageously,<br>
backward compatible devices will operate with the old device driver, although new or<br>
improved functionality may not be available through the old device driver.<br>
A flow diagram illustrating an example process for obtaining summary information from an<br>
external device is shown in Figure 18 for another embodiment of the present invention.<br>
Initially, in step 800, the handset detects a connection from an external device. The<br>
connection can be detected over a wired or wireless link. Upon detecting a connection, the<br>
handset determines if the connection was initiated by a user, as shown in step 802. For<br>
example, the user may press a sequence of keys or issue spoken commands to instruct the<br>
handset that a new device is connected. In one embodiment, if the connection is user<br>
initiated, summary device information is provided to the handset directly from the user. In<br>
such an embodiment, the handset next stores the summary device information in step 804.<br>
Alternatively, if the detection was not user initiated, then the handset next formulates a<br>
query for the external device, as illustrated in step 806. The query can advantageously<br>
conform to a standard protocol or it may be a proprietary protocol. Once the query is<br><br>
formulated, the handset sends the query to the external device in step 808. In step 810, the<br>
handset determines if a valid response was received from the external device. If there was<br>
no response or the response was invalid, the handset can return to step 806 and reformulate<br>
the query and proceed to query the external device again. Advantageously, the handset may<br>
cycle through a variety of known query formats and protocols until a valid response is<br>
received. Once a valid response is received that preferably includes summary profile<br>
information about the external device, the handset stores the summary profile information,<br>
as shown in step 304.<br>
Figure 19 is a flow diagram illustrating an example process for requesting interface software<br>
from a remote server. Initially, in step 820 the runtime engine is launched. Once the<br>
runtime engine is running, the engine can compile a set of server opcodes, as shown in step<br>
822. The set of server opcodes may be obtained from a background process running on the<br>
wireless device. Alternatively, the server opcode set may be obtained from a process<br>
running on the wireless device under the direction of a user. The compiled set of server<br>
opcodes preferably causes the server to reply with an executable interface for the particular<br>
external device that is connected to the handset.<br>
For example, the wireless device detects a connection from an external device. The external<br>
device is queried and summary profile information is obtained. A server opcode set is<br>
compiled instructing the server to provide the handset with an executable interface for the<br>
external device so mat the handset may communicate with the external device. In such as<br>
case, the result is a server opcode set generated by the runtime engine, as shown in step 822.<br>
Once the server opcode set has been generated, the runtime engine includes the summary<br>
information for the external device in the data payload that corresponds to the server opcode<br>
set. For example, the runtime engine may fetch the summary profile data from persistent or<br>
volatile memory, or execute an instruction that returns the data needed. Once the data has<br>
been obtained, the run time engine next inserts the data into the server opcode set, as<br>
illustrated in step 824. One simple way to achieve this is to append the data payload to the<br>
server opcode set in a single data packet.<br><br>
Once the data payload has been combined with the server opcode set, then the runtime<br>
engine sends the server opcode set with the corresponding data payload to the server, as<br>
shown in step 826. After the server opcode set and data payload has been sent, the runtime<br>
engine may be terminated to free up resources on the wireless device, as illustrated in step<br>
828.<br>
Figure 20 is a flow diagram illustrating an example process for installing interface software<br>
on a wireless communication device. Initially, in step 830, the wireless device receives a set<br>
of handset opcodes. The set of handset opcodes can be received via an over-the-air<br>
communication link, for example a link with a wireless communication network.<br>
Preferably, the opcodes are optimized to minimize the amount of data sent over-the-air.<br>
Additionally, a data payload can be included with the set of opcodes received by the<br>
handset.<br>
In step 832, the wireless device launches its runtime engine to process the handset opcode<br>
set. As illustrated in step 834, the runtime engine parses the handset opcode set and then<br>
extracts the data payload in step 836. If no data payload exists, then this step can be<br>
skipped. If a data payload does exist, then the resulting data can be stored in an available<br>
portion of volatile memory for later use. Next, the runtime engine obtains the executable<br>
instructions that correspond to the opcodes in the handset opcode set as shown in step 838.<br>
These instructions can be obtained from the remote runtime instructions set stored in<br>
persistent storage on the data storage area of the handset.<br>
Once the executable instructions corresponding to the opcodes in the handset opcode set<br>
have been obtained, the runtime engine executes the instructions, as illustrated in step 840.<br>
When the instructions are being executed, any necessary data to be operated on can be<br>
obtained from volatile memory where the data payload is stored. Alternatively, or<br>
additionally, any necessary data to be operated on may be obtained as the result of an<br>
executed instruction.<br>
For example, the data payload may comprise the interface needed by the handset to<br>
communicate with the external device. Additionally, one or more of the opcodes in the<br><br>
handset opcode set preferably correspond to one or more executable instructions for storing<br>
the data payload in persistent memory on the handset. In this example, once the data<br>
payload comprising the interface is stored in persistent memory, the handset may thereafter<br>
communicate with the device using the executable interface. Alternatively, the data payload<br>
may replace a portion of persistent memory that contains an outdated interface for the<br>
particular external device. Thus, the handset opcode set and data payload operate on the<br>
wireless device to install a new interface for the external device. Additional opcodes and<br>
instructions may also be employed to configure the new interface once it has been installed,<br>
if necessary.<br>
Once the instruction set has been executed in its entirety by the runtime engine, the runtime<br>
engine can be terminated, as shown in step 842. Advantageously, the runtime engine may<br>
be launched and terminated so that it only runs when necessary. This saves system<br>
resources on the wireless device, for example it may save volatile memory space and CPU<br>
cycles. Once the interface for the external device has been installed and configured for use,<br>
the handset may begin communicating with the external device, as illustrated in step 846.<br>
Figure 21 is flow diagram illustrating an example process for initializing an external device.<br>
Initially, in step 850, the handset uses the new interface to send a setup request to the<br>
external device. Next, in step 852, the handset receives a response from the external device.<br>
In one embodiment the response may comprise more comprehensive profile information<br>
about the device. For example, the response may provide the handset with additional<br>
information relating to the communication interface such as the interface version or other<br>
information to make communication between the devices more efficient.<br>
Alternatively, the response may be an indication of an unsuccessful attempt to initialize the<br>
external device, as determined in step 854. If the setup request received a response<br>
indicating that the setup was unsuccessful, the handset returns to step 850 and sends another<br>
setup request. In one embodiment, the handset may cycle through various setup requests<br>
until a request that is formatted correctly is provided to the external device. For example,<br>
the various setup requests may conform to different versions of the interface. Accordingly,<br>
the particular setup request that receives a successful response may advantageously provide<br>
the handset with important information about the version of the firmware that is installed on<br><br>
the external device, the capabilities of the external device, and other information about to<br>
the external device. Once a successful response is received from the external device, as<br>
determined in step 854, the handset may proceed to exchange information with the external<br>
device as shown in step 856.<br>
Figure 10 is a block diagram illustrating an exemplary wireless communication device 450<br>
that may be used in connection with the various embodiments described herein. For<br>
example, the wireless communication device 450 may be used in conjunction with a handset<br>
or PDA network device or as a part of a sensor node in a wireless mesh network. However,<br>
other wireless communication devices and/or architectures may also be used, as will be clear<br>
to those skilled in the art.<br>
In the illustrated embodiment, wireless communication device 450 comprises an antenna<br>
452, a multiplexor 454, a low noise amplifier ("LNA") 456, a power amplifier ("PA") 458, a<br>
modulation circuit 460, a baseband processor 462, a speaker 464, a microphone 466, a<br>
central processing unit ("CPU") 468, a data storage area 470, and a hardware interface 472.<br>
In the wireless communication device 450, radio frequency ("RF") signals are transmitted<br>
and received by antenna 452. Multiplexor 454 acts as a switch, coupling antenna 452<br>
between the transmit and receive signal paths. In the receive path, received RF signals are<br>
coupled from a multiplexor 454 to LNA 456. LNA 456 amplifies the received RF signal<br>
and couples the amplified signal to a demodulation portion of the modulation circuit 460.<br>
Typically modulation circuit 460 will combine a demodulator and modulator in one<br>
integrated circuit ("IC"). The demodulator and modulator can also be separate components.<br>
The demodulator strips away the RF carrier signal leaving a base-band receive signal, which<br>
is sent from the demodulator output to the base-band processor 462.<br>
If the base-band receive audio signal contains audio information, then base-band processor<br>
462 decodes the signal and converts it to an analog signal. Then the signal is amplified and<br>
sent to the speaker 464. The base-band processor 462 also receives analog audio signals<br>
from the microphone 466. These analog audio signals are converted to digital signals and<br>
encoded by the base-band processor 462. The base-band processor 462 also codes the digital<br><br>
signals for transmission and generates a base-band transmit audio signal that is routed to the<br>
modulator portion of modulation circuit 460. The modulator mixes the base-band transmit<br>
audio signal with an RF carrier signal generating an RF transmit signal that is routed to the<br>
power amplifier 458. The power amplifier 458 amplifies the RF transmit signal and routes it<br>
to the multiplexor 454 where the signal is switched to the antenna port for transmission by<br>
antenna 452.<br>
The baseband processor 462 is also communicatively coupled with the central processing<br>
unit 468. The central processing unit 468 has access to a data storage area 470. The central<br>
processing unit 468 is preferably configured to execute instructions (i.e., computer programs<br>
or software) that can be stored in the data storage area 470. Computer programs can also be<br>
received from the baseband processor 462 and stored in the data storage area 470 or<br>
executed upon receipt. Such computer programs, when executed, enable the wireless<br>
communication device 450 to perform the various functions of the present invention as<br>
previously described.<br>
In this description, the term "computer readable medium" is used to refer to any media used<br>
to provide executable instructions (e.g., software and computer programs) to the wireless<br>
communication device 450 for execution by the central processing unit 468. Examples of<br>
these media include the data storage area 470, microphone 466 (via the baseband processor<br>
462), antenna 452 (also via the baseband processor 462), and hardware interface 472. These<br>
computer readable mediums are means for providing executable code, programming<br>
instructions, and software to the wireless communication device 450. The executable code,<br>
programming instructions, and software, when executed by the central processing unit 468,<br>
preferably cause the central processing unit 468 to perform the inventive features and<br>
functions previously described herein.<br>
The central processing unit is also preferably configured to receive notifications from the<br>
hardware interface 472 when new devices are detected by the hardware interface. Hardware<br>
interface 472 can be a combination electromechanical detector with controlling software that<br>
communicates widi the CPU 468 and interacts with new devices.<br><br>
Figure 11 is a block diagram illustrating an exemplary computer system 550 that may be<br>
used in connection with the various embodiments described herein. For example, the<br>
computer system 550 may be used in conjunction with a remote server configured to process<br>
server opcode sets and create and send handset opcode sets. However, other computer<br>
systems and/or architectures may be used, as will be clear to those skilled in the art.<br>
The computer system 550 preferably includes one or more processors, such as processor<br>
552. Additional processors may be provided, such as an auxiliary processor to manage<br>
input/output, an auxiliary processor to perform floating point mathematical operations, a<br>
special-purpose microprocessor having an architecture suitable for fast execution of signal<br>
processing algorithms (e.g., digital signal processor), a slave processor subordinate to the<br>
main processing system (e.g., back-end processor), an additional microprocessor or<br>
controller for dual or multiple processor systems, or a coprocessor. Such auxiliary<br>
processors may be discrete processors or may be integrated with the processor 552.<br>
The processor 552 is preferably connected to a communication bus 554. The communication<br>
bus 554 may include a data channel for facilitating information transfer between storage and<br>
other peripheral components of the computer system 550. The communication bus 554<br>
further may provide a set of signals used for communication with the processor 552,<br>
including a data bus, address bus, and control bus (not shown). The communication bus 554<br>
may comprise any standard or non-standard bus architecture such as, for example, bus<br>
architectures compliant with industry standard architecture ("ISA"), extended industry<br>
standard architecture ("EISA"), Micro Channel Architecture ("MCA"), peripheral<br>
component interconnect ("PCI") local bus, or standards promulgated by the Institute of<br>
Electrical and Electronics Engineers ("IEEE") including IEEE 488 general-purpose interface<br>
bus ("GPIB"), IEEE 696/S-100, and the like.<br>
Computer system 550 preferably includes a main memory 556 and may also include a<br>
secondary memory 558. The main memory 556 provides storage of instructions and data<br>
for programs executing on the processor 552. The main memory 556 is typically<br>
semiconductor-based memory such as dynamic random access memory ("DRAM") and/or<br>
static random access memory ("SRAM"). Other semiconductor-based memory types<br><br>
include, for example, synchronous dynamic random access memory ("SDRAM"), Rambus<br>
dynamic random access memory ("RDRAM"), ferroelectric random access memory<br>
("FRAM"), and the like, including read only memory ("ROM").<br>
The secondary memory 558 may optionally include a hard disk drive 560 and/or a<br>
removable storage drive 562, for example a floppy disk drive, a magnetic tape drive, a<br>
compact disc ("CD") drive, a digital versatile disc ("DVD") drive, etc. The removable<br>
storage drive 562 reads from and/or writes to a removable storage medium 564 in a well-<br>
known manner. Removable storage medium 564 may be, for example, a floppy disk,<br>
magnetic tape, CD, DVD, etc.<br>
The removable storage medium 564 is preferably a computer readable medium having<br>
stored thereon computer executable code (i.e., software) and/or data. The computer software<br>
or data stored on the removable storage medium 564 is read into the computer system 550 as<br>
electrical communication signals 578.<br>
In alternative embodiments, secondary memory 558 may include other similar means for<br>
allowing computer programs or other data or instructions to be loaded into the computer<br>
system 550. Such means may include, for example, an external storage medium 572 and an<br>
interface 570. Examples of external storage medium 572 may include an external hard disk<br>
drive or an external optical drive, or and external magneto-optical drive.<br>
Other examples of secondary memory 558 may include semiconductor-based memory such<br>
as programmable read-only memory ("PROM"), erasable programmable read-only memory<br>
("EPROM"), electrically erasable read-only memory ("EEPROM"), or flash memory (block<br>
oriented memory similar to EEPROM). Also included are any other removable storage units<br>
572 and interfaces 570, which allow software and data to be transferred from the removable<br>
storage unit 572 to the computer system 550.<br>
Computer system 550 may also include a communication interface 574. The communication<br>
interface 574 allows software and data to be transferred between computer system 550 and<br>
external devices (e.g. printers), networks, or information sources. For example, computer<br><br>
software or executable code may be transferred to computer system 550 from a network<br>
server via communication interface 574. Examples of communication interface 574 include<br>
a modem, a network interface card ("NIC"), a communications port, a PCMCIA slot and<br>
card, an infrared interface, and an IEEE 1394 fire-wire, just to name a few.<br>
Communication interface 574 preferably implements industry promulgated protocol<br>
standards, such as Ethernet IEEE 802 standards, Fiber Channel, digital subscriber line<br>
("DSL"), asynchronous digital subscriber line ("ADSL"), frame relay, asynchronous<br>
transfer mode ("ATM"), integrated digital services network ("ISDN"), personal<br>
communications services ("PCS"), transmission control protocol/Internet protocol<br>
("TCP/IP"), serial line Internet protocol/point to point protocol ("SLIP/PPP"), and so on, but<br>
may also implement customized or non-standard interface protocols as well.<br>
Software and data transferred via communication interface 574 are generally in the form of<br>
electrical communication signals 578. These signals 578 are preferably provided to<br>
communication interface 574 via a communication channel 576. Communication channel<br>
576 carries signals 578 and can be implemented using a variety of communication means<br>
including wire or cable, fiber optics, conventional phone line, cellular phone link, radio<br>
frequency (RF) link, or infrared link, just to name a few.<br>
Computer executable code (i.e., computer programs or software) is stored in the main<br>
memory 556 and/or the secondary memory 558. Computer programs can also be received<br>
via communication interface 574 and stored in the main memory 556 and/or the secondary<br>
memory 558. Such computer programs, when executed, enable the computer system 550 to<br>
perform the various functions of the present invention as previously described.<br>
In this description, the term "computer readable medium" is used to refer to any media used<br>
to provide computer executable code (e.g., software and computer programs) to the<br>
computer system 550. Examples of these media include main memory 556, secondary<br>
memory 558 (including hard disk drive 560, removable storage medium 564, and external<br>
storage medium 572), and any peripheral device communicatively coupled with<br>
communication interface 574 (including a network information server or other network<br><br>
device). These computer readable mediums are means for providing executable code,<br>
programming instructions, and software to the computer system 550.<br>
In an embodiment that is implemented using software, the software may be stored on a<br>
computer readable medium and loaded into computer system 550 by way of removable<br>
storage drive 562, interface 570, or communication interface 574. In such an embodiment,<br>
the software is loaded into the computer system 550 in the form of electrical communication<br>
signals 578. The software, when executed by the processor 552, preferably causes the<br>
processor 552 to perform the inventive features and functions previously described herein.<br>
Various embodiments may also be implemented primarily in hardware using, for example,<br>
components such as application specific integrated circuits ("ASICs"), or field<br>
programmable gate arrays ("FPGAs"). Implementation of a hardware state machine capable<br>
of performing the functions described herein will also be apparent to those skilled in the<br>
relevant art. Various embodiments may also be implemented using a combination of both<br>
hardware and software.<br>
While the particular modular software components for wireless communication devices<br>
herein shown and described in detail is fully capable of attaining the above described objects<br>
of this invention, it is to be understood that the description and drawings presented herein<br>
represent a presently preferred embodiment of the invention and are therefore representative<br>
of the subject matter which is broadly contemplated by the present invention. It is further<br>
understood that the scope of the present invention fully encompasses other embodiments<br>
that may become obvious to those skilled in the art and that the scope of the present<br>
invention is accordingly limited by nothing other than the appended claims.<br><br>
WE CLAIM:<br>
1.	A method for dynamically installing a data component (240) on a deployed wireless<br>
communication device (20, 30), comprising:<br>
a runtime engine of the deployed wireless communication device receiving a<br>
communication to install the data component, the communication comprising a unique<br>
identifier for the requested data component, wherein the runtime engine receives the<br>
communication from at least one of a modular software interface (200) configured to receive<br>
a user initiated software module download, a modular hardware detector (202) configure to<br>
detect a new hardware component installed in the wireless communication device, and an<br>
external device detector (204) configured to detect connection of an external device;<br>
the runtime engine compiling a server query, the server query comprising the unique<br>
identifier and at least one server operation code corresponding to at least one server<br>
instruction executable by a remote server, the at least one server operation code housed in a<br>
server opcode library of the deployed wireless communication device;<br>
sending the server query to the remote server (60) via a wireless communication<br>
network (50); and<br>
receiving a response from the remote server (60) via the wireless communication<br>
network (50), wherein the response comprises the data component (240).<br>
2.	The method as claimed in claim 1, wherein the data component is a software module.<br>
3.	The method as claimed in claim 2, comprising the steps of:<br>
identifying the existing software module to be deleted; and<br>
deleting the identified existing software module to be deleted from the deployed<br>
wireless communication device to free up storage space for the software module.<br>
4.	The method as claimed in claim 2, wherein the receiving a response from the<br><br>
remote server step comprises:<br>
receiving a handset instruction set having a corresponding data payload;<br>
extracting the data payload, wherein the data payload comprises the software module;<br>
obtaining a set of executable instructions corresponding to the handset instruction set;<br>
and<br>
executing the set of executable instructions to install the software module.<br>
5.	The method as claimed in claim 4, wherein the executing the set of executable<br>
instructions step is carried out within a runtime engine operating on the wireless<br>
communication device.<br>
6.	The method as claimed in claim 1, wherein the data component is an executable<br>
device driver for the new hardware component and installation instructions, comprising the<br>
steps of:<br>
the modular hardware detector (202) of the wireless communication device detecting<br>
a presence of the new hardware component in the wireless communication device, the new<br>
hardware component replacing a previous hardware component having a previous device<br>
hardware driver; and<br>
querying the new hardware component to obtain profile information for the new<br>
hardware component;<br>
wherein the unique identifier comprises at least a portion of the profile information.<br>
7.	The method as claimed in claim 6, comprising the steps of:<br>
installing the executable device driver; and<br>
configuring the new hardware component.<br>
8.	The method as claimed in claim 6, wherein the receiving the data component<br>
comprises the steps of:<br>
receiving a handset instruction set having a sequence of operation codes and a<br>
corresponding data payload;<br>
extracting the corresponding data payload, wherein the corresponding data payload<br><br>
comprises the executable device driver;<br>
translating the sequence of operation codes into a set of executable instructions<br>
comprising the installation instructions; and<br>
executing the set of executable instructions to install the executable device driver<br>
utilizing a runtime engine operating on the wireless communication device.<br>
9.	The method as claimed in claim 6, comprising:<br>
determining that a size of the previous hardware device driver is greater than the size<br>
of the executable device driver;<br>
copying the previous hardware device driver from a persistent storage to a volatile<br>
storage;<br>
deleting the previous hardware device driver from the persistent storage; and<br>
storing the executable device driver for the new hardware component in at least a<br>
portion of a location in persistent storage previously occupied by the previous device<br>
hardware driver.<br>
10.	The method as claimed in claim 1, wherein the data component is an external device<br>
interface for an external device, comprising the steps of:<br>
the external device detector (204) of the wireless communication device detecting a<br>
connection from the external device;<br>
querying the external device; and<br>
receiving profile information in response to the query;<br>
wherein the unique identifier comprises at least a portion of the profile information.<br>
11.	A deployed wireless communication device having means for dynamically installing a<br>
data component comprising:<br>
a data storage area (240) comprising instructions executable by the wireless<br>
communication device;<br>
at least one of a modular software interface (200) for receiving a user initiated<br>
software module download, a modular hardware detector (202) configured to detect a new<br>
hardware component installed in the wireless communication device, and an external device<br>
detector (204) configured to detect connection of an external device, wherein the at least one<br><br>
of the modular software interface (200), the modular hardware detector (202) and the external<br>
device detector (204) communicates with a runtime engine to initiate request of a new data<br>
component corresponding to the user initiated software module download, the detected new<br>
hardware component or the detected connection of the external device, and wherein the at<br>
least one of the modular software interface (200), the modular hardware detector (202) and<br>
the external device detector (204) determines a unique identifier for the new data component<br>
and provides the unique identifier to the runtime engine;<br>
a server opcode library (210) housed in the data storage area (240), the server opcode<br>
library comprising operation codes corresponding to instructions executable by a remote<br>
server (60);<br>
a handset opcode library (220) housed in the data storage area, the handset opcode<br>
library comprising operation codes corresponding to the instructions executable by the<br>
wireless communication device (20, 30); and<br>
the runtime engine (230) configured to compile and send server opcode sets and<br>
receive and process handset opcode sets, wherein the runtime engine uses the unique<br>
identifier and the server opcode library to compile a server opcode set for requesting the new<br>
data component from the remote server (60) via a wireless communication network (50), the<br>
server opcode set having a data payload comprising the unique identifier.<br><br><br>
ABSTRACT<br><br>
A METHOD FOR DYNAMICALLY INSTALLING A DATA COMPONENT<br>
ON A DEPLOYED WIRELESS COMMUNICATION DEVICE AND<br>
A WIRELESS COMMUNICATION DEVICE<br>
Systems and methods for dynamic installation of modular software applications (140) or<br>
hardware device drivers (130) are provided. A wireless communication device (20) sends a<br>
request to an update module server (60) identifying a requested software or hardware<br>
module (140, 130). The update module server (60) responds with an instruction set for<br>
installing the requested module and the software or hardware module itself. Upon receipt,<br>
the device (20) executes the instruction set to install the requested module, making any<br>
necessary adjustments or deletions to data in persistent storage (240) in order to<br>
accommodate the requested module (140, 130). Subsequently, the wireless communication<br>
device (20) is reconfigured or rebooted to complete the installation and configuration.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNiBhYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006 abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNiBjbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006 claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNiBjb3JyZXNwb25kZW5jZSBvdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006 correspondence others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNiBkZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006 description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNiBkcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006 drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNiBmb3JtLTEucGRm" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006 form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNiBmb3JtLTMucGRm" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006 form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNiBmb3JtLTUucGRm" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006 form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNiBpbnRlcm5hdGlvbmFsIHB1YmxpY2F0aW9uLnBkZg==" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006 international publication.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNiBpbnRlcm5hdGlvbmFsIHNlYXJjaCByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006 international search report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNiBwY3Qgb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006 pct others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNiBwcmlvcml0eSBkb2N1bWVudC5wZGY=" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006 priority document.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNi1hc3NpZ25tZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNi1jbGFpbXMtMS4xLnBkZg==" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006-claims-1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNi1jb3JyZXNwb25kZW5jZSBvdGhlcnMtMS4xLnBkZg==" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006-correspondence others-1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNi1jb3JyZXNwb25kZW5jZS0xLjEucGRm" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006-correspondence-1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNi1jb3JyZXNwb25kZW5jZS0xLjIucGRm" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006-correspondence-1.2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNi1mb3JtLTEzLnBkZg==" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006-form-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNi1mb3JtLTE4LnBkZg==" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006-form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNi1mb3JtLTMtMS4xLnBkZg==" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006-form-3-1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDMyNzAta29sbnAtMjAwNi1wLmEucGRm" target="_blank" style="word-wrap:break-word;">03270-kolnp-2006-p.a.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LSgxMy0wMi0yMDEyKS1DT1JSRVNQT05ERU5DRS5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-(13-02-2012)-CORRESPONDENCE.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUFCU1RSQUNULnBkZg==" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-ABSTRACT.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUFNQU5ERUQgQ0xBSU1TLnBkZg==" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-AMANDED CLAIMS.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUFNQU5ERUQgUEFHRVMgT0YgU1BFQ0lGSUNBVElPTi5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-AMANDED PAGES OF SPECIFICATION.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUFTU0lHTk1FTlQgMS4xLnBkZg==" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-ASSIGNMENT 1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUFTU0lHTk1FTlQucGRm" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-ASSIGNMENT.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUNPUlJFU1BPTkRFTkNFIDEuMS5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-CORRESPONDENCE 1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUNPUlJFU1BPTkRFTkNFIDEuMi5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-CORRESPONDENCE 1.2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUNPUlJFU1BPTkRFTkNFLnBkZg==" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-CORRESPONDENCE.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LURFU0NSSVBUSU9OIChDT01QTEVURSkucGRm" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-DESCRIPTION (COMPLETE).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LURSQVdJTkdTLnBkZg==" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-DRAWINGS.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUVYQU1JTkFUSU9OIFJFUE9SVCAxLjEucGRm" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-EXAMINATION REPORT 1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUVYQU1JTkFUSU9OIFJFUE9SVC5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-EXAMINATION REPORT.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUZPUk0gMTMgMS4xLnBkZg==" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-FORM 13 1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUZPUk0gMTMucGRm" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-FORM 13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUZPUk0gMTggMS4xLnBkZg==" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-FORM 18 1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUZPUk0gMTgucGRm" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-FORM 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUZPUk0gMyAxLjEucGRm" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-FORM 3 1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUZPUk0gMyAxLjIucGRm" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-FORM 3 1.2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUZPUk0gNSAxLjEucGRm" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-FORM 5 1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUZPUk0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-FORM 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUZPUk0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-FORM-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUZPUk0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-FORM-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUZPUk0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-FORM-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUdSQU5URUQtQUJTVFJBQ1QucGRm" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-GRANTED-ABSTRACT.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUdSQU5URUQtQ0xBSU1TLnBkZg==" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-GRANTED-CLAIMS.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUdSQU5URUQtREVTQ1JJUFRJT04gKENPTVBMRVRFKS5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-GRANTED-DESCRIPTION (COMPLETE).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUdSQU5URUQtRFJBV0lOR1MucGRm" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-GRANTED-DRAWINGS.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUdSQU5URUQtRk9STSAxLnBkZg==" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-GRANTED-FORM 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUdSQU5URUQtRk9STSAyLnBkZg==" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-GRANTED-FORM 2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LUdSQU5URUQtU1BFQ0lGSUNBVElPTi5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-GRANTED-SPECIFICATION.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LU9USEVSIFBBVEVOVCBET0NVTUVOVC5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-OTHER PATENT DOCUMENT.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LU9USEVSUyAxLjEucGRm" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-OTHERS 1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LU9USEVSUyAxLjIucGRm" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-OTHERS 1.2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LU9USEVSUy5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-OTHERS.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LVBBIDEuMS5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-PA 1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LVBBLnBkZg==" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-PA.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LVJFUExZIFRPIEVYQU1JTkFUSU9OIFJFUE9SVCAxLjEucGRm" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-REPLY TO EXAMINATION REPORT 1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LVJFUExZIFRPIEVYQU1JTkFUSU9OIFJFUE9SVCAxLjIucGRm" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-REPLY TO EXAMINATION REPORT 1.2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LVJFUExZIFRPIEVYQU1JTkFUSU9OIFJFUE9SVC5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-REPLY TO EXAMINATION REPORT.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzI3MC1LT0xOUC0yMDA2LVRSQU5TTEFURUQgQ09QWSBPRiBQUklPUklUWSBET0NVTUVOVC5wZGY=" target="_blank" style="word-wrap:break-word;">3270-KOLNP-2006-TRANSLATED COPY OF PRIORITY DOCUMENT.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QtMDMyNzAta29sbnAtMjAwNi5qcGc=" target="_blank" style="word-wrap:break-word;">abstract-03270-kolnp-2006.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="253327-a-processing-apparatus-for-determining-the-occurrence-of-a-high-impedace-fault-in-an-electrical-power-line.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="253329-improved-clutch-linkage-mechanism.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>253328</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>3270/KOLNP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>28/2012</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>13-Jul-2012</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>12-Jul-2012</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>08-Nov-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>KYOCERA WIRELESS CORP.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>10300, CAMPUS POINT DRIVE, SAN DIEGO, CALIFORNIA, 92121</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>DATE, UMESH M.</td>
											<td>201, VARS CRESCENT, PAI LAY OUT, BENNIGANHALLI EXT.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>RAJARAM, GOWRI S.</td>
											<td>1151 , SUNBRIGHT DRIVE, OCEANSIDE, CA 92056,</td>
										</tr>
										<tr>
											<td>3</td>
											<td>PATEL ,MEHUL B.</td>
											<td>B-305,PURVA HEIGHTS ,BILLEKAHALLI, BANNERGHATTA ROAD, BANGALORE KARNATAKA-560076</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F9/445; H04Q7/32</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2005/017451</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-05-18</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/848,939</td>
									<td>2004-05-18</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>10/848,940</td>
									<td>2004-05-18</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>3</td>
									<td>10/848,941</td>
									<td>2004-05-18</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/253328-a-method-for-dynamically-installing-a-data-component-on-a-deployed-wireless-communication-deivce by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:53:46 GMT -->
</html>
