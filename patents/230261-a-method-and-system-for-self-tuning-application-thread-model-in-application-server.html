<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/230261-a-method-and-system-for-self-tuning-application-thread-model-in-application-server by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 11:01:27 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 230261:A METHOD AND SYSTEM FOR SELF TUNING APPLICATION THREAD MODEL IN APPLICATION SERVER</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD AND SYSTEM FOR SELF TUNING APPLICATION THREAD MODEL IN APPLICATION SERVER</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A system and method for application server with self-tuned threading model. A server queue is used as a priority scheme, including a number of entries therein associated with received requests, and which allows the entries to have expressed priorities or share values, instead of simply the number of threads. Flexibility is retained to express the threads in raw numbers whenever this might be desired, or to express constraints on the number of threads to be made available.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
SYSTEM AND METHOD FOR APPLICATION SERVER WITH SELF-TUNED THREADING MODEL<br>
Copyright Notice A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.<br>
Claim of Priority:<br>
U.S. Provisional Patent Application entitled SYSTEM AND METHOD FORAPPLICATION SERVER WITH SELF-TUNED THREADING MODEL, Application No. 60/572,938, filed May 20,2004, by Anno Langen and Naresh Revanuru (Atty. Docket No.: BEAS-01560US0), and incorporated herein by reference.<br>
U.S. Patent Application entitled SYSTEM AND METHOD FORAPPLICATION SERVER WITH SELF-TUNED THREADING MODEL,<br>
Application No.	, filed May 19,2005, by Anno Langen and<br>
Naresh Revanuru (Atty. Docket No.: BEAS-01560US1), and incorporated herein by reference.<br>
Field of the Invention:<br>
The invention is related generally to application servers and messaging systems, and specifically to a system and method for application server with self-tuned threading model.<br><br>
Background:<br>
In a typical application server or web server environment, where there exists perhaps many hundreds or thousands of concurrent users (clients), each of these clients can send requests to the server. Figure 1 shows an example of such an environment A modem server 100 may have many processors, and many threads 102 servicing those processors. The threads take requests 110,112,114 from the clients 104,106,108, and<br>
apply them to the processors in a queue-like fashion. The actual number of threads used has a big impact on the performance of the server, and its ability to handle large numbers of users. However, figuring out the optimal number of threads is a complicated process.<br>
One approach to this problem has been to add even more threads, so that the number of threads greatly exceeds the number of processors. This ensures that requests are almost immediately fed into threads, but doesn't ensure that those requests are quickly taken up by the processors. A more recent alternative has been to create thread pools, with aflexiblenumberofthreadsoperating within. The actual number of threads can then be fine-tuned by an administrator to provide the best performance for a particular runtime environment. However, this process is heavily dependent on the skill of the administrator, and, since it is largely environment-dependent and static, is of most use only for test-benching and marketing purposes. In real-life situations, the environments are so varied that this static approach is not satisfactory.<br>
Accordingly, what is needed is a means for allowing a server to automatically determine and implement the optimal number of concurrent threads based on objective predictions forthe workload. Because of the<br><br>
limitations of where an application server sits (above the operating system) this thread control cannot be embedded within the operating system, but must be able to exist at a higher level. Accordingly there should be a means for controlling the number of the threads in the application server, and the queues that feed them.<br>
Summary:<br>
In accordance with an embodiment of the invention a system and method for application server with self-tuned threading model is provided. In accordance with an embodiment a server queue is used as a priority scheme, including a number of entries therein associated with received requests, and which allows the entries to have expressed priorities that are more natural and closer to the business users than simply the number of threads. Flexibility is still retained to express the threads in raw numbers where this might be desired (for example if there is a known calling sequence that would deadlock unless a specific number of threads were made available), or to express constraints on the number of threads to be made available on a system-wide or workload-basis.<br>
In accordance with an embodiment, priorities may be specified as a "share", an abstract notion which reflects the proportional priority between entities that will receive the requests. Since the total number is arbitrary and there may perhaps be more than 100 shares, the shares are not identical to percentage thread-use, although they are similar. Shares determine the thread usage (in terms of thread number) allocated to each entity. The system (or algorithm operating thereon) then ensures that, overthe longerterm, the use of the threads (in terms of thread time) will be distributed according to those shares. Any entity who, for example, uses<br><br>
twice as much time orthread minutes as they had been allocated will then be penalized to bring the relative usage proportion back into balance.<br>
In accordance with an embodiment, during runtime the algorithm can also be used to size the thread pool and then allocate the thread within that pool.<br>
In accordance with an embodiment, a priority queue is maintained. Each requesting entity, for example a client, can issue requests that go into the queue, and that are spaced apart according to the relative shares. So, for example, if an entity has not exceeded its allocation then its requests can be placed relatively high up in the queue, and will start getting threads immediately, compared to another entity who had used up their allocation or has a lower time-based allocation or share.<br>
In accordance with an embodiment, for a maximum thread constraint the system can maintain a separate queue for holding a request in the priority queue and also in the maximum thread constraint queue. When the maximum thread constraint queue is cleared any similar item in the priority queue (i.e. something for the same constraint) will be allowed to execute.<br>
In accordance with an embodiment, the sizing of the thread pool can be distilled down to an increment or a decrement by one of the existing pool. This is performed on a periodic basis, for example everyone or two seconds.<br>
The overall result of the self-tuned threading model is a dramatic improvement of the server in out-of-the box performance. The thread characteristics can then be further tailored to suit specific needs. This feature also allows the server customer to have more flexibility in the setup of their system and provides them with ways to prioritize their threading model for a specific business logic, or set of customer needs etc.<br><br>
Brief Description of the Figures:<br>
Figure 1 shows an illustration of an environment in which multiple clients access a server using threads.<br>
Figure 2 shows an illustration of an environment in which multiple clients access a server using threads and a priority queue, in accordance with an embodiment of the invention.<br>
Figure 3 shows a flow chart for a process of accessing a server using threads, in accordance with an embodiment of the invention.<br>
Detailed Description:<br>
Presently, application server customers define new thread pools and configure their size to avoid deadlocks and provide differentiated service. This is quite a difficult process. Atalented software administration team may spend several days puzzling out a configuration for optimal performance.<br>
In accordance with an embodiment of the present invention, a self-tuned server dynamically adjusts the number of threads to avoid deadlocks and achieve optimal throughput subject to concurrency constraints. It also meets objectives for differentiated service. These objectives are stated as response time goals, shares, and priorities.<br>
In accordance with an embodiment, the system addresses requirements related to workload management, execute queue clean-up, thread counttuning, and overload protection. The numerous execute queues in the server can be collapsed into a single, priority-based queue. The system implements a priority based work scheduling scheme, where high priority work spends less time in the queue; Schedulingtakes into account<br><br>
resource constraints. The primary focus is to make the scheduling model scalable and enable administrators to specify workload management rules.<br>
In accordance with an embodiment of the invention, a system and method for application server with self-tuned threading model is provided. In accordance with an embodiment a server queue is used as a priority scheme, including a number of entries therein associated with received requests, and which allows the entries to have expressed priorities that are more natural and closer to the business users than simply the number of threads. Flexibility is still retained to express the threads in raw numbers where this might be desired (for example if there is a known calling sequence that would deadlock unless a specific number of threads were made available), or to express constraints on the number of threads to be made available on a system-wide or workload-basis.<br>
In accordance with an embodiment, priorities may be specified as a "share", an abstract notion which reflects the proportional priority between entities that will receive the requests. Since the total number is arbitrary and there may perhaps be more than 100 shares, the shares are not identical to percentage thread-use, although they are similar. Shares determine the thread usage (in terms of thread number) allocated to each entity. The system (or algorithm operating thereon) then ensures that, over the longer term, the use of the threads (in terms of thread time) will be distributed according to those shares. Any entity who, for example, uses twice as much time or thread minutes as they had been allocated will then be penalized to bring the relative usage proportion back into balance.<br>
In accordance with an embodiment, during runtime the algorithm can also be used to size the thread pool and then allocate the thread within that pool.<br><br>
In accordance with an embodiment, a priority queue is maintained. Each requesting entity, for example a client, can issue requests that go into the queue, and that are spaced apart according to the relative shares. So for example if an entity has not exceeded its allocation its requests can be placed relatively high up in the queue, and will start getting threads immediately, compared to another entity who had used up their allocation or has a lower time-based allocation or share.<br>
In accordance with an embodiment, for a maximum thread constraint the system can maintain a separate queue for holding a request in the priority queue and also in the maximum thread constraint queue. When the maximum thread constraint queue is cleared any similar item in the priority queue (i.e. something for the same constraint) will be allowed to execute.<br>
In accordance with an embodiment, the sizing of the thread pool can be distilled down to an increment or a decrement by one of the existing pool. This is performed on a periodic basis, for example every one or two seconds.<br>
The overall result of the self-tuned threading model is a dramatic improvement of the server in out-of-the box performance. The thread characteristics can then be further tailored to suit specific needs. This feature also allows the server customer to have more flexibility in the setup of their system and provides them with ways to prioritize their threading model for a specific business logic, or set of customer needs etc.<br>
Figure 2 shows an illustration of an environment in which multiple clients access a server using threads and a priority queue, in accordance with an embodiment of the invention. As shown in Figure 2, a server 120 may have many processors, and many threads 122 servicing those processors. A priority queue 124 takes requests 110,112,114from<br><br>
the clients 104, 106, 108, and queues the entries, prioritizing them according to any pre-configured share value or constraints, before passing them 126 to the threads which then apply them to the processors.<br>
Figure 3 shows a flow chart for a process of accessing a server using threads, in accordance with an embodiment of the invention. As shown in Figure 3, in step 130, the server is configured to share thread resou 3S among entities according to share values. This may be through a console application in which an administrator enters share values numerically or through some other type of device. In step 132, the server receives requests from clients. In step 134 the requests are queued in a priority queue according to the share values and on the basis of how much thread time each entity has already used. In step 136 requests are taken from the priority queue and presented to the threads for processing by a processor.<br>
Implementation Details<br>
Performance engineers and application administrators are the primary users of these features. An administrator states scheduling objectives of an application like the fair share and response time goals. As used within the context of this section, the following definitions are used:<br>
Constrained work set - Work can be grouped based on the resources they share. The performance of all work in this set is constrained by the capacity of the shared resource.<br>
Entry point- Examples include RMI method descriptor, HTTP URI, MDBs, and JCA 1.5 WorkManager instance.<br>
Fair share - An entitlement to use threads. When service classes compete for threads they will be allocated threads in proportion to<br><br>
their respective shares. This proportion is realized only as an average for sufficiently long periods during which the service classes compete. All threads may be allocated to a service class if no others are active.<br>
Self-tuning - The ability of the serverto automatically set low level kernel parameters. Administrators can define application requirements they understand, e.g., response time goals, and the server will tune its low-level parameters accordingly.<br>
Response time goal - A goal for the maximum number of milliseconds that can elapse between a request arriving at an entry point in the server and a response being sent out.<br>
Service class - A service class groups work in the server. Objectives are expressed and tracked for a service class, not individual requests. The system should be able to determine the service class of a request before it is enqueued. Some useful service classes arise by grouping according to: entry point, J2EE module, transaction name, current user, or some designated work area field.<br>
Scheduling policy- Determines the wait duration of a request based on its service class and requests from competing service classes.<br>
Workload Management<br>
This feature describes how the server schedules work using service classes, constraints, and the observed load condition in the server. The server permits different scheduling policies for the various classes of work enqueued in the priority queue. This is possible by specifying a service class with the submitted work. This feature lets the system schedule high priority work before less important work even when the high priority work arrives later. During periods of contention the number of threads serving a given service class depends on its stated objective. Constraints<br><br>
define how the kernel should handle work during deadlocks and overload conditions.<br>
Automatic Thread hound<br>
The server automatically adjusts its thread count striving for maximum throughput and implementing minimum concurrency guarantees. Parameters likethreadslncrease orthreadsMaximum are no longer needed.<br>
Reduce execute queues created on startup<br>
In traditional implementations, subsystems create execute queues of their own for various reasons like deadlock prevention, minimum threads guarantee etc. Self-tuning obviates the need to create multiple execute queues and meet those requirements using service classes and constraints.<br>
Overload Protection<br>
Overload protection protects the serverfrom degradation of service under heavy load. In an overloaded condition the server rejects requests in a configurable way. Administrators are able to specify a threshold queue length after which the server may reject requests. Bursts of low priority requests are most likely to get rejected. They can also specify more specific thresholds for individual service classes,<br>
JCA 1.5 WorkManager<br>
JCA1.5 WorkManager API provides a way for an adapter to schedule work in a server. This API exposes the thread scheduling functionality. Applications can use the WorkManager API to execute work asynchronously and receive notifications on the execution status.<br><br>
Workload Management Functional Description<br>
Administrators may define scheduling policies to state special objectives and may express constraints, as shown in the example below:<br><response-time-dispatch-policy name="Shopping" goal-ms="2000"></response-time-dispatch-policy>
/&gt;<br><fair-share-dispatch-policy name="l,GuestShare”" percent="l"></fair-share-dispatch-policy><br><context-dispatch-policy name="ContextShopping"><br><case context=" subject" valuer policy guest share></case>
/&gt;<br><case context="role" value='nBigSpender"' policy></case><br></context-dispatch-policy><br><!-- This configuration tracks the max-processes value of the<br/>
apache web server that faces the extranet --><min-threads-constraint name="minThreadsForPluginMaxProcesses" count="10"></min-threads-constraint><br>
Deployment descriptors and RMI descriptors can then refer to names like ContextShopping and minThreadsForPluginMaxProcesses to apply them to entry points.<br>
Fair shares are reflected in scheduling logic such that as long as multiple service classes compete, the average number of threads used by each is in proportion to their fair share. For example, consider a situation in which there are only two service classes, A and B, having a fair share of 80 and 20, respectively. During a period in which both service classes are sufficiently requested, say, zero thinktime and more clients than threads, the probability that a thread will work on behalf of A or B will tend toward 80% or 20%, respectively. The scheduling logic ensures this even when A tends to use a thread for much longer than B.<br>
Response time goals can differentiate service classes. The system does not try to meet a response time goal for an individual request.<br><br>
Rather it computes a tolerable waiting time for a service class by subtracting the observed average thread use time. Then it can schedule requests so that the average wait for each service class is in proportion to their tolerable waiting time. Forexample, consider there are only two service classes, A and B, with response time goals 2000ms and 5000ms, respectively, where the time an individual request uses a thread is much smaller. During a period in which both service classes are sufficiently requested, say, zero think time and more clients than threads, the system can schedule to keep the average response time in the ratio 2:5 so that it is a common fraction or multiple of the stated goal.<br>
An understanding of the scheduling implementation is helpful for an understanding of the scheduling policies. Each service class has an increment and can enter requests in an event queue with virtual time stamps spaced apart by its interval. A high priority is implemented by small increments. The scheduling policies can be explained as follows:<br>
ResponseTime<br>
With attribute, goal-ms, in milliseconds. The increment is<br>
(   (  goal   -  T  )   Cr )   /  R<br>
where T is the average thread use time, R the arrival rate, and Cr a coefficient to prioritize response time goals over fair shares.<br>
Fair Share<br>
With attribute percentage of default share. Therefore, the default is 100. The increment is<br><br>
Cf   /    (   P  R T   )<br>
where P is the percentage, R the arrival rate, T the average thread use time, and Cf a coefficient for fair shares to prioritize them lower than response time goals.<br>
Context<br>
With multiple cases mapping contextual information, like current user or its role, cookie, or work area fields to named service classes.<br>
SubordinateStepResponseTime<br>
With attribute, primary, which names a PrimaryStepResponseTime.<br>
PrimaryStepResponseTime<br>
With attribute, goal-ms, in milliseconds. Increment is computed similarly to response time goal. Use the ratio of subordinate steps to primary step and subtract that many average thread uses of the subordinate steps to obtain tolerable wait. Divide the tolerable wait by arrival rate for all steps, primary plus subordinate, and multiply by response time coefficient.<br>
Fixed increment<br>
With attribute increment.<br><br>
The fair share coefficient is chosen to be about 1000 times the largest product of arrival rate and average thread use time. The response time coefficient is chosen so that the average increment of response time policies is only one tenth of the average increment of fair share policies.<br>
Constraints<br>
Constraints can be defined and applied to sets of entry points, which are referred to herein as a constrained work set<br>
max-threads<br>
Limits the number of concurrent threads executing requests from the constrained work set The default is unlimited. For example, consider a constraint defined with maximum threads of 10 and shared by 3 entry points. The scheduling logic ensures that not more than 10 threads are executing requests from the three entry points combined.<br>
min-threads<br>
Guarantees a number of threads the server will allocate to requests of the constrained work set to avoid deadlocks. The default is zero. A min-threads value of one is useful, for example, for a replication update request, which is called synchronously from a peer.<br>
capacity<br>
The server starts rejecting requests only when the capacity is reached. The default is zero. Note that the capacity includes all requests, queued or executing, from the constrained work set. This constraint is<br><br>
primarily intended for subsystems like JMS, which do their own flow control. This constraint is independent of the global queue threshold.<br>
Different scheduling policies and constraints interact as follows:<br>
Above, it was explained that scheduling policy can be based on fair share and response time by relating the scheduling to other work using the same policy. A mix of fair share and response time policies is scheduled with a marked bias in favor of response time scheduling.<br>
A min threads constraint does not increase a fair share. It matters only for an almost deadlocked server. Then, however, it will trump it in the sense that the system schedules a request from a min threads constrained work set even if its service class has gotten more than its fair share recently.<br>
A max threads constraint might, but does not necessarily, prevent a service class from taking its fair share or meeting its response time goal. Once the maximum threads constraint is reached the server will not schedule requests of this constraint type until the number of concurrent executions falls below the limit. The server will then schedule work based on the fair share or response time goal.<br>
A min threads constraint and a default air share can address the adminjrmi and adminjitml queue requirement. The System queue requirement is also met by a minimum threads constraint. The multicast queue requirement is met by setting max threads equals min threads equals one. This ensures that there is only one thread that is processing multicast requests thus guaranteeing ordering.<br><br>
Functional Requirements<br>
Dispatch policies and constraints can be defined at three levels: globally in config.xml, per application in weblogic-application.xml, or for specific J2EE modules in weblogic deployment descriptors, weblogic-eib-jar.xml and weblogicxml. These names can be used from the corresponding tags dispatch-policy, max-threads, and min-threads. The max-threads and min-threads tags take a value that is either a name of a max-threads-constraintormin-threads-constraint, respectively, or a number. In weblogic-appiication.xml these tags specify an application wide default. In weblogicxml and weblogic-ejb-jar.xml they specify a component wide default at the top level. In weblogicxml mappings are allowed analogous to the filter-mapping of the web.xml, where named dispatch-policy, max-threads, or min-threads are mapped for url-patternsorservlet names. The max-threads-mapping and min-threads-mapping also tolerate numeric values. In weblogic-ejb-jar.xml the value of the existing dispatch-policy tag under weblogic-enterprise-bean can be a named dispatch-policy. For backwards compatibility, it can also name an ExecuteQueue. In addition, the system can allow dispatch-policy, max-threads, and min-threads, to specify named (or unnamed with numeric value for constraints) policy and constraints for a list of methods, analogously to the present isolation-level tag.<br>
The following is an example from a weblogic-appiication.xml<br><weblogic-application> *«* <response-time-dispatch-policy><br><name>TradeExe cut i on<br><goal-ms>3000</goal-ms></name></response-time-dispatch-policy><fair-share-dispatch-policy><br><br><name>Engui ry <br><percent>30</percent> • • • <max- threads-constraint><br><name>TradeDB</name><br><count>db.pool.trade</count><max-threads-constraint><br><name>CustomerInfoDB</name><br><count>db.pool.crm</count></max-threads-constraint></max-></name></fair-share-dispatch-policy></weblogic-application>
The following is an example from a RMI descriptor that defines service classes at component level:<br><method name="getStockQuote (String)" transactional false dispatch-policy- max-threads="10"></method><method></method>
name="sellStock(String, int)"<br>
di spat ch-policy="TradeExecut ion"<br>
max-threads="TradeDB"<br>
transactional^n true"&gt;  <method></method>
name="getHomePhone (int) "<br>
dispatch-policy="Enquiry"<br>
max-threads="CustomerInfoDB"<br>
transactional^"false"&gt; <br>
The max-threads value can be a number, a named max-threads-constraint, ora named connection pool (JDBC or JCA). If the<br><br>
resource size is dynamic the associated min or max threads constraint will also be dynamic and changes as the resource size changes.<br>
Automatic Thread Count Tuning Functional Description<br>
The thread pool serving the priority queue changes its size automatically to maximize throughput. Administrators no longer need to specify ExecuteQueueMBean attributes like threadslncrease and threadsMaximum. The priority queue monitors the throughput every 2 seconds and uses the collected data to determine if thread count needs to be changed. For example, if more threads gave a better throughput in the past, the server will increase the thread count. Similarly, if less number of threads gave the same throughput in the past, the server will reduce the thread count.<br>
Functional Requirements<br>
No user input is necessary. The server bases the thread count entirely on the throughput history and queue size.<br>
Reduce execute queues created on startup Functional Description<br>
Collapse the different execute queues into a single priority queue. In the past, it was necessary create different execute queues to prevent deadlocks(admin- rmi, non-blocking), prioritize work(system) and achieve ordering (multicast). These requirements are met by associating a service class with enqueued work. All work can be submitted to the priority queue and the thread usage time is based on the types of service classes that are present in the queue.<br><br>
Functional Requirements<br>
The following table explains how the existing execute queues can be mapped to service classes and constraints.<br>
Execute queue fair-share (1-100) response-time-goal nvin-threads<br>
max-threads weblogic.kernel.System 50 None 5 No restriction weblogic.admin.HTTP 50 None 2 No restriction weblogic.admin.RMI 50 None 3 No restriction weblogic.kernel.Non-Blocking 50 None 5 No restriction JmsDispatcher 50 None 15 No restriction Multicast 80 None 1 1<br>
Overload Protection Functional Description<br>
Administrators can configure an overload threshold after which the server starts throttling requests. Throttling is done as follows:<br>
The server rejects requests starting from lower order fair shares with no minimum threads constraint set. Service classes with high priorities or those with minimum threads constraint are still accepted.<br>
If the overload condition continues to prevail, higher priority requests will also be rejected since the server is unable to recover from the overload condition. Requests with minimum threads constraint and administration requests will still be accepted.<br>
A well defined error response is sent if work is rejected. A "503: server is busy" error is sent for HTTP and a remote exception is thrown for RMI which would enable the cluster aware client to failover.<br>
Functional Requirements<br>
Queue limits can be specified at the global level or per class of work. The global threshold can be exposed as a KemelMBean attribute.<br><br>
A class of work can define a threshold using the capacity element in Constraints. Here is an example on how to set the capacity element:<br><weblogic-application><br>
*   *   *<br><capacity-constraint><br><name>myCons t raint <br><treshold>5000</treshold></name></capacity-constraint></weblogic-application><br><method></method>
name="*"<br>
constraints="myConstraint"<br>
transact ional="false"&gt; <br>
A capacity constraint overrides the global threshold. This means that the server will continue to accept requests even when the global threshold is reached. Work will be rejected only with the capacity constraint is reached. This is useful for subsystems that perform their own flow control and cannot use the global queue threshold.<br>
HTTP overload actions<br>
The system will send a 503 error code if the server is in a cluster. This will allow the plugin to failover. If the server does not belong to a cluster, the system can allow customers to configure an error JSP that will be used as the overload response. Customers can also redirect requests to another server during the overload period by specifying redirection as the overload action.<br><br>
RMI overload actions<br>
If the server is in a cluster, the system throws a ServerOverloadedException, which is a subclass of RemoteException. The client will interpret this as a recoverable exception and fail over to another cluster node. In a non-clustered scenario, customers can specify an alternate serverfor redirection. RMI requests during the overload period will be redirected to the alternate server.<br>
The server will not use a reader thread to send out the rejection responses. Writing a response involves I/O which can be slow. Using a reader thread to write the response can block all the reader threads preventing incoming socket mixing.<br>
Subsystems can register with the kernel for overload notifications. The kernel will notify its listeners when the global queue threshold is exceeded. This notification can be used to throttle back work at the subsystem level.<br>
Functional Requirements<br>
WorkManagers can be app-scoped or global. An app-scoped WorkManager can be defined in the weblogic-application.xml like the following:<br><weblogic-application></weblogic-application><workmanager name="MyWM"><br><fair-share>3 0</fair-share><min-threads>5</min-threads><raax-threads>25 <capacity>5000</capacity></raax-threads></workmanager><br><br><br>
To access the WorkManagerfrom the application, one would look up its name in the local environment (java:comp/env). For example:<br>
javax.resource.spi.work.WorkManager wm = (j avax. resource. spi. work - WorkManager) ctx. lookup (" j ava: comp/env/myWM") ; wm.doWork(work) ;<br>
The system does not create a thread group for each WorkManager definition. All WorkManager instances share the default queue. They get priorities based on theirfair-share or response-time-goai.<br>
The present invention may be conveniently implemented using a conventional general purpose or a specialized digital computer or microprocessor programmed according to the teachings of the present disclosure. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art.<br>
in   some embodiments  the present invention   includes a<br>
computer program product which is a storage medium (media) having instructions stored thereon/in which can be used to program a computerto perform any of the processes of the present invention. The storage medium can include, but is not limited to, any type of disk including floppy disks, optical discs, DVD, CD-ROMs, microdrive, and magneto-optical disks, ROMs, RAMs, EPROMs, EEPROMs, DRAMs, VRAMs, flash memory devices, magnetic or optical cards, nanosystems (including molecular memory ICs), or any type of media or device suitable for storing instructions and/or data.<br>
The foregoing description of the present invention has been provided for the purposes of illustration and description. It is not intended<br><br>
to be exhaustive or to limit the invention to the precise forms disclosed. The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalence.<br><br>
Claims:<br>
What is claimed is:<br>
^ 1. A system for self-tuned threading model in an application server, comprising:<br>
a server, including one or more processors;<br>
one or more threads for receiving requests from clients and communicating those requests to a processor; and<br>
a priority queue for allocating threads to multiple requests according to share values, to optimize performance of the threads.<br>
2.	The system of claim 1 wherein said server includes multiple processors.<br>
3.	The system of claim 1 wherein the entries are queued in the priority queue according to pro-rata time values.<br>
4.	The system of claim 3 wherein the entries are queued according to the calculated thread usage time already used in comparison to the time values.<br>
5.	The system of claim 1 wherein the entries may be queued according to additional configured constraints<br>
6.	The system of claim 5 wherein the constraints are determined by queing the entry in an additional constraints queue.<br><br>
7.	A method for self-tuned threading model in an application server,<br>
comprising the steps of:<br>
configuring the server to share thread resources among entities according to share values;<br>
receiving requests at the server from clients;<br>
queuing requests in a priority queue according to the share values and on the basis of how much thread time each entity has already used; and<br>
taking the requests from the priority queue and presenting them to the threads for processing by a processor.<br>
8.	The method of claim 7 wherein said server includes multiple processors.<br>
9.	The method of claim 7 wherein the entries are queued in the priority queue according to pro-rata time values.<br>
10.	The method of claim 9 wherein the entries are queued according to the calculated thread usage time already used in comparison to the time values.<br>
11.	The method of claim 7 wherein the entries may be queued according to additional configured constraints.<br>
12.	The method of claim 11 wherein the constraints are determined by queuing the entry in an additional constraints queue.<br>
13.	A computer readable medium, including instructions thereon which when executed cause the computer to perform the steps of:<br><br>
configuring a server to share thread resources among entities according to share values;<br>
receiving requests at the server from clients;<br>
queuing requests in a priority queue according to the share values and on the basis of how much thread time each entity has already used; and<br>
taking the requests from the priority queue and presenting them to the threads for processing by a processor.<br>
14.	The computer readable medium of claim 13 wherein said server includes multiple processors.<br>
15.	The computer readable medium of claim 13 wherein the entries are queued in the priority queue according to pro-rata time values.<br>
16.	The computer readable medium of claim 15 wherein the entries are<br>
queued according to the calculated thread usage time already used in<br>
comparison to the time values.<br>
17.	The computer readable medium of claim 13 wherein the entries may be queued according to additional configured constraints.<br>
18.	The computer readable medium of claim 17 wherein the constraints are determined by queuing the entry in an additional constraints queue.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2ICAgICBjb21wbGV0ZSBzcGVjaWZpY2F0aW9uIGFzIGdyYW50ZWQucGRm" target="_blank" style="word-wrap:break-word;">1998-chenp-2006     complete specification as granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1DSEVOUC0yMDA2ICBDT1JSRVNQT05ERU5DRSBPVEhFUlMucGRm" target="_blank" style="word-wrap:break-word;">1998-CHENP-2006  CORRESPONDENCE OTHERS.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1DSEVOUC0yMDA2ICBDT1JSRVNQT05ERU5DRSBQTy5wZGY=" target="_blank" style="word-wrap:break-word;">1998-CHENP-2006  CORRESPONDENCE PO.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1DSEVOUC0yMDA2ICBGT1JNLTEucGRm" target="_blank" style="word-wrap:break-word;">1998-CHENP-2006  FORM-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1DSEVOUC0yMDA2ICBGT1JNLTE4LnBkZg==" target="_blank" style="word-wrap:break-word;">1998-CHENP-2006  FORM-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1DSEVOUC0yMDA2ICBGT1JNLTIucGRm" target="_blank" style="word-wrap:break-word;">1998-CHENP-2006  FORM-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1DSEVOUC0yMDA2ICBQT1dFUiBPRiBBVFRPUk5FWS5wZGY=" target="_blank" style="word-wrap:break-word;">1998-CHENP-2006  POWER OF ATTORNEY.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2IGFic3RyYWN0LWR1cGxpY2F0ZS5qcGc=" target="_blank" style="word-wrap:break-word;">1998-chenp-2006 abstract-duplicate.jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2IGFic3RyYWN0LWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">1998-chenp-2006 abstract-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2IGNsYWltcy1kdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">1998-chenp-2006 claims-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2IGRlc2NyaXB0aW9uIChjb21wbGV0ZSktZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">1998-chenp-2006 description (complete)-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2IGRyYXdpbmdzLWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">1998-chenp-2006 drawings-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">1998-chenp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2LWFzc2lnbmVtZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">1998-chenp-2006-assignement.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">1998-chenp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2LWNvcnJlc3BvbmRuZWNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">1998-chenp-2006-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2LWRlc2NyaXB0aW9uKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">1998-chenp-2006-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1998-chenp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">1998-chenp-2006-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2LWZvcm0gMTgucGRm" target="_blank" style="word-wrap:break-word;">1998-chenp-2006-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2LWZvcm0gMjYucGRm" target="_blank" style="word-wrap:break-word;">1998-chenp-2006-form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">1998-chenp-2006-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">1998-chenp-2006-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OC1jaGVucC0yMDA2LXBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">1998-chenp-2006-pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="230260-start-up-circuit-for-delay-locked-loop.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="230262-kerosene-composition.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>230261</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1998/CHENP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>13/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>27-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>25-Feb-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>06-Jun-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>BEA SYSTEMS, INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2315 North First Street, San Jose, California 95131,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>LANGEN, Anno, R</td>
											<td>973 Indian Rock, Berkeley, CA 94707,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>REVANURU, Naresh</td>
											<td>2000 Walnut Avenue, #H-106, Fremont, California 94538,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F9/46</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2005/017744</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-05-20</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>11/132,601</td>
									<td>2005-05-19</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/572,938</td>
									<td>2004-05-20</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/230261-a-method-and-system-for-self-tuning-application-thread-model-in-application-server by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 11:01:28 GMT -->
</html>
