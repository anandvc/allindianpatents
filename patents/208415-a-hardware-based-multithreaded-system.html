<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/208415-a-hardware-based-multithreaded-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:07:39 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 208415:A HARDWARE BASED MULTITHREADED SYSTEM</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A HARDWARE BASED MULTITHREADED SYSTEM</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A computer instruction includes a command instruction to issue a memory reference to an address in a memory shared among threads executing in microprocessors while a context of thread is inactive.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT,   1970<br>
[39 OF 1970]<br>
COMPLETE SPECIFICATION<br>
[See Section 10; Rule 13]<br>
"A HARDWARE BASED MULTITHREADED SYSTEM"<br>
INTEL CORPORATION, a Delaware Corporation, 2200 Mission College Boulevard, Santa Clara, California 95052-8119, United States of America,<br>
The following specification particularly describes the nature of the invention and the manner in which it is to be performed:-<br><br>
The present invention relates to a hardware based multithreaded system.<br>
This invention relates to memory reference instructions for computer processors.<br>
Parallel processing is an efficient form of information processing of concurrent events in a computing process. Parallel processing demands concurrent execution of many programs in a computer, in contrast to sequential processing. In the context of a parallel processor, parallelism involves doing more than one thing at the same time. Unlike a serial paradigm where all tasks are performed sequentially at a single station or a pipelined machine where tasks are performed at specialized stations, with parallel processing, a number of stations are provided with each capable of performing all tasks. That is, in general all or a number of the stations work simultaneously and independently on the same or common elements of a problem. Certain problems are suitable for solution by applying parallel processing.<br>
The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features, objects, and advantages of the invention will be apparent from the description and drawings, and from the claims.<br>
DESCRIPTION OF DRAWINGS<br>
the foregoing features and other aspects of the invention will bedescribed further in detail by the accompanying drawmgs, in which:<br>
FIG. 1 is a block diagram of a communication system employing a hardware based multithreaded processor.<br>
FIG. 2 is a detailed block diagram of the hardware-based multithreaded processor of FIG. 1.<br>
FIG. 3 is a block diagram of a micro engine functional unit employed in the hardware-based multithreaded processor of FIGS. 1 and 2.<br>
FIG. 4 is a block diagram of a pipeline in the micro engine of FIG. 3.    FIG. 5 is a block diagram of SRAM address space.<br>
FIG. 6 is a block diagram of a SRAM/WRITE command.<br><br>
FIG. 7 is a block diagram of a PUSH/POP Command.<br>
FIG. 8 is a block diagram of an Indirect_ref Format for the BIT_WR Command.<br>
FIG. 9 is a block diagram of a format for an indirect_ref for a READ/WRITE<br>
Command.<br>
	FIG. 10 is a block diagram of an indirect_ref Format for the T_FIFO_WR<br>
      command.<br>
	FIG. 11 is a block diagram of an indirect ref Format for the R_FIFO_RD<br>
     command.<br>
	FIG. 12 is a block diagram of a format for an indirect_ref Format for a<br>
                                             READ/WRITE Command.<br>
FIG. 13 is a block diagram of an indirect_ref Format for the BIT_WR command.<br>
Like reference symbols in the various drawings indicate like elements.<br>
	DETAILED DESCRIPTION<br><br>
t<br>
	Referring to FIG. 1, a communication system 10 includes a parallel, hardware-<br>
	based multithreaded processor 12. The hardware-based multithreaded processor 12 is<br>
	coupled to a bus such as a PCI bus 14, a memory system 16 and a second bus 18. The<br>
	system 10 is especially useful for tasks that can be broken into parallel subtasks or<br>
	functions. Specifically, hardware-based multithreaded processor 12 is useful for tasks<br><br>
        that are bandwidth oriented rather than latency oriented. The hardware-based<br><br>
        multithreaded processor 12 has multiple micro engines 22 each with multiple hardware<br>
controlled threads that can be simultaneously active and independently work on a task.<br>
The hardware-based multithreaded processor 12 also includes a central controller<br>
20 that assists in loading micro code control for other resources of the hardware-based<br>
multithreaded processor 12 and performs other general purpose computer type functions<br>
       such as handling protocols, exceptions, extra support for packet processing where the<br>
micro engines 22 pass the packets off for more detailed processing such as in boundary<br>
conditions.   In one embodiment, the processor 20 is a Strong Arm® (Arm is a trademark<br>
     of ARM Limited, United Kingdom) based architecture. The general-purpose<br>
     microprocessor 20 has an operating system. Through the operating system the processor<br>
        20 can call functions to operate on micro engines 22a-22f. The processor 20 can use any<br>
        supported operating system, preferably a real time operating system. For the core<br><br>
processor 20 implemented as Strong Arm architecture, operating systems such as, Microsoft-NT real-time, VXWorks and microCUS, a freeware operating system available over the Internet, can be used.<br>
Functional micro engines (micro engines) 22a-22f each maintain program        counters in hardware and states associated with the program counters. Effectively, a corresponding number of sets of threads can be simultaneously active on each of the micro engines 22a-22f while only one is actually operating at any one time.<br>
In an embodiment, there are six micro engines 22a-22f as shown. Each micro engine 22a-22f has capabilities for processing four hardware threads. The six micro           engines 22a-22f operate with shared resources including memory system 16 and bus<br>
interfaces 24 and 28. The memory system 16 includes a Synchronous Dynamic Random Access Memory (SDRAM) controller 26a and a Static Random Access Memory (SRAM) controller 26b. SDRAM memory 16a and SDRAM controller 26a are typically used for processing large volumes of data, e.g., processing of network payloads from network          packets. The SRAM controller 26b and SRAM memory 16b are used in a networking implementation for low latency, fast access tasks, e.g., accessing look-up tables, memory for the core processor 20, and so forth.<br>
The six micro engines 22a-22f access either the SDRAM 16a or SRAM 16b based on characteristics of the data. Thus, low latency, low bandwidth data is stored in and fetched from SRAM 16b, whereas higher bandwidth data for which latency is not as important, is stored in and fetched from SDRAM 16a. The micro engines 22a-22f can execute memory reference instructions to either the SDRAM controller 26a or SRAM controller 16b.<br>
Advantages of hardware multithreading can be explained by SRAM or SDRAM 25     memory accesses. As an example, an SRAM access requested by a Thread_0, from a micro engine will cause the SRAM controller 26b to initiate an access to the SRAM memory 16b. The SRAM controller 26b controls arbitration for the SRAM bus, accesses the SRAM 16b, fetches the data from the SRAM 16b, and returns data to a requesting micro engine 22a-22f. During an SRAM access, if the. micro engine, e.g., micro engine          22a, had only a single thread that could operate, that micro engine would be dormant until data was returned from the SRAM 16b. By employing hardware context swapping within each of the micro engines 22a-22f, the hardware context swapping enables other contexts<br><br>
 with unique program counters to execute in that same micro engine. Thus, another thread, e.g., Thread__l can function while the first thread, i.e., Thread_0, is awaiting the read data to return. During execution, Thread_l may access the SDRAM memory 16a. While Thread_l operates on the SDRAM unit 16a, and Thread_0 is operating on the         SRAM unit 16b, a new thread, e.g., Thread_2 can now operate in the micro engine 22a. Thread_2 can operate for a certain amount of time until it needs to access memory or perform some other long latency operation, such as making an access to a bus interface. Therefore, simultaneously, the processor 12 can have a bus operation, SRAM operation and SDRAM operation all being completed or operated upon by one micro engine 22a         and have one more thread available to process more work in the data path.<br>
The hardware context swapping also synchronizes completion of tasks. For example, two threads could hit the same shared resource e.g., SRAM 16b. Each one of these separate functional units, e.g., the FBUS interface 28, the SRAM controller 26a, and the SDRAM controller 26b, when they complete a requested task from one of the micro engine thread contexts reports back a flag signaling completion of an operation. When the micro engine receives the flag, the micro engine can determine which thread to turn on.<br>
An application for the hardware-based multithreaded processor 12 is as a network processor. As a network processor, the hardware-based multithreaded processor 12           interfaces to network devices such as a media access controller device e.g., a<br>
10/100BaseT Octal MAC 13a or a Gigabit Ethernet device 13b. In general, as a network processor, the hardware-based multithreaded processor 12 can interface to any type of communication device or interface that receives/sends large amounts of data. Communication system 10 functioning in a networking application could receive network           packets from the devices 13a, 13b and process those packets in a parallel manner. With the hardware-based multithreaded processor 12, each network packet can be independently processed.<br>
Another example for use of processor 12 is a print engine for a postscript processor or as a processor for a storage subsystem, e.g., Redundant Array of Independent          Disk (RAID) storage, a category of disk drives that employs two or more drives in<br>
combination for fault tolerance and performance. A further use is as a matching engine. In the securities industry for example, the advent of electronic trading requires the use of<br><br><br>
electronic matching engines to match orders between buyers and sellers. These and other parallel types of tasks can be accomplished utilizing the system 10.<br>
The processor 12 includes the bus interface 28 that couples the processor to the second bus 18. In an embodiment, bus interface 28 couples the processor 12 to the FBUS         (FIFO bus) 18. The FBUS interface 28 is responsible for controlling and interfacing the processor 12 to the FBUS 18. The FBUS 18 is a 64-bit wide FIFO bus, used to interface to Media Access Controller (MAC) devices, e.g., 10/100 Base T Octal MAC 13a.<br>
The processor 12 includes a second interface e.g., PCI bus interface 24, that couples other system components that reside on the PCI 14 bus to the processor 12. The         PCI bus interface 24 provides a high-speed data path 24a to memory 16, e.g., SDRAM memory 16a. Through PCI bus interface 24 data can be moved quickly from the SDRAM 16a through the PCI bus 14, via direct memory access (DMA) transfers. The hardware based multithreaded processor 12 supports image transfers. The hardware based multithreaded processor 12 can employ DMA channels so if one target of a DMA transfer        is busy, another one of the DMA channels can take over the PCI bus 14 to deliver<br>
information to another target to maintain high processor 12 efficiency. Additionally, the PCI bus interface 24 supports target and master operations. Target operations are operations where slave devices on bus 14 access SDRAMs through reads and writes that are servicedas a slave to a target operation. In master operations, the processor core 20         sends data directly to or receives data directly from the PCI interface 24.<br>
Each of the functional units 22 is coupled to one or more internal buses. As described below, the internal buses are dual, 32 bit buses (i.e., one bus for read and one for write). The hardware-based multithreaded processor 12 also is constructed such that the sum of the bandwidths of the internal buses in the processor 12 exceed the bandwidth          of external buses coupled to the processor 12. The processor 1.2 includes an internal core processor bus 32, e.g., an ASB Advanced System Bus (ASB), that couples the processor core 20 to the memory controller 26a, 26b and to an ASB translator 30, described below. The ASB bus 32 is a subset of the so-called Advanced Microcontroller Bus Architecture (AMBA) bus that is used with the Strong Arm processor core 20. AMBA is an open           standard, on-chip bus specification that details a strategy for the interconnection and<br>
management of functional blocks that makes up a System-on-chip (SoC). The processor 12 also includes a private bus 34 that couples the micro engine units 22 to SRAM<br><br>
controller 26b, ASB translator 30 and FBUS interface 28. A memory bus 38 couples the memory controller 26a, 26b to the bus interfaces 24 and 28 and memory system 16 including flashrom 16c that is used for boot operations and so forth.<br>
Referring to FIG. 2, each of the micro engines 22a-22f includes an arbiter that examines flags to determine the available threads to be operated upon. Any thread from any of the micro engines 22a-22f can access the SDRAM controller 26a, SDRAM controller 26b or FBUS interface 28. The memory controllers 26a and 26b each include queues to store outstanding memory reference requests. The queues either maintain order of memory references or arrange memory references to optimize memory bandwidth. For         example, if a thread_0 has no dependencies or relationship to a thready 1, there is no<br>
reason that thread_l and thread_0 cannot complete their memory references to the SRAM unit 16b out of order. The micro engines 22a-22f issue memory reference requests to the memory controllers 26a and 26b. The micro engines 22a-22f flood the memory subsystems 26a and 26b with enough memory reference operations such that the memory          subsystems 26a and 26b become the bottleneck for processor 12 operation.<br>
If the memory subsystem 16 is flooded with memory requests that are independent in nature, the processor 12 can perform memory reference sorting.   Memory reference sorting improves achievable memory bandwidth. Memory reference sorting, as described below, reduces dead time or a bubble that occurs with accesses to SRAM 16b. With          memory references to SRAM 16b, switching current direction on signal lines between reads and writes produces a bubble or a dead time waiting for current to settle on conductors coupling the SRAM 16b to the SRAM controller 26b.<br>
That is, the drivers that drive current on the bus need to settle out prior to changing states. Thus, repetitive cycles of a read followed by a write can degrade peak 2-5     bandwidth. Memory reference sorting allows the processor 12 to organize references to memory such that long strings of reads can be followed by long strings of writes. This can be used to minimize dead time in the pipeline to effectively achieve closer to maximum available bandwidth. Reference sorting helps maintain parallel hardware context threads. On the SDRAM 16a, reference sorting allows hiding of pre-charges           from one bank to another bank. Specifically, if the memory system 16b is organized into an odd bank and an even bank, while the processor is operating on the odd bank, the memory controller can start pre-charging the even bank. Pre-charging is possible if<br><br>
memory references alternate between odd and even banks. By ordering memory references to alternate accesses to opposite banks, the processor 12 improves SDRAM bandwidth. Additionally, other optimizations can be used. For example, merging optimizations where operations that can be merged, are merged prior to memory access, open page optimizations where by examining addresses an opened page of memory is not reopened, chaining, as will be described below, and refreshing mechanisms, can be employed.<br>
The FBUS interface 28 supports Transmit and Receive flags for each port that a MAC device supports, along with an Interrupt flag indicating when service is warranted.        The FBUS interface 28 also includes a controller 28a that performs header processing of incoming packets from the FBUS 18. The controller 28a extracts the packet headers and performs a micro programmable source/destination/protocol hashed lookup (used for address smoothing) in SRAM 16b. If the hash does not successfully resolve, the packet header is sent to the processor core 20 for additional processing. The FBUS interface 28         supports the following internal data transactions:<br>
FBUS unit	(Shared bus SRAM)   to/from micro engine.<br>
FBUS unit	(via private bus)	writes from SDRAM Unit.<br>
FBUS unit	(viaMbus)	Reads to SDRAM.<br>
        The FBUS 18 is a standard industry bus and includes a data bus, e.g., 64 bits wide and sideband control for address and read/write control. The FBUS interface 28 provides the ability to input large amounts of data using a series of input and output FIFOs 29a-29b. . From the FIFOs 29a-29b, the micro engines 22a-22f fetch data from or command the SDRAM controller 26a to move data from a receive FIFO in which data has come from a<br>
         device on bus 18, into the FBUS interface 28. The data can be sent through memory<br>
controller 26a to SDRAM memory 16a, via a direct memory.access. Similarly, the micro engines can move data from the SDRAM 26a to interface 28. out to FBUS 18, via the FBUS interface 28.<br>
Data functions are distributed amongst the micro engines 22. Connectivity to the<br>
         SRAM 26a, SDRAM 26b and FBUS 28 is via command requests. A command request can be a memory request or a FBUS request For exampJe, a command request can move data from a register located in a micro engine 22a to a shared resource, e.g., an SDRAM<br><br>
location, SRAM location, flash memory or some MAC address. The commands are sent out to each of the functional units and the shared resources. However, the shared resources do not need to maintain local buffering of the data. Rather, the shared resources access distributed data located inside of the micro engines 22a-22f. This         enables micro engines 22a-22f, to have local access to data rather than arbitrating for access on a bus and risk contention for the bus. With this feature, there is a zero cycle stall for waiting for data internal to the micro engines 22a-22f.<br>
The data buses, e.g., ASB bus 30, SRAM bus 34 and SDRAM bus 38 coupling these shared resources, e.g., memory controllers 26a and 26b, are of sufficient bandwidth          such that there are no internal bottlenecks. In order to avoid bottlenecks, the processor 12 has a bandwidth requirement where each of the functional units is provided with at least twice the maximum bandwidth of the internal buses. As an example, the SDRAM 16a can run a 64 bit wide bus at 83 MHz. The SRAM data bus could have separate read and write buses, e.g., could be a read bus of 32 bits wide running at 166 MHz and a write bus    `	     of 32 bits wide at 166 MHz. That is, in essence, 64 bits running at 166 MHz that is effectively twice the bandwidth of the SDRAM.<br>
The core processor 20 also can access the shared resources. The core processor 20 has a direct communication to the SDRAM controller 26a to the bus interface 24 and to SRAM controller 26b via bus 32. However, to access the micro engines 22a-22f and 20     transfer registers located at any of the micro engines 22a-22f, the core processor 20 access the micro engines 22a-22f via the ASB Translator 30 over bus 34. The ASB translator 30 can physically reside in the FBUS interface 28, but logically is distinct. The ASB Translator 30 performs an address translation between FBUS micro engine transfer register locations and core processor addresses (i.e., ASB bus) so that the core processor 25     20 can access registers belonging to the micro engines 22a-22f.<br>
Although micro engines 22a-22f can use the register set to exchange data as<br>
described below, a scratchpad memory 27 is also provided to permit micro engines 22a-<br>
22f to write data out to the memory for other micro engines to read. The scratchpad 27 is<br>
coupled to bus 34.<br>
  	The processor core 20 includes a RISC core 50 implemented in a five stage<br>
pipeline performing a single cycle shift of one operand or two operands in a single cycle, provides multiplication support and 32 bit barrel shift support. This RISC core 50 is a<br><br>
standard Strong Arm® architecture but it is implemented with a five-stage pipeline for performance reasons. The processor core 20 also includes a 16-kilobyte instruction cache 52, an 8-kilobyte data cache 54 and a prefetch stream buffer 56. The core processor 20 performs arithmetic operations in parallel with memory writes and instruction fetches. The core processor 20 interfaces with other functional units via the ARM defined ASB bus. The ASB bus is a 32-bit bi-directional bus 32.<br>
Referring to FIG. 3, an exemplary one of the micro engines 22a-22f, e.g.. micro engine 22f, is shown. The micro engine 22f includes a control store 70, which, in one implementation, includes a RAM of here 1,024 words of 32 bit. The RAM stores a micro program (not shown). The micro program is loadable by the core processor 20. The micro engine 22f also includes controller logic 72. The controller logic 72 includes an instruction decoder 73 and program counter (PC) units 72a-72d. The four micro program counters 72a-72d are maintained in hardware. The micro engine 22f also includes context event switching logic 74. Context event logic 74 receives messages (e.g.,          SEQ_#_EVENT_RESPONSE; FBI__EVENT_RESPONSE; SRAM _EVENT_RESPONSE; SDRAM _EVENT_RESPONSE; and ASB _EVENT_RESPONSE) from each one of the shared resources, e.g., SRAM 26a, SDRAM 26b, or processor core 20, control and status registers, and so forth. These messages provide information on whether a requested function has completed. Based on whether or          not a function requested by a thread has completed and signaled completion, the thread      needs to wait for that completion signal, and if the thread is enabled to operate, then the thread is placed on an available thread list (not shown). The micro engine 22f can have a maximum of four threads available.<br>
In addition to event signals that are local to an executing thread, the micro engines<br>
         22a-22f employ signaling states that are global. With signaling states, an executing<br>
thread can broadcast a signal state to all micro engines 22a-22f, e.g., Receive Request<br>
Available (RRA) signal, any and all threads in the micro engines 22a-22f can branch on<br>
these signaling states. These signaling states can be used to determine availability of a<br>
resource or whether a resource is due for servicing.<br>
	The context event logic 74 has arbitration for the four threads. In an embodiment,<br>
the arbitration is a round robin mechanism. Other techniques could be used including priority queuing or weighted fair queuing. The micro engine 22f also includes an<br><br><br>
execution box (EBOX) data path 76 that includes an arithmetic logic unit (ALU) 76a and general-purpose register set 76b. The ALU 76a performs arithmetic and logical functions as well as shift functions. The register set 76b has a relatively large number of general-purpose registers. In an embodiment, there are 64 general-purpose registers in a first bank, Bank A and 64 in a second bank, Bank B. The general-purpose registers are windowed so that they are relatively and absolutely addressable.<br>
The micro engine 22f also includes a write transfer register stack 78 and a read transfer stack 80. These registers 78 and 80 are also windowed so that they are relatively and absolutely addressable. Write transfer register stack 78 is where write data to a        resource is located. Similarly, read register stack 80 is for return data from a shared resource. Subsequent to or concurrent with data arrival, an event signal from the respective shared resource e.g., the SRAM controller 26a, SDRAM controller 26b or core processor 20 will be provided to context event arbiter 74, which will then alert the thread that the data is available or has been sent. Both transfer register banks 78 and 80 are           connected to the execution box (EBOX) 76 through a data path. In an embodiment, the read transfer register has 64 registers and the write transfer register has 64 registers.<br>
Referring to FIG. 4, the micro engine data path maintains a 5-stage micro-pipeline 82. This pipeline includes lookup of microinstruction words 82a, formation of the register file addresses 82b, read of operands from register file 82c, ALU shift or compare           operations 82d, and write-back of results to registers 82e. By providing a write-back data bypass into the ALU/shifter units, and by assuming the registers are implemented as a register file (rather than a RAM), the micro engine 22f can perform a simultaneous register file read and write, which completely hides the write operation.<br>
The SDRAM interface 26a provides a signal back to the requesting micro engine           on reads that indicates whether a parity error occurred on the read request. The micro<br>
engine micro code is responsible for checking the SDRAM 16a read Parity flag when the micro engine uses any return data. Upon checking the flag, if it was set, the act of branching on it clears it. The Parity flag is only sent when the SDRAM 16a is enabled for checking, and the SDRAM 16a is parity protected. The micro engines 22 and the PCI Unit 14 are the only requestors notified of parity errors. Therefore, if the processor core 20 or FIFO 18 requires parity protection, a micro engine assists in the request. The micro engines 22a-22f support conditional branches.<br><br>
The instruction set also includes an instruction that issues a memory reference to Static Random Access Memory (SRAM).<br>
A format of the instruction that issues a memory reference to SRAM is sram[sram_cmd, $sram_xfer_reg, source_opl, source_op2,         ref_count_or_queue_num_or_bit_op], optional_token. A description of each of the fields follows.<br>
The "sram_cmd" field refers to an operation to be performed on SRAM. Operations include bit_wr, read, read_lock, write, write_unlock, unlock, push and pop. The "bit_wr" operation sets or clears user specified bits in an SRAM longword.          The "read" operation reads from SRAM to an SRAM transfer register. The "read_lock" operation locks memory and then reads it. If memory is already locked, it waits until it is unlocked. The "ctx_swap" optional token is always required for a read lock operation. The "write" operation writes to SRAM from an SRAM transfer register. The "write_unlock" operation performs a write and unlocks a specified address. The "unlock"         operation unlocks a specified address without performing a read or a write.<br>
The "push" operation pushes a list element specified by an address onto a specified stack. The "pop" operation pops a list element specified by an address from a specified stack.<br>
The "$sram_xfer_reg" field indicates if the read, read_lock, write, or write_unlock          sram_cmd parameters are used, the contents of this transfer register is the beginning of a contiguous set of registers that receive or supply the SRAM data on a read or write operation, respectively. SRAM transfer register names always begin with a $ symbol. If the unlock sram_cmd parameter is used, this register is not meaningful and the "-" notation is used instead of a register name. If the pop sram_cmd parameter is used, this         register contains the pointer to the list that is removed from the queue specified by ref_count_or_queue_num. This register has no meaning if push is specified as an sram_cmd parameter and the "--" notation is used. If the bit_wr sram_cmd parameter is used, this register contains the bit mask that chooses which bits should be set or cleared. For the test_and_set_bits and test_and__clear_bits options, this register also returns the       original data as it existed before setting or clearing bits.<br>
The "source_opl" and "source_op2" fields refer to context-relative registers or 5-bit zero filled immediate data ranging from +31 to 0. These fields are added together to<br><br><br>
form a longword address to SRAM memory space. For the push sram_cmd parameter,<br>
the sum specifies the address that is to be pushed onto the queue. This register has no<br>
meaning if pop is specified as an sram_cmd parameter and dummy parameters for<br>
source_opl and source_op2 are used in this case.<br>
  	The "ref_count_or_queue_num_or_bit_op" field indicates if the read, read_lock,<br>
write, or write_unlock sram_cmd parameters are used, it specifies the number of contiguous SRAM longwords to be referenced with this operation. If the count is &gt; 1, then the SRAM address is implicitly incremented for each subsequent reference. If a read_lock or write_unlock command is specified with a ref_count &gt; 1, the refcount          refers only to the number of memory words transferred and not to the number of<br>
addresses locked or unlocked. The number of addresses locked or unlocked per reference<br>
is always 1. If the unlock sram_cmd parameter is used, this register is not meaningful and<br>
a 1 is always used. If the push or pop sram_cmd parameters are used, this specifies one<br>
of the eight push/pop queues. Valid queue numbers are 0 through 7. If the bit wr<br>
         sram_cmd parameter is used, one of the following parameters must be used: set_bits,<br>
clear_bits, test_and_set_bits, or test_and_clear_bits. set_bits and clear_bits are used to<br>
set or clear bits at an address using a specified bit mask. test_and_set_bits and<br>
test_and_clear_bits are also used to set or clear bits, but return the original data as it<br>
existed before the operation.<br>
  	The "sig_done" parameter indicates when the reference completes, signal the<br>
corresponding microengine/thread pair that is sourcing or sinking the memory data. Not used with ctx_swap.<br>
The "ctx_swap" parameter indicates when the memory reference is issued, swap out the current thread execution to let another one run. Not used with sig_done and          always required for the read lock command.<br>
The "defer [1]" parameter is used with the ctx_swap option; it specifies that one instruction will be executed after this reference before the context is swapped and is not used with sig_done.<br>
The "ordered" parameter places this SRAM reference into the Ordered queue. The            Ordered queue preserves the order of execution of references that use the ordered optional token. For example, if a thread issues two writes with the sig_done optional token on the second reference, both references would need to be ordered to ensure that the second<br><br><br>
reference finishes after the first. Not used with optimize_mem or priority. If neither ordered nor optimize_mem is specified, the default value becomes ordered.<br>
The "priority" parameter places this SRAM reference into the Priority queue. The Priority queue gives higher priority to this memory reference over others. Not used with        ordered or optimize_mem. If neither priority nor optimize_mem is specified, the default value becomes ordered.<br>
The "optimize_rnem" parameter optimizes memory bandwidth by automatically placing the SRAM reference into either the Read or Ordered queues. The Read or Ordered queues are selected according to whether the operation is a read or a write. This 10     may result in the references being executed in an order different from that in which they were issued. Not used with ordered or priority. If neither priority nor optimize_mem is specified, the default value becomes ordered.<br>
The "indirect_ref parameter indicates that overriding qualifiers or additional qualifiers are associated with this reference. These qualifiers are output by the ALU          during the previous microword. The format of the qualifier depends on the SRAM<br>
command. There are different formats for read/write, push/pop, and bit_wr, as shown in the following illustrations.<br><br>
Referring to FIG. 5, a block diagram of SRAM address space is shown. Referring to FIG. 6, a block diagram of a SRAM/WRITE command is shown, where:<br><br>
Bits<br><br>
Field<br><br>
Description<br><br><br><br>
31<br>
30:28<br>
27 26<br>
25:21<br>
20 19:16<br>
15<br>
14:11 10:7<br>
6:3<br>
2:<br>
1:0<br><br>
OV<br>
UENG ADDR<br>
OV ABS<br>
XADD<br>
OV<br>
REF CNT<br>
CV<br>
RES<br>
BYTE MASK<br>
RES OV<br>
CTX<br><br>
If set, the UENG ADDR field overrides the default<br>
microengine address implied by the RAM instruction,<br>
which is the microengine that issued the reference.<br>
Specifies the microengine associated with the memory<br>
reference. If bit [31] = 0, this field is a don"t care. Valid<br>
UENG ADDR values axe 0 through 5.<br>
If set, the XADD field overrides the default transfer<br>
register address implied by the SRAM instruction.<br>
If set, enables absolute addressing for the microengine<br>
transfer registers. This bit should always be set if bit<br>
[27] (OV) is set.<br>
Absolute transfer register address. Valid addresses are:<br>
0-7 Eight transfer registers for context 0. 8-15 Eight<br>
transfer registers for context 1. 16-23 Eight transfer<br>
registers for context 2. 24-31 Eight transfer registers for<br>
context 3.<br>
If set, the REF CNT field overrides the ref_count<br>
specified by the SRAM instruction<br>
The number of longwords to be transferred to/from<br>
SRAM. Valid REF CNT values are 0 through 7, where<br>
the number of longwords = REF CNT + 1.<br>
If set, the BYTE MASK field overrides default byte<br>
mask of OxFF implied by the SRAM instruction<br>
Reserved. Returns 0 when read.<br>
BYTE MASK allows aligned byte write operations<br>
within an addressed SRAM longword. The bytes that<br>
are written are specified by the byte mask. For each bit<br>
in the byte mask, value of 1 enables a write to occur in<br>
corresponding byte position and a value of 0 preserves<br>
the previously existing value. The least significant bit<br>
corresponds to the right-most byte; the most significant<br>
bit corresponds to the left-most byte. A byte mask other<br>
than the default (OxF) requires the SRAM controller<br>
perform a read-modify-write operation, which impacts<br>
performance.<br>
Reserved. Returns 0 when read<br>
If set, the CTX field overrides the default context<br>
implied by the SRAM instruction.<br>
Specifies the context associated with the memory<br>
reference. If bit [2] = 0, this field is a don"t care. Valid<br>
CTX values are 0 through 3.<br><br><br>
Referring to FIG. 7, 2 block diagram of a PUSH/POP Command is shown, where:<br>
Bits	Field	Description<br>
5       31	OV	If set, the UENGADDR field<br>
overrides the default<br>
microengine address implied by<br>
the SRAM command, which is the<br>
microengine that issued the<br>
10	reference.<br>
30:28     UENG ADDR	Specifies the microengine<br>
associated with the memory reference. If bit [31] = 0, this<br>
field is a don"t care. Valid<br>
15	UENG ADDR values are 0 through 5.<br>
27	OV	If set, the XADD field overrides<br>
the default transfer register<br>
address implied by the SRAM<br>
instruction.<br>
20      26	ABS	If set, enables absolute<br>
addressing for the micToengine<br>
transfer registers. This bit<br>
should always be set if bit [27]<br>
(OV) is set<br>
25       25:21     XADD	Absolute transfer register<br>
address.<br>
Valid addresses are:<br>
0-7 Eight transfer registers for<br>
context 0.<br>
30	8-15 Eight transfer registers<br>
for context 1.<br>
16-23 Eight transfer registers for context 2.<br>
24-31 Eight transfer registers<br>
35	for context 3.<br>
20	OV	If set, the REF CNT field<br>
overrides<br>
the refcount specified by the SRAM<br>
instruction.<br>
40      19	RES	Reserved. Returns 0 when read.<br>
18:16    LIST REG	Specifies one of the 8 push/pop<br>
registers. Valid LIST REG values<br>
are 0 through 7.<br>
15:3	RES	Reserved. Returns 0 when read.<br>
45       2	OV	If set, the CTX field overrides the<br>
default context implied by the SRAM<br>
instruction.<br>
1:0	CTX	Specifies the context associated<br>
with the memory reference. If bit<br>
50	[2] = 0, this field is a don"t<br>
care. Valid CTX values are 0 through 3.<br><br>
Referring to FIG. 8 a block diagram of an Indirect_ref Format for the BIT_WR Command is shown, where:<br>
Bits	Field	Description<br>
5       31	OV	If set, the UENG ADDR field<br>
overrides the default<br>
microengine address implied by<br>
the SRAM instruction, which is<br>
the microengine that issued the<br>
10	reference.<br>
30:28    UENG ADDR	Specifies the microengine<br>
associated with the memory<br>
reference. If bit [31] = 0, this<br>
field is a don"t care. Valid<br>
15	UENG ADDR values are 0 through<br>
      5.	"<br>
27	OV	If set, the XADD field overrides<br>
the default transfer register<br>
address implied by the SRAM<br>
20	instruction.<br>
26	ABS	If set, enables absolute<br>
addressing for the microengine<br>
transfer registers. This bit<br>
should always be set if bit [27]<br>
25	(OV) is set<br>
25:21	XADD	Absolute transfer register<br>
address. Valid addresses are:<br>
0-7 Eight transfer registers for<br>
context 0.<br>
30	8-15 Eight transfer registers<br>
for context 1.<br>
16-23 Eight transfer registers for context 2.<br>
24-31 Eight transfer registers<br>
35	for context 3.<br>
20	OV	If set, the TS and ST fields<br>
override the bit operation<br>
specified by the SRAM<br>
instruction.<br>
40       19:18	RES	Reserved Returns 0 when read.<br>
17	TS	When set, specifies that the<br>
. read data is returned before the<br>
write operation so that the data<br>
can be tested.<br>
45       16	ST	Specifies whether the operation<br>
is set (ST=1) or clear (ST=0).<br>
15:3	RES	Reserved. Returns 0 when read.<br>
2	OV	If set, the CTX field overrides<br>
the default context	implied by<br>
50	the SRAM instruction.<br>
1:0	CTX	Specifies the context associated<br>
with the memory reference. If<br>
bit [2] = 0, this field is a<br>
don"t care. Valid CTX values are<br>
55	0 through 3.<br><br>
Several examples of the SRAM instruction follow.<br>
In an example, sram [ write,Sxfer7, tempa, tempb,l], optimize_mem instructs write the context of the SRAM transfer register $xfer7 to the memory location at the address specified by tempa + tempb. Memory is optimized by placing this reference in either the         Read or Order queue.<br>
In an example, sram [read,$xferl,tempa,0xl5,4],priority, ctx_swap, defer [1] immed [final_queue,0] reads four longword memory locations at the address specified by temp + 0x15 into the contiguous SRAM transfer registers starting at Sxferl. Place the reference in the priority queue and swap out the context after the next instruction (immed)           is executed.<br>
In another example, sram [pop,$xfer2,--,--,4], optimize_mem, ctx_swap, defer [1 ] ld_field [protocol_group,0110,$$xfer0,»8]. Pop the pointer off of queue number 4 and . return it to the SRAM transfer register $xfer2. Optimize memory by placing this reference in either the Read or Ordered queue and swap out the context after the next instruction         (ld_field) is executed. The — notation for source_opl and source_op2 indicates that these operands do not apply to the pop command.<br>
In another example, sram [push,--, head_offset, sram_buff_descriptor_base,4]. Push the pointer whose values are specified by head_offset + sram_buff_descriptor_base onto queue 4. The - notation for $sram_xfer_reg indicates that this transfer register is not         relevant to the push command.<br>
In another example, sram [read_lock, $xfer6, queue_descriptor_addr,0,2], optimize_mem, ctxswap. Lock the SRAM memory at the location specified by  queue_descriptor_addr + 0 and read that memory location plus the next contiguous location into the contiguous SRAM transfer registers beginning with $xfer6. Optimize         memory by placing this reference in either the Read or Ordered queue and swap out the context.<br>
In an example, sram [write_unlock, Sxferl, queue_descriptor_addr, 0,2], ctx_swap,defer [1] alu [tempa,—,b,@sram_counter_base]. Unlock the SRAM memory at the location specified by queue_descriptor_addr + 0 and write the two contiguous SRAM        , transfer registers beginning with $xfero" into the SRAM memory location plus the next contiguous location. Swap out the context after the next instruction (ALU) is executed. This reference is placed into the default (Ordered) queue.<br><br><br>
In another example, sram [unlock, $xferl, queue_descriptor_addr, 0, 2], ctx_swap, defer [1] ALU [tempa,—,b,@sram_counter_base]. Unlock the SRAM memory at the location specified by queue_descriptor_addr + 0. Swap out the context after the next instruction (ALU) is executed.    ,<br>
In an example, sram [bit_wr, $xfer5, tempa, 0, set_bits]. Set the bits specified by the bit mask in the SRAM transfer register $xfer at the SRAM memory address specified by tempa +0.<br>
In another example, sram [bit_wr, $xfer5, tempa, 0, test_and_clear_bits]. Clear the bits specified by the bit mask in the SRAM transfer register $xfer5 at the SRAM memory        address specified by tempa + 0. Return the entire 32 bit data at that location prior to this change to the SRAM transfer register $xfer5 so that the bits can be tested.<br>
In another example sram [read, Sxferl, tempa, 0,1], ordered /reference 1 sram [read, $xfer2, tempb, 0, 1], optimize_mem /reference 2 sram [read, $xfer3, tempc, 0, l],ordered /reference 3. Issue three SRAM references and swap out the context once reference 3 is issued. Wake up the context once reference 3 is complete. Reference 1 is guaranteed to be completed when the context wakes since it is ordered with reference 3. Reference 2 is not ordered so it is not guaranteed to have completed.<br>
The computer instruction architecture also includes an instruction to issue a memory reference to Synchronous Dynamic Random Access Memory (SDRAM). A          format of the SDRAM instruction is:<br>
sdram[sdrarn_cmd, $$sdram_xfer_reg, source_opl, source_op2, ref_counfJ, optional_token<br>
where each of the fields are described below.<br>
  	The "sdram_cmd" field represents the operation to be performed on SDRAM, i.e.,<br><br>
a "read" commend reads from SDRAM to an SDRAM transfer register. A "write" command writes to SDRAM from an SDRAM transfer register. A "r_fifo_rd" command reads from receive FIFO to SDRAM and always requires an indirect-ref optional token, more fully discussed below. A "t_fifo_wr" command writes to transmit FIFO from SDRAM and also always requires an indirect_ref optional token.<br>
The "$$sdram_xfer_reg" field is a register that is the beginning of a contiguous set of registers which receive or supply the SDRAM data on a read or write operation,<br><br><br>
respectively. Two contiguous transfer registers are associated with each ref_count, since each ref_count refers to a quadword. SDRAM transfer register names always begin with a $$ symbol.<br>
The "source-opl" and "source_op2" fields are context-relative registers or 5-bit zero filled immediate data ranging from +31 to 0. These operands are added together to form the SDRAM address.<br>
The "ref_count" field represents a number of contiguous SDRAM quadwords to<br>
be referenced with this operation. If the ref_count is &gt; 1, then the SDRAM address is<br>
implicitly incremented for each subsequent reference. Valid ref_count values are 1<br>
      through 4. For ref_count values greater than 4, the indirect_ref optional token is used.<br>
The "optional_token" is an optional user selectable field containing one of the<br>
following parameters. A "sig_done" parameter indicates when the reference completes,<br>
signal the corresponding microengine/thread pair that is sourcing or sinking the memory<br>
data. It is not used with ctx_swap or defer [ 1 ] parameters.<br>
 	A "ctx_swap" parameter indicates when the memory reference is issued, swap out<br>
the current thread execution to let another one run. Not used with chain_ref and sig_done. A "chain_ref parameter indicates that the next SDRAM reference from this micro . engine/thread pair will be processed by the SDRAM unit immediately following the current reference. References from other micro engine/thread pairs will not be accepted          by the SDRAM unit until the chain is complete. It is not used with ctx_swap or defer parameters. Once a chain is started, branch instructions can not be executed by a microengine/thread pair until the chain is complete.<br>
The "defer [1]" parameter is used with the ctx_swap option and specifies that one instruction will be executed after this reference before the context is swapped. It is not         used with chain_ref or sig_done parameters.<br>
The "ordered" parameter places this SDRAM reference into an ordered queue. The ordered queue preserves the order of execution of references that use the ordered optional token. For example, if a thread issues two writes with the sig_done optional token on the second reference, both references would need to be ordered to ensure that the second reference finishes after the first. Not used with optirnize_mem or priority. If neither priority nor optimize_mern is specified, the default value becomes ordered.<br><br>
The "priority" parameter places this SDRAM reference into a priority queue. The priority queue gives higher priority to this memory reference over others. Not used with ordered or optimize-mem. If neither priority nor optimize_mem is specified, the default value becomes ordered.<br>
The "oprimize_mem" parameter optimizes memory bandwidth by automatically placing the SDRAM reference into either the Odd or Even queues. The Odd or Even queues are selected according to whether the address references data in the odd or even SDRAM bank. This may result in the references being executed in an order different from that in which they were issued. Not used with ordered or priority. If neither priority nor        optimize_mem is specified, the default value becomes ordered.<br>
The "indirect_ref" parameter indicates that overriding qualifiers or additional<br>
qualifiers are associated with this reference. These qualifiers are output by the ALU<br>
during the previous microword. The format of the qualifier depends on the SDRAM<br>
command. There are different formats for read/write, r_fifo_rd, and t_fifo_wr, as shown<br>
         in the following figures.	<br>
FIG. 9 is a block diagram showing a format for an Indirect_refer READ/WRITE Command, where:<br>
Bits	Field	Description<br>
             31	OV	If set, the UENGADDR field overrides<br>
	the default rnicroengine address implied by the<br>
SDRAM command,	which is the rnicroengine<br>
that issued the reference.<br>
30:28     UENG ADDR	Specifies the rnicroengine associated<br>
	with the memory reference. If bit [31 ]<br>
	=0, this field is a don"t care. Valid UENG ADDR<br>
values are 0 through 5.<br>
27	OV	If set,, the XADD field overrides the<br>
	default transfer register address implied by the<br>
	R_FIFO_RD instruction.<br>
	26	ABS	If set, enables absolute addressing<br>
for the rnicroengine transfer registers. This bit should<br>
always<br>
be set if bit [27] (OV) is set.<br>
       25:21     XADD	Absolute transfer register address.<br>
	Valid addresses are:<br>
0-7 Eight transfer registers for context 0.<br>
8-15 Eight transfer registers for context 1.<br>
	16-23 Eight transfer registers for context 2.<br>
	24-31 Eight transfer registers for context 3.<br>
	20	OV	if set, the REFCNT field overrides<br>
the ref_count specified by the SDRAM instruction.<br>
19:16     REF CNT	The number of quadwords to be<br><br>
transferred to/from SDRAM. Valid REF CNT values<br>
are 0 through 3, where the number of quadwords =<br>
REF CNT + 1. 15 OV Only applies to SDRAM<br>
	writes. If set, the BYTE MASK field overrides the<br>
	default byte mask of OxFF implied by the SDRAM<br>
instruction. BYTE MASK values other than OxFF<br>
require REF CNT = 1.<br>
14:7	BYTE MASK	BYTE MASK allows aligned byte write<br>
operations within an addressed SDRAM quadword.<br>
	The bytes that are written are specified by the byte<br>
mask. For each bit in the byte mask, a value of 1<br>
enable write to occur in the corresponding byte<br>
position and a value of 0 preserves the previously<br>
existing value. The least significant bit corresponds to<br>
	the right-most byte; the most significant bit<br>
corresponds to the left-most byte. A byte mask other<br>
than the default (OxFF) requires the SDRAM<br>
controller to perform a read-modify-write operation,<br>
which impacts performance.<br>
       6:3"	RES	Reserved. Returns 0 when read.<br>
        2	OV	If set, the CTX field overrides the<br>
default context implied by the SDRAM<br>
instruction,<br>
1:0	CTX	Specifies the context associated with<br>
	the memory reference. If bit [2] = 0, this field is a<br>
don"t care. Valid CTX values are 0 through 3.<br>
Referring to FIG. 10, a block diagram of a format for an Indirect_reference T_FIFO_WR command is shown, where:<br><br>
	Bits	Field	Description<br>
31	OV	If set, the UENGADDR field overrides<br>
the default microengine address implied by the<br>
	T_FIFO_WR instruction, which is the microengine<br>
	that issued the reference.<br>
30:28    UENG ADDR	Specifies the microengine associated<br>
with the memory reference. If bit [31] = 0, this field is<br>
	a don"t care. Valid UENG ADDR values are 0<br>
	through 5.<br>
27:21     RES	Reserved.	Returns 0 when read.<br>
20	OV	If set, the REF CNT field overrides<br>
the ref_count specified by the T_FIFO_WR<br>
	instruction.<br>
19:16     REF CNT	The number of quadwords to be<br>
transferred to be transferred to/from SDRAM. Valid<br>
REF CNT values are 0 through 15.<br>
15	RES	Reserved. Returns 0 when read.<br>
          14:12     BYTE ALN	Indicates byte alignment when<br>
addressing the transmit     FIFO.<br>
,11:4      XMTT FIFO	QWD ADDR Specifies the address of one<br>
of the 160 quadwords in the transmit FIFO. Lower<br>
numbered addresses are the first to be transmitted<br>
	onto the FIFO bus.<br>
	3	RES	Reserved. Returns 0 when read.<br><br>
2	OV	If set, the CTX field overrides the<br>
default context implied by the T_FIFO_WR<br>
instruction.<br>
   1:0	CTX	Specifies the context associated with<br>
	the memory ref. If bit [2] = 0, this field is a don"t<br>
care. Valid CTX values are 0 through 3.<br>
Referring to FIG. 11, a block diagram of a format for a read R_FIFO_Rd command is shown, where:<br><br>
Bits	Field	Description<br>
31	OV	If set, the UENG ADDR field overrides<br>
the default microengine address implied by the<br>
SDRAM instruction, which is the microengine that<br>
	issued the reference.	<br>
30:28     UENG ADDR	Specifies the microengine associated<br>
with the memory reference. If bit [31 ] = 0, this field is<br>
a don"t care. Valid UENG ADDR values are 0<br>
through 5.<br>
      27:21     RES	Reserved. Returns 0 when read.<br>
20	OV	If set, the REF CNT field overrides<br>
the ref_count specified by the T_FIFO_WR<br>
instruction.<br>
19:16     REF CNT	The number of quadwords to be<br>
	transferred to be transferred to/from SDRAM. Valid<br>
REF CNT values are 0 through 15.<br>
15:12    RES	Reserved. Returns 0 when read.<br>
11:4	RECV FIFO QWD ADDR Specifies the address of one of the<br>
160 quadwords in the receive FIFO. Lower numbered<br>
	addresses are the first to be received from the FIFO<br>
	bus.<br>
3	RES	Reserved. Returns 0 when read.<br>
2	OV	If set, the CTX field overrides the<br>
	default context implied by the SDRAM instruction.<br>
1:0	CTX	Specifies the context associated with<br>
the memory reference. If bit [2] = 0, this field is a   . don"t care. Valid CTX values are 0 through 3.<br>
The computer instruction set also includes an instruction to issue a memory reference to scratchpad memory.<br>
A format of the memory reference instruction to scratch memory is scratch[scratch_cmd, $sram_xfer_reg, source__opl, source_op2, ref_count_or_bit_op],    optiona-token. Each of the. fields are fully described below.<br>
The "Scratch_cmd" field represents an operation to be performed on scratchpad memory. A "bit_wr" operation sets or clears user specified bits in a scratchpad longword. A "read" operation reads from scratchpad to a SRAM transfer register. A "write"<br><br>
operation writes to scratchpad from an SRAM transfer register. A "incr" operation increments the addressed scratchpad location; ref count must equal 1.<br>
The "$sram_xfer_reg" field, if the read or write scratch_cmd parameters are used, represents a beginning of a contiguous set of registers which receive or supply the        scratchpad data on a read or write operation, respectively. If the incr scratch_cmd<br>
parameter is used, this must be "—". SRAM transfer register names always begin with a $ . symbol. If the "bit_wr scratch_cmd" parameter is used, this register contains a bit mask that chooses which bits should be set or cleared. For the test_and_set_bits and test_and_clear_bits options, this register also returns the original data as it existed before         setting or clearing bits.<br>
The "source_opl" and "source_op2" fields represent context-relative registers or 5-bit zero filled immediate data ranging from +31 to 0. These operands are added together to form the scratchpad address. Valid scratchpad addresses range from 0 to 1023.<br>
The "ref_count_or_bit_op" field, if the read, write, or incr scratch_cmd parameters<br>
       are used, specifies the number of contiguous scratchpad longwords to be referenced with<br>
this operation. If the count is &gt; 1, then the scratchpad address is implicitly incremented<br>
for each subsequent reference. Valid reference count values are 1 through 8 for read and<br>
write operations. If the incr scratch_cmd parameter is used, the reference count must be 1.<br>
If the bit_wr scratch_cmd parameter is used, one of the following parameters must also be<br>
used: "set_bits" are used to set or clear bits at an address using a specified bit mask.<br>
"clear_bits" are used to set or clear bits at an address using a specified bit mask.<br>
"test_and_set_bits" are also used to set or clear bits, but return the original data as it<br>
existed before the operation. "test_and_clear_bits" are also used to set or clear bits, but<br>
return the original data as it existed before the operation.<br>
 	The "optional_token" field is a user selectable optional field containing one of the<br>
parameters described below.<br>
The "sig_done" parameter indicates when the reference completes, signal<br>
thecorresponding microengine/thread pair that is sourcing or sinking the memory data.<br>
Not used with ctx_swap.<br>
 	The "ctx_swap" parameter indicates when the memory reference is issued, swap<br>
out the current thread execution to let another one run. Not used with sig_done.<br><br><br>
The "defer [1]" parameter is used with the sig__done or ctx_swap options. Specifies that one instruction will be executed after this reference before the context is swapped. Not used with sig_done.<br>
The "indirect_ref" parameter indicates that overriding qualifiers or additional     qualifiers are associated with this reference. These qualifiers are output by the ALU during the previous microword. The format of the qualifier depends on the scratchpad command.<br>
Referring to FIG. 12 a block diagram of a format for an indirect ref for a READ/WRITE Command is shown, where<br>
Bits	Field	Description<br>
31	OV	If set, the UENG ADDR field overrides<br>
the default microengine address implied by the<br>
SCRATCH instruction, which is the microengine that<br>
	issued the reference.<br>
30:28     UENGADDR	Specifies the microengine<br>
associated with the memory reference. If bit [31] = 0,<br>
this field is a don"t care. Valid UENG ADDR values<br>
are 0 through 5.<br>
27	OV	If set, the XADD field overrides the<br>
default transfer register address implied by the<br>
SCRATCH instruction.<br>
26	ABS	If set, enables absolute addressing<br>
for the microengine transfer registers. This bit should<br>
always be set if bit [27] (OV) is set<br>
25:21     XADD	absolute transfer register<br>
aadress. Valid addresses are: 0-7 Eight transfer<br>
registers for context 0.8-15 Eight transfer registers for<br>
context 1.16-23 Eight transfer registers for context<br>
2.24-31 Eight transfer registers for context 3.<br>
20	OV	If set, the REF CNT field<br>
overrides the ref_count specified by the SCRATCH<br>
instruction.<br>
19:16    REF CNT	The number of longwords to<br>
be transferred to/from       scratchpad memory. Valid<br>
REF CNT values are 0 through 7, where the number<br>
of longwords = REF CNT + 1.<br>
15	OV	If set, the BYTE MASK field<br>
overrides the default byte mask of OxF implied by the<br>
SCRATCH instruction.<br>
14:11     RES	Reserved. Returns 0 when read.<br>
10:7      BYTE MASK	BYTE MASK allows aligned<br>
byte write operations within an addressed scratchpad longword. The bytes that are written are specified by the byte mask. For each bit in the byte mask, a value of 1 enables a write to occur in the corresponding byte position and a value of 0 preserves the previously existing value. The least significant bit corresponds to the right-most byte; the most significant bit corresponds to the left-most byte. A byte mask other than the default (OxF) requires a<br><br>
read-modify-write operation, which impacts<br>
performance.<br>
6:3	RES	Reserved. Returns 0 when<br>
	read.<br>
2	OV	if Set, the CTX field<br>
overrides the defaullcontext implied by the<br>
SCRATCH instruction.<br>
1:0	CTX	Specifies the context<br>
associated with the memory reference. If bit [2] = 0,<br>
this field is a don"t care. Valid CTX values are 0<br>
through 3.<br>
Referring to FIG. 13, a block diagram of a format for an Indirect_ref BIT_WR Command is shown, where<br>
Bits	Field	 Description<br>
31	OV	if set, the UENG ADDR field<br>
overrides the default<br>
microengine address implied<br>
by the scratch instruction,<br>
which is the microengine<br>
that issued the reference.<br>
30:28     UENG ADDR	Specifies the microengine<br>
associated with the<br>
memory reference. If bit<br>
. [31] = 0, this field is<br>
a don"t care. Valid UENG<br>
ADDR values are 0<br>
through 5.<br>
27	OV	If set, the XADD field<br>
overrides the default<br>
transfer register address<br>
implied by the SCRATCH<br>
instruction.<br>
26	ABS	If set, enables absolute<br>
addressing for the<br>
microengine transfer<br>
registers. This bit should<br>
always be set if bit [27]<br>
(OV)is set.<br>
25:21     XADD	Absolute transfer register<br>
address. Valid addresses are:<br>
0-7 Eight transfer<br>
registers for context 0.<br>
8-15 Eight transfer<br>
registers for context 1.<br>
16-23 Eight transfer<br>
registers for context 2.<br>
24-31 Eight transfer<br>
registers for context 3.<br>
20	OV	If set, the TS and ST<br>
fields override the bit<br>
operation specified by the<br>
SCRATCH instruction.<br>
19:18     RES	Reserved. Returns 0 when<br>
read.<br><br>
17	TS	When set, specifies that<br>
the read data is<br>
returned before the write<br>
operation so that the<br>
data can be tested.<br>
16	ST	Specifies whether the<br>
operation is set (ST=1) or<br>
dear(ST=0).<br>
15:3	RES	Reserved. Returns 0 when<br>
read.<br>
2	OV	If set, the CTX field<br>
overrides the default<br>
context implied by the<br>
scratch instruction.<br>
1:0	CTX	Specifies the context<br>
associated with the memory reference. If bit [2] = 0, this field is a don"t care. Valid CTX values are 0 through 3.<br>
It is to be understood that while the invention has been described in conjunction with the detailed description thereof, the foregoing description is intended to illustrate and not limit the scope of the invention, which is defined by the scope of the appended claims. Other aspects, advantages, and modifications are within the scope of the following claims.<br>
WHAT IS CLAIMED	<br><br>
WE CLAIM:<br>
1.       A hardware based multithreaded system comprising:<br>
a plurality of microengines, each(22a22b) of the microengines comprising:<br>
a control store; (70)<br>
controller logic; (72)	<br>
context event switching logic;(74) and	   <br>
an execution box data path(76) including an arithmetic logic unit (ALU)(76a) and<br>
a general purpose  register  set, (76b)  one  of the  instructions  adapted  for<br>
causing the ALU to issue a memory reference to an address in a memory<br>
shared among threads executing in the microengines while a context of a<br>
thread is inactive.<br>
Dated this 22nd day of February, 2002.<br>
[RITUSHKA NEGI] OF REMFRY &amp; SAGAR ATTORNEY FOR THE APPLICANTS]</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyMzAtbXVtLWNvcnJlc3BvbmRlbmNlKGlwbyktKDctMy0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-00230-mum-correspondence(ipo)-(7-3-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1jYW5jZWxsZWQgcGFnZXMoMjUtNy0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-cancelled pages(25-7-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1jbGFpbXMoZ3JhbnRlZCktKDI1LTctMjAwNSkuZG9j" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-claims(granted)-(25-7-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1jbGFpbXMoZ3JhbnRlZCktKDI1LTctMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-claims(granted)-(25-7-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1jb3JyZXNwb25kZW5jZSgyNS03LTIwMDYpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-correspondence(25-7-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1jb3JyZXNwb25kZW5jZShpcG8pLSgxOS0yLTIwMDcpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-correspondence(ipo)-(19-2-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1kcmF3aW5nKDI1LTctMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-drawing(25-7-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1mb3JtIDEoMjItMi0yMDAyKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-form 1(22-2-2002).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1mb3JtIDE5KDIwLTgtMjAwNCkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-form 19(20-8-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1mb3JtIDFhKDI1LTctMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-form 1a(25-7-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1mb3JtIDIoZ3JhbnRlZCktKDI1LTctMjAwNSkuZG9j" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-form 2(granted)-(25-7-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1mb3JtIDIoZ3JhbnRlZCktKDI1LTctMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-form 2(granted)-(25-7-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1mb3JtIDMoMjItMi0yMDAyKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-form 3(22-2-2002).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1mb3JtIDMoMjctOS0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-form 3(27-9-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1mb3JtIDUoMi0xLTIwMDYpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-form 5(2-1-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1mb3JtLXBjdC1pcGVhLTQwOSgyNS03LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-form-pct-ipea-409(25-7-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1wZXRpdGlvbiB1bmRlciBydWxlIDEzNygyNy05LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-petition under rule 137(27-9-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1wZXRpdGlvbiB1bmRlciBydWxlIDEzOCgyNy05LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-petition under rule 138(27-9-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjMwLW11bS1wb3dlciBvZiBhdXRob3JpdHkoMy04LTIwMDEpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-230-mum-power of authority(3-8-2001).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="208414-streptomyces-avermitilis-gene-directing-the-ratio-of-b2-b1-avermectins.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="208416-toothbrush.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>208415</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2002/00230/MUM</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>35/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>31-Aug-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>26-Jul-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>22-Feb-2002</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTEL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2200 , MISSION BOULEVARD, SANTA CLARA, CALIFORNIA 95052</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>GILBERT WOLRICH</td>
											<td>4 CIDER MILL ROAD, FRAMINGHAM, MA 01701</td>
										</tr>
										<tr>
											<td>2</td>
											<td>WILLIAM R. WHEELER</td>
											<td>145 SCHOOL STREET, WEBSTER MA 01570, USA.</td>
										</tr>
										<tr>
											<td>3</td>
											<td>DEBRA BERNSTEIN</td>
											<td>38 HETEN STREET WALTHAM MA 02452, U.S.A.</td>
										</tr>
										<tr>
											<td>4</td>
											<td>DONALD F. HOOPER</td>
											<td>19 MAIN CIRCLE, SHREWSBURY, MA 01545, U.S.A.</td>
										</tr>
										<tr>
											<td>5</td>
											<td>MATTHEW J. ADILETTA</td>
											<td>20 MONTICELLO DRIVE, WORCESTER, MA 01603, USA.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F7/38</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US00/24095</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2000-09-01</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/151,961</td>
									<td>1999-09-01</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/208415-a-hardware-based-multithreaded-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:07:40 GMT -->
</html>
