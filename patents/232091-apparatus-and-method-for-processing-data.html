<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/232091-apparatus-and-method-for-processing-data by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:58:07 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 232091:&quot;APPARATUS AND METHOD FOR PROCESSING DATA&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;APPARATUS AND METHOD FOR PROCESSING DATA&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A digital signal processing system comprising a central processing unit core 2, a memory 8 and a coprocessor 4 operates using coprocessor memory access instructions (e.g. LDC, STC). The addressing mode information within these coprocessor memory access instructions (P, U, W, Offset) not only controls the addressing mode used by the central processing unit core 2 but is also used by the coprocessor 4 to determine the number of data words in the transfer being specified such that the coprocessor 4 can terminate the transfer at the appropriate time. Knowledge in advance of the number of words in a transfer is also advantageous in some bus systems, such as those that can be used with synchronous DRAM. The Offset field within the instruction may be used to specify changes to be made in the value provided by the central processing unit core 2 upon execution of a particular instruction and also to specify the number of words in the transfer. This arrangement is well suited to working through a regular array of data such as in digital signal processing operations. If the Offset field is not being used, then the number of words to be transferred may default to 1.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>The present invention relates to a apparatus and method for processing data. More particularly, this invention relates to data processing systems incorporating a central processing unit, a memory and a coprocessor in which data words are transferred between the memory and the coprocessor under control of instructions executed jointly by the central processing unit and the coprocessor.<br>
It is known to provide processing systems having a central processing unit, a memory and a coprocessor, such as the coprocessor equipped ARM microprocessors produced by Advanced RISC Machines Limited of Cambridge England, Within such known systems the central processing unit executes coprocessor memory access instructions (such as a coprocessor load or a coprocessor store) that serve to generate appropriate address data for supply to the memory and to prepare the coprocessor to exchange data words (units of data transfer) directly with the memory. Once the start address information has been provided by the central processing unit to the memory, then it is most efficient if the data words are passed directly to the coprocessor without having to be routed through or stored in the central processing unit. With such direct transfer to the coprocessor it is desirable that the coprocessor control the end of the data transfer so that different coprocessors with different numbers of words in each transfer can be attached to the central processing unit without having to modify the e central processing unit, hi order to control the end of the data transfer, the coprocessor must be able to determine how many data words are intended to be transferred in response to the instruction executing on the central processing unit.<br>
One possibility would be to make each instruction executing on the central processing unit transfer only a single data word. This would be highly inefficient, both in terms of the use of data memory band width and also code side and instruction memory band Width, and it is desirable to use burst mode transfers in which a start address is provided to the memory which then returns data words from a sequence of adjacent memory locations. With burst mode transfers the efficiency gains are accompanied by the difficulty that it is desirable that the coprocessor then determines how many data words are intended to be transferred so that it can exercise the necessary control to stop the transfer.<br>
It is known (e.g. within the ARM floating point accelerator unit) to allocate a bit field within an instruction executing upon the central processing unit which is passed to the coprocessor and specifies to the coprocessor the number of data words to be transferred. However, the bit space available within the instructions executing on the central processing unit is limited and if bits within the instructions are dedicated to passing the number of data words to the coprocessor, then this restricts the bit space available for other fields within the instruction that may be used to specify other parameters relating to the data transfer, e.g. changes in the address pointer within the central processing unit to be made following the execution of the instruction.<br>
Accordingly, there is provided an apparatus for processing data comprising: a central processing unit for executing central processing unit instructions to perform data processing operations, said central processing unit instructions including coprocessor memory access instructions;<br>
a memory coupled to said central processing unit for holding data words; and a coprocessor coupled to said central processing unit and said memory, data words within said memory to be processed by said coprocessor being addressed using one of a plurality of addressing modes under control of said coprocessor memory access instructions executed by said central processing unit;<br>
wherein at least one coprocessor memory access instruction includes addressing mode information controlling which of said plurality of addressing modes is used by said central processing unit to access said memory, characterized in that said coprocessor uses at least a portion of said addressing mode information to control how many data words are transferred between said memory and said coprocessor in response to said at least one coprocessor memory access instruction.<br>
Accordingly, there is also provided a method of processing data in the apparatus, said method comprising the steps of:<br>
executing central processing unit instructions with a central processing unit to perform data processing operations, said central processing unit instructions including coprocessor memory access instructions;<br>
holding data words in a memory coupled to said central processing unit; and<br>
addressing data words within said memory to be processed by a coprocessor coupled to said central processing unit and said memory using one of a plurality of addressing modes under control of coprocessor memory access instructions executed by said central processing unit;<br>
wherein at least one of said coprocessor memory access instructions has addressing mode information controlling which of said plurality of addressing modes is used by said central processing unit to access said memory; characterized in that<br>
said coprocessor using at least a portion of said addressing mode information to control how many data words are transferred between said memory and said coprocessor in response to said at least one of said coprocessor memory access instructions.<br>
The invention recognizes that the bit fields (that may include register numbers and immediate constants) that are used by the central processing unit to control which of a plurality of addressing modes is used may also be used to specify (possibly in combination with other factors, such as other fields in the instruction or values written in control registers) to the coprocessor the number of data words to be transferred. For example, it has been found that in a large number of cases the bit field information that is used by the central processing unit to control the address used foi<br>
the transfer and/or the change to an address pointer is (or may be) related to the number of data words to be transferred to the coprocessor and accordingly this bit field can be read by the coprocessor as well as by the central processing unit. The overlapping use of the same bit field within the coprocessor memory access instructions frees bit space within those coprocessor memory access instructions for other uses. Furthermore, it has been found that in a large majority of cases the number of data words to be transferred fall into a small number of categories and so the full flexibility of providing a dedicated bit field for the number of data words to be transferred to the coprocessor is outweighed by the improvements in code density and efficiency that are gained by employing the present invention.<br>
Whilst the central processing unit can control the addressing in a number of different ways, in preferred embodiments of the invention said at least one coprocessor memory access instruction references a register within said central processing unit holding an address value and said address mode information includes an offset field, wherein a start address within said memory to be accessed is determined from at least one of said address value and said offset value upon execution of said at least one coprocessor memory access instruction.<br>
Such use of an address pointer held within a register of the central processing unit provides a great deal of flexibility and in combination with the offset field within the instruction simplifies the coding of applications.<br>
When it is desirable to work through an array of data with the coprocessor preferred embodiments of the invention are such that said change made to said address value yields a final address value that is optionally stored back into said register.<br>
It has been found that it is highly convenient that at least a portion of said offset field is used by said coprocessor to control how many data words are transferred between said memory and said coprocessor.<br>
Such an'arrangement caters for a high proportion of the real life situations in which a coprocessor is used for performing data processing operations upon data held within a memory.<br>
It is also advantageous that the addressing mode information should include one or more flags that control which of said plurality of addressing modes used and also control whether or not said offset field is to be used by said coprocessor in<br>
determining how many data words are transferred between said memory and said coprocessor.<br>
The selective use of the offset field in dependence upon other flag bits within the addressing mode information increases the number of options available to the way in which the coprocessor may control the number of data words transferred and so making it possible to match the requirements of a higher proportion of real life situations whilst requiring no further bit space within the coprocessor memory access instructions.<br>
It has been found to encompass a high proportion of desired types of operation that preferred embodiments should be ones in which when said offset field is not used by said coprocessor in determining how many data words are transferred between said memory and said coprocessor, a fixed number of words are transferred between said memory and said coprocessor.<br>
A complementary set of coprocessor memory access instruction modes of controlling the coprocessor are such that said register stores an address value of Rn, a data word is WL bytes in length, and said offset value is M and said one or more flags comprise three or more value bits that select said at least one coprocessor memory access instruction to operate in accordance with one of:<br><br>
(Table Removed) <br>
The coprocessor memory access instructions also advantageously include flags that comprise<br>
(i) a flag bit P that specifies whether said start address value is said address<br>
value originally stored in said register or an address value changed as specified<br>
by said offset field;<br>
(ii) a flag bit U that specifies whether said change should be addition or<br>
subtraction of a value specified in said offset field from said address value<br>
originally stored in said register; and<br>
(iii) a flag bit W that specifies whether or not said final value in said address<br>
register should be stored back into said register.<br>
With such a set of flags the coprocessor may be configured to provide rapid and simple control of its operation by providing logic such that said coprocessor evaluates P EOR U in order to determine whether one data word or M data words should be transferred.<br>
An additional possibility is to make the number of words transferred 1 when the base register is the ARM program counter register (PC or R15). This would modify the logic for determining a single word transfer to P EOR (U or (base register is PC)).<br>
Whilst the above discussed features of controlling the interaction of a coprocessor with a central processing unit and a memory may be employed in many different fields (e.g. floating point coprocessors) the comparative regularity of data access is such that the invention is particularly suited for embodiments in which said central processing unit and said coprocessor perform digital signal processing operations and said data words transferred between said memory and said coprocessor include coefficient values from within an array of coefficient values stored in said memory.<br>
Viewed from another aspect the invention provides a method of processing data, said method comprising the steps of:<br>
executing central processing unit instructions with a central processing unit to perform data processing operations, said central processing unit instructions including coprocessor memory access instructions;<br>
holding data words in a memory coupled to said central processing unit;<br>
addressing data words within said memory to be processed by a coprocessor coupled to said central processing unit and said memory using one of a plurality of addressing modes under control of coprocessor memory access instructions executed by said central processing unit;<br>
wherein at least one of said coprocessor memory access instructions includes addressing mode information controlling which of said plurality of addressing modes is used by said central processing unit to access said memory, said coprocessor using at least a portion of said addressing mode information to control how many data words are transferred between said memory and said coprocessor in response to said at least one of said coprocessor memory access instructions.<br>
An embodiment of the invention will now be described, by way of example only, with reference to the accompanying drawings in which:<br>
Figure 1 illustrates the high level configuration of a digital signal processing apparatus;<br>
Figure 2 illustrates the input buffer and register configuration of a coprocessor;<br>
Figure 3 illustrates the datapath through the coprocessor;<br>
Figure 4 illustrates a multiplexing circuit for read high or low order bits from a register;<br>
Figure 5 is a block diagram illustrating re^is,ter,xemapping,lQgic.,iiSfid,by-the coprocessor in preferred embodiments;<br>
Figure 6 illustrates in more detail the register remapping logic shown in Figure 5;<br>
Figure 7 is a table illustrating a Block Filter Algorithm;<br>
Figure 8 schematically illustrates a system comprising a central processing unit, a memory and a coprocessor for executing coprocessor memory access instructions; and<br>
Figure 9 is a flow diagram corresponding to the operation of the system of Figure 8.<br>
In the following description Section One describes a system comprising a central processing unit, a memory and a coprocessor that is designed to provide high speed digital signal processing capabilities. Section Two describes a modification to the system of Section One in which the coprocessor memory access instructions have<br>
been modified to enhance the ease of control by the coprocessor of the number of data words transferred. SECTION ONE<br>
The system described below is concerned with digital signal processing (DSP). DSP can take many forms, but may typically be considered to be processing that requires the high speed (real time) processing of large volumes of data. This data typically represents some analogue physical signal. A good example of DSP is that used in digital mobile telephones in which radio signals are received and transmitted that require decoding and encoding (typically using convolution, transform and correlation operations) to and from an analogue sound signal. Another example is disk driver controllers in which the signals recovered from the disk heads are processed to yield head tracking control.<br>
In the context of the above, there follows a description of a digital signal processing system based upon a microprocessor core (in this case an ARM core from the range of microprocessors designed by Advanced RISC Machines Limited of Cambridge, United Kingdom) cooperating with a coprocessor. The interface of the microprocessor' and the coprocessor and the coprocessor architecture itself are specifically configured to provide DSP functionality. The microprocessor core will be referred to as the ARM and the coprocessor as the Piccolo. The ARM and the Piccolo will typically be fabricated as a single integrated circuit that will often include other elements (e.g. on-chip DRAM, ROM, D to A and A to D converters etc.) as part of an ASIC.<br>
Piccolo is an ARM coprocessor, it therefore executes part of the ARM instruction set. The ARM coprocessor instructions allow ARM to transfer data between Piccolo and memory (using Load Coprocessor, LDC and Store Coprocessor, STC, instructions), and to transfer ARM registers to and from Piccolo (using move to coprocessor, MCR, and move from coprocessor, MRC, instructions). One way of viewing the synergistic interaction of the ARM and Piccolo is that ARM acts as a powerful address generator for Piccolo data, with Piccolo being left free to perform DSP operations requiring the real time handling of large volumes of data to produce corresponding real time results.<br>
Figure 1 illustrates the ARM 2 and Piccolo 4 with the ARM 2 issuing control signals to the Piccolo 4 to control the transfer of data words to and from Piccolo 4. An instruction cache 6 stores the Piccolo program instruction words that are required by Piccolo 4. A single DRAM memory 8 (alternatively this could be SRAM or memory of another form) stores all the data and instruction words required by both the ARM 2 and Piccolo 4. The ARM 2 is responsible for addressing the memory 8 and controlling all data transfers. The arrangement with only a single memory 8 and one set of data and address buses is less complex and expensive than the typical DSP approach that requires multiple memories and buses with high bus bandwidths.<br>
Piccolo executes a second instruction stream (the digital signal processing program instruction words) from the instruction cache 6, which controls the Piccolo datapath. These instructions include digital signal processing type operations, for example Multiply-Accumulate, and control flow instructions, for example zero overhead loop instructions. These instructions operate on data which is held in Piccolo registers 10 (see Figure 2). This data was earlier transferred from memory 8 by the ARM 2. The instructions are streamed from the instruction cache 6; the instruction cache 6 drives the data bus as a full bus master. A small Piccolo instruction cache 6 will be a 4 line, 16 words per line direct mapped cache (64 instructions). In some implementations, it may be worthwhile to make the instruction cache bigger or more associative.<br>
Thus two tasks are run independently - ARM loading data, and Piccolo processing it. This allows sustained single cycle data processing on 16 bit data. Piccolo has a data input mechanism (illustrated in Figure 2) that allows the ARM to<br>
prefetch sequential data, loading the data before it is required by Piccolo. Piccolo can access the loaded data in any order, automatically refilling its register as the old data is used for the last time (most instructions have one bit per source operand to indicate that the source register should be refilled). This input mechanism is termed the reorder buffer and comprises an input buffer 12. Every value loaded into Piccolo (via an LDC or MCR see below) carries with it a tag Rn specifying which register the value is destined for. The tag Rn is stored alongside the data word in the input buffer. When a register is accessed via a register selecting circuit 14 and the instruction specifies the data register is to be refilled, the register is marked as empty by asserting a signal E. The register is then automatically refilled by a refill control circuit 16 using the oldest loaded value destined for that register within the input buffer 12. The reorder buffer holds 8 tagged values. The input buffer 12 has a form similar to a FIFO except that data words can be extracted from the centre of the queue after which later stored words will be passed along to fill the space. Accordingly, the data words furthest from the input are the oldest and this can be used to decide which data word should be used to refill a register when the input buffer 12 holds two data words with the correct tag Rn.<br>
Piccolo outputs data by storing it in an output buffer 18 (FIFO) as shown in Figure 3. Data is written to the FIFO sequentially, and read out to memory 8 in the same order by ARM. The output buffer 18 holds 8 32 bit values.<br>
Piccolo connects to ARM via the coprocessor interface (CP Control signals of Figure 1). On execution of an ARM coprocessor instruction Piccolo can either execute the instruction, cause the ARM to wait until Piccolo is ready before executing the instruction or refuse to execute the instruction. In the last case ARM will take an undefined instruction exception.<br>
The most common coprocessor instructions that Piccolo will execute are LDC and STC, which respectively load and store data words to and from the memory 8 via the data bus, with ARM generating all addresses. It is these instructions which load data into the reorder buffer 12, and store data from the output buffer 18. Piccolo will stall the ARM on an LDC if there is not enough room in the input reorder buffer to load in the data and on an STC if there is insufficient data in the output buffer to store, i.e. the data the ARM is expecting is not in the output buffer 18. Piccolo also<br>
executes ARM/Coprocessor register transfers to allow ARM to access Piccolo's special registers.<br>
Piccolo fetches its own instructions from memory to control the Piccolo datapath illustrated in Figure 3 and to transfer data from the reorder buffer to registers and from registers to the output buffer 18. The arithmetic logic unit of the Piccolo that executes these instructions has a multiplier/adder circuit 20 and an accumulate/decumulate circuit 22 that cooperate to perform multiplies, adds, subtracts, multiple-accumulates, logical operations, shifts and rotates. There is also provided in the datapath a scale/saturate circuit 24.<br>
The Piccolo instructions are initially loaded from memory into the instruction cache 6, where Piccolo can access them without needing access back to the main memory.<br>
Piccolo cannot recover from memory aborts. Therefore if Piccolo is used in a virtual memory system, all Piccolo data must be in physical memory throughout the Piccolo task. This is not a significant limitation given the real time nature of Piccolo tasks, e.g. real time DSP.<br>
Figure 3 shows the overall datapath functionality of Piccolo. The register bank 10 uses 3 read ports and 2 write ports. One write port (the L port) is used to refill registers from the reorder buffer. The output buffer 18 is updated directly from the ALU result bus 26, output from the output buffer 18 is under ARM program control. The ARM coprocessor interface performs LDC (Load Coprocessor) instructions into the reorder buffer, and STC (Store Coprocessor) instructions from the output buffer 18, as well as MCR and MRC (Move ARM register to/from CP register) in the register bank 10 via the reorder buffer 12 and the output buffer 18.<br>
The remaining register ports are used for the ALU. Two read ports (A and B) drive the inputs to the multiplier/adder circuit 20, the C read port is used to drive the accumulator/decumulator circuit 22 input. The remaining write port W is used to return results to the register bank 10.<br>
The multiplier 20 performs a 16 x 16 signed multiply, with the accumulator/decumulator circuit 22 performing an optional 40 bit accumulate. The sealer unit 24 can provide a 0 to 31 immediate arithmetic or logical shift right, followed by an optional saturate. The multiplier 20 can also alternatively perform<br>
executes ARM/Coprocessor register transfers to allow ARM to access Piccolo's special registers.<br>
Piccolo fetches its own instructions from memory to control the Piccolo datapath illustrated in Figure 3 and to transfer data from the reorder buffer to registers and from registers to the output buffer 18. The arithmetic logic unit of the Piccolo that executes these instructions has a multiplier/adder circuit 20 and an accumulate/decumulate circuit 22 that cooperate to perform multiplies, adds, subtracts, multiple-accumulates, logical operations, shifts and rotates. There is also provided in the datapath a scale/saturate circuit 24.<br>
The Piccolo instructions are initially loaded from memory into the instruction cache 6, where Piccolo can access them without needing access back to the main memory.<br>
Piccolo cannot recover from memory aborts. Therefore if Piccolo is used in a virtual memory system, all Piccolo data must be in physical memory throughout the Piccolo task. This is not a significant limitation given the real time nature of Piccolo tasks, e.g. real time DSP.<br>
Figure 3 shows the overall datapath functionality of Piccolo. The register bank 10 uses 3 read ports and 2 write ports. One write port (the L port) is used to refill registers from the reorder buffer. The output buffer 18 is updated directly from the ALU result bus 26, output from the output buffer 18 is under ARM program control. The ARM coprocessor interface performs LDC (Load Coprocessor) instructions into the reorder buffer, and STC (Store Coprocessor) instructions from the output buffer 18, as well as MCR and MRC (Move ARM register to/from CP register) in the register bank 10 via the reorder buffer 12 and the output buffer 18.<br>
The remaining register ports are used for the ALU. Two read ports (A and B) drive the inputs to the multiplier/adder circuit 20, the C read port is used to drive the accumulator/decumulator circuit 22 input. The remaining write port W is used to return results to the register bank 10.<br>
The multiplier 20 performs a 16 x 16 signed multiply, with the accumulator/decumulator circuit 22 performing an optional 40 bit accumulate. The sealer unit 24 can provide a 0 to 31 immediate arithmetic or logical shift right, followed by an optional saturate. The multiplier 20 can also alternatively perform<br>
either a shift or a logical operation every cycle.<br>
Piccolo has 16 general purpose registers named DO-D15 or AO-A3, XO-X3, YO-Y3, ZO-Z3. The first four registers (AO-A3) are intended as accumulators and are 40 bits wide, the extra 16 bits providing a guard against overflow during many successive calculations. The remaining registers are 32 bits wide.<br>
Each of Piccolo's registers can be treated as containing two independent 16 bit values. Bits 0 to 15 contain the low half, bits 16 to 31 contain the high half. Instructions can specify a particular 16 bit half of each register as a source operand, or they may specify the entire 32 bit register.<br>
Piccolo also provides for saturated arithmetic. Variants of the multiply, add and subtract instructions provide a saturated result if the result is greater than the size of the destination register. Where the destination register is a 40 bit accumulator, the value is saturated to 32 bits (i.e. there is no way to saturate a 40 bit value). There is no overflow detection on 40 bit registers. This is a reasonable restriction since it would take at least 65536 multiply accumulate instructions to cause an overflow.<br>
Each Piccolo register (or half a Piccolo register) is either marked as "empty" (E flags, see Figure 2) or contains a value. Initially, all registers are marked as empty. On each cycle Piccolo attempts with the refill control circuit 16 to fill one of the empty registers by a value from the input reorder buffer. Alternatively if the register is written with a value from the ALU it is no longer marked as "empty". If a register is written from the ALU and at the same time there is a value waiting to be placed in the register from the reorder buffer, then the two register writes may be done in either order at the hardware implementor's option and a programmer cannot rely upon the final contents of the register in this case. Piccolo's execution unit will stall if a read is made to an empty register.<br>
The Input Reorder Buffer (ROB) sits between the coprocessor interface and Piccolo's register bank. Data is loaded into the ROB with ARM coprocessor transfers. The ROB contains a number of 32-bit values, each with a tag indicating the Piccolo register that the value is destined for. The tag also indicates whether the data should be transferred to a whole 32-bit register or just to the bottom 16-bits of a 32-bit register. If the data is destined for a whole register, the bottom 16 bits of the entry will be transferred to the bottom half of the target register and the top 16 bits will be<br>
(Table Removed)<br>
To summarise, the two halves of a register may be refilled independently from the ROB. The data in the ROB is either marked as destined for a whole register or as two 1 6-bit values destined for the bottom half of a register.<br>
Data is loaded into the ROB using ARM coprocessor instructions. How the data<br>
is marked in the ROB depends on which ARM coprocessor instruction was used to perform the transfer. The following ARM instructions are available for filling the ROB with data:<br>
LDP{<cond>}	<dest>, [Rn]{!&gt;, #<size><br>
LDP{<cond>}W	<dest>, <wrap>, [Rn]{!}, #<size><br>
LDP{<cond>}16U	<bank>,<br>
MPR{<cond>}	<dest>, Rn<br>
MPRW{<cond>}	<dest>, Rn<br>
The following ARM instruction is provided for configuring the ROB:<br>
LDPA <bank list><br>
The first three are assembled as LDCs, MPR and MRP as MCRs, LDPA is assembled as a CDP instruction.<br>
In the above <dest> stands for a Piccolo register (AO-Z3), Rn for an ARM register, <size> for a constant number of bytes which must be a non zero multiple of 4, <wrap> for a constant (1,2,4,8) <cond> for conditional execution specifying bits and <bank> for one of the groups of registers A,X,Y and Z illustrated in Figure 5. Fields<br>
surrounded by {} are optional. For a transfer to be able to fit into the Reorder Buffer, <size> must be at most 32. In many circumstances <size> will be smaller than this limit to avoid deadlock. The  field indicates whether the data being loaded should be treated as 16-bit data, and endianess specific action taken (see below), or as 32-bit data.<br>
Notel: In the following text, when referring to LDP or LDPW this refers to both the 16-bit and 32-bit variants of the instructions.<br>
Note2: A 'word' is a 32-bit chunk from memory, which may consist of two 16-bit data items or one 32-bit data item.<br>
The LDP instruction transfers a number of data items, marking them as destined for a full register. The instruction will load <size>/4 words from address Rn in memory, inserting them into the ROB. The number of words that can be transferred is limited by the following:<br>
-The quantity <size> must be a non-zero multiple of 4 bytes;<br>
-<size> must be less than or equal to the size of the ROB for a particular implementation (8 words in the first version, and guaranteed to be no less than this in future versions).<br>
The first data item transferred will be tagged as destined for <dest>, the second as destined for <dest>+l and so on (with wrapping from Z3 to AO). If the ! is specified then the register Rn is incremented by <size> afterwards.<br>
If the LDP 16 variant is used, endian specific action is performed on the two 16-bit halfwords forming the 32-bit data items as they are returned from the memory system. See below for more details on Big Endian and Little Endian Support.<br>
The LDPW instruction transfers a number of data items to a set of registers. The first data item transferred is tagged as destined for <dest>, the next for <dest>+l, etc. When <wrap> transfers have occurred, the next item transferred is tagged as destined for <dest>, and so on. The <wrap> quantity is specified in halfword quantities.<br>
For LDPW, the following restrictions apply: -The quantity <size> must be a non-zero multiple of 4 bytes;<br>
-<size> must be less than or equal to the size of the ROB for a particular implementation (8 words in the first version, and guaranteed to be no less than this in future versions);<br>
-<dest> may be one of {AO, XO, YO, ZO};<br>
-<wrap> may be one of {2,4,8} halfwords for LDP32W and one of {1,2,4,8} halfwords for LDP16W;<br>
-The quantity <size> must be greater than 2*<wrap>, otherwise no wrapping occurs and the LDP instruction shall be used instead.<br>
For example, the instruction,<br>
LDP32W	XO, 2, [RO]!, #8<br>
will load two words into the ROB, marking them as destined for the full register XO. RO will be incremented by 8.The instruction,<br>
LDP32W	XO, 4, [RO], #16<br>
will load four words into the ROB, marking them as destined for XO, XI, XO, XI (in that order). RO will not be affected.<br>
For LDP16W, <wrap> may be specified as 1,2,4 or 8. The wrap of 1 will cause all data to be tagged as destined for the bottom half of the destination register <dest>.l. This is the 'Half Register' case.<br>
For example the instruction,<br>
LDP16W	XO, 1, [RO]!, #8<br>
will load two words into the ROB, marking them as 16-bit data destined for XO.l. RO will be incremented by 8. The instruction,<br>
LDP16W	XO, 4, [RO], #16<br>
will behave in a similar fashion to the LDP32W examples, except for the fact that endian specific action may be performed on the data as it is returned from memory.<br>
All unused encodings of the LDP instruction may be reserved for future expansion.<br>
The LDP16U instruction is provided to support the efficient transfer of non-word aligned 16-bit data. LDP16U support is provided for registers D4 to D15 (the X, Y and Z banks). The LDP16U instruction will transfer one 32-bit word of data (containing two 16-bit data items) from memory into Piccolo. Piccolo will discard the bottom 16 bits of this data and store the top 16 bits in a holding register. There is a holding register for the X, Y and Z banks. Once the holding register of a bank is primed, the behaviour of LDP{W} instructions is modified if the data is destined for a register in that bank. The data loaded into the ROB is formed by the concatenation of the holding register and the bottom 16 bits of data being transferred by the LDP instruction. The upper 16 bits of data being transferred is put into the holding register:<br>
entry 
This mode of operation is persistent until it is turned off by a LDPA instruction. The holding register does not record the destination register tag or size. These characteristics are obtained from the instruction that provides the next value of data.l.<br>
Endian specific behaviour may always occur on the data returned by the memory system. There is no non 16-bit equivalent to LDP16U since it is assumed that<br>
all 32-bit data items will be word aligned in memory.<br>
The LDPA instruction is used to switch off the unaligned mode of operation initiated by a LDP16U instruction. The unaligned mode may be turned off independently on banks X, Y, Z. For example the instruction,<br>
LDPA	{X, Y}<br>
will turn off the unaligned mode on banks X and Y. Data in the holding registers of these banks will be discarded.<br>
Executing an LDPA on a bank which is not in unaligned mode is allowed, and will leave that bank in aligned mode.<br>
The MPR instruction places the contents of ARM register Rn into the ROB, destined for Piccolo register <dest>. The destination register <dest> may be any full register in the range AO-Z3. For example the instruction,<br>
MPR   XO, R3<br>
will transfer the contents of R3 into the ROB, marking the data as destined for the full register XO.<br>
No endianess specific behaviour occurs to the data as it is transferred from ARM to Piccolo since the ARM is internally little endian.<br>
The MPRW instruction places the contents of ARM register Rn into the ROB, marking it as two 16-bit data items destined for the 16-bit Piccolo register <dest>.l. The restrictions on <dest> are the same as those for the LDPW instructions (i.e. AO,XO,YO,ZO). For example the instruction,<br>
MPRW	XO, R3<br>
will transfer the contents of R3 into the ROB, marking the data as 2 16-bit quantities destined for XO.l. It should be noted that as for the LDP16W case with a wrap of 1, only the bottom half of a 32-bit register can be targeted.<br>
As with MPR no endianess specific operations are applied to the data. LDP is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
where PICCOLO 1 is Piccolo's first coprocessor number (currently 8). The N bit selects between LDP32 (1) and LDP16 (0). P, U and W are bits that are described further later in the description and also in published datasheets relating to the ARM central processing unit.<br>
LDPW is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
where DEST is 0-3 for destination register AO,XO,YO,ZO and WRAP is 0-3 for wrap values 1,2,4,8. PICCOLO2 is Piccolo's second coprocessor number (currently 9). The N bit selects between LDP32 (1) and LDP 16 (0).<br>
LDP16U is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed) <br>
where DEST is 1-3 for the destination bank X, Y, Z.<br>
LDPA is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
where BANK[3:0] is used to turn off the unaligned mode on a per bank basis. If BANK[1] is set, unaligned mode on bank X is turned off. BANK[2] and BANK[3] turn off unaligned mode on banks Y and Z if set, respectively. BANK[0] corresponds to the bank A, but this does not support unaligned mode. N.B. This is a CDP operation.<br>
MPR is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
MPRW is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
where DEST is 1-3 for the destination register XO,YO,ZO.<br>
The output FIFO can hold up to eight 32-bit values. These are transferred from Piccolo by using one of the following (ARM) opcodes:<br>
STP{<cond>}<br>
MRP	Rn<br>
The first saves <size>/4 words from the output FIFO to the address given by the ARM register Rn, indexing Rn if the ! is present. To prevent deadlock, <size> must not be greater than the size of the output FIFO (8 entries in the this implementation). If the STP16 variant is used, endian specific behaviour may occur to the data returned to the memory system.<br>
The MRP instruction removes one word from the output FIFO and places it in ARM register Rn. As with MPR no endian specific operations are applied to the data.<br>
The ARM encoding for STP is:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
where N selects between STP32 (1) and STP16 (0). For the definitions of the P, U and W bits, refer to an ARM data sheet or see later.<br>
The ARM encoding for MRP is:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
The Piccolo instruction set assumes little endian operation internally. For example when accessing a 32-bit register as 16 bits halves, the lower half is assumed to occupy bits 15 to 0. Piccolo may be operating in a system with big endian memory or peripherals and must therefore take care to load 16-bit packed data in the correct manner.<br>
Piccolo (i.e. the DSP adapted coprocessor), like the ARM (e.g. the ARM? microprocessors produced by Advanced RISC Machines Limited of Cambridge, United Kingdom), has a 'BIGEND' configuration pin which the programmer can control, perhaps with a programmable peripheral. Piccolo uses this pin to configure the input<br>
reorder buffer and output FIFO.<br>
When the ARM loads packed 16-bit data into the reorder buffer it must indicate this by using the 16-bit form of the LDP instruction. This information is combined with the state of the 'BIGEND' configuration input to place data into the holding latches and reorder buffer in the appropriate order. In particular when in big endian mode the holding register stores the bottom 16 bits of the loaded word, and is paired up with the top 16 bits of the next load. The holding register contents always end up in the bottom 16 bits of the word transferred into the reorder buffer.<br>
The output FIFO may contain either packed 16-bit or 32-bit data. The programmer must use the correct form of the STP instruction so that Piccolo can ensure that the 16-bit data is provided on the correct halves of the data bus. When configured as big endian the top and bottom 16-bit halves are swapped when the 16-bit forms of STP are used.<br>
Piccolo has 3 private registers which can only be accessed from the ARM. They are called SO-S2. They can only be accessed with MRC and MCR instructions. The opcodes are:<br>
MPSR Sn, Rm<br><br>
MRPS<br>
Rm, Sn<br>
These opcodes transfer a 32-bit value between ARM register Rm and private register Sn. They are encoded in ARM as a coprocessor register transfer:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)where L is 0 for the MPSR and 1 for the MRPS.<br>
Register SO contains the Piccolo unique ID and revision code<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
Bits[3:0] contain the revision number for the processor.<br>
Bits[15:4] contain a 3 digit part number in binary coded decimal format: 0x500 for Piccolo<br>
Bits[23:16] contain the architecture version: 0x00 = Version 1<br>
Bits[31:24] contain the ASCII code of an implementers trademark: 0x41 = A = ARM Ltd<br>
Register SI is the Piccolo status register.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
Primary condition code flags (N,Z,C,V)<br>
Secondary condition code flags (SN,SZ,SC,SV)<br>
E bit: Piccolo has been disabled by the ARM and has halted.<br>
U bit: Piccolo encountered an UNDEFINED instruction and has halted.<br><br>
B bit: Piccolo encountered a BREAKPOINT and has halted. H bit: Piccolo encountered a HALT instruction and has halted.<br>
A bit: Piccolo suffered a memory abort (load, store or Piccolo instruction) and has halted.<br>
D bit: Piccolo has detected a deadlock condition and has halted (see below).<br>
Register S2 is the Piccolo program counter:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br>
(Table Removed) <br>
Writing to the program counter will start Piccolo executing a program at that address (leaving halted state if it is halted). On reset the program counter is undefined, since Piccolo is always started by writing to the program counter.<br>
During execution Piccolo monitors the execution of instructions and the status of the coprocessor interface. If it detects that:<br>
-Piccolo has stalled waiting for either a register to be refilled or the output FIFO to have an available entry.<br>
-The coprocessor interface is busy-waiting, because of insufficient space in the ROB or insufficient items in the output FIFO.<br>
If both of these conditions are detected Piccolo sets the D-bit in its status register, halts and rejects the ARM coprocessor instruction, causing ARM to take the undefined instruction trap.<br><br>
This detection of deadlock conditions allows a system to be constructed which can at least warn the programmer that the condition has occurred and report the exact point of failure, by reading the ARM and Piccolo program counters and registers. It should be stressed that deadlock can only happen due to an incorrect program or perhaps another part of the system corrupting Piccolo's state. Deadlock can not occur due to data starvation or 'overload'.<br>
There are several operations available that may be used to control Piccolo from the ARM, these are provided by CDP instructions. These CDP instructions will only be accepted when the ARM is in a privileged state. If this is not the case Piccolo will reject the CDP instruction resulting in the ARM taking the undefined instruction trap. The following operations are available:<br>
Enter State Access Mode<br>
Enable<br>
Disable<br>
Piccolo may be reset in software by using the PRESET instruction.<br><br>
PRESET<br><br>
; Clear Piccolo's state<br><br>
This instruction is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15  14 13  12 11  10   9    8    7    6    5    4    3    2    1    0<br><br>
(Table Removed) <br>
When this instruction is executed the following occurs:<br>
-All registers are marked as empty (ready for refill).<br>
-Input ROB is cleared. -Output FIFO is cleared.<br>
-Loop counters are reset.<br>
-Piccolo is put into halted state (and H bit of SI will be set).<br>
Executing the PRESET instruction may take several cycles to complete (2-3 for this embodiment). Whilst it is executing, following ARM coprocessor instructions to be executed on Piccolo will be busy waited.<br>
In state access mode, Piccolo's state may be saved and restored using STC and LDC instructions (see the below regarding accessing Piccolo state from ARM). To enter state access mode, the PSTATE instruction must first be executed:<br><br>
PSTATE;<br><br>
Enter State Access Mode<br><br>
This instruction is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11  10   9   8    7   6   5   4   3    2    1    0<br><br>
(Table Removed) <br>
When executed, the PSTATE instruction will:<br>
-Halt Piccolo (if it is not already halted), setting the E bit in Piccolo's Status Register. -Configure Piccolo into its State Access Mode.<br>
Executing the PSTATE instruction may take several cycles to complete, as Piccolo's instruction pipeline must drain before it can halt. Whilst it is executing, following ARM coprocessor instructions to be executed on Piccolo will be busy waited.<br>
The PEN ABLE and PDI SABLE instructions are used for fast context switching. When Piccolo is disabled, only private registers 0 and 1 (the ID and Status registers) are accessible, and only then from a privileged mode. Access to any other state, or any access from user mode will cause an ARM undefined instruction exception. Disabling Piccolo causes it to halt execution, i.e. become unresponsive except to those instructions reading the private registers 0 and 1 and the PENABLE instruction. When Piccolo has halted execution, it will acknowledge the fact by setting the E bit in the status register.<br>
Piccolo is enabled by executing the PENABLE instruction:<br><br>
PENABLE;<br><br>
Enable Piccolo<br><br>
This instruction is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed) <br>
Piccolo is disabled by executing the PDISABLE instruction:<br><br>
PDISABLE<br><br>
; Disable Piccolo<br><br>
This instruction is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 54 3 2 1 0<br><br>
(Table Removed) <br>
When this instruction is executed, the following occurs:<br>
-Piccolo's instruction pipeline will drain.<br>
-Piccolo will halt and the H bit in the Status register set.<br>
_ This section discusses the Piccolo instruction set which controls the Piccolo data path. Each instruction is 32 bits long. The instructions are read from the Piccolo instruction cache.<br>
Decoding the instruction set is quite straight forward. The top 6 bits (26 to 31) give a major opcode, with bits 22 to 25 providing a minor opcode for a few specific instructions. Bits shaded in grey are currently unused and reserved for expansion (they must contain the indicated value at present).<br>
There are eleven major instruction classes. This does not fully correspond to the major opcode filed in the instruction, for ease of decoding some sub-classes.<br>
33222222222211111111119876543210 1098765432109876543210<br><br>
(Table Removed)<br>
The instructions in the above table have the following names:<br>
Standard Data Operation<br>
Logical Operation<br>
Conditional Add/Subtract<br>
Undefined<br>
Shifts<br>
Select<br>
Undefined<br>
Parallel Select<br>
Multiply Accumulate<br>
Undefined<br>
Multiply Double<br>
Undefined<br>
Move Signed Immediate<br>
Undefined<br>
Repeat<br>
Repeat<br>
Register List Operations<br>
Branch<br>
Renaming Parameter Move<br>
Halt/Break<br>
The format for each class of instructions is described in detail in the following sections. The source and destination operand fields are common to most instructions and described in detail in separate sections, as is the register re-mapping.<br>
Most instructions require two source operands; Source 1 and Source 2. Some exceptions are saturating absolute.<br>
The Source 1 (SRC1) operand has the following 7 bit format:<br><br>
18<br><br>
17<br><br>
16<br><br>
15<br><br>
14<br><br>
13<br><br>
12<br><br><br>
(Table Removed) <br>
The elements of the field have the following meaning:<br>
-Size - indicates the size of operand to read (l=32-bit, 0=16-bit).<br>
-Refill - specifies that the register should be marked as empty after being read and can<br>
be refilled from the ROB.<br>
-Register Number - encodes which of the 16 registers to read.<br>
-Hi/Lo - For 16-bit reads indicates which half of the 32-bit register to read. For 32-bit<br>
operands, when set indicates that the two 16-bit halves of the register should be<br>
interchanged.<br>
(Table Removed)<br>
The register size is specified in the assembler by adding a suffix to the register number: .1 for the low 16 bits, .h for the high 16 bits or .x for 32 bits with the upper and lower sixteen bits interchanged.<br>
The general Source 2 (SRC2) has one of the following three 12 bit formats: 11     10     987654         3210<br><br>
(Table Removed) <br>
Figure 4 illustrates a multiplexer arrangement responsive to the Hi/Lo bit and Size bit to switch appropriate halves of the selected register to the Piccolo datapath. If the Size bit indicates 16 bits, then a sign extending circuit pads the high order bits of the datapath with Os or Is as appropriate.<br>
The first encoding specifies the source as being a register, the fields having the same encoding as the SRC1 specifier. The SCALE field specifies a scale to be applied to the result of the ALU.<br>
(Table Removed)<br>
The 8-bit immediate with rotate encoding allows the generation of a 32-bit immediate which is expressible by an 8-bit value and 2-bit rotate. The following table<br>
shows the immediate values that can be generated from the 8-bit value XY:<br><br>
(Table Removed)<br>
The 6-bit Immediate encoding allows the use of a 6-bit unsigned immediate (range 0 to 63), together with a scale applied to the output of the ALU.<br>
The general Source 2 encoding is common to most instruction variants. There are some exceptions to this rule which support a limited subset of the Source 2 encoding or modify it slightly:<br>
-Select Instructions.<br>
-Shift Instructions.<br>
-Parallel Operations.<br>
-Multiply Accumulate Instructions.<br>
-Multiply Double Instructions.<br>
Select instructions only support an operand which is a register or a 6-bit unsigned immediate. The scale is not available as these bits are used by the condition field of the instruction.<br>
 (Table Removed)Shift instructions only support an operand which is a 16-bit register or a 5-bit unsigned immediate between 1 and 31. No scale of the result is available.<br><br>
(Table Removed)<br>
In the case of parallel operations, if a register is specified as the source of the operand, a 32-bit read must be performed. The immediate encoding has slightly different meaning for the parallel operations. This allows an immediate to be duplicated onto both 16-bit halves of a 32-bit operand. A slightly restricted range of scales are available for parallel operations.<br>
(Table Removed)<br>
If the 6-bit immediate is used then it is always duplicated onto both halves of the 32-bit quantity. If the 8-bit immediate is used it is duplicated only if the rotate indicates that the 8-bit immediate should be rotated onto the top half of the 32-bit quantity:<br>
(Table Removed) <br>
No scale is available for parallel select operations; the scale field shall be set to 0 for these instructions.<br>
The multiply accumulate instructions do not allow an 8-bit rotated immediate to be specified. Bit 10 of the field is used to partly specify which accumulator to use. Source 2 is implied as a 16-bit operand.<br><br>
(Table Removed) <br>
Multiply double instructions do not allow the use of a constant. Only a 16-bit register can be specified. Bit 10 of the field is used to partly specify which accumulator to use.<br><br>
11      10<br><br>
8<br><br>
1<br><br>
0<br><br><br><br>
SRC2 MULD<br><br><br>
0 	AO 	R2 	Register number 	Hi/ Lo 	SCALE <br><br>
Some instructions always imply a 32-bit operation (e.g. ADDADD), and in these cases the size bit shall be set to 1, with the Hi/Lo bit used to optionally swap the two 16-bit halves of the 32-bit operand. Some instructions always imply a 16-bit operation (e.g. MUL) and the size bit should be set to 0. The Hi/Lo bit then selects which half of the register is used (it is assumed that the missing size bit is clear). Multiply-accumlulate instructions allow independent specification of the source accumulator and destination registers. For these instructions the Size bits are used to indicate the source accumulator, and the size bits are implied by the instruction type as 0.<br>
When a 16-bit value is read (via the A or B busses) it is automatically sign extended to a 32-bit quantity. If a 40 bit register is read (via the A or B busses), only the bottom 32 bits appear on the bus. Hence in all cases source 1 and source 2 are converted to 32-bit values. Only accumulate instructions using bus C can access the full 40 bits of an accumulator register.<br>
If the refill bit is set, the register is marked as empty after use and will be refilled from the ROB by the usual refill mechanism (see the section on the ROB). Piccolo will not stall unless the register is used again as a source operand before the refill has taken place. The minimum number of cycles before the refilled data is valid (best case - the data is waiting at the head of the ROB) will be either 1 or 2. Hence it is advisable not to use the refilled data on the instruction following the refill request. If use of the operand on the next two instructions can be avoided it should be, since this will prevent performance loss on deeper pipeline implementations.<br>
The refill bit is specified in the assembler by suffixing the register number with a 'A'. The section of the register marked as empty depends on the register operand. The two halves of each register may be marked for refill independently (for example X0.1A will mark only the bottom half of XO for refill, XOA will mark the whole of XO for refill).   When the top 'half (bits 39:16) of a 40-bit register are<br>
refilled, the 16-bits of data is written to bits 31:16 and is sign extended up to bit 47.<br>
If an attempt is made to refill the same register twice (eg ADD X1,XOA,XOA), then only one refill takes place. The assembler should only allow the syntax ADD X1,XO,XOA.<br>
If a register read is attempted before that register has been refilled, Piccolo stalls waiting for the register to be refilled. If a register is marked for refill, and the register is then updated before the refilled value is read, the result will depend upon the particular hardware implementation and cannot be relied upon by a programmer (for example ADD XO, XOA, XI is unpredictable since it marks XO for refill and then refills it by placing the sum of XO and XI into it).<br>
The 4-bit scale field encodes fourteen scale types:<br>
-ASR #0, 1, 2, 3, 4, 6, 8, 10 -ASR #12 to 16 -LSL #1<br>
Parallel Max/Min instructions do not provide a scale, and therefore the six bit constant variant of source 2 is unused (Set to 0 by assembler).<br>
Within a REPEAT instruction register re-mapping is supported, allowing a REPEAT to access a moving 'window' of registers without unrolling the loop. This is described in more detail in below.<br>
Destination operands have the following 7 bit format:<br>
(Table Removed) <br>
There are ten variants of this basic encoding:<br><br>
Assembler Mnemonic<br>
Dx	1<br>
DxA	2<br>
Dx.l	3<br>
Dx.lA	4<br>
Dx.h	5<br>
Dx.hA	6<br>
Undefined<br>
.1 (No register writeback 16-bits)	7<br>
"" (No register writeback 32-bits)	8<br>
.1A (16-bit) output<br>
(32-bit) output<br>
(Table Removed) <br>
The register number (Dx) indicates which of the 16 registers is being addressed. The Hi/Lo bit and the Size bit work together to address each 32-bit register as a pair of 16-bit registers. The Size bit defines how the appropriate flags, as defined in the instruction type, will be set, irrespective of whether a result is written to the register bank and/or output FIFO. This allows the construction of compares and similar instructions. The add with accumulate class of instruction must write back the result to a register.<br>
The following table shows the behaviour of each encoding:<br><br>
(Table Removed) <br><br>
In all cases the result of any operation prior to writing back to a register or inserting into the output FIFO is a 40 bit quantity. There are two cases:<br>
If the write is of 16-bits the 40 bit quantity is reduced to a 16-bit quantity by selecting the bottom 16 bits [15:0]. If the instruction saturates then the value will be saturated into the range -2A15 to 2A15-1. The 16-bit value is then written back to the indicated register and, if the Write FIFO bit is set, to the output FIFO. If it is written to the output FIFO then it is held until the next 16-bit value is written when the values are paired up and placed into the output FIFO as a single 32-bit value.<br>
For 32-bit writes the 40 bit quantity is reduced to a 32-bit quantity by selecting the bottom 32 bits [31:0].<br>
For both 32-bit and 40-bit writes, if the instruction saturates the 40-bit value will be converted to a 32-bit value in the range -2A31-1 to 2A31. Following the saturation:<br>
-If writeback to an accumulator is performed, the full 40 bits will be written.<br>
-If writeback to a 32-bit register is performed, bits [31:0] are written.<br>
-If writeback to the output FIFO is indicated, again bits [31:0] will be written.<br>
The destination size is specified in the assembler by a .1 or .h after the register number. If no register writeback is performed then the register number is unimportant, so omit the destination register to indicate no write to a register or use A to indicate a write only to the output FIFO. For example, SUB , XO, YO is equivalent to CMP XO, YO and ADD A, XO, YO places the value of XO+YO into the output FIFO.<br>
If there is no room in the output FIFO for a value, Piccolo stalls waiting for space to become available.<br>
If a 16-bit value is written out, for example ADD XO.hA, XI, X2, then the value is latched until a second 16-bit value is written. The two values are then combined and placed into the output FIFO as a 32-bit number. The first 16-bit value written always appears in the lower half of the 32-bit word. An an alternative to the STP16 and STP32 mechanisms described earlier, data entered into the output FIFO<br><br>
may be marked as either 16 or 32-bit data, to allow endianess to be corrected on big endian systems.<br>
If a 32-bit value is written between two 16-bit writes then the outcome will depend upon the particular hardware implementation and cannot be relied upon by a programmer.<br>
Within a REPEAT instruction register re-mapping is supported, allowing a REPEAT to access a moving 'window' of registers without unrolling the loop. This is described in more detail below.<br>
In preferred embodiments of the present invention, the REPEAT instruction provides a mechanism to modify the way in which register operands are specified within a loop. Under this mechanism, the registers to be accessed are determined by a function of the register operand in the instruction and an offset into the register bank. The offset is changed in a programmable manner, preferably at the end of each instruction loop. The mechanism may operate independently on registers residing in the X, Y and Z banks. In preferred embodiments, this facility is not available for registers in the A bank.<br>
The notion of a logical and physical register can be used. The instruction operands are logical register references, and these are then mapped to physical register references identifying specific Piccolo registers 10. All operations, including refilling, operate on the physical register. The register remapping only occurs on the Piccolo instruction stream side - data loaded into Piccolo is always destined for a physical register, and no remapping is performed.<br>
The remapping mechanism will be discussed further with reference to Figure 5, which is a block diagram illustrating a number of the internal components of the Piccolo coprocessor 4. Data items retrieved by the ARM core 2 from memory are placed in the reorder buffer 12, and the Piccolo registers 10 are refilled from the reorder buffer 12 in the manner described earlier with reference to Figure 2. Piccolo instructions stored in the cache 6 are passed to an instruction decoder 50 within<br><br>
Piccolo 4, where they are decoded prior to being passed to the Piccolo processor core 54. The Piccolo processor core 54 includes the multiplier/adder circuit 20, the accumulate/decumulate circuit 22, and the scale/saturate circuit 24 discussed earlier with reference to Figure 3.<br>
If the instruction decoder 50 is handling instructions forming part of an instruction loop identified by a REPEAT instruction, and the REPEAT instruction has indicated that remapping of a number of registers should take place, then the register remapping logic 52 is employed to perform the necessary remapping. The register remapping logic 52 can be considered as being part of the instruction decoder 50, although it will be apparent to those skilled in the art that the register remapping logic 52 may be provided as a completely separate entity to the instruction decoder 50.<br>
An instruction will typically include one or more operands identifying registers containing the data items required by the instruction. For example, a typical instruction may include two source operands and one destination operand, identifying two registers containing data items required by the instruction, and a register in to which the result of the instruction should be placed. The register remapping logic 52 receives the operands of an instruction from the instruction decoder 50, these operands identifying logical register references. Based on the logical register references, the register remapping logic will determine whether remapping should or should not be applied, and will then apply a remapping to physical register references as required. If it is determined that remapping should not be applied, the logical register references are provided as the physical register references. The preferred manner in which the remapping is performed will be discussed in more detail later.<br>
Each output physical register reference from the register remapping logic is passed to the Piccolo processor core 54, such that the processor core can then apply the instruction to the data item in the particular register 10 identified by the physical register reference.<br>
The remapping mechanism of the preferred embodiment allows each bank of registers to be split into two sections, namely a section within which registers may be remapped, and a section in which registers retain their original register references without remapping. In preferred embodiments, the remapped section starts at the bottom of the register bank being remapped.<br>
A number of parameters are employed by the remapping mechanism, and these parameters will be discussed in detail with reference to Figure 6, which is a block diagram illustrating how the various parameters are used by the register remapping logic 52. It should be noted that these parameters are given values that are relative to a point within the bank being remapped, this point being, for example, the bottom of the bank.<br>
The register remapping logic 52 can be considered as comprising two main logical blocks, namely the Remap block 56 and the Base Update block 58. The register remapping logic 52 employs a base pointer that provides an offset value to be added to the logical register reference, this base pointer value being provided to the remap block 56 by base update block 58.<br>
A BASESTART signal can be used to define the initial value of the base pointer, this for example typically being zero, although some other value may be specified. This BASESTART signal is passed to multiplexer 60 within the Base Update block 58. During the first iteration of the instruction loop, the BASESTART signal is passed by the multiplexer 60 to the storage element 66, whereas for subsequent iterations of the loop, the next base pointer value is supplied by the multiplexer 60 to the storage element 66.<br>
The output of the storage element 66 is passed as the current base pointer value to the ReMap logic 56, and is also passed to one of the inputs of an adder 62 within the Base Update logic 58. The adder 62 also receives a BASEINC signal that provides a base increment value. The adder 62 is arranged to increment the current base pointer<br>
value supplied by storage element 66 by the BASEINC value, and to pass the result to the modulo circuit 64.<br>
The modulo circuit also receives a BASEWRAP value, and compares this value to the output base pointer signal from the adder 62. If the incremented base pointer value equals or exceeds the BASEWRAP value, the new base pointer is wrapped round to a new offset value. The output of the modulo circuit 64 is then the next base pointer value to be stored in storage element 66. This output is provided to the multiplexer 60, and from there to the storage element 66.<br>
However, this next base pointer value cannot be stored in the storage element 66 until a BASEUPDATE signal is received by the storage element 66 from the loop hardware managing the REPEAT instruction. The BASEUPDATE signal will be produced periodically by the loop hardware, for example each time the instruction loop is to be repeated. When a BASEUPDATE signal is received by the storage element 66, the storage element will overwrite the previous base pointer value with the next base pointer value provided by the multiplexer 60. In this manner, the base pointer value supplied to the ReMap logic 58 will change to the new base pointer value.<br>
The physical register to be accessed inside a remapped section of a register bank is determined by the addition of a logical register reference contained within an operand of an instruction, and the base pointer value provided by the base update logic 58. This addition is performed by adder 68 and the output is passed to modulo circuit 70. In preferred embodiments, the modulo circuit 70 also receives a register wrap value, and if the output signal from the adder 68 (the addition of the logical register reference and the base pointer value) exceeds the register wrap value, the result will wrap through to the bottom of the remapped region. The output of the modulo circuit 70 is then provided to multiplexer 72.<br>
A REGCOUNT value is provided to logic 74 within Remap block 56, identifying the number of registers within a bank which are to be remapped. The logic<br>
74 compares this REGCOUNT value with the logical register reference, and passes a control signal to multiplexer 72 dependent on the result of that comparison. The multiplexer 72 receives as its two inputs the logical register reference and the output from modulo circuit 70 (the remapped register reference). In preferred embodiments of the present invention, if the logical register reference is less than the REGCOUNT value, then the logic 74 instructs the multiplexer 72 to output the remapped register reference as the Physical Register Reference. If, however, the logical register reference is greater than or equal to the REGCOUNT value, then the logic 74 instructs the multiplexer 72 to output the logical register reference directly as the physical register reference.<br>
As previously mentioned, in preferred embodiments, it is the REPEAT instruction which invokes the remapping mechanism. As will be discussed in more detail later, REPEAT instructions provide four zero cycle loops in hardware. These hardware loops are illustrated in Figure 5 as part of the instruction decoder 50. Each time the instruction decoder 50 requests an instruction from cache 6, the cache returns that instruction to the instruction decoder, whereupon the instruction decoder determines whether the returned instruction is a REPEAT instruction. If so, one of the hardware loops is configured to handle that REPEAT instruction.<br>
Each repeat instruction specifies the number of instructions in the loop and the number of times to go around the loop (which is either a constant or read from a Piccolo register). The opcode REPEAT and an associated assembler mnemonic NEXT are provided for defining a hardware loop, the NEXT mnemonic being used merely as a delimiter and not being assembled as an instruction. The REPEAT goes at the start of the loop, and NEXT delimits the end of the loop, allowing the assembler to calculate the number of instructions in the loop body. In preferred embodiments, the REPEAT instruction can include remapping parameters such as the REGCOUNT, BASEINC, BASEWRAP and REGWRAP parameters to be employed by the register remapping logic 52.<br>
A number of registers can be provided to store remapping parameters used by the register remapping logic. Within these registers, a number of sets of predefined remapping parameters can be provided, whilst some registers are left for the storage of user defined remapping parameters. If the remapping parameters specified with the REPEAT instruction are equal to one of the sets of predefined remapping parameters, then the appropriate REPEAT encoding is used, this encoding causing a multiplexer or the like to provide the appropriate remapping parameters from the registers directly to the register remapping logic. If, on the other hand, the remapping parameters are not the same as any of the sets of predefined remapping parameters, then the assembler will generate a Remapping Parameter Move Instruction (RMOV) which allows the configuration of the user defined register remapping parameters, the RMOV instruction being followed by the REPEAT instruction. Preferably, the user defined remapping parameters would be placed by the RMOV instruction in the registers left aside for storing such user defined remapping parameters, and the multiplexer would then be programmed to pass the contents of those registers to the register remapping logic.<br>
In the preferred embodiments, the REGCOUNT, BASEINC, BASEWRAP and REGWRAP parameters take one of the values identified in the following chart:<br>
PARAMETER<br>
DESCRIPTION<br><br><br><br>
REGCOUNT<br><br>
This identifies the number of 16 bit registers to perform remapping on, and may take the values 0, 2, 4, 8. Registers below REGCOUNT are remapped, those above or equal to REGCOUNT are accessed directly.<br><br><br><br>
BASEINC<br><br>
This defines by how many 16 bit registers the base pointer is incremented at the end of each loop iteration.  It may in preferred embodiments take the values 1, 2, or 4, although in fact it can take other values if desired, including negative values where appropriate.<br><br><br><br>
BASEWRAP<br><br>
This determines the ceiling of the base calculation.  The base wrapping modulus may take the values 2, 4, 8.<br><br><br><br>
REGWRAP<br><br>
This determines the ceiling of the remap calculation.   The register wrapping modulus may take the values 2, 4, 8. REGWRAP may be chosen to be equal to REGCOUNT.<br><br>
Returning to Figure 6, an example of how the various parameters are used by the remap block 56 is as follows (in this example, the logical and physical register values are relative to the particular bank):<br>
if (Logical Register 
Physical Register = (Logical Register + Base) MOD REGCOUNT<br>
Physical Register = Logical Register<br>
end if<br>
At the end of the loop, before the next iteration of the loop begins, the following update to the base pointer is performed by the base update logic 58:<br>
Base = (Base + BASEINC) MOD BASEWRAP<br>
At the end of a remapping loop, the register remapping will be switched off and all registers will then be accessed as physical registers. In preferred embodiments, only one remapping REPEAT will be active at any one time. Loops may still be nested, but only one may update the remapping variables at any particular time. However, it will be appreciated that, if desired, remapping repeats could be nested.<br>
To illustrate the benefits achieved with regards to code density as a result of employing the remapping mechanism according to the preferred embodiment of the present invention, a typical block filter algorithm will now be discussed. The principles of the block filter algorithm will first be discussed with reference to Figure 7. As illustrated in Figure 7, accumulator register AO is arranged to accumulate the results of a number of multiplication operations, the multiplication operations being the multiplication of coefficient cO by data item dO, the multiplication of coefficient cl by data item dl, the multiplication of coefficient c2 by data item d2, etc. Register Al accumulates the results of a similar set of multiplication operations, but this time the set of coefficients have been shifted such that cO is now multiplied by dl, cl is now multiplied by d2, c2 is now multiplied by d3, etc. Likewise, register A2 accumulates the results of multiplying the data values by the coefficient values shifted<br>
another step to the right, such that cO is multiplied by d2, cl is multiplied by d3, c2 is multiplied by d4, etc. This shift, multiply, and accumulate process is then repeated with the result being placed in register A3.<br>
If register remapping in accordance with the preferred embodiment of the present invention is not employed, then the following instruction loop will be required to perform the block filter instruction:<br>
;   start  with 4  new data values<br>
ZERO   {AO-A3}	;   Zero   the   accumulators<br>
REPEAT     Zl	;   Zl=   (number of  coeffs/4)<br>
;   do  the next  four  coefficients,   on the  first  time  around:<br>
;   aO   +=   dO*cO+dl*cl+d2*c2+d3*c3<br>
;   al   + =  dl*cO+d2*cl+d3*c2+d4*c3<br>
;   a2   +=   d2*cO+d3*cl+d4*c2+d5*c3<br>
;   a3   +=   d3*cO+d4*cl+d5*c2+d6*c3<br>
MULA	AO,   X0.1~,   YO.l   ,   AO	;   aO   +=   dO*cO,   and  load  d4<br>
MTJLA	Al,    XO.h   ,    YO.l    ,   Al	;   al   +=   dl*cO<br>
MULA    A2, Xl.l , YO.l , A2    ; a2 += d2*cO<br>
MULA    A3, Xl.h , Y0.1\ A3    ; a3 += d3*cO, and load c4<br>
MULA    AO, XO.h", YO.h , AO    ; aO += dl*cl, and load d5<br>
MULA    Al, Xl.l , YO.h , Al    ; al += d2*cl<br>
MULA    A2, Xl.h , YO.h , A2    ; a2 += d3*cl<br>
MULA    A3, XO.l , YO.h^, A3    ; a3 += d4*cl, and load c5<br>
MULA    AO, Xl.l*, Yl.l , AO    ; aO += d2*c2, and load d6<br>
MULA    Al, Xl.h , Yl.l , Al    ; al += d3*c2<br>
MULA    A2, XO.l , Yl.l , A2    ; a2 += d4*c2<br>
MULA    A3, XO.h , Yl.l*, A3    ; a3 += d5*c2, and load c6<br>
MULA   AO, Xl.h*, Yl.h , AO    ; aO += d3*c3, and load d7<br>
MULA    Al, XO.l , Yl.h , Al    ; al += d4*c3<br>
MULA    A2, XO.h , Yl.h , A2    ,- a2 += d5*c3<br>
MULA   A3, Xl.l , Yl.h*, A3    ; a3 += d6*c3, and load c7<br>
NEXT<br>
In this example, the data values are placed in the X bank of registers and the coefficient values are placed in the Y bank of registers. As a first step, the four<br>
accumulator registers AO, Al, A2, and A3 are set to zero. Once the accumulator registers have been reset, an instruction loop is then entered, which is delimited by the REPEAT and NEXT instructions. The value Zl identifies the number of times that the instruction loop should be repeated, and for the reasons that will be discussed later, this will actually be equal to the number of coefficients (cO, cl, c2, etc.) divided by 4.<br>
The instruction loop comprises 16 multiply accumulate instructions (MULA), which, after the first iteration through the loop, will result in the registers AO, Al, A2, A3 including the result of the calculations shown in the above code between the REPEAT and the first MULA instruction. To illustrate how the multiply accumulate instructions operate, we will consider the first four MULA instructions. The first instruction multiplies the data value within the first, or lower, 16 bits of the X bank register zero with the lower 16 bits within Y bank register zero, and adds the result to the accumulator register AO. At the same time the lower 16 bits of the X bank register zero are marked by a refill bit, this indicating that that part of the register can now be refilled with a new data value. It is marked in this way, since as will be apparent from Figure 7, once data item dO has been multiplied by the coefficient cO (this being represented by the first MULA instruction), then dO is no longer required for the rest of the block filter instruction and so can be replaced by a new data value.<br>
The second MULA instruction then multiplies the second, or higher 16 bits of the X bank register zero with the lower 16 bits of the Y bank register zero (this representing the multiplication dl x cO shown in Figure 7). Similarly, the third and fourth MULA instructions represent the multiplications d2 x cO, and d3 x cO, respectively. As will be apparent from Figure 7, once these four calculations have been performed, coefficient CO is no longer required and so the register YO.l is marked by a refill bit to enable it to be overwritten with another coefficient (c4).<br>
The next four MULA instructions represent the calculations dlxcl, d2xcl, d3xcl, and d4xcl, respectively. Once the calculation dlxcl has been performed, the<br><br>
register XO.h is marked by a refill bit since dl is no longer required. Similarly, once all four calculations have been performed, the register YO.h is marked for refilling, since the coefficient cl is no longer needed. Similarly, the next four MULA instructions correspond to the calculations d2xc2, d3xc2, d4xc2, and d5xc2, whilst the final four calculations correspond to the calculations d3xc3, d4xc3, d5xc3, and d6xc3.<br>
Since, in the above described embodiment, registers are not remappable, each multiplication operation has to be reproduced explicitly with the specific register required being designated in the operands. Once the sixteen MULA instructions have been performed, the instruction loop can be repeated for coefficients c4 to c7 and data items d4 to dlO. Also, because the loop acts on four coefficient values per iteration, then the number of coefficient values must be a multiple of four and the computation Zl = no. of coeffs/4 must be calculated.<br>
By employing the remapping mechanism in accordance with the preferred embodiment of the present invention, the instruction loop can. be dramatically reduced, such that it now only includes 4 multiply accumulate instructions, rather than the 16 multiply accumulate instructions that were otherwise required. Using the remapping mechanism, the code can now be written as follows:<br>
;   start with 4  new data values<br>
ZERO   {AO-A3}	;   Zero   the   accumulators<br>
REPEAT     Zl,   X++  n4   w4   r4,   Y++  n4   w4   r4;   Zl=    (number  of   coefficients)<br>
;   Remapping   is   applied  to  the  X  and Y banks.<br>
;   Four   16  bit   registers   in  these  banks   are   remapped.<br><br>
; The base pointer for both banks is incremented by one on each<br>
; iteration of the loop.<br>
,- The base pointer wraps when it reaches the fourth register in the<br>
; bank.<br>
MULA	AO,   X0.1X,   YO.l   ,   AO	;   aO   +=   dO*cO,   and  load  d4<br>
MULA	Al,    XO.h,      YO.l    ,   Al	;   al   +=   dl*cO<br>
MULA	A2,    Xl.l,      YO.l   ,   A2	;   a2   + =   d2*cO<br>
MULA	A3,   XI. h,      YO.l*,   A3	;   a3   +=   d3*cO,   arid  load  c4<br><br>
NEXT<br><br>
; go round loop and advance remapping<br><br>
As before, the first step is to set the four accumulator registers AO-A3 to zero. Then, the instruction loop is entered, delimited by the REPEAT and NEXT opcodes. The REPEAT instruction has a number of parameters associated therewith, which are as follows:<br>
X++    : indicates that BASEINC is ' 1' for the X Bank of registers<br>
n4        : indicates that REGCOUNT is '4' and hence the first four X Bank registers<br>
XO.l to XI.h are to be remapped w4       : indicates that BASE WRAP is '4' for the X Bank of registers<br>
r4        : indicates that REGWRAP is '4' for the X Bank of registers<br>
Y++    : indicates that BASEINC is ' 1' for the Y Bank of registers<br>
n4        : indicates that REGCOUNT is '4' and hence the first four Y Bank registers<br>
YO.l to Yl.h are to be remapped<br>
w4       : indicates that BASE WRAP is '4' for the Y Bank of registers r4        : indicates that REGWRAP is '4' for the Y Bank of registers<br>
It should also be noted that now the value Zl is equal to the number of coefficients, rather than being equal to the number of coefficients/4 as in the prior art example.<br>
For the first iteration of the instruction loop, the base pointer value is zero, and so there is no remapping. However, next time the loop is executed, the base pointer value will be ' 1' for both the X and Y banks, and so the operands will be mapped as follows:<br>
XO.l becomes XO.h<br>
XO.h becomes XI.1<br>
X1.1 becomes Xl.h<br>
XI.h becomes XO.l (since BASEWRAP is '4')<br>
YO.l becomes YO.h<br>
YO.h becomes Yl.l Yl.l becomes Yl.h Yl.h becomes YO.l (since BASEWRAP is '4')<br>
Hence, it can be seen that on the second iteration, the four MULA instructions actually perform the calculations indicated by the fifth to eight MULA instructions in the example discussed earlier that does not include the remapping of the present invention. Similarly, the third and fourth iterations through the loop perform the calculations formerly performed by the ninth to twelfth, and thirteenth to sixteenth MULA instructions of the prior art code.<br>
Hence, it can be seen that the above code performs exactly the same block filter algorithm as the prior art code, but improves code density within the loop body by a factor of four, since only four instructions need to be provided rather than the sixteen required by the prior art.<br>
By employing the register remapping technique in accordance with preferred embodiments of the present invention, the following benefits can be realised:<br>
1.	It improves code density;<br>
2.	It can in certain situations hide the latency from marking a register being as<br>
empty to that register being refilled by Piccolo's reorder buffer.    This could be<br>
achieved by unrolling loops, at the cost of increased code size;<br>
3.	It enables a variable number of registers to be accessed - by varying the<br>
number of loop iterations performed the number of registers accessed may be varied;<br>
and<br>
4. It can ease algorithm development. For suitable algorithms, the programmer can produce a piece of code for the nth stage of the algorithm, then use register remapping to apply the formula to a sliding set of data.<br>
It will be apparent that certain changes can be made to the above described register remapping mechanism without departing from the scope of the present invention. For example, it is possible for the bank of registers 10 to provide more physical registers than can be specified by the programmer in an instruction operand. Whilst these extra registers cannot be accessed directly, the register remapping mechanism can make these registers available. For example, consider the example discussed earlier where the X bank of registers has four 32 bit registers available to the programmer, and hence eight 16 bit registers can be specified by logical register references. It is possible for the X bank of registers to actually consist of, for example, six 32 bit registers, in which case there will be four additional 16 bit registers not directly accessible to the programmer. However, these extra four registers can be made available by the remapping mechanism thereby providing additional registers for the storage of data items.<br>
The following assembler syntax may will be used:<br>
»    means logical shift right or shift left if the shift operand is negative (see <lscale> below).<br>
-»  means arithmetic shift right or shift left if the shift operand is negative (see <scale> below).<br>
SAT(a)means the saturated value of a (saturated to 16 or 32 bits depending on the size of the destination register). Specifically, to saturate to 16 bits, any value greater  than +0x7fff is replaced by +0x7fff and any value less than -0x8000 is replaced by -0x8000. Saturation to 32 bits is similar with extremes +0x7fffffff and -0x80000000. If the destination register is 40 bits the saturation is still at 32 bits.<br>
Source operand 1 can be one of the following formats:<br><srcl>will be used a shorthand for [Rn|Rn.l|Rn.h|Rn.x][A]. In other words all 7 bits of the source specifier are valid and the register is read as a 32-bit value (optionally swapped) or a 16-bit value sign extended. For an accumulator only the bottom 32 bits are read. The A specifies register refill.<br><srcl_16>is short for [Rn.l|Rn.h][A]. Only 16-bit values can be read.<br><srcl_32>is short for [Rn|Rn.x][A]. Only a 32-bit value can be read, with the<br>
upper and lower halves optionally swapped.<br>
Source operand 2 can be one of the following formats:<br><src2>will be a shorthand for three options:<br>
_ a source register of the form [Rn|Rn.l|Rn.h}Rn.x][A], plus a<br>
scale (<scale>) of the final result. _  an optionally shifted eight bit constant (<immed_8>), but no<br>
scale of the final result. _  a six bit constant (<immed_6>), plus a scale (<scale>) of the<br>
final result.<br><src2_maxmin>	is the same as <src2> but a scale is not permitted.<br><src2_shift>   shift instructions provide a limited subset of <src2>. See above.<br>
for details. <src2_par>      as for <src2_shift><br>
For instructions which specify a third operand:<br><acc>	is short for any of the four accumulator registers [AO] Al ] A2| A3].<br>
All 40 bits are read. No refill can be specified.<br>
The destination register has the format:<br><dest>	which is short for [RnjRn.ljRn.hj.lj ][A]. With no "." extension<br>
the full register is written (40 bits in the case of an accumulator).<br>
In the case where no write back to the register is required, the register used is unimportant. The assembler supports the omission of a destination register to indicate that write back is not required or ".1" to indicate that no writeback is required but flags should be set as though the result is a 16-bit quantity. A denotes that the value is written to the output FIFO.<br><scale>	represents a number of arithmetic scales. There are fourteen<br>
available scales:<br>
ASR#0, 1, 2, 3, 4, 6, 8, 10 ASR #12 to 16 LSL#1 <immed_8>    stands for a unsigned 8-bit immediate value. This consists of a<br>
byte rotated left by a shift of 0, 8, 16 or 24. Hence values<br>
OxYZOOOOOO, OxOOYZOOOO, OxOOOOYZOO and OxOOOOOOYZ can<br>
be encoded	for any YZ. The rotate is encoded<br>
as a 2 bit quantity.<br><imm_6>        Stands for an unsigned 6-bit immediate. <params>   is used to specify register re-mapping and has the following<br>
format:<br><bank><baseinc> n<renumber><br>
w<basewrap><bank>        can be [X|Y|Z] <baseinc> can be [++!+lj+2|+4] <renumber>         can be [0|2i4|8] <basewrap>         can be [2|4|8]<br>
The expression <cond> is shorthand for any one of the following condition codes. Note that the encoding is slightly different from the ARM since the unsigned LS and HI codes have been replaced by more useful signed overflow/underflow tests. The V and N flags are set differently on Piccolo than on the ARM so the translation from condition testing to flag checking is not the same as the ARM either.<br>
0	EQ       Z=0	Last result was zero.<br>
1	NE      Z=l	Last result was non zero.<br><br>
10	CS       C=l	Used after a shift/MAX operation.<br>
11	CC       C=0<br><br>
100	MI/LT	N=l	Last result was negative.<br>
101	PL/GE	N=0	Last result was positive<br><br>
110	VS       V=l	Signed overflow/saturation on last result<br>
111	VC      V=0	No overflow/saturation on last result<br>
112	VP      V=l &amp; N=0	Overflow positive on last result.<br>
113	VN      V=l &amp; N=l	Overflow negative on last result<br><br>
1010	reserved<br>
1011	reserved<br><br>
1100	GT      N=0 &amp; Z=0<br>
1101	LE      N=l ! Z=l<br><br>
1110	AL<br>
1111	reserved<br>
Since Piccolo deals with signed quantities, the unsigned LS and HI conditions have been dropped and replaced by VP and VN which describe the direction of any overflow. Since the result of the ALU is 40 bits wide, MI and LT now perform the same function, similarly PL and GE. This leaves 3 slots for future expansion.<br>
All operations are signed unless otherwise indicated.<br>
The primary and secondary condition codes each consist of: N - negative. Z - zero. C - carry/unsigned overflow.<br>
V - signed overflow.<br>
Arithmetic instructions can be divided into two types; parallel and 'full width'. The 'full width' instructions only set the primary flags, whereas the parallel operators set the primary and secondary flags based on the upper and lower 16-bit halves of the result.<br>
The N, Z and V flags are calculated based on the full ALU result, after the scale has been applied but prior to being written to the destination. An ASR will always reduce the number of bits required to store the result, but an ASL would increase it. To avoid this Piccolo truncates the 40-bit result when an ASL scale is<br>
applied, to limit the number of bits over which zero detect and overflow must carried out.<br>
The N flag is calculated presuming signed arithmetic is being carried out. This is because when overflow occurs, the most significant bit of the result is either the C flag or the N flag, depending on whether the input operands are signed or unsigned.<br>
The V flag indicates if any loss of precision occurs as a result of writing the result to the selected destination. If no write-back is selected a 'size' is still implied, and the overflow flag is set correctly. Overflow can occur when:<br>
-Writing to a 16-bit register when the result is not in the range -2A15 to 2A15-1. -Writing to a 32-bit register when the result is not in the range -2A31 to 2A31-1.<br>
Parallel add/subtract instructions set the N, Z and V flags independently on the upper and lower halves of the result.<br>
When writing to an accumulator the V flag is set as if writing to a 32-bit register. This is to allow saturating instructions to use accumulators as 32-bit registers.<br>
The saturating absolute instruction (SABS) also sets the overflow flag if the absolute value of the input operand would not fit in designated destination.<br>
The Carry flag is set by add and subtract instructions and is used as a 'binary' flag by the MAX/MIN, SABS and CLB instructions. All other instructions, including multiply operations preserve the Carry flag(s).<br>
For add and subtract operations the Carry is that which is generated by either bit 31 or bit 15 or the result, based on whether the destination is 32 or 16-bits wide.<br>
The standard arithmetic instructions can be divided up into a number types, depending on how the flags are set:<br>
In the case of Add and Subtract instructions, if the N bit is set, then all flags are preserved. If the N bit is not set then the flags are updated as follows:<br>
Z is set if the full 40 bit result was 0.<br>
N is set if the full 40 bit result had bit 47 set (was negative).<br>
V is set if either:<br>
The destination register is 16-bit and the signed result will not fit into a 16-bit register (not in the range -2A15
The destination register is a 32/40 bit register and the signed result will not fit into 32 bits.<br>
If <dest> is a 32 or 40 bit register then the C flag is set if there is a carry out of bit 31 when summing <srcl> and <src2> or if no borrow occurred from bit 31 when subtracting <src2> from <srcl> (the same carry value you would expect on the ARM). If <dest> is a 16-bit register then the C flag is set if there is a carry out of bit 15 of the sum.<br>
The secondary flags (SZ, SN, SV, SC) are preserved.<br>
In the case of instructions which either carry out a multiplication or accumulate from a 40-bit register.<br>
Z is set if the full 40 bit result was 0.<br>
N is set if the full 40 bit result had bit 47 set (was negative).<br>
V is set if either (1) the destination register is 16-bit and the signed result will<br>
not fit into a 16-bit register (not in the range -2A15
destination register is a 32/40 bit register and the signed result will not fit into<br>
32 bits.<br>
C is preserved.<br>
The secondary flags (SZ, SN, SV, SC) are preserved.<br>
The other instructions, including logical operations, parallel adds and subtracts, max and tnin, shifts etc. are covered below.<br>
The Add and Subtract instructions add or subtract two registers, scale the result, and then store back to a register. The operands are treated as signed values. Flag updating for the non-saturating variants is optional and may be suppressed by appending an N to the end of the instruction.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
OPC specifies the type of instruction.<br><br>
Action (OPC):<br>
100NO 110NO 10001 11001<br>
01110<br>
01111<br>
101NO<br>
111NO<br>
dest = (srcl + Src2) (-» scale) (, N)<br>
dest = (srcl - src2) (-» scale) (, N)<br>
dest = SAT((srcl + src2) (-» scale))<br>
dest = SAT((srcl - src2) (-» scale))<br>
dest = (src2 - srcl) (-» scale)<br>
dest = SAT((src2 - srcl) (-» scale))<br>
dest = (srcl + src2 + Carry) (-» scale) (, N)<br>
dest = (srcl - src2 + Carry - 1) (-» scale) (, N)<br><br><br><br>
Mnemonics: 100NO 110NO 10001 11001 OHIO 01111 101NO 111NO<br><br><br>
(Table Removed) <br><br>
The assembler supports the following opcodes CMP  <srcl>, <src2> CMN <srcl>, <src2><br>
CMP is a subtract which sets the flags with the register write disabled. CMN is an add which sets the flags with register write disabled.<br>
Flags:<br>
These have been discussed above.<br>
Reasons for inclusion:<br>
ADC is useful for inserting carry into the bottom of a register following a shift/MAX/MN operation. It is also used to do a 32/32 bit divide. It also provides for extended precision adds. The addition of an N bit gives finer control of the flags, in particular the carry. This enables a 32/32 bit division at 2 cycles per bit.<br>
Saturated adds and subtracts are needed for G.729 etc.<br>
Incrementing/decrementing counters. RSB is useful for calculating shifts (x-32-x is a common operation). A saturated RSB is needed for saturated negation (used in G.729).<br>
Add/subtract accumulate instructions perform addition and subtraction with accumulation and scaling/saturation. Unlike the multiply accumulate instructions the<br><br>
accumulator number cannot be specified independently of the destination register. The bottom two bits of the destination register give the number, ace, of the 40 bit accumulator to accumulate into. Hence ADDA XO,X1,X2,AO and ADDA A3,X1,X2,A3 are valid, but ADDA X1,X1,X2,AO is not. With this class of instruction, the result must be written back to a register - the no writeback encodings of the destination field are not allowed.<br>
(Table Removed)<br>
OPC specifies the type of instruction. In the following ace is (DEST[1:0]). The Sa bit indicates saturation.<br>
Action (OPC):<br>
0	dest = {SAT}(acc + (srcl + src2)) {-» scale}<br>
1	dest = {SAT}(acc + (srcl - src2)) {-» scale}<br>
Mnemonics:<br><br>
(S}ADDA {S}SUBA<br><br><dest>, <srcl>, <src2>, <acc> {,<scale>} <dest>, <srcl>, <src2>, <acc> {,<scale>}<br><br><br><br>
Flags<br>
An S before the command indicates saturation.<br>
See above. Reasons for inclusion:<br>
The ADDA (add accumulate) instruction is useful for summing two words of an array of integers with an accumulator (for instance to find their average) per cycle. The SUBA (subtract accumulate) instruction is useful in calculating the sum of the differences (for correlation); it subtracts two separate values and adds the difference to a third register.<br>
Addition with rounding can be done by using <dest> different from <acc>. For example, XO=(X1+X2+16384)»15 can be done in one cycle by keeping 16384 in AO. Addition with a rounding constant can be done by ADDA XO,X1,#16384,AO.<br>
For a bit exact implementation of:<br>
sum of ((a_i * b_i)»k) (quite common - used in TrueSpeech) the standard Piccolo code would be:<br>
MUL      tl, a_0, b_0, ASR#k<br>
ADD      ans, ans, tl<br>
MUL      t2, a_l, b_l, ASR#k<br>
ADD      ans, ans, t2<br>
There are two problems with this code; it is too long and the adds are not to 40-bit precision so guard bits can't be used. A better solution is to use ADDA:<br>
MUL tl, a_0, b_0, ASR#k MUL t2, a_l, b_l, ASR#k ADDA ans, tl, t2, ans<br>
This gives a 25% speed increase and retains 40-bit accuracy.<br>
Add/Subtract in Parallel instructions perform addition and subtraction on two signed 16-bit quantities held in pairs in 32-bit registers. The primary condition code flags are set from the result of the most significant 16 bits, the secondary flags are<br>
updated from the least significant half. Only 32-bit registers can be specified as the source for these instructions, although the values can be halfword swapped. The individual halves of each register are treated as signed values. The calculations and scaling are done with no loss of precision. Hence ADDADD XO, XI, X2, ASR#1 will produce the correct averages in the upper and lower halves of XO. Optional saturation is provided for each instruction for which the Sa bit must be set.<br>
(Table Removed)C defines the operation. Action (OPC):<br>
0	dest.h = (srcl.h + src2.h) -» {scale},<br>
dest.l = (srcl.l + src2.1) -» {scale}<br>
1	dest.h = (srcl.h + src2.h) -» {scale},<br>
dest.l = (srcl.l - src2.1) -» {scale}<br><br>
100	dest.h = (srcl.h - src2.h) -» {scale},<br>
dest.l = (srcl.l + src2.1) -» {scale}<br>
101	dest.h = (srcl.h - src2.h) -» {scale},<br>
dest.l = (srcl.l - src2.1) -» {scale}<br>
Each sum/difference is independently saturated if the Sa bit is set.<br>
Mnemonics:<br>
0	{S}ADDADD	<dest>, <srcl_32>, <src2_32> {,<scale>}<br>
1	{S}ADDSUB	<dest>, <srcl_32>, <src2_32> {,<scale>}<br><br>
100	{S}SUBADD	<dest>, <srcl_32>, <src2_32> {,<scale>}<br>
101	{SjSUBSUB	<dest>, <srcl_32>, <src2_32> {,<scale>}<br>
An S before the command indicates saturation. The assembler also supports<br>
CMNCMN	<dest>, <srcl_32>, <src2_32> {,<scale>}<br>
CMNCMP	<dest>, <srcl_32>, <src2_32> {,<scale>}<br>
CMPCMN	<dest>, <srcl_32>, <src2_32> {,<scale>}<br>
CMPCMP	<dest>, <srcl_32>, <src2_32> {,<scale>}<br>
generated by the standard instructions with no write-back.<br>
Flags:<br>
C         is set if there is a carry out of bit 15 when adding the two upper<br>
sixteen bit halves.<br>
Z         is set if the sum of the upper sixteen bit halves is 0. N         is set if the sum of the upper sixteen bit halves is negative. V         is set if the signed 17 bit sum of the upper sixteen bit halves<br>
will not fit into 16 bits (post scale). SZ, SN, SV, and SC are set similarly for the lower 16-bit halves.<br>
Reason for inclusion:<br>
The parallel Add and Subtract instructions are useful for performing operations on complex numbers held in a single 32-bit register. They are used in the FFT kernel. It is also useful for simple addition/subtraction of vectors of 16-bit data, allowing two elements to be processed per cycle.<br>
The Branch (conditional) instruction allows conditional changes in control flow. Piccolo may take three cycles to execute a taken branch.<br>
(Table Removed)Action:<br>
Branch by offset if <cond> holds according to the primary flags.<br>
The offset is a signed 16-bit number of words. At the moment the range<br>
of the offset is restricted to -32768 to +32767 words.<br>
The address calculation performed is<br>
target address = branch instruction address + 4 + OFFSET<br>
Mnemonics:<br>
B<cond> ^destination label&gt;<br>
Flags:<br>
Unaffected.<br>
Reasons for inclusion:<br>
Highly useful in most routines.<br>
Conditional Add or Subtract instructions conditionally add or subtract src2 to<br>
srcl.<br>
(Table Removed)OPC specifies the type of instruction.<br>
Action (OPC):<br>
0         if (carry set) temp=srcl-src2 else temp=srcl+src2<br>
dest = temp {-» scale}<br>
1	if (carry set) temp=srcl-src2 else temp=srcl+src2<br>
dest = temp {-» scale} BUT if scale is a shift left<br>
then the new value of carry (from srcl-src2 or<br>
srcl+src2) is shifted into the bottom.<br>
Mnemonics:<br>
0	CAS    <dest>, <srcl>, <src2> {,<scale>}<br>
1	CASC <dest>, <srcl>, <src2> {,<scale>}<br>
Flags:<br>
See above. Reasons for inclusion:<br>
The Conditional Add or Subtract instruction enables efficient divide code to be constructed.<br>
Example 1: Divide the 32-bit unsigned value in XO by the 16-bit unsigned value in XI (with the assumption that XO 
LSL    XI, XI, #15	; shift up divisor<br>
SUB    XI, XI, #0	; set the carry flag<br>
REPEAT #16<br>
CASC XO, XO, XI, LSL#1<br>
NEXT<br>
At the end of the loop XO.l holds the quotient of the divide. The remainder can be recovered from XO.h depending on the value of carry.<br>
Example 2: Divide the 32-bit positive value in XO by the 32-bit positive value in XI, with early termination.<br>
MOV	X2, #0	; clear the quotient<br>
LOG	ZO, XO	; number of bits XO can be shifted<br>
LOG	Zl, XI	; number of bits XI can be shifted<br>
SUBS BLT LSL ADD SUBS REPEAT CAS ADCN NEXT div end<br>
ZO, Zl, ZO<br>
div_end<br>
XI, XI, ZO<br>
ZO, ZO, #1<br>
ZO, ZO, #0<br>
ZO<br>
XO, XO, XI, LSL#1<br>
X2, X2, X2<br><br>
; XI shift up so 1's match ; X1&gt;XO so answer is 0 ; match leading ones ; number of tests to do ; set carry<br>
At the end, X2 holds the quotient and the remainder can be recovered from XO. The Count Leading Bits instruction allows data to be normalised.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed) <br>
Action:<br>
dest is set to the number of places the value in srcl must be shifted left in order for bit 31 to differ from bit 30. This is a value in the range 0-30 except in the special cases where srcl is either -1 or 0 where 31 is returned.<br>
Mnemonic:<br>
CLB    <dest>, <srcl><br>
Flags:<br>
Z	is set if the result is zero.<br>
N	is cleared.<br>
C	is set if srcl is either -1 or 0.<br>
V	is preserved.<br>
Reasons for inclusion:<br>
Step needed for normalisation.<br>
Halt and Breakpoint instructions are provided for stopping Piccolo execution<br>
 (Table Removed)<br>
OPC specifies the type of instruction.<br>
Action (OPC):<br>
0	Piccolo execution is stopped and the Halt bit is set in the<br>
Piccolo status register.<br>
1	Piccolo execution is stopped, the Break bit is set in the<br>
Piccolo status register and the ARM is interrupted to say<br>
that a breakpoint has been reached.<br>
Mnemonics:<br>
0	HALT<br>
1	BREAK<br>
Flags:<br>
Unaffected<br>
Logical Operation instructions perform a logical operation on a 32 or 16-bit register. The operands are treated as unsigned values.<br><br>
(Table Removed)<br>
OPC encodes the logical operation to perform. Action (OPC):<br>
0	dest = (srcl &amp; src2) {-» scale}<br>
1	dest = (srcl ] src2) {-» scale}<br><br>
10	dest = (srcl &amp; ~src2) {-» scale}<br>
11	dest = (srcl A src2) {-» scale}<br>
Mnemonics:<br>
0	AND   <dest>, <srcl>, <src2> {,<scale>}<br>
1	ORR   <dest>, <srcl>, <src2> {,<scale>}<br><br>
10	BIC     <dest>, <srcl>, <src2> {,<scale>}<br>
11	EOR   <dest>, <srcl>, <src2> {,<scale>}<br>
The assembler supports the following opcodes<br>
TST     <srcl>, <src2> TEQ    <srcl>, <src2><br><br>
TST is an AND with the register write disabled. TEQ is an EOR with the register write disabled.<br>
Flags:<br>
Z	is set if the result is all zeros<br>
N, C, V	are preserved<br>
SZ, SN, SC, SV are preserved<br>
Reasons for inclusion:<br>
Speech compression algorithms use packed bitfields for encoding  information. Bitmasking instructions help for extracting/packing these fields.<br>
Max  and  Min  Operation instructions perform maximum and minimum operations.<br><br>
(Table Removed)<br>
OPC specifies the type of instruction. Action (OPC):<br>
0	dest = (srcl 
1	dest = (srcl &gt; src2) ? srcl : src2<br>
Mnemonics:<br>
0	MIN    <dest>, <srcl>, <src2><br>
1	MAX  <dest>, <srcl>, <src2><br>
Flags:<br>
Z         is set if the result is zero N         is set if the result is negative C         For Max: C is set if src2&gt;=srcl (dest=srcl case) For Min: C is set if src2&gt;=srcl (dest=src2 case) V        preserved.<br>
Reasons for inclusion:<br>
In order to find the strength of a signal many algorithms scan a sample to find the minimum/maximum of the absolute value of the samples. The MAX and MIN operations are invaluable for this. Depending on whether you wish to find the first or last maximum in the signal the operands srcl and src2 can be swapped around.<br>
MAX  XO, XO, #0 will convert XO to a positive number with clipping below. MIN    XO, XO, #255 will clip XO above. This is useful for graphics processing.<br>
Max and Min Operations in Parallel instructions perform maximum and<br>
minimum operations on parallel 16-bit data.<br><br>
(Table Removed)OPC specifies the type of instruction.<br>
Action (OPC):<br>
0         dest.1 = (srcl.l 
dest.h = (srcl.h 
1	dest.1 = (srcl.l &gt; src2.1) ? srcl.l : src2.1<br>
dest.h = (srcl.h &gt; src2.h) ? srcl.h : src2.h<br>
Mnemonics:<br>
0	MINMIN        <dest>, <srcl>, <src2><br>
1	MAXMAX     <dest>, <srcl>, <src2><br>
Flags:<br>
Z         is set if the upper 16 bits of the result is zero<br>
N         is set if the upper 16 bits of the result is negative C         For Max: C is set if src2.h&gt;=srcl.h (dest=srcl case) For Min: C is set if src2.h&gt;=srcl.h (dest=src2 case)<br>
V        preserved.<br>
SZ,SN,SC,SV are set similarly for the lower 16-bit halves.<br>
Reasons for inclusion:<br>
As for 32-bit Max and Min.<br>
Move Long Immediate Operation instructions allow a register to be set to any signed 16-bit, sign extended value. Two of these instructions can set a 32-bit register to any value (by accessing the high and low half in sequence). For moves between registers see the select operations.<br>
 (Table Removed)<br>
Mnemonics:<br>
MOV  <dest>, #<imm_16><br>
The assembler will provide a non-interlocking NOP operation using this MOV instruction, i.e. NOP is equivalent to  MOV , #0.<br>
Flags:<br>
Flags are unaffected.<br>
Reasons for inclusion: Initialising registers/counters.<br>
Multiply Accumulate Operation instructions perform signed multiplication with accumulation or de-accumulation, scaling and saturation.<br><br>
(Table Removed)The field OPC specifies the type of instruction. Action (OPC):<br>
0	dest = (ace + (srcl * src2)) {-» scale}<br>
1	dest = (ace - (srcl * src2)) {-» scale}<br>
In each case the result is saturated before being written to the destination if the Sa bit is set.<br>
Mnemonics:<br>
0	{SjMULA        <dest>, <srcl_16>, <src2_16>, <acc> {,<scale>}<br>
1	{S}MULS         <dest>, <srcl_16>, <src2_16>, <acc> {,<scale>}<br>
An S before the command indicates saturation.<br>
Flags:<br>
See section above. Reasons for inclusion:<br>
A one cycle sustained MULA is required for FIR code. MULS is used in the FFT butterfly. A MULA is also useful for multiply with rounding. For example AO=(XO*X1+16384)»15 can be done in once cycle by holding 16384 in another accumulator (Al for example). Different <dest> and <acc> is also required for the FFT kernel.<br>
Multiply Double Operation instructions perform signed multiplication, doubling the result prior to accumulation or de-accumulation, scaling and saturation.<br><br>
(Table Removed)<br>
OPC specifies the type of instruction.<br>
Action (OPC):<br>
0	dest = SAT((acc + SAT(2 * srcl * src2)) {-» scale})<br>
1	dest = SAT((acc - SAT(2 * srcl * src2)) {-» scale})<br>
Mnemonics:<br>
0	SMLDA	<dest>, <srcl_16>, <src2_16>, <acc> {,<scale>}<br>
1	SMLDS	<dest>, <srcl_16>, <src2_16>, <acc> {,<scale>}<br>
Flags:<br>
See section above. Reasons for inclusion:<br>
The MLD instruction is required for G.729 and other algorithms which use fractional arithmetic. Most DSPs provide a fractional mode which enables a left shift of one bit at the output of the multiplier, prior to accumulation or writeback. Supporting this as a specific instruction provides more programming flexibility. The name equivalents for some of the G series basic operations are:<br>
L_msu =&gt; SMLDS L_mac =&gt; SMLDA<br>
These make use of the saturation of the multiplier when left shifting by one bit. If a sequence of fractional multiply-accumulates is required, with no loss of precision, MULA can be used, with the sum maintained in 33.14 format. A left shift and saturate can be used at the end to convert to 1.15 format, if required.<br>
Multiply Operation instructions perform signed multiplication, and optional scaling/saturation. The source registers (16-bit only) are treated as signed numbers.<br><br>
(Table Removed)OPC specifies the type of instruction. Action (OPC):<br>
0	dest = (srcl * src2) {-» scale}<br>
1	dest = SAT((srcl * src2) {-» scale})<br>
Mnemonics:<br>
0	MUL   <dest>, <srcl_16>, <src2> {,<scale>}<br>
1	SMUL	<dest>, <srcl_16>, <src2> {,<scale>}<br>
Flags:<br>
See section above.<br>
Reasons for inclusion:<br>
Signed and saturated multiplies are required by many processes.<br>
Register List Operations are used to perform actions on a set of registers. The Empty and Zero instructions are provided for resetting a selection of registers prior to, or in between routines. The Output instruction is provided to store the contents of a list of registers to the output FIFO.<br><br><br>
(Table Removed)OPC specifies the type of instruction. Action (OPC):<br>
000	for (k=0; k
if bit k of the register list is set then register k is marked as being empty.<br>
001	for (k=0; k
if bit k of the register list is set then register k is set to contain 0.<br>
10	Undefined<br>
11	Undefined<br>
100	for (k=0; k
if bit k of the register list is set then<br>
(register k -» scale) is written to the output FIFO.<br>
101	for (k=0; k
if bit k of the register list is set then<br>
(register k -» scale) is written to the output FIFO and<br>
register k is marked as being empty.<br>
110	for (k=0; k
if bit k of the register list is set then - SAT(register k -» scale) is written to the output FIFO.<br>
111	for (k=0; k
if bit k of the register list is set then<br>
SAT(register k -» scale) is written to the output FIFO and<br>
register k is marked as being empty.<br>
Mnemonics:<br>
0	EMPTY	<register_list><br>
1	ZERO	<register_list><br><br>
10	Unused<br>
11	Unused<br><br>
100	OUTPUT	<register_list>   {,<scale>}<br>
101	OUTPUT	<register_list>A {,<scale>}<br><br>
110	SOUTPUT	<register_list>   {,<scale>}<br>
111	SOUTPUT	<register_list>A   {,<scale>}<br>
Flags:<br>
Unaffected<br>
Examples:<br>
EMPTY	{AO, Al, XO-X3}<br>
ZERO	{YO-Y3}<br>
OUTPUT        {XO-Y1}A<br>
The assembler will also support the syntax<br>
OUTPUT        Rn<br>
In which case it will output one register using a MOV A, Rn instruction. The EMPTY instruction will stall until all registers to be empties contain valid data<br>
(i.e. are not  empty).<br>
Register list operations must not be used within re-mapping REPEAT loops. The OUTPUT instruction can only specify up to eight registers to output. Reasons for inclusion:<br>
After a routine has finished, the next routine expects all registers to be empty so it can receive data from the ARM. An EMPTY instruction is needed to accomplish this. Before performing a FIR or other filter all accumulators and partial results need to be zeroed. The ZERO instruction helps with this. Both are designed to improve code density by replacing a series of single register moves. The OUTPUT instruction is included to improve code density by replacing a series of MOV A, Rn instructions.<br>
A Remapping Parameter Move Instruction RMOV is provided to allow the configuration of the user defined register re-mapping parameters.<br>
The instruction encoding is as follows:<br><br>
(Table Removed)<br>
Each PARAMS field is comprised of the following entries:<br>
(Table Removed)<br>
The meaning of these entries is described below<br>
PARAMETER<br>
DESCRIPTION<br><br>
RENUMBER<br>
Number of 16-bit registers to perform re-mapping on, may take the values 0, 2, 4, 8.<br>
Registers below RENUMBER are re-mapped, those above are accessed directly.<br><br>
BASEINC<br>
The amount the base pointer is incremented at the end of each loop. May take the values 1, 2, or<br>
4.<br><br>
BASEWRAP<br>
The base wrapping modulus may take the values 2, 4, 8.<br>
Mnemonics:<br>
RMOV <params>, [<params>] The <params> field has the following format:<br><params>    ::=  <bank><baseinc> n<renumber> w<basewrap><br><bank>       ::= [X]Y|Z] <baseinc>   ::= [++|+l|+2|+4] <renumber> ::= [0!2|4J8] <basewrap> ::= [2J4J8]<br>
If the RMOV instruction is used whilst re-mapping is active, the behaviour will depend upon the particular hardware implementation and cannot be relied upon by a programmer.<br>
Flags:<br>
Unaffected<br>
Repeat Instructions provide four zero cycle loops in hardware. The REPEAT instruction defines a new hardware loop. Piccolo uses hardware loop 0 for the first REPEAT instruction, hardware loop 1 for a REPEAT instruction nested within the first repeat instruction and so on. The REPEAT instruction does not need to specify which loop is being used. REPEAT loops must be strictly nested. If an attempt is made to nest loops to a depth greater than 4 then the behaviour is unpredictable.<br>
Each REPEAT instruction specifies the number of instructions in the loop (the loop instructions immediately following the REPEAT instruction) and the number of times to go around the loop (which is either a constant or read from a Piccolo register).<br>
If the number of instructions in the loop is small (1 or 2) then Piccolo may take extra cycles to set the loop up.<br>
If the loop count is register-specified, a 32-bit access is implied<br>
though only the bottom 16 bits are significant and the number is considered to be unsigned. If the loop count is zero, then the action of the loop depends upon the particular hardware implementation and cannot be relied upon by a programmer. A copy of the loop count is taken so the register can be immediately reused (or even refilled) without affecting the loop.<br>
The REPEAT instruction provides a mechanism to modify the way in which register operands are specified within a loop. The details are described above<br>
Encoding of a REPEAT with a register specified number of loops:<br><br>
(Table Removed)Encoding of REPEAT with a fixed number of loops:<br><br>
(Table Removed)<br>
The RFIELD operand specifies which of 16 re-mapping parameter configurations to use inside the loop.<br>
(Table Removed)<br>
The assembler provides two opcodes REPEAT and NEXT for defining a hardware loop. The REPEAT goes at the start of the loop and the NEXT delimits the end of the loop, allowing the assembler to calculate the number of instructions<br>
in the loop body. For the REPEAT it is only necessary to specify the number of loops either as a constant or register. For example:<br>
REPEAT	XO<br>
MULA	AO, YO.l , ZO.l , AO<br>
MULA	AO, YO.hA, ZO.hA, AO<br>
NEXT<br>
This will execute the two MULA instructions XO times. Also,<br>
REPEAT        #10<br>
MULA	AO, XOA, YOA, AO<br>
NEXT<br>
will perform 10 multiply accumulates. The assembler supports the syntax:<br>
REPEAT iterations [, <params>]<br>
To specify the re-mapping parameters to use for the REPEAT. If the required remapping parameters are equal to one of the predefined set of parameters, then the appropriate REPEAT encoding is used. If it is not then the assembler will generate an RMOV to load the user defined parameters, followed by a REPEAT instruction. See the section above for details of the RMOV instruction and the re-mapping parameters format.<br>
If the number of iterations for a loop is 0 then the action of REPEAT depends upon the particular hardware implementation and cannot be relied upon by a<br>
programmer.<br>
If the number of instructions field is set to 0 then the action of REPEAT depends upon the particular hardware implementation and cannot be relied upon by a programmer.<br>
A loop consisting of only one instruction, with that instruction being a branch will have behaviour that depends upon the particular hardware implementation and cannot be relied upon by a programmer.<br>
Branches within the bounds of a REPEAT loop that branch outside the bounds of that loop will have a result that depends upon the particular hardware implementation and cannot be relied upon by a programmer.<br>
The Saturating Absolute instruction calculates the saturated absolute of source 1.<br><br>
(Table Removed)Action:<br>
dest = SAT((srcl &gt;= 0) ? srcl : -srcl). The value is always saturated. In particular the absolute value of 0x80000000 is OxTfffffff and NOT 0x80000000!<br>
Mnemonic:<br>
SABS <dest>, <srcl><br>
Flags:<br>
is set if the result is zero.<br>
N       is preserved.<br>
C       is set of srcKO (dest=-srcl case)<br>
V       is set if saturation occured.<br>
Reasons for inclusion:<br>
Useful in many DSP applications.<br>
Select Operations (Conditional Moves) serve to conditionally move either source 1 or source 2 into the destination register. A select is always equivalent to a move. There are also parallel operations for use after parallel adds/subtracts.<br>
Note that both source operands may be read by the instruction for implementation reasons and so if either one is empty the instruction will stall, irrespective of whether the operand is strictly required.<br><br>
(Table Removed)OPC specifies the type of instruction.<br>
Action (OPC):<br>
00      If <cond> holds for primary flags	then dest=srcl<br>
else dest=src2.<br>
01       If <cond> holds for the primary flags        then dest.h=srcl.h<br>
else dest.h=src2.h,<br>
If <cond> holds for the secondary flags     then dest.l=srcl.l<br>
else dest.l=src2.1.<br>
10      If <cond> holds for the primary flags        then dest.h=srcl.h<br>
else dest.h=src2.h,<br>
If <cond> fails for the secondary flags        then dest.l=srcl.l<br>
else dest.l=src2.1.<br><br>
11        Reserved<br>
Mnemonics<br>
00       SEL<cond><dest>, <srcl>, <src2><br>
01        SELTT<cond><dest>, <srcl>, <src2><br></src2></srcl></dest></cond></src2></srcl></dest></cond></cond></cond></cond></cond></cond></srcl></dest></params></basewrap></renumber></baseinc></bank></basewrap></renumber></baseinc></bank></params></params></params></params></scale></register_list></scale></register_list></scale></register_list></scale></register_list></register_list></register_list></scale></src2></srcl_16></dest></scale></src2></srcl_16></dest></scale></acc></src2_16></srcl_16></dest></scale></acc></src2_16></srcl_16></dest></acc></dest></scale></acc></src2_16></srcl_16></dest></scale></acc></src2_16></srcl_16></dest></imm_16></dest></src2></srcl></dest></src2></srcl></dest></src2></srcl></dest></src2></srcl></dest></src2></srcl></src2></srcl></scale></src2></srcl></dest></scale></src2></srcl></dest></scale></src2></srcl></dest></scale></src2></srcl></dest></srcl></dest></scale></src2></srcl></dest></scale></src2></srcl></dest></cond></cond></scale></src2_32></srcl_32></dest></scale></src2_32></srcl_32></dest></scale></src2_32></srcl_32></dest></scale></src2_32></srcl_32></dest></scale></src2_32></srcl_32></dest></scale></src2_32></srcl_32></dest></scale></src2_32></srcl_32></dest></scale></src2_32></srcl_32></dest></acc></dest></scale></acc></src2></srcl></dest></scale></acc></src2></srcl></dest></src2></srcl></src2></srcl></dest></srcl></src2></src2></srcl></dest></cond></basewrap></renumber></baseinc></bank></basewrap></renumber></baseinc></bank></params></imm_6></immed_8></scale></dest></acc></src2_shift></src2_par></src2></src2_shift></src2></src2_maxmin></scale></immed_6></immed_8></scale></src2></srcl_32></srcl_16></srcl></scale></lscale></size></size></cond></dest></dest></dest></dest></dest></wrap></wrap></size></wrap></dest></size></size></wrap></dest></wrap></dest></dest></size></dest></dest></size></size></size></size></size></bank></cond></wrap></size></dest></bank></dest></cond></dest></cond></bank></cond></size></wrap></dest></cond></size></dest></cond></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">163-del-1998-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">163-del-1998-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWNvbXBsZXRlIHNwZWNpZmljYXRpb24gKGdyYW50ZWQpLnBkZg==" target="_blank" style="word-wrap:break-word;">163-del-1998-complete specification (granted).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">163-del-1998-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWNvcnJlc3BvbmRlbmNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">163-del-1998-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">163-del-1998-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">163-del-1998-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">163-del-1998-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWZvcm0tMTMucGRm" target="_blank" style="word-wrap:break-word;">163-del-1998-form-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWZvcm0tMTkucGRm" target="_blank" style="word-wrap:break-word;">163-del-1998-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">163-del-1998-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWZvcm0tMjkucGRm" target="_blank" style="word-wrap:break-word;">163-del-1998-form-29.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">163-del-1998-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWZvcm0tNC5wZGY=" target="_blank" style="word-wrap:break-word;">163-del-1998-form-4.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWZvcm0tNi5wZGY=" target="_blank" style="word-wrap:break-word;">163-del-1998-form-6.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LWdwYS5wZGY=" target="_blank" style="word-wrap:break-word;">163-del-1998-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LXBjdC0yMTAucGRm" target="_blank" style="word-wrap:break-word;">163-del-1998-pct-210.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LXBjdC0yMjAucGRm" target="_blank" style="word-wrap:break-word;">163-del-1998-pct-220.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LXBldGl0aW9uLTEzNy5wZGY=" target="_blank" style="word-wrap:break-word;">163-del-1998-petition-137.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYzLWRlbC0xOTk4LXBldGl0aW9uLTEzOC5wZGY=" target="_blank" style="word-wrap:break-word;">163-del-1998-petition-138.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QuanBn" target="_blank" style="word-wrap:break-word;">abstract.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="232090-a-data-transmitting-receiving-satellite-terminal.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="232092-a-process-for-the-preparation-of-4s-5r-n-boc-2-2-4-dimethoxyphenyl-4-isobutyl-1-oxazolidine-5-carboxylic-acid.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>232091</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>163/DEL/1998</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>13/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>27-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>15-Mar-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>28-Jan-1998</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>ARM LIMITED,</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>110 FULBOURN ROAD, CHERRY HINTON,CAMBRIDGE CB1 9NJ,ENGLAND.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>DOMINIC SYMES</td>
											<td>7 WEDGEWOOD DRIVE,CHERRY HINTON,CAMBRIDGE,CB1 4HY</td>
										</tr>
										<tr>
											<td>2</td>
											<td>RICHARD YORK</td>
											<td>6 VIOLET CLOSE,CHERRY HINTON,CAMBRIDGE,CB1 4YW</td>
										</tr>
										<tr>
											<td>3</td>
											<td>DAVID JAMES SEAL</td>
											<td>68 KEYNES ROAD,CAMBRIDGE CB5 8PR</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F17/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>9712041.4</td>
									<td>1997-06-10</td>
								    <td>U.K.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/232091-apparatus-and-method-for-processing-data by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:58:08 GMT -->
</html>
