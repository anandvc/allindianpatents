<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/277989-method-and-system-for-verifying-trust-of-a-file by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 00:11:00 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 277989:METHOD AND SYSTEM FOR VERIFYING TRUST OF A FILE</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD AND SYSTEM FOR VERIFYING TRUST OF A FILE</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Systems and methods for validating integrity of an executable file are described. In one aspect, the systems and methods determine that an executable file is being introduced into a path of execution. The executable file is then automatically evaluated in view of multiple mal ware checks to detect if the executable file represents a type of mal ware. The multiple mal ware checks are integrated into an operating system trust verification process along the path of execution.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>TECHNICAL FIELD<br>
[0001] This disclosure relates to data authentication and verification.<br>
BACKGROUND<br>
[0002] An executable file (e.g., a binary image, object code, portable executables (PEs), macros, scripts like Visual Basic script (VBS), etc.) can be risky to run on a computer as it may contain a virus or a Trojan horse. A virus is a program or piece of code that modifies a binary image on disk, typically against the user's wishes and without the user's knowledge. Viruses can also replicate themselves. A simple virus that can make a copy of itself over and over again is relatively easy to produce. Even simple viruses are dangerous because they may quickly use all available memory and bring a system to a hah. Some viruses are capable of transmitting themselves across networks and bypassing security systems. Unlike viruses, Trojan horses do not replicate themselves but they can be just as destructive, often masquerading as benign applications that can be launched by an unsuspecting user. One type of Trojan horse is a program that claims to rid your computer of viruses but instead introduces viruses onto your computer.<br>
[0003] One approach to identify executable code that has been corrupted, for example, with a virus or a Trojan horse, involves the use of trusted cryptographic hashes when installing or downloading an executable onto a computing device, A cryptographic hash, or simply a "hash", compiles an executable into a summarized form, or digest. A trusted hash is known to be good, or represent uncorrupted code, at the time of the hashes' creation (e.g., at build time). To generate trusted hashes for an executable file (i.e., a binary image, executable code, scripts, macros, etc.), a message digest or checksum calculation is performed on the executable, including associated resources such as data, to obtain a first trusted result (e.g., at build time) before transferring the executable from one location to another. The same calculation is made on the transferred executable to obtain a<br>
 <br>
second result. The first trusted result is compared to the second result to determine if the received executable is the same data that was originally sent. For instance, if the before and after calculation results match, then the received data is likely accurate. Otherwise, the received executable has been corrupted. In this manner, the risk of downloading or installing a corrupted binary image has been effectively reduced.<br>
[0004] Although conventional techniques to verify files at installation reduce the risk of installing files associated with trusted hashes, these conventional techniques do not reduce the risk of installing files from untrusted sources (e.g., without a trusted hash or signature of the file), executing files after they have been installed onto a computing device, or executing files that are part of the basic input output system (BIOS). Problems associated with installing a file from an untrusted source onto a computing system are well known. To make matters worse, files verified for integrity at installation-time can be corrupted after installation, making any initial trust verification evaluations obsolete. Additionally, today's computer systems have no inherent mechanism to distinguish between trusted and suspect or malicious executable object codes. In the case of a file loaded into BIOS firmware, when the file is loaded for execution during boot-up operations, conventional systems typically do not have enough code integrity checking infrastructure in place (loaded) at that time to adequately perform code integrity or any other type of virus, spy ware, or other malicious software (malware) check on the file prior to its execution as part of the boot-up process.<br>
SUMMARY<br>
[0005] Systems and methods for validating integrity of an executable file are described. In one aspect, the systems and methods determine that an executable file is being introduced into a path of execution. The executable file is then automatically evaluated in view of multiple malware checks to detect if the executable file represents a<br>
 <br>
type of malware.   The multiple malware checks are integrated into an operating system trust verification process along the path of execution.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[0006] In the Figures, the left-most digit of a component reference number identifies the particular Figure in which the component first appears.<br>
[0007] Fig. 1 illustrates an exemplary system for verifying trust of executable files.<br>
[0008] Fig. 2 shows an exemplary procedure for verifying trust of executable files.<br>
[0009] Fig. 3 shows an example of a suitable computing environment in which systems and methods for verifying trust of executable files may be fully or partially implemented.<br>
DETAILED DESCRIPTION Overview<br>
[0010] The systems and methods for verifying trust of executable files address the limitations of conventional code integrity checking techniques and independent (non-integrated) malware checks by providing a comprehensive trust verification facility that is integrated into an operating system (OS). The trust verification facility includes multiple trust verifiers that are automatically invoked when executable files are being installed onto a system, and when code is being mapped into memory for execufion. Respective ones of the trust verifiers determine if the executable code is from a trusted source (e.g., code signed by a trusted certificate authority) and further evaluate the executable code for Trojan Horses (code integrity), viruses, spyware, and/or other types of known malware. Known Malware is malware associated with a known malware signature or other known malware characteristic.<br>
[0011] If the code is determined to be malware, the systems and methods for verifying trust of executable files mark the code "untrusted", or untrustworthy. Untrusted<br>
 <br>
code is not installed or executed. If the code is determined not to be from a trusted source and determined not to be a known type of malware, a system administrator is provided with an opportunity to authorize the trustworthiness of the code (e.g., by digitally signing the file with a local key). This opportunity is presented to the system administrator in view of respective indications from a trust verifier chain that the code does not represent a known-type of malware. As such, the system administrator can make an educated decision as to whether to install or execute code that has not been validated by an outside trusted 3 party. Once code is marked trustworthy, if the code is ever subsequently modified (e.g., introducing a Trojan horse), such modification will be detected prior to execution by the systems and methods for trust verification, and the code will not be allowed to execute.<br>
[0012] In view of the above, only after the systems and methods for verifying trust of executable files indicate that an executable file is not a known type of malware, do the systems and methods allow the executable file to be installed or executed. This is in stark contrast to conventional systems, which do not automatically perform multiple file malware evaluations on an executable file during installation or immediately prior to being loaded into memory for execution. Additionally, the integration of multiple trust verifications into an operating system is very different from conventional systems, wherein virus, spy ware, or other forms of checking for malware are stand alone processes, processes that are not integrated into an operating system.<br>
[0013] These and other aspects of the systems and methods for verifying trust of executable files are now described in greater detail.<br>
An Exemplary System<br>
[0014] Although not required, the systems and methods for verifying trust of executable files are described in the general context of computer-executable instructions (program   modules)   being   executed  by   a  computing  device   such   as   a  personal<br>
 <br>
computer. Program modules generally include routines, programs, objects, components, data structures, etc., that perform particular tasks or implement particular abstract data types. While the systems and methods are described in the foregoing context, acts and operations described hereinafter may also be implemented in hardware.<br>
[0015] Fig. 1 illustrates an exemplary system 100 for verifying trust of executable files. In this implementation, system 100 includes computing device 102. Computing device 102 is any type of computing device such as a personal computer, a laptop, a server, small form factor mobile computing device (e.g., a cellular phone, personal digital assistant, or handheld computer), etc. Computing device 102 includes program modules 104 and program data 106. Program modules 102 include, for example, operating system 108 to provide a runtime environment, and other program modules 110 such as executable object code (e.g., binary images, PE files, DLLs, scripts, etc.). As part of the runtime environment, operating system 108 includes trust verifier module 112, which provides an integrated file trust verification facility.<br>
[0016] Responsive to detecting, by operating system 108, that an executable file (e.g., object code, scripts, DLLs, etc.) is being installed onto computing device 102, and/or loaded into memory for execution, trust verifier 112 determines whether the executable code is from a trusted source (e.g., a trusted certificate authority) and implements multiple trust verification checks to determine if the executable code is a known type of malware (e.g., does the code include a Trojan horse, virus, spyware, etc.). Techniques for determining that a file is being installed onto a computing device, loaded (e.g., paged) into memory for execution, whether a file is an executable file, and for evaluating whether a file is from a trusted authority are known.<br>
[0017] Executable file trust verification checks implemented by trust verifier 112 include, for example, code integrity, virus, spy ware, and/or other malware checks. Techniques to evaluate code integrity of an executable file by comparing a trusted full<br>
 <br>
image hash (if present) of the executable file, to a computed full hash of the executable file are known. Additionally, techniques to check an executable file for a virus or a Trojan horse are known. Exemplary techniques for trust verifier 112 to perform partial image hash verification operations responsive to a portion of an executable file being loaded into memory for execution are described in U.S. Patent Application serial no, 11/037,566, titled "Systems and Methods for Validating Executable File Integrity Using Partial Image Hashes", filed on 01/18/2005, commonly assigned hereto, and hereby incorporated by reference. A partial image hash is a hash of less than an entire executable file. For instance, a partial image hash is a hash of one or more pages of an executable file (e,g., in the case of a PE file, and/or the like) or portions of the executable file not tied to page boundaries (e.g., in the case of a script, and/or the like).<br>
[0018] In one implementation, trust verifier 112 verifies trust of an executable file with respective plug-in modules for one or more of digital certificate checking, virus, Trojan horse, spy ware, and/or other malware checks. For purposes of exemplary illustration, such plug-in modules are shown as respective portions of "other program modules" 110. In one implementation, the various malware checks implemented by trust verifier 112 trust chain can be customized. For example, plug-in modules that implement respective ones of the malware checks can be added and/or removed from the trust chain.<br>
[0019] In one implementation, when accessing functionality associated with a particular malware check, trust verifier 112 detects whether the particular malware check is deactivated, and/or whether a non-authorized substitute for the particular malware check has been introduced into the trust chain. In one implementation, trust verifier 112 determines whether functionality associated with a particular malware check, and/or whether a malware check plug-in module is an authorized module by referencing a trusted list of malware check plug-ins.   In this implementation, such a list is maintained by an<br>
 <br>
administrator, or other authorized entity. For purposes of exemplary illustration, such a list is shown as a respective portion of "other data" 114.<br>
[0020] If trust verifier 112 determines that the executable file is from a trusted source and not malware (e.g., no virus, no spy ware, no Trojan horse -successful hash checks, and/or so on), operating system 108 allows the process which triggered the trust verification process (e.g., file installation operations or operations to load the file into memory for execution) to complete. However, if trust verifier 112 determines that the executable file is not from a trusted source, and also determines that the executable file is not to be a known type of malware, trust verifier 112 (or operating system 108) provides a system administrator with an opportunity to authorize the trustworthiness of the executable file (e.g., by signing the file with a local key), indicate that the file is of quesfionable trustworthiness, or indicate that the file is untrustworthy. (Techniques for signing with a local key are known).<br>
[0021] In one implementation, when an executable file is determined not to be from a trusted source and determined not to be a known type of malware, trust verifier 112 (or operating system 108) presents a dialog box or other user interface (UI) component (e.g., voice controlled) to the administrator to allow the administrator to authorize the trustworthiness, questionable trustworthiness, or untrustworthiness of the executable file. For purposes of exemplary illustration, such a UI is shown as a respective portion of "other data" 114. In this scenario, and because trust verifier 112 evaluates the executable file in view of multiple malware checks, trust verifier 112 provides an administrator with substantially superior levels of knowledge regarding the file's trustworthiness, as compared to conventional systems and techniques. Thus, the system administrator can make an educated decision as to whether to authorize the file's trustworthiness, and subsequently allow or bar file installation and/or execution of code that has not been previously validated by a trusted outside 3rdparty.<br>
 <br>
[0022] In view of the above, trust verification 112 operations are invoked at various times associated with computer-program installation and execution operations. For purposes of description, these various times are referred to as times when the program is being "introduced into a path of execution." In this implementation, for example, trust verification operations are invoked both during program installation and after program installation (e.g., responsive to determining that the program is targeted for loading into memory for execution). In another implementation, trust verifier 112 operations are implemented at one or more of the above-described times, and/or at other time(s) associated with when the program is introduced into a path of execution.<br>
[0023] If trust verifier 112 determines that the executable file is malware (regardless of whether it is signed by a trusted source), trust verifier 112 (or operating system 108) marks the code "untrusted", or untrustworthy. In this scenario, and if the trust verifier operations are responsive to code installation operations, operating system 108 does not install the untrusted code onto computing device 102. Additionally, if the trust verifier operations are responsive to operating system 108 preparation(s) to load the code into memory for execution, operating system 108 does not allow the untrusted code to be loaded into memory for execution. This means that even if an executable file is marked trustworthy, as described above, if the code is ever subsequently modified (e.g., introducing a Trojan horse), such modification will be detected by trust verifier 112 prior to execution of the code, and the code will not be allowed to execute.<br>
[0024] Exemplary trust verifier 112 trust chain operations (i.e., malware detection operations) are now described.<br>
 <br>
Exemplary Protection Path<br>
[0025] Trust verifier 112 or operating system 108, responsive to determining that an executable file targeted for installation onto computing device 102 or loading into memory for execution is not trustworthy, automatically implements a customizable protection path. For example, in one implementation, the protection path includes one or more of the following actions:<br>
•	tagging the executable file as untrustworthy;<br>
•	directing an installation module not to install the file, or directs memory manager 116 not to load any portion of the file into memory for execution;<br>
•	throwing an associated event identifying the failed file verification, and/or<br>
•	writing the event to an event log;<br>
•	automatically evaluating substantially all files (executable and data files) on computing device 102 to determine if respective ones of the files are from a trusted source and represent a known type of malware; and/or<br>
•	powering down computing device 102.<br>
In one implementation, the protection path identifies one or more action rules for implementation when a file fails trust verification, the alert(s) to be sent, logging operations to be taken, etc. In one implementation, the protection path is based on group policy and/or user interface settings to provide a uniform user experience.<br>
An Exemplary Procedure<br>
[0026] Fig. 2 shows an exemplary procedure 200 for verifying trust of executable files. For purposes of discussion and illustration, operations of the procedure are described with respect to components of Fig. 1. The left-most digit of a component reference number identifies the particular figure in which the component first appears. At block 202, operating system 108 (e.g., a file system or a memory manager portion of the<br>
 <br>
operating system) determines that an executable file is being installed onto computing device 102, or being loaded (not yet loaded) into memory for execution. Responsive to this determination, trust verifier 112 evaluates the executable file to determine if it is from a trusted source (e.g., digitally signed by a trusted certificate authority).<br>
[0027] At block 204, trust verifier 112 determines if the executable file represents a known type of malware. In one implementation, after the executable file has been installed onto computing device 102 and in addition to what has already been described above, these operations include determining if a signature associated with the executable file matches a known malware signature, whereupon the executable file is determined to be malware. For purposes of illustration, a list of one or more known malware signatures is shown as a respective portion of "other data" 114. In one implementation, this list is distributed to the trust verifier 112 to identify any executable file(s) that may have initially been deemed trustworthy at the time of program installation, but later determined to constitute or otherwise comprise malicious code.<br>
[0028] At block 206, if the executable file is not from a trusted source and not malware, trust verifier 112 (or operating system 108) provides an administrator with an opportunity to authorize the trustworthiness of the file, indicate that the file is of questionable trust, or indicate that the file is untrustworthy. At block 208, if the executable file is not from a trusted source or was determined to be malware (block 204), trust verifier 112 marks / tags the file as untrustworthy. In one implementation, wherein the executable file had previously been marked as trustworthy, these operations include automatic revocation of trust (or downgrading of trust) associated with an executable file (e.g., when the executable file was determined to have a signature that matched a known malware signature).<br>
[0029] At block 210, if the executable file is not from a trusted source or marked untrustworthy, trust verifier 112 (or operating system 108) implements a protection path.<br>
 <br>
For example, if the executable file is being installed onto computing device 102, the protection path at least fails the installation operations for the executable file. In another example, if at least a portion of the executable file is being loaded into memory for execution on computing device 102, the protection path at least fails the memory loading operations so the file will not be loaded into memory for execution.<br>
An Exemplary Operating Environment<br>
10030] Fig. 3 illustrates an example of a suitable computing environment 300 in which the systems and methods for verifying trust of executable files may be fully or partially implemented. Exemplary computing environment 300 is only one example of a suitable computing environment for the exemplary system of Fig. 1 and exemplary operations of Fig. 2, and is not intended to suggest any limitation as to the scope of use or functionality of systems and methods as described herein. Neither should computing environment 300 be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in computing environment 300.<br>
[0031] The methods and systems described herein are operational with numerous other general purpose or special purpose computing systems, environments or configurations. Examples of well-known computing systems, environments, and/or configurations that may be suitable for use include, but are not limited to, personal computers, laptops, small form factor mobile computing devices (e.g., a cellular phone, personal digital assistant, or handheld computer), server computers, multiprocessor systems, microprocessor-based systems, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and so on. Compact or subset versions of the framework may also be implemented in clients of limited resources, such as handheld computers, or other computing devices. The invention is practiced in a distributed computing environment where tasks are performed by remote processing devices that are linked through a<br>
 <br>
communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.<br>
[0032] With reference to Fig. 3, an exemplary system 300 illustrates an example of a suitable computing environment in which systems and methods for verifying trust of executable files may be fully or partially implemented. System 300 includes a general purpose computing device in the form of a computer 310 implementing, for example, client computer 102 of Fig. 1. Components of computer 310 may include, but are not limited to, processing unit(s) 320, a system memory 330, and a system bus 321 that couples various system components including the system memory to the processing unit 320. The system bus 321 may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example and not limitation, such architectures may include Industry Standard Architecture (ISA) bus. Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus,<br>
[0033] A computer 310 typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by computer 310 and includes both volatile and nonvolatile media, removable and nonremovable media. By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage<br>
 <br>
devices, or any other medium which can be used to store the desired information and which can be accessed by computer 310.<br>
[0034] Communication media typically embodies computer-readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism, and includes any information delivery media. The term "modulated data signal" means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation, communication media includes wired media such as a wired network or a direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer-readable media,<br>
[0035] System memory 330 includes computer storage media in the form of volatile and/or nonvolatile memory such as read only memory (ROM) 331 and random access memory (RAM) 332. A basic input/output system 333 (BIOS), containing the basic routines that help to transfer information between elements within computer 310, such as during start-up, is typically stored in ROM 331. RAM 332 typically contains data and/or program modules that are immediately accessible to and/or presently being operated on by processing unit 320. By way of example and not limitation. Fig. 1 illustrates operating system 334, application programs 335, other program modules 336, and program data 337.<br>
[0036] The computer 310 may also include other removable/non-removable, volatile/nonvolatile computer storage media. By way of example only, Figure 3 illustrates a hard disk drive 341 that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive 351 that reads from or writes to a removable, nonvolatile magnetic disk 352, and an optical disk drive 355 that reads from or writes to a removable, nonvolatile  optical  disk 356  such  as  a  CD  ROM  or  other  optical  media. Other<br>
 <br>
removable/non-removable, volatile/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive 341 is typically connected to the system bus 321 through a non-removable memory interface such as interface 340, and magnetic disk drive 351 and optical disk drive 355 are typically connected to the system bus 321 by a removable memory interface, such as interface 350.<br>
[0037] The drives and their associated computer storage media discussed above and illustrated in Figure 3, provide storage of computer-readable instructions, data structures, program modules and other data for the computer 310. In Figure 3, for example, hard disk drive 341 is illustrated as storing operating system 344, application programs 345, other program modules 346, and program data 347. Note that these components can either be the same as or different from operating system 334, application programs 335, other program modules 336, and program data 337. Application programs 335 include, for example, program modules 104 of Fig. 1. Program data 337 includes, for example, program data 106 of Fig. 1. Operating system 344, application programs 345, other program modules 346, and program data 347 are given different numbers here to illustrate that they are at least different copies.<br>
[0038] A user may enter commands and information into the computer 310 through input devices such as a keyboard 362 and pointing device 361, commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit 320 through a user input interface 360 that is coupled to the system bus 321, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB).<br>
 <br>
[0039] A monitor 391 or other type of display device is also connected to the system bus 321 via an interface, such as a video interface 390. In addition to the monitor, computers may also include other peripheral output devices such as printer 396 and audio devices 397, which may be connected through an output peripheral interface 395.<br>
[0040] The computer 310 operates in a networked environment using logical connections to one or more remote computers, such as a remote computer 380. The remote computer 380 may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and as a function of its particular implementation, may include many or all of the elements (e.g., program module(s) 104 and program data 106, etc.) described above relative to the computer 102, although only a memory storage device 381 has been illustrated in Figure 3. The logical connections depicted in Figure 3 include a local area network (LAN) 371 and a wide area network (WAN) 373, but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.<br>
[0041] When used in a LAN networking environment, the computer 310 is connected to the LAN 371 through a network interface or adapter 370. When used in a WAN networking environment, the computer 310 typically includes a modem 372 or other means for establishing communications over the WAN 373, such as the Internet. The modem 372, which may be internal or external, may be connected to the system bus 321 via the user input interface 360, or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer 310, or portions thereof, may be stored in the remote memory storage device. By way of example and not limitation. Figure 3 illustrates remote application programs 385 as residing on memory device 381. The network connections shown are exemplary and other means of establishing a communications link between the computers may be used.<br>
 <br>
Conclusion<br>
[0042] Although the systems and methods for verifying trust of executable files have been described in language specific to structural features and/or methodological operations or actions, it is understood that the implementations defined in the appended claims are not necessarily limited to the specific features or actions described. For example, although trust verifier 112 is shown independent of memory manager 116 and file system 118, in one implementation, trust verifier is a plug-in to memory manager 116 or file system 118. In another example, although system 100 has been described with respect to verifying trust of executable files, using the described methods system 100 can also be implemented to verify trust of data files. Accordingly, the specific features and operations are disclosed as exemplary forms of implementing the claimed subject matter.<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
CLAIMS<br>
1.	A computer-implemented method comprising:<br>
determining that an executable file is being introduced into a path of execution; and<br>
responsive to said determining, automatically evaluating the executable file with multiple mal ware checks to detect if the executable file represents a type of mal ware, the multiple malware checks being integrated into an operating system trust verification process along the path of execution.<br>
2.	A method as recited in claim 1, wherein the path of execution comprises an installation path or a path associated with loading at least a portion of the executable code into memory for execution.<br>
3.	A method as recited in claim 1, wherein the multiple mal ware checks are integrated into a file system module or a memory manager module of the operating system.<br>
4.	A method as recited in claim 1, wherein the multiple integrated mal ware checks comprise a virus check, a spy ware check, a code-integrity check.<br>
5.	A method as recited in claim 1, wherein the executable file is being installed onto the computing device, and wherein the method further comprises:<br>
if the executable file is not mal ware in view of the multiple mal ware checks, allowing an entity to mark the executable file as trustworthy, of questionable trustworthiness, or untrustworthy; and<br>
 <br>
only if the executable file is trustworthy, installing the executable file onto the computing device.<br>
6. A method as recited in claim 1, wherein at least a portion of the executable file is being loaded into memory for execution, and wherein the method further comprises:<br>
if the executable file is not mal ware in view of the multiple mal ware checks;<br>
allowing an entity to mark the executable file as trustworthy, of questionable trustworthiness, or untrustworthy; and<br>
only if the executable file is trustworthy, loading the at least a portion of the executable file into memory for execution.<br>
7. A method as recited in claim 1, wherein the method further comprises responsive to determining the executable file is being installed, automatically determining if the executable file is from by a trusted source.<br>
8. A method as recited in claim 1, wherein the executable file was determined to be trustworthy upon installation, and wherein the method further comprises:<br>
determining, subsequent to installation of the executable file, that the executable file comprises mal ware; and<br>
revoking trustworthiness of the executable file.<br>
9.       A    computer-readable    medium    comprising    computer-program    instructions executable by a processor for:<br>
determining that an executable file is being introduced into a path of execution; and<br>
 <br>
responsive to said determining, automatically evaluating the executable file with multiple mal ware checks to detect if the executable file represents a type of mal ware, the multiple malware checks being integrated into an operating system trust verification process along the path of execution.<br>
10. A computer-readable medium as recited in claim 9, wherein the multiple mal ware checks are integrated into a file system module or a memory manager module of the operating system.<br>
11.      A computer-readable medium as recited in claim 9, wherein the multiple mal ware integrated checks comprise a virus check, a spy ware check, and a code-integrity check.<br>
12. A computer-readable medium as recited in claim 9, wherein the executable file is being installed onto the computing device, and wherein the computer-program instructions further comprise instructions for:<br>
if the executable file is not mal ware in view of the multiple mal ware checks, allowing an entity to mark the executable file as trustworthy, of questionable trustworthiness, or untrustworthy; and<br>
only if the executable file is trustworthy, installing the executable file onto the computing device.<br>
13. A computer-readable medium as recited in claim 9, wherein at least a portion of the executable file is being loaded into memory for execution, and wherein the computer-program instructions further comprise instructions for:<br>
if the executable file is not mal ware in view of the multiple mal ware checks;<br>
 <br>
allowing an entity to mark the executable file as trustworthy, of questionable trustworthiness, or untrustworthy; and<br>
only if the executable file is trustworthy, loading the at least a portion of the executable file into memory for execution.<br>
14. A computer-readable medium as recited in claim 9, wherein the executable file was determined to be trustworthy upon installation, and wherein the computer-program instructions ftirther comprise instructions for:<br>
determining, subsequent to installation of the executable file, that the executable file comprises mal ware; and<br>
revoking trustworthiness of the executable file.<br>
15.       A computing device comprising:<br>
a processor; and<br>
a memory coupled to the processor, the memory comprising computer-program instructions executable by the processor for:<br>
determining that an executable file is being introduced into a path of execution; and<br>
responsive to said determining, automatically evaluating the executable file with multiple mal ware checks to detect if the executable file represents a type of mal ware, the multiple maltvare checks being integrated into an operating system trust verification process along the path of execution.<br>
 <br>
16, A computing device as recited in claim 15, wherein the path of execution comprises an installation path or a path associated with loading at least a portion of the executable code into memory for execution.<br>
17, A computing device as recited in claim 15, wherein the multiple mal ware checks are integrated into a file system module or a memory manager module of the operating system.<br>
18.       A computing device as recited in claim 15, wherein the multiple integrated mal ware checks comprise a virus check, a spy ware check, and a code-integrity check.<br>
19. A computing device as recited in claim 15, wherein the executable file is being installed onto the computing device, and wherein the computer -program instructions further comprise instructions for:<br>
if the executable file is not mal ware in view of the multiple mal ware checks allowing an entity to mark the executable file as trustworthy, of questionable trustworthiness, or untrustworthy; and<br>
only if the executable file is trustworthy, installing the executable file onto the<br>
computing device.<br>
 <br>
20. A computing device as recited in claim 15, wherein at least a portion of the executable file is being loaded into memory for execution, and wherein the computer-program instructions further comprise instructions for:<br>
if the executable file is not mal ware in view of the multiple mal ware checks;<br>
allowing an entity to mark the executable file as trustworthy, of questionable trustworthiness, or untrustworthy; and<br>
only if the executable file is trustworthy, loading the at least a portion of the executable file into memory for execution.<br>
 <br>
</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=412jlAGUhR4Zen0vt6DeUw==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=412jlAGUhR4Zen0vt6DeUw==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==</a></p>
		<br>
		<div class="pull-left">
			<a href="277988-method-for-manufacturing-a-welded-component-with-very-high-mechanical-characteristics-from-a-coated-lamination-sheet.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="277990-programmed-wireless-sensor-system.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>277989</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>3694/CHENP/2007</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>51/2016</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>09-Dec-2016</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>07-Dec-2016</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>23-Aug-2007</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>MICROSOFT TECHNOLOGY LICENSING, LLC</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>One Microsoft Way, Redmond, Washington 98052</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>KRAMER, MICHAEL</td>
											<td>ONE MICROSOFT WAY, REDMOND, WASHINGTON 98052-6399</td>
										</tr>
										<tr>
											<td>2</td>
											<td>RAY, KENNETH D</td>
											<td>ONE MICROSOFT WAY, REDMOND, WASHINGTON 98052-6399, USA.</td>
										</tr>
										<tr>
											<td>3</td>
											<td>ENGLAND, PAUL</td>
											<td>ONE MICROSOFT WAY, REDMOND, WASHINGTON 98052-6399, USA.</td>
										</tr>
										<tr>
											<td>4</td>
											<td>FIELD, SCOTT, A</td>
											<td>ONE MICROSOFT WAY, REDMOND, WASHINGTON 98052-6399, USA.</td>
										</tr>
										<tr>
											<td>5</td>
											<td>SCHWARTZ, JONATHAN, D</td>
											<td>ONE MICROSOFT WAY, REDMOND, WASHINGTON 98052-6399, USA.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F12/14</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2006/013006</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2006-04-06</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>11/100,770</td>
									<td>2005-04-07</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/277989-method-and-system-for-verifying-trust-of-a-file by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 00:11:01 GMT -->
</html>
