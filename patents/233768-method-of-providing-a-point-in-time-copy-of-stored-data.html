<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/233768-method-of-providing-a-point-in-time-copy-of-stored-data by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:53:16 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 233768:METHOD OF PROVIDING A POINT-IN-TIME COPY OF STORED DATA</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD OF PROVIDING A POINT-IN-TIME COPY OF STORED DATA</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>There is disclosed a point-in-time copy of stored data which includes providing a virtual storage area having a table of pointers that point to sections of the stored data and to sections of at least one other storage area where the virtual storage area contains no sections of data. In response to a write of new data to a section of the stored data pointed to by a pointer of the table of the virtual storage area, the section of stored data is copied to a section of the at least one other storage area prior to the write (312). Providing the point-in-time copy also includes causing a pointer of the virtual storage area to point to the section of the at least one other storage area (308) and writing the new data to the section of the stored data (324)</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>METHOD OF PROVIDING A POINT-IN-TIME COPY OF STORED DATA<br>
Background of the Invention<br>
1. Technical Field<br>
This application relates to computer storage devices, and more particularly to<br>
the field of providing copies of portions of data stored on a computer storage device.<br>
2. Description of Related Art<br>
Host processor systems may store and retrieve data using a storage device<br>
containing a plurality of host interface units (host adapters), disk drives, and disk<br>
interface units (disk adapters). Such storage devices are provided, for example, by<br>
EMC Corporation of Hopkinton, Mass. and disclosed in U.S. Patent No. 5,206,939 to<br>
Yanai et al., 5,778,394 to Galtzur et al., U.S. Patent No. 5,845,147 to Vishlitzky et al.,<br>
and U.S. Patent No. 5,857,208 to Ofek. The host systems access the storage device<br>
through a plurality of channels provided therewith. Host systems provide data and<br>
access control information through the channels of the storage device and the storage<br>
device provides data to the host systems also through the channels. The host systems<br>
do not address the disk drives of the storage device directly, but rather, access what<br>
appears to the host systems as a plurality of logical volumes. The logical volumes<br>
may or may nor correspond to the actual disk drives.<br>
In some instances, it may desirable to provide a copy of a logical volume<br>
where the copy is then accessed by other processes. For example, to test new<br>
software on actual stored data, a copy of a logical volume containing the data may be<br>
made and the copy, as opposed to the original data, may be used to test new software.<br>
Once the test is complete, the copy may be eliminated. Thus, the new software is<br>
tested on actual data without affecting the actua] data. This reduces the likelihood<br>
that testing new software and/or functionality will corrupt actual data.<br>
One difficulty with making such copies is that they require as much storage<br>
space as the logical volume from which the data is obtained since the copy process<br>
simply creates a new volume containing all the data of the original volume. In<br>
addition, in some instances, the differences between the original volume and the copy<br>
are minimal. Thus, the extra storage space required for such a copy of a logical<br>
volume is used somewhat inefficiently since it merely duplicates already-existing<br>
data. Accordingly, it would be desirable to provide a mechanism for copying data in<br>
a way that uses storage space efficiently.<br>
Summary of the Invention<br>
According to the present invention, there is disclosed a method of<br>
providing a point-in-time copy of stored data, comprising providing a virtual<br>
storage area having a table of pointers that point to sections of the stored data<br>
and to sections of at least one other storage area, wherein the virtual storage<br>
area contains no sections of data, in response to a write of new data to a<br>
section of the stored data pointed to by a pointer of the table of the virtual<br>
storage area, copying the section of stored data to a section of the at least one<br>
other storage area prior to the write, causing a pointer of the virtual storage area<br>
to point to the section of the at least one other storage area, and writing the new<br>
data to the section of the stored data, in response to a request for accessing<br>
data of the virtual storage area, determining which particular one of the other<br>
storage areas contain the data and accessing the data on the particular one of<br>
the other storage areas using the table of pointers.<br>
Accessing stored data may also include associating a first one of the<br>
other storage area with the virtual storage area, where the virtual storage area<br>
represents a copy of data of the first one of the other storage areas. Accessing<br>
storage data may also include causing all of the pointers of the table to initially<br>
point to sections of the first one of the other storage areas when the virtual<br>
storage area is initially associated with the first one of the other storage areas.<br>
Accessing stored data may also include, in response to a write to a fist section<br>
on the first one of the other storage areas, copying data of the first section to a<br>
second section that is on a second one of the other storage areas and causing a<br>
corresponding one of the pointers of the table to point to the second section. Prior to<br>
copying data from the first section to the second section, the second section may be<br>
maintained as a free section containing no data. Accessing stored data may also<br>
include maintaining a doubly linked list of all free sections of the second one of the<br>
other storage areas. Accessing stored data may also include associating a data<br>
indicator with sections of the first one of the other storage areas, where the data<br>
indicator for a particular section indicates whether a write operation has been<br>
performed to the particular section after the first one of the other storage areas has<br>
been associated with the virtual storage area. Accessing stored data may also include,<br>
in response to a write to a first section on the first one of the other storage areas and<br>
the data indicator indicating that no write operation has been performed to the first<br>
section after the first one of the other storage areas has been associated with the<br>
virtual storage area, copying data of the first section to a second section that is on a<br>
second one of the other storage areas and causing a corresponding one of the pointers<br>
of the table to point to the second section. Accessing stored data may also include<br>
sending status information to a device that caused the write operation to be performed<br>
following copying the data from the first section to the second section. Each of the<br>
sections of data may be a track of data. Each of the storage areas may be a storage<br>
device.<br>
According to the present invention,there is further disclosed a method of<br>
providing point-in-time copies of data stored in a data storage area, comprising<br>
providing a first virtual storage area having a first table of pointers that point to<br>
sections of the data storage area and to sections of at least one other storage<br>
area, wherein the first virtual storage area contains no sections of data, in<br>
response to a write of new data to a section of the data storage area pointed to<br>
by a pointer of the first table of the first virtual storage area, copying the section<br>
of data to a section of the at least one other storage area prior to the write,<br>
causing a pointer of the first virtual storage area to point to the section of the at<br>
least one other storage area, and writing the new data to the section of the data<br>
storage area, associating the data storage area with the first virtual storage<br>
area, wherein the first virtual storage area represents a copy of data of the data<br>
storage area at a first point in time, providing a second virtual storage area<br>
having a second table of pointers that point to sections of the data storage area<br>
and to sections of the at least one other storage area, wherein the second<br>
virtual storage area contains no sections of data, in response to a write to a<br>
section of the data storage area pointed to by a pointer of the second table of<br>
the second virtual storage area, copying the section of data to a section of the<br>
at least one other storage area prior to the write and causing a pointer of the<br>
second virtual storage area to point to the section of the at least one other<br>
storage area, associating the data storage area with the second virtual storage<br>
area, wherein the second virtual storage area represents a copy of data of the<br>
data storage area at a second point in time, in response to a request for<br>
accessing data of one of the virtual storage areas, determining which particular<br>
one of the storage areas contain the data and accessing the data on the<br>
particular one of the storage areas using one of the tables of pointers.<br>
Accessing stored data may also include causing all of the<br>
pointers of the first table to initially point to sections of the first one of the<br>
other storage areas when the first virtual storage area is initially associated<br>
with the first one of the other storage areas and causing all of the pointers<br>
of the second table to initially point to sections of the first one of the other storage<br>
areas when the second virtual storage area is initially associated with the first one of<br>
the other storage areas. Accessing stored data may further include associating a first<br>
data indicator with sections of the first one of the other storage areas, where the first<br>
data indicator for a particular section of the first other one of the storage areas<br>
indicates whether a write operation has been performed to the particular section after<br>
the first one of the other storage areas has been associated with the first virtual storage<br>
area, and associating a second data indicator with sections of the first one of the other<br>
storage areas, where the second data indicator for a particular section of the first other<br>
one of the storage areas indicates whether a write operation has been performed to the<br>
particular section after the second one of the other storage areas has been associated<br>
with the second virtual storage area. Accessing stored data may also include, in<br>
response to a write to a first section that is on the first one of the other storage areas<br>
and the data indicator indicating that no write operation has been performed to the<br>
first section after the first one of the other storage areas has been associated with the<br>
first virtual storage area, copying data of the first section to a second section that is on<br>
a second one of the other storage areas and causing a corresponding one of the<br>
pointers of the first table to point to the second section. Accessing stored data may<br>
also include, in response to a write to a first section that is on the first one of the other<br>
storage areas and the data indicator indicating that no write operation has been<br>
performed to the first section after the first one of the other storage areas has been<br>
associated with the first and second virtual storage areas, copying data of the first<br>
section to a second section that is on a second one of the other storage areas and<br>
causing a corresponding one of the pointers of the first table and a corresponding one<br>
of the pointers of the second table to point to the second section. Accessing stored<br>
data may also include, in response to a write to the first virtual storage area<br>
corresponding to the second section, copying data from the second section to a third<br>
section. Accessing stored data may also include causing a corresponding one of the<br>
pointers of the first table to point to the third section. Accessing stored data may also<br>
include causing a corresponding one of the pointers of the second table to point to the<br>
third section. The first time may be the same as the second time. The first time may<br>
be different from the second time. Each of the sections of data may be a track of data.<br>
Each of the storage areas may be a storage device.<br>
According further to the present invention, a computer program product<br>
includes executable code that provides a virtual storage area having a table of pointers<br>
that point to sections of at least two other storage areas, where the virtual storage area<br>
contains no sections of data, executable code that determines which particular one of<br>
the other storage areas contain the data in response to a request for accessing data of<br>
the virtual storage area, and executable code that accesses the data on the particular<br>
one of the other storage areas using the table of pointers. The computer program<br>
product may also include executable code that associates a first one of the other<br>
storage areas with the virtual storage area, where the virtual storage area represents a<br>
copy of data of the first one of the other storage areas. The computer program<br>
product may also include executable code that causes all of the pointers of the table to<br>
initially point to sections of the first one of the other storage areas when the virtual<br>
storage area is initially associated with the first one of the other storage areas. The<br>
computer program product may also include executable code that copies data of the<br>
first section to a second section that is on a second one of the other storage areas and<br>
causes a corresponding one of the pointers of the table to point to the second section<br>
in response to a write to a first section on the first one of the other storage areas. The<br>
computer program product may also include executable code that associates a data<br>
indicator with sections of the first one of the other storage areas, where the data<br>
indicator for a particular section indicates whether a write operation has been<br>
performed to the particular section after the first one of the other storage areas has<br>
been associated with the virtual storage area. The computer program product may<br>
also include executable code that copies data of the first section to a second section<br>
that is on a second one of the other storage areas and causes a corresponding one of<br>
the pointers of the table to point to the second section in response to a write to a first<br>
section on the first one of the other storage areas and the data indicator indicating that<br>
no write operation has been performed to the first section after the first one of the<br>
other storage areas has been associated with the virtual storage area. The computer<br>
program product may also include executable code that sends status information to a<br>
device that caused the write operation to be performed following copying the data<br>
from the first section to the second section. Each of the sections of data may be a track<br>
of data. Each of the storage areas may be a storage device.<br>
According further to the present invention, a virtual storage device includes at<br>
least one table for associating the virtual storage device with a standard storage<br>
device, storage for sections of data of the virtual storage device, where a first portion<br>
of the storage for sections is sections of data of the standard storage device, and a first<br>
plurality of pointers provided with the at least one table, where at least some of the<br>
pointers point to sections of the standard storage device corresponding to the first<br>
portion. The virtual storage device may also include a second portion of the storage<br>
for sections that contain data that is different from data on corresponding sections of<br>
the standard storage device that map to the second portion, and a second plurality of<br>
pointers provided with the at least one table, where the second plurality of pointers<br>
point to sections of a device different from the standard storage device. Each section<br>
of the second portion may contain an earlier version of data on a corresponding<br>
section of the standard storage device. Each of the sections of data may be a track of<br>
data.<br>
Brief Description of the Accompanying Drawings<br>
Figure 1 is a diagram of a storage device used in connection with the system<br>
described herein.<br>
Figure 2 is a diagram of a storage that shows various logical volumes that are<br>
used in connection with the system described herein.<br>
Figure 3 is a diagram showing use of a virtual device according to the system<br>
described herein.<br>
Figure 4 is a diagram showing use of a plurality of virtual devices according to<br>
the system described herein.<br>
Figure 5 is a diagram showing device tables used in connection with the<br>
system described herein.<br>
Figure 6 is a flow chart illustrating reading a table used in connection with a<br>
virtual device according to the system described herein.<br>
Figure 7 is a flow chart illustrating writing to a table used in connection with a<br>
virtual device according to the system described herein.<br>
Figure 8 is a flow chart illustrating modification of a virtual device table and<br>
establishing a virtual device according to the system described herein.<br>
Figure 9 is a flow chart illustrating modification of data structures used to<br>
handle tracks of a log device according to the system described herein.<br>
Figure 10 is a flow chart illustrating steps performed in connection with<br>
reading a virtual device according to the system described herein.<br>
Figure 11 is a flow chart illustrating steps performed by a disk adapter in<br>
connection with writing to a standard logical device to which a virtual device has been<br>
established according to the system described herein.<br>
Figure 12 is a flow chart illustrating steps performed by a host adapter in<br>
connection with writing to a standard logical device to which a virtual device has been<br>
established according to the system described herein.<br>
Figure 13 is a flow chart illustrating steps performed in connection with<br>
writing to a virtual device according to the system described herein.<br>
Figure 14 is a flow chart illustrating steps performed in connection with<br>
removing a virtual device.<br>
Detailed Description of Various Embodiments<br>
Referring to Fig. 1, a storage device 30 includes a plurality of host adapters<br>
(HA) 32-34, a plurality of disk adapters (DA) 36-38 and a plurality of disk drives 42-<br>
44. Each of the disk drives 42-44 is coupled to a corresponding one of the DA's 36-<br>
38. The storage device 30 also includes a global memory 46 that may be accessed by<br>
the HA's 32-34 and the DA's 36-38. The storage device 30 also includes an RDF<br>
adapter (RA) 48 that may also access the global memory 46. The RA 48 may<br>
communicate with one or more additional remote storage devices (not shown) and/or<br>
one or more other remote devices (not shown) via a data link 52. The HA's 32-34,<br>
the DA's 36-38, the global memory 46 and the RA 48 are coupled to a bus 54 that is<br>
provided to facilitate communication therebetween.<br>
Each of the HA's 32-34 may be coupled to one or more host computers (not<br>
shown) that access the storage device 30. The host computers (hosts) read data stored<br>
on the disk drives 42-44 and write data to the disk drives 42-44. The global memory<br>
46 contains a cache memory that holds tracks of data from the disk drives 42-44 as<br>
well as storage for tables that may be accessed by the HA's 32-34, the DA's 36-38<br>
and the RA 48. Note that, for the discussion herein, blocks of data are described as<br>
being a track or tracks of data. However, it will be appreciated by one of ordinary<br>
skill in the art, that the system described herein may work with any appropriate<br>
incremental amount, or section, of data, including possibly variable incremental<br>
amounts of data and/or fixed incremental amounts of data.<br>
Referring to Fig. 2, the storage device 30 is shown as including a plurality of<br>
standard logical devices 61-68. Each of the standard logical devices 61-68 may<br>
correspond to a volume that is accessible to one or more hosts coupled to the storage<br>
device 30. Each of the standard logical devices 61-68 may or may not correspond to<br>
one of the disk drives 42-44. Thus, for example, the standard logical device 61 may<br>
correspond to the disk drive 42, may correspond to a portion of the disk drive 42, or<br>
may correspond to a portion of the disk drive 42 and a portion of the disk drive 43.<br>
Each of the standard logical devices 61-68 appears to the host as a contiguous block<br>
of disk storage, even though each of the standard logical devices 61-68 may or may<br>
not correspond to actual contiguous physical storage of the disk drives 42-44.<br>
The storage device 30 may also includes a plurality of virtual devices 71-74.<br>
The virtual devices 71-74 appear to a host coupled to the storage device 30 as<br>
volumes containing a contiguous block of data storage. Each of the virtual devices<br>
71-74 may represent a point in time copy of an entire one of the standard logical<br>
devices 61-68, a portion of one of the standard logical devices 61-68, or a<br>
combination of portions or entire ones of the standard logical devices 61-68.<br>
However, as described in more detail elsewhere herein, the virtual devices 71-74 do<br>
not contain the track data from the standard logical devices 61-68. Instead, each of<br>
the virtual devices 71-74 is coupled to a log device 76 or a log device 78 that stores<br>
some or all the track data, as described in more detail elsewhere herein. The virtual<br>
devices 71-74 contain tables that point to tracks of data on either on the standard<br>
logical devices 61-68 or the log devices 76, 78.<br>
The virtual device 71 may represent a point in time copy of the standard<br>
logical device 61. As described in more detail elsewhere herein, the virtual device 71<br>
is coupled to the log device 76 that contains track data to facilitate the virtual device<br>
71 appearing to a host to be a point in time copy of the standard logical device 61. It<br>
is possible for more than one virtual device to use a single log device. Thus, the<br>
virtual devices 72-74 are shown being coupled to the log device 78. Similarly, it is<br>
possible for more than one virtual device to represent point in time copies of a single<br>
standard logical device. Thus, the virtual devices 72,73 are shown as being point in<br>
time copies of the standard logical device 64. The virtual devices 72,73 may<br>
represent the same point in time copy of the standard logical device 64 or,<br>
alternatively, may represent point in time copies of the standard logical device 64<br>
taken at different times. Note that only some of the standard logical devices 61-68 are<br>
shown as being associated with a corresponding one of the virtual devices 71-74<br>
while others of the standard logical devices 61-68 are not.<br>
In some embodiments, it may be possible to implement the system described<br>
herein using storage areas, instead of storage devices. Thus, for example, the virtual<br>
devices 71-74 may be virtual storage areas, the standard logical devices 61-68 may be<br>
standard logical areas, and the log devices 76,78 may be log areas. In some instances,<br>
such an implementation may allow for hybrid logical/virtual devices where a single<br>
logical device has portions that behave as a standard logical device, portions that<br>
behave as a virtual device, and/or portions that behave as log device. Accordingly, it<br>
should be understood that, in appropriate instances, references to devices in the<br>
discussion herein may also apply to storage areas that may or may not correspond<br>
directly with a storage device.<br>
Referring to Fig. 3, a diagram shows a standard logical device 82, a virtual<br>
device 84, and a log device 86. As discussed above, the virtual device 84 may<br>
represent a point in time copy of all or a portion of the standard logical device 82. A<br>
host coupled to a storage device that accesses the virtual device 84 may access the<br>
virtual device 84 in the same way that the host would access the standard logical<br>
device 82. However, the virtual device 84 does not contain any track data from the<br>
standard logical device 82. Instead, the virtual device 84 includes a plurality of table<br>
entries that point to tracks on either the standard logical device 82 or the log device<br>
86.<br>
When the virtual device is established 84 (e.g., when a point in time copy is<br>
made of the standard logical device 82), the virtual device 84 is created and provided<br>
with appropriate table entries that, at the time of establishment, point to tracks of the<br>
standard logical device 82. A host accessing the virtual device 84 to read a track<br>
would read the appropriate track from the standard logical device 82 based on the<br>
table entry of the virtual device 84 pointing to the track of the standard logical device<br>
82.<br>
After the virtual device 84 has been established, it is possible for a host to<br>
write data to the standard logical device 82. In that case, the previous data that was<br>
stored on the standard logical device 82 is copied to the log device 86 and the table<br>
entries of the virtual device 84 that previously pointed to tracks of the standard logical<br>
device 82 would be modified to point to the new tracks of the log device 86 to which<br>
the data had been copied. Thus, a host accessing the virtual device 84 would read<br>
either tracks from the standard logical device 82 that have not changed since the<br>
virtual device 84 was established or, alternatively, would read corresponding tracks<br>
from the log device 86 that contain data copied from the standard logical device 82<br>
after the virtual device 84 was established. Adjusting data and pointers in connection<br>
with reads and writes to and from the standard logical device 82 and virtual device 84<br>
is discussed in more detail elsewhere herein.<br>
In an embodiment described herein, hosts would not have direct access to the<br>
log device 86. That is, the log device 86 would be used exclusively in connection<br>
with the virtual device 84 (and possibly other virtual devices as described in more<br>
detail elsewhere herein). In addition, for an embodiment described herein, the<br>
standard logical device 82, the virtual device 84, and the log device 86 may be<br>
provided on the single storage device 30. However, it is possible to provide the<br>
different logical devices and the log device on separate storage devices interconnected<br>
using, for example, the RDF protocol or other remote communication protocols. In<br>
addition, it may be possible to have portions of one or more of the standard logical<br>
device 82, the virtual device 84, and/or the log device 86 provided on separate storage<br>
devices that are appropriately interconnected.<br>
Referring to Fig. 4, another example of the use of virtual devices shows a<br>
standard logical device 92, a plurality of virtual devices 94-97 and a log device 98. In<br>
the example of Fig. 4, the virtual device 94 represents a point in time copy of the<br>
standard logical device 92 taken at ten a.m. Similarly, the virtual device 95 represents<br>
a copy of the standard logical device 92 taken at twelve noon, the virtual device 96<br>
represents a copy of the standard logical device 92 taken at two p.m., and the virtual<br>
device 97 represents a copy of the standard logical device 92 taken at four p.m. Note<br>
that all of the virtual devices 94-97 may share the log device 98. In addition, it is<br>
possible for table entries of more than one of the virtual devices 94-97, or, a subset of<br>
the table entries of the virtual devices 94-97, to point to the same tracks of the log<br>
device 98. For example, the virtual device 95 and the virtual device 96 are shown as<br>
having table entries that point to the same tracks of the log device 98.<br>
In an embodiment discussed herein, the log device 98 and other log devices<br>
discussed herein are provided by a pool of log devices that is managed by the storage<br>
device 30. In that case, as a virtual device requires additional tracks of a log device,<br>
the virtual device would cause more log device storage to be created (in the form of<br>
more tracks for an existing log device or a new log device) using the log device pool<br>
mechanism. Pooling storage device resources in this manner is known in the art.<br>
Other techniques that do not use pooling may be used to provide log device storage.<br>
Referring to Fig. 5, a diagram 100 illustrates tables that are used to keep track<br>
of device information. A first table 102 corresponds to all of the devices used by a<br>
storage device or by an element of a storage device, such as an HA and/or a DA. The<br>
table 102 includes a plurality of logical device entries 106-108 that correspond to all<br>
the logical devices used by the storage device (or portion of the storage device). The<br>
entries in the table 102 include descriptions for standard logical devices, virtual<br>
devices, log devices, and other types of logical devices.<br>
Each of the entries 106-108 of the table 102 correspond to another table that<br>
contains information for each of the logical devices. For example, the entry 107 may<br>
correspond to a table 112. The table 112 includes a header that contains overhead<br>
information. The table 112 also includes entries 116-118 for each of the cylinders of<br>
the logical device. In an embodiment disclosed herein, a logical device may contain<br>
any number of cylinders depending upon how the logical device is initialized.<br>
However, in other embodiments, a logical device may contain a fixed number of<br>
cylinders.<br>
The table 112 is shown as including a section for extra track bytes 119. The<br>
extra track bytes 119 are used in connection with the log devices in a manner that is<br>
discussed elsewhere herein. In an embodiment disclosed herein, there are eight extra<br>
track bytes for each track of a log device. For devices that are not log devices, the<br>
extra track bytes 119 may not be used.<br>
Each of the cylinder entries 116-118 corresponds to a track table. For<br>
example, the entry 117 may correspond to a track table 122 that includes a header 124<br>
having overhead information. The track table 122 also includes entries 126-128 for<br>
each of the tracks. In an embodiment disclosed herein, there are fifteen tracks for<br>
every cylinder. However, for other embodiments, it may be possible to have different<br>
numbers of tracks for each of the cylinders or even a variable number of tracks for<br>
each cylinder. For standard logical devices and log devices, the information in each<br>
of the entries 126-128 includes a pointer (either direct or indirect) to the physical<br>
address on one of the disk drives 42-44 of the storage device 30 (or a remote storage<br>
device if the system is so configured). Thus, the track table 122 may be used to map<br>
logical addresses of the logical device corresponding to the tables 102, 112, 122 to<br>
physical addresses on the disk drives 42-44 of the storage device 30. For virtual<br>
devices, each of the entries 126-128 of the table 122 points to a track of a<br>
corresponding standard logical device or corresponding log device. For other<br>
embodiments, however, it may be possible to use a different mechanism where the<br>
tables 102, 122, 122 are used only for standard logical devices that contain tracks of<br>
data while another type of table, such as a simple array of tracks, is used by virtual<br>
devices to map tracks of the virtual devices to tracks of corresponding standard<br>
logical devices or log devices.<br>
Each track of a log device is either free, meaning that it is not being used by a<br>
virtual device, or is assigned, meaning that the track is pointed to by a table entry in<br>
one or more of the virtual devices. In an embodiment disclosed herein, the tracks of a<br>
log device are managed by first creating a doubly linked list of all of the free tracks of<br>
the log device. The pointers for the doubly linked list are provided by the extra track<br>
bytes 119 of the table 112 so that the extra track bytes 119 for a log device contains<br>
eight bytes for every track of the log device. For every track of the log device that is<br>
free, the extra eight bytes include a forward pointer pointing to the next free track of<br>
the log device and a backward pointer pointing to the previous free track of the log<br>
device. Using a doubly linked list in this manner facilitates accessing free tracks of<br>
the log device.<br>
In addition, if a track of a log device is assigned (i.e., is used by one or more<br>
virtual devices), the corresponding extra track bytes 119 for the track may be used to<br>
point back to the corresponding track of the standard logical device. Thus, when a<br>
write is performed to the standard logical device after the virtual device has been<br>
established, the data from the standard logical device is copied to a new track of the<br>
log device and the extra track bytes corresponding to the new track of the log device<br>
are made to point back to the track of the standard logical device from which the data<br>
came. Having each track of the log device point back to the corresponding track of<br>
the standard logical device is useful in, for example, data recovery situations.<br>
In addition, for an embodiment disclosed herein, the pointers for the extra<br>
eight bytes per track for an assigned track are stored with the data also. That is, when<br>
a particular track of a log device is assigned, the pointer back to the corresponding<br>
track of a standard logical device is stored with the extra track bytes 119 and, in<br>
addition, the pointer is stored with the track data itself on the track of the log device.<br>
For CKD formatted tracks, the extra eight bytes may be stored in block zero. For<br>
FBA formatted tracks, the extra eight bytes may be stored in an additional block<br>
appended on the end of the track. In an embodiment disclosed herein, a block is five<br>
hundred and twelve bytes and an FBA track contains forty blocks, which is increased<br>
to forty one when an additional block is appended. Different track formats are<br>
disclosed, for example, in U.S. Patent No, 5,206,939 to Yanai, et al., which is<br>
incorporated herein by reference.<br>
The tables 102, 112, 122 of Fig. 5 may be stored in the global memory 46 of<br>
the storage device 30. In addition, the tables corresponding to devices accessed by a<br>
particular host may be stored in local memory of the corresponding one of the HA's<br>
32-36. In addition, the RA 48 and/or the DA's 36-38 may also use and locally store<br>
portions of the tables 102, 112, 122.<br>
Referring to Fig. 6, a flow chart 140 illustrates steps performed when a host<br>
reads data from a device table corresponding to a track that is accessible through a<br>
virtual device. That is, the flow chart 140 illustrates obtaining information about a<br>
track that is pointed to by a table entry for a virtual device.<br>
Processing begins at a test step 142 where it is determined if the track of<br>
interest (i.e., the track corresponding to the table entry being read) is on the standard<br>
logical device or the log device. This is determined by accessing the device table<br>
entry for the virtual device and determining whether the table entry for the track of<br>
interest points to either the standard logical device or the log device. If it is<br>
determined at the test step 142 that the pointer in the table for the virtual device points<br>
to the standard logical device, then control passes from the step 142 to a step 148<br>
where the table entry of interest is read. Following the step 148, processing is<br>
complete.<br>
If it is determined that the test step 142 that the pointer in the device table for<br>
the virtual device for the track of interest points to the log device, then control<br>
transfers from the step 142 to a step 158 where the log table entry of interest is read.<br>
Following the step 158, processing is complete.<br>
Note that, in some instances, access to data may be controlled by a flag or lock<br>
that prohibits multiple processes having access to the data simultaneously. This is<br>
especially useful in instances where a device table is being read or modified. The<br>
system disclosed herein contemplates any one of a variety of mechanisms for<br>
controlling access to data by multiple processes, including conventional combinations<br>
of software and/or hardware locks, also known as "flags" or "semaphores". In some<br>
instances, a process accessing data may need to wait until another process releases the<br>
data. In one embodiment, a hardware lock controls access to a software lock (flag) so<br>
that a process first obtains control of the hardware lock, tests the software lock, and<br>
then, if the software lock is clear, the process sets the software lock and then releases<br>
the hardware lock. If the process gets the hardware lock and determines that the<br>
software lock is not clear, then the process releases the hardware lock so that another<br>
process that has set the software lock can clear the software lock at a later time.<br>
Further note that, in some instances, it is useful to first read a table entry<br>
corresponding to a particular track, read the track into a cache slot (if the track is not<br>
already in cache), lock the cache slot, and then reread the corresponding table entry.<br>
Referring to Fig. 7, a flow chart 170 illustrates steps performed in connection<br>
with writing information to a device table for a virtual device corresponding to a<br>
standard logical device or a log device. Processing begins at a first step 172 where it<br>
is determined if the particular track corresponding to the device table entry being<br>
written is on the standard logical device or the log device. If it is determined the<br>
particular track of interest is on the standard logical device, control passes from the<br>
step 172 to a step 178 where the track corresponding to the device table entry being<br>
written is locked. Locking the track at the step 178 prevents other processes from<br>
getting access to the track, and from modifying the corresponding table entry, while<br>
the current process is modifying the device table entry corresponding to the track.<br>
Following the step 178 is a step 182 where the write operation is performed.<br>
Following the step 182 is a step 184 where the track is unlocked. Following the step<br>
184, processing is complete.<br>
If it is determined that the test step 172 that the track corresponding to the<br>
table entry for the virtual device that is being modified points to the log device, then<br>
control passes from the test step 172 to a step 194 where the track of the log device<br>
corresponding to the entry of the device table that is being written is locked.<br>
Following the step 194 is a step 196 where the write operation is performed.<br>
Following the step 196 is a step 198 where the track is unlocked. Following the step<br>
198, processing is complete.<br>
Referring to Fig. 8, a flow chart 210 illustrates steps performed in connection<br>
with modifying a device table corresponding to a virtual device. This may be<br>
contrasted with the flow chart 170 of Fig. 7 that illustrates modifying the device table<br>
for the standard logical device or the log device pointed to by an entry for a track of<br>
the device table for a virtual device. In flow chart 210, the device table for the virtual<br>
device is modified, as opposed to the device table for the standard logical device or<br>
the device table for the log device.<br>
Processing begins at a first step 212 where it is determined if the modifications<br>
to the table relate to establishing the virtual device. As discussed elsewhere herein,<br>
establishing a virtual device includes making the virtual device available for access by<br>
a host after the virtual device is created. Establishing a virtual device causes the<br>
virtual device to be associated with a standard logical device (and thus, represent a<br>
point in time copy of the standard logical device at the time of establishment). Prior<br>
to being associated with a standard logical device, a virtual device is not established<br>
and is not accessible by a host. After being established, a virtual device is accessible<br>
by a host.<br>
If it is determined at the step 212 that the modifications to the table relate to<br>
establishing the virtual device, then control passes from the step 212 to a step 214<br>
where a device lock for the virtual device is set to prohibit access to the table by other<br>
processes. The device lock is comparable to the cache slot lock, discussed elsewhere<br>
herein.<br>
Following the step 214 is a step 216 where the pointers of the virtual device<br>
table are made to point to tracks of the standard logical device and where a protection<br>
bit is set for each of the tracks of the standard logical device that corresponds to the<br>
virtual device being established. In an embodiment disclosed herein, each of the<br>
tracks of the standard logical device has sixteen bits which may be set as protection<br>
bits, one for each virtual device established to the standard logical device. In some<br>
embodiments, the protection bits may have uses that are unrelated to virtual devices.<br>
A new virtual device being established may be assigned a new bit position in the<br>
sixteen bit field while the bit for each track of the standard logical device may be set.<br>
As discussed in more detail elsewhere herein, the protection bit being set followed by<br>
a subsequent write to the standard logical device indicates that special processing<br>
needs to take place to accommodate the virtual device established to the standard<br>
logical device. The special processing is described in more detail elsewhere herein.<br>
Also at the step 216, the track entries for the device table for the virtual device are all<br>
modified to point to the corresponding tracks of the standard logical device. Thus,<br>
when the virtual device is first established, all of the pointers of the device table of the<br>
virtual device point to the tracks of the standard logical device.<br>
Following the step 216 is a step 217 the virtual device is set to the ready state,<br>
thus making the virtual device accessible to hosts. Following the step 217 is a step<br>
218 where the virtual device is unlocked, thus allowing access by other processes.<br>
Following the step 218, processing is complete.<br>
If it is determined that the test step 212 that the virtual device is not being<br>
established (i.e., some other operation is being performed), then control passes from<br>
the test step 212 to a step 222 to lock a track corresponding to the entry of the device<br>
table for the virtual device that is being modified. Note that the track that is locked at<br>
the step 222 may either be a track on the standard logical device (if the entry of<br>
interest in the device table of the virtual device points to the standard logical device)<br>
or a track of the log device (if the entry of interest points to the log device).<br>
Following the step 222 is a step 224 where the modification to the device table for the<br>
virtual device is performed. Following the step 224 is a step 226 where the track is<br>
unlocked. Following the step 226, processing is complete.<br>
Referring to Fig. 9, a flow chart 230 illustrates steps performed in connection<br>
with manipulating tracks of a log device. As discussed above, the tracks of a log<br>
device are maintained by creating a doubly linked list of tracks of the log device that<br>
are free (i.e. tracks that are available for accepting new data). Thus, if one or more<br>
tracks are needed for use in connection with a corresponding virtual device, the free<br>
tracks are obtained from the doubly linked list, which is modified in a conventional<br>
manner to indicate that the tracks provided for use by the virtual device are no longer<br>
free. Conversely, if one or more tracks that are used by one or more virtual devices<br>
are no longer needed, the tracks are returned to the doubly linked list, in a<br>
conventional manner, in order to indicate that the tracks are free. The flow chart 230<br>
of Fig. 9 illustrates the steps performed in connection with controlling access to the<br>
tracks (and track pointers) by multiple processes which manipulate the tracks.<br>
Processing begins at a test step 232 where it is determined if the operation<br>
being performed is modifying only tracks that are on the free list. Note that<br>
modifying tracks only on the free lists by, for example, transferring a free track from<br>
one part of the list to another part or from one free lists to another free list (in the case<br>
of multiple free lists), does not involve modifications for tracks corresponding to any<br>
data! If it is determined at the test step 232 that the modification being performed<br>
does not involve only tracks on the free list, then control transfers from the step 232 to<br>
a step 234 where the track is locked to prevent access by other processes.<br>
Following the step 234 or the step 232 if the step 234 is not reached is a test<br>
step 236 where it is determined if the manipulation involves only allocated tracks.<br>
For any operation involving only allocated tracks, it is not necessary to lock the log<br>
device list of free tracks. If it determined at the step 236 that the operation being<br>
performed is not manipulating only allocated tracks, then control transfers from the<br>
step 236 to the step 238 where the log device list of free tracks is locked to prevent<br>
access by other processes. Following the step 238, or following the step 236 if the<br>
step 238 is not executed, is a step 242 where the modification is performed.<br>
Following the step 242 is a test step 244 where it is determined if the<br>
manipulation involves only allocated tracks. If it is determined at the test step 244<br>
that the modification being performed does not involve only allocated tracks, then<br>
control transfers from the step 244 to a step 246 where the log device free list is<br>
unlocked. Following the step 246 or the step 244 if the step 246 is not reached is a<br>
test step 248 where it is determined if the operation being performed is modifying<br>
only tracks that are on the free list. If it determined at the step 248 that the operation<br>
being performed is modifying only tracks that are on the free list, then control<br>
transfers from the step 248 to the step 252 where the track or tracks locked at the step<br>
234 are unlocked. Following the step 252, or following the step 248 if the step 252 is<br>
not executed, processing is complete.<br>
Referring to Figure 10, a flow chart 280 illustrates steps performed in<br>
connection with reading data from a virtual device. Processing begins at a test step<br>
282, where it is determined if the device table entry for the track of interest of the<br>
virtual device points to the standard logical device or points to the log device. If it is<br>
determined at the test step 282 that the table points to the standard logical device, then<br>
control passes from the step 282 to a step 284, where the track is read from the<br>
standard logical device. Following the step 284, processing is complete.<br>
Alternatively, if it determined at the test step 282 that the device table of the virtual<br>
device points to the log device, then control passes from the step 282 to a step 286,<br>
where the track of interest is read from the log device. Following the step 286,<br>
processing is complete.<br>
Note that in some instances, it may be possible that prior to the test step 282, it<br>
is determined that the track of interest being read is already in the cache memory<br>
(global memory). In that case, the track may be obtained from the cache memory<br>
without executing any of the steps 282, 284, 286.<br>
Referring to Figure 11, a flow chart 300 illustrates steps performed by a DA in<br>
connection with writing to a track of a standard logical device to which a virtual<br>
device has been previously established. Processing begins at a first step 302 where it<br>
is determined if any protection bits for the track being written on the standard logical<br>
device have been set. If it determined at the test step 302 that the protection bits are<br>
not set, then control transfers from the step 302 to a step 304, where a normal write<br>
operation is performed. That is, at the step 304, data is written to the standard logical<br>
device in a conventional fashion without regard to the existence of a virtual device<br>
that had been previously established to the standard logical device. Following the<br>
step 304, processing is complete.<br>
If it is determined at the test step 302 that one or more protection bits have<br>
been set on the track of the standard logical device that is being written, control passes<br>
from the step 302 to a step 306, where a free track of the log device is obtained. The<br>
free track of the log device is needed to copy data from the track of the standard<br>
logical device. Also, as described in more detail elsewhere herein, free tracks of the<br>
log device may be managed using a doubly-linked list of the free tracks. Thus, at the<br>
step 306, it may be possible to obtain a free track by traversing the list of free tracks<br>
of the log device and modifying the pointers appropriately to remove one of the free<br>
tracks for use.<br>
Following the step 306 is a step 308, where, for each virtual device that<br>
corresponds to a protection bit that was determined to be set at the test step 302, the<br>
pointers of the virtual devices, which initially pointed to the track being written on the<br>
standard logical device, are modified at the step 308 to point to the free track of the<br>
log device obtained at the step 306. As discussed above, it is possible to have more<br>
than one virtual device established to a standard logical device. For each virtual<br>
device that has been established to a particular standard logical device, a specific<br>
protection bit will be set for each of the tracks of the standard logical device. Thus, at<br>
the step 308, the track pointers are changed for all the virtual devices corresponding to<br>
a set protection bit detected at the step 302. The track pointers in the device tables of<br>
virtual devices are modified to point to the new track that was obtained at the step<br>
306.<br>
Following the step 308 is a step 312, where the data is caused to be copied<br>
from the standard logical device to the new track on the log device that was obtained<br>
at the step 306. In an embodiment disclosed herein, the data may be copied by<br>
moving the data from disk storage to the global memory of the storage device (e.g.,<br>
into a cache slot), and then setting a write pending indicator to cause the data to be<br>
copied to the track of the log device obtained at the step 306. The step 312 represents<br>
copying the data from the track of the standard logical device that is being written to<br>
the new track of the log device obtained at the step 306. Since all the pointers are<br>
modified at the step 308, any virtual device that has been established to the standard<br>
logical device prior to the track being written now points to the old data (i.e., the data<br>
as it existed on the track of the standard device when the virtual devices were<br>
established). Note also that, in connection with copying the track, the protection bits<br>
of the standard logical device track are copied to virtual device map bits for the track<br>
on the log device, which is explained in more detail elsewhere herein.<br>
Following the step 312 is a step 314, where the track of the log device<br>
obtained at the step 306 is modified so that the extra bytes in the table (discussed<br>
elsewhere herein) are made to point back to the track of the standard logical device<br>
that is being written. Having the track of the log device point to the corresponding<br>
track of the standard logical device from which the data was provided is useful in<br>
many instances. For example, it may be useful in connection with data recovery.<br>
Following the step 314 is a step 316, where the protection bits of the tracks of the<br>
standard logical device being written are cleared. Following the step 316 is a step<br>
318, where status is sent to the HA. Following the step 318, processing is complete.<br>
Note that once the HA receives status, the HA may perform a normal write<br>
operation and, in that case, at the test step 302, the protection bits will not be set, since<br>
the bits are cleared at the step 316. The HA that is performing the write operation<br>
sees the protection bits that are set at the step 302 and sends a protection request to the<br>
appropriate DA. The HA then may disconnect from the DA and wait for status to<br>
arrive from the DA indicating that a normal write may be performed. While the HA<br>
is disconnected and waiting for status from the DA, the DA may perform the steps<br>
disclosed in the flow chart 300. This is described in more detail below.<br>
Referring to Figure 12, a flow chart 320 illustrates steps performed by an HA<br>
in connection with a write to a standard logical device to which one or more virtual<br>
devices have been established. Processing begins at a first test step 322, where it is<br>
determined if any protection bits are set for the tracks of the standard logical device<br>
that are being written. If it is determined at the test step 322 that no protection bits are<br>
set, then control passes from the step 322 to a step 324, where a normal write is<br>
performed. Following the step 324, processing is complete.<br>
If it is determined at the test step 322 that one or more protection bits are set<br>
for the tracks of the standard logical device that are being written, control passes from<br>
the step 322 to a step 326, where the HA sends a request to the DA indicating that<br>
protection bits are set for the tracks. When the DA receives the request that is sent at<br>
the step 326, the DA performs the operations set forth in the flow chart 300 of Figure<br>
11, discussed above. Following the step 326 is a step 328, where the HA disconnects<br>
from the DA in order to allow (possibly unrelated) operations to be performed with<br>
the DA by other processes and/or other HA's.<br>
Following the step 328 is a step 332, where the HA waits for the DA to<br>
perform the operations set forth in the flow chart 300 of Figure 11 and to send status<br>
to the HA indicating that the appropriate steps have been performed to handle the set<br>
protection bits. Following the step 332, processing transfers back to the step 322,<br>
where the protection bits for the track of the standard logical device are again tested.<br>
Note that on a second iteration, it is expected that the protection bits of the track of the<br>
standard logical device that are being written would be clear at the step 322, since the<br>
DA would have cleared the protection bits in connection with performing the steps of<br>
the flow chart 300. Of course, it is always possible that a new virtual device will be<br>
established to the standard logical device in between the DA clearing the protection<br>
bits and the step 322 being executed again. However, it is usually expected that the<br>
second iteration of the step 322 for a particular track of the standard logical device<br>
will determine that all the protection bits are clear, and control will transfer from the<br>
step 322 to the step 324 to perform a normal write.<br>
Referring to Figure 13, a flow chart 340 illustrates steps performed in<br>
connection with writing to a virtual device. The flow chart 340 represents steps<br>
performed by both the HA and the DA and thus could have been provided as two flow<br>
charts, similar to the flow chart 300 of Figure 11 and the flow chart 320 of Figure 12.<br>
However, it will be understood by those of ordinary skill in the art that the flow chart<br>
340 may represent a division of steps similar to those set forth in the flow charts 300,<br>
320 and described in the corresponding portions of the text of the specification.<br>
Processing begins at a first step 342, where it is determined if the virtual<br>
device points to the standard logical device. If so, then control transfers from the test<br>
step 342 to a step 344, where a free track of the log device is obtained. Following the<br>
step 344 is a step 346, where data from the standard logical device corresponding to<br>
the track being written is caused to be copied from the standard logical device to the<br>
track of the log device obtained at the step 344. Following the step 346 is a step 348,<br>
where the virtual device pointer for the track is adjusted to point to the track obtained<br>
at the step 344. Following the step 348 is a step 352, where a protection bit<br>
corresponding to the virtual device is cleared in the track data of the standard logical<br>
device, thus indicating that no special processing on behalf of the virtual device is<br>
required when writing to the track of the standard device. Following the step 352 is a<br>
step 354, where the write is executed. At the step 354, the data to be written may be a<br>
track or a portion of a track that is written to the track obtained at the step 344.<br>
Following the step 354, processing is complete. If the data corresponds to an entire<br>
track, then it may be possible to eliminate the step 346, which copies data from the<br>
track of the standard logical device to the new track of the log device, since writing an<br>
entire track's worth of data at the step 354 would overwrite all of the data copied at<br>
the step 346.<br>
If it is determined at the test step 342 that the pointer for the track of the<br>
virtual devices being written does not point to the standard logical device, then control<br>
transfers from the step 342 to a test step 356, where it is determined if more than one<br>
virtual devices have been established to the standard logical device. If not, then<br>
control transfers from the step 356 to a step 358, where a normal write operation to<br>
the track of the log device is performed. If it is determined at the test step 356 that<br>
there is more than one virtual device established to the standard logical device, then<br>
control transfers from the step 356 to a step 362, where a free track from the log<br>
device is obtained.<br>
Following the step 362 is a step 364, where the data of the track corresponding<br>
to the virtual device being written is copied to the track obtained at the step 362.<br>
Following the step 364 is a step 366, where the virtual device pointers are adjusted to<br>
point to the new track. In one embodiment, the pointer for the virtual device that is<br>
being written is made to point to the new track. Alternatively, it is possible to not<br>
change the pointer for the virtual device that is being written and, instead, adjust all<br>
the pointers for all of the other virtual devices that point to the track at the step 366.<br>
Following the step 366 is a step 368 where the virtual device map bits for the<br>
tracks of the log device are modified. For the log device tracks, the virtual device<br>
map bits may be used to indicate which virtual devices point to each track, where, in<br>
one embodiment, there are sixteen virtual device map bits and each bit corresponds to<br>
a particular virtual device. Thus, the test at the step 356 may examine the virtual<br>
device map bits for the track.<br>
Following the step 368 is a step 369, where the write is executed. Note that<br>
whether the write is executed to the track obtained at the step 362 or to the track that<br>
is initially pointed to by the virtual device being written depends upon how the<br>
pointers are adjusted at the step 366. In all cases, however, data is written to the track<br>
pointed to by the virtual device to which the data is being written. Following the step<br>
369, processing is complete.<br>
Referring to Figure 14, a flow chart 370 illustrates steps performed in<br>
connection with removing (i.e., eliminating) a virtual device. Once a virtual device<br>
has been established and used for its intended purpose, it may be desirable to remove<br>
the virtual device. Processing begins at a first step 372, where a pointer is set to point<br>
to the first track of the virtual device. The virtual device is removed by examining<br>
each track corresponding to the virtual device.<br>
Following the step 372 is a step 374, where it is determined if the track of the<br>
virtual device that is being examined points to the standard logical device. If so, then<br>
control transfers from the step 374 to a step 376 to clear the protection bit on the track<br>
of the standard logical device corresponding to the virtual device being removed.<br>
Following the step 376 is a step 378, where a pointer points to the next track of the<br>
virtual device in order to continue processing by examining the next track. Following<br>
the step 378 is a step 382, where it is determined if processing complete (i.e., all the<br>
tracks of the virtual device have been processed). If not, then control transfers from<br>
the step 382 back to the test step 374, discussed above.<br>
If it is determined at the test step 374 that the track of the virtual device being<br>
examined does not point to the standard logical device, then control transfers from the<br>
step 374 to a step 384, where a virtual device map bit on the track of the log device<br>
that corresponds to the virtual device being removed is cleared. Each track of the log<br>
device may have a set of virtual device map bits indicating which virtual devices use<br>
the track of the log device. Thus, at the step 384, the virtual device map bit<br>
corresponding to the virtual device being removed is cleared.<br>
Following the step 384 is a test step 386, where it is determined if the bit that<br>
was cleared at the step 384 was the last virtual device map bit that was set for the<br>
track. In other words, the test step 386 determines if there are other virtual devices<br>
that are using the track on the log device. If it is determined at the test step 386 that<br>
the last virtual device map bit was cleared at the step 3 84 (and thus, no other virtual<br>
devices use the track), then control transfers from the step 386 to a step 388, where<br>
the track of the log device is returned to the free list of tracks of the log device,<br>
discussed elsewhere herein. Following the step 388, or following the step 386 if it is<br>
determined that the bit cleared at the step 384 is not the last virtual device map bit of<br>
the track of the log device, is the step 378, discussed above, where the next track of<br>
the virtual device is pointed to for subsequent examination. Once all of the tracks<br>
corresponding to the virtual device have been processed, the tables and other data<br>
structures associated with the virtual device may also be removed although, in some<br>
embodiments, the tables and other data structures from the virtual device may be<br>
maintained, so long as the virtual device is not made available for use by hosts after<br>
the virtual device is deestablished.<br>
While the invention has been disclosed in connection with various<br>
embodiments, modifications thereon will be readily apparent to those skilled in the<br>
art. Accordingly, the spirit and scope of the invention is set forth in the following<br>
claims.<br>
WE CLAIM:<br>
1. A method of providing a point-in-time copy of stored data, comprising:<br>
providing a virtual storage area having a table of pointers that point to<br>
sections of the stored data and to sections of at least one other storage area,<br>
wherein the virtual storage area contains no sections of data;<br>
in response to a write of new data to a section of the stored data pointed<br>
to by a pointer of the table of the virtual storage area, copying the section of<br>
stored data to a section of the at least one other storage area prior to the write,<br>
causing a pointer of the virtual storage area to point to the section of the at least<br>
one other storage area, and writing the new data to the section of the stored<br>
data;<br>
in response to a request for accessing data of the virtual storage area,<br>
determining which particular one of the other storage areas contain the data; and<br>
accessing the data on the particular one of the other storage areas using<br>
the table of pointers<br>
2. A method, as claimed in claim 1, which involves:<br>
associating the stored data with the virtual storage area, wherein the<br>
virtual storage area represents a copy of the stored data.<br>
3. A method, as claimed in claim 2, which involves:<br>
causing all of the pointers of the table to initially point to the stored data<br>
when the virtual storage area is initially associated with the stored data.<br>
4. A method, as claimed in claim 1, wherein prior to copying data to a<br>
section of the at least one other storage area, the section of the at least one<br>
other storage area is maintained as a free section containing no data<br>
5. A method, as claimed in claim 3, which involves:<br>
associating a data indicator with sections of the stored data, wherein the<br>
data indicator for a particular section indicates whether a write operation has<br>
been performed to the particular section after the stored data has been<br>
associated with the virtual storage area<br>
6. A method, as claimed in claim 1, wherein each of the sections of data is a<br>
track of data.<br>
7. A method, as claimed in claim 1, wherein each of the storage areas is a<br>
storage device<br>
8. A method of providing point-in-time copies of data stored in a data storage<br>
area, comprising:<br>
providing a first virtual storage area having a first table of pointers that<br>
point to sections of the data storage area and to sections of at least one other<br>
storage area, wherein the first virtual storage area contains no sections of data;<br>
in response to a write of new data to a section of the data storage area<br>
pointed to by a pointer of the first table of the first virtual storage area, copying<br>
the section of data to a section of the at least one other storage area prior to the<br>
write, causing a pointer of the first virtual storage area to point to the section of<br>
the at least one other storage area, and writing the new data to the section of the<br>
data storage area;<br>
associating the data storage area with the first virtual storage area,<br>
wherein the first virtual storage area represents a copy of data of the data<br>
storage area at a first point in time;<br>
providing a second virtual storage area having a second table of pointers<br>
that point to sections of the data storage area and to sections of the at least one<br>
other storage area, wherein the second virtual storage area contains no sections<br>
of data;<br>
in response to a write to a section of the data storage area pointed to by a<br>
pointer of the second table of the second virtual storage area, copying the<br>
section of data to a section of the at least one other storage area prior to the<br>
write and causing a pointer of the second virtual storage area to point to the<br>
section of the at least one other storage area;<br>
associating the data storage area with the second virtual storage area,<br>
wherein the second virtual storage area represents a copy of data of the data<br>
storage area at a second point in time;<br>
in response to a request for accessing data of one of the virtual storage<br>
areas, determining which particular one of the storage areas contain the data;<br>
and<br>
accessing the data on the particular one of the storage areas using one of<br>
the tables of pointers.<br>
9. A method, as claimed in claim 8, which involves:<br>
causing all of the pointers of the first table to initially point to sections of<br>
the data storage area when the first virtual storage area is initially associated<br>
with the data storage area; and<br>
causing all of the pointers of the second table to initially point to sections<br>
of the data storage area when the second virtual storage area is initially<br>
associated with the data storage area.<br>
There is disclosed a point-in-time copy of stored data which includes providing a<br>
virtual storage area having a table of pointers that point to sections of the stored<br>
data and to sections of at least one other storage area where the virtual storage<br>
area contains no sections of data. In response to a write of new data to a section<br>
of the stored data pointed to by a pointer of the table of the virtual storage area,<br>
the section of stored data is copied to a section of the at least one other storage<br>
area prior to the write (312). Providing the point-in-time copy also includes<br>
causing a pointer of the virtual storage area to point to the section of the at least<br>
one other storage area (308) and writing the new data to the section of the<br>
stored data (324)<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTI4MS1rb2xucC0yMDAzLWdyYW50ZWQtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">1281-kolnp-2003-granted-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTI4MS1rb2xucC0yMDAzLWdyYW50ZWQtYXNzaWdubWVudC5wZGY=" target="_blank" style="word-wrap:break-word;">1281-kolnp-2003-granted-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTI4MS1rb2xucC0yMDAzLWdyYW50ZWQtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">1281-kolnp-2003-granted-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTI4MS1rb2xucC0yMDAzLWdyYW50ZWQtY29ycmVzcG9uZGVuY2UucGRm" target="_blank" style="word-wrap:break-word;">1281-kolnp-2003-granted-correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTI4MS1rb2xucC0yMDAzLWdyYW50ZWQtZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">1281-kolnp-2003-granted-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTI4MS1rb2xucC0yMDAzLWdyYW50ZWQtZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">1281-kolnp-2003-granted-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTI4MS1rb2xucC0yMDAzLWdyYW50ZWQtZXhhbWluYXRpb24gcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">1281-kolnp-2003-granted-examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTI4MS1rb2xucC0yMDAzLWdyYW50ZWQtZm9ybSAxLnBkZg==" target="_blank" style="word-wrap:break-word;">1281-kolnp-2003-granted-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTI4MS1rb2xucC0yMDAzLWdyYW50ZWQtZm9ybSAxOC5wZGY=" target="_blank" style="word-wrap:break-word;">1281-kolnp-2003-granted-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTI4MS1rb2xucC0yMDAzLWdyYW50ZWQtZm9ybSAzLnBkZg==" target="_blank" style="word-wrap:break-word;">1281-kolnp-2003-granted-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTI4MS1rb2xucC0yMDAzLWdyYW50ZWQtZm9ybSA1LnBkZg==" target="_blank" style="word-wrap:break-word;">1281-kolnp-2003-granted-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTI4MS1rb2xucC0yMDAzLWdyYW50ZWQtZ3BhLnBkZg==" target="_blank" style="word-wrap:break-word;">1281-kolnp-2003-granted-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTI4MS1rb2xucC0yMDAzLWdyYW50ZWQtcmVwbHkgdG8gZXhhbWluYXRpb24gcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">1281-kolnp-2003-granted-reply to examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTI4MS1rb2xucC0yMDAzLWdyYW50ZWQtc3BlY2lmaWNhdGlvbi5wZGY=" target="_blank" style="word-wrap:break-word;">1281-kolnp-2003-granted-specification.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="233767-container-for-storage-and-pouring-of-liquids.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="233769-an-applier-10-for-a-surgical-procedure.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>233768</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1281/KOLNP/2003</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>15/2099</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>10-Apr-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>08-Apr-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>08-Oct-2003</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>EMC CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>176 SOUTH STREET, HOPKINTON, MASSACHUSETTS</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>KOPYLOVITZ HAIM</td>
											<td>1175 CHESTNUT STREET, UNIT #23, NEWTON, MASSACHUSETTS 02464</td>
										</tr>
										<tr>
											<td>2</td>
											<td>VISHLITZKY NATAN</td>
											<td>87 CLINTON ROAD, BROOKLINE, MASSA-CHUSETTS 02445</td>
										</tr>
										<tr>
											<td>3</td>
											<td>MORESHET HANA</td>
											<td>15 BELLWOOD WAY, FRAMINGHAM, MASSA-CHUSETTS 01701</td>
										</tr>
										<tr>
											<td>4</td>
											<td>OFER ADI</td>
											<td>96 WASHBURN AVENUE WELLESLEY, MASSA-CHUSETTS 02481</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 12/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2003/11272</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2003-04-10</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/120,016</td>
									<td>2002-04-10</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/233768-method-of-providing-a-point-in-time-copy-of-stored-data by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:53:17 GMT -->
</html>
